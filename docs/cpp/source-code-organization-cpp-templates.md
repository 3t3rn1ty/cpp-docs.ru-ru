---
title: Исходный код организации (шаблонов C++) | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-language
ms.topic: language-reference
dev_langs:
- C++
ms.assetid: 50569c5d-0219-4966-9bcf-a8689074ad1d
author: mikeblome
ms.author: mblome
ms.openlocfilehash: 05a5b0423b79e817e16aeb0d39f1d0dcf856c1ba
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
---
# <a name="source-code-organization-c-templates"></a>Исходный код организации (шаблонов C++)

При определении шаблона класса, необходимо упорядочить исходный код таким образом, что отображаются компилятору определения элементов, если они нужны.   Вы можете выбрать с помощью *модель включения* или *явное создание экземпляра* модели. В модели включения включают определения членов в любом файле, который использует шаблон. Такой подход является простым и обеспечивает максимальную гибкость с точки зрения, какие конкретные типы можно использовать с шаблонами. Его недостаток заключается в том, что он может увеличить время компиляции. Влияние может быть существенным, если проект или включенные файлы сами велики. В случае явного создания экземпляра сам шаблон создает конкретные классы или члены класса для определенных типов.  Этот подход может ускорить время компиляции, но он ограничивает использование только классам, которые исполнитель шаблона включил заранее. Как правило рекомендуется использовать модель включения, если времени компиляции стать проблемой.

## <a name="background"></a>Фон

Шаблоны, как обычные классы, в том смысле, что компилятор не создает объектный код для шаблона или любого из его элементов. Нет элементов для формирования до создания экземпляра шаблона с конкретными. Когда компилятор встречает экземпляра шаблона, такие как `MyClass<int> mc;` и нет класса с этой подписью еще существует, он создает новый класс. Он также пытается создать код для любой функции-члены, используемые. Если эти определения указаны в файл, который не является #included, прямо или косвенно, CPP-файл, который скомпилирован, компилятор не видны.  С точки зрения компилятора это не обязательно является ошибка, так как в другой записи преобразования, в котором случае компоновщик будет найти их, могут быть определены функции.  Если компоновщику не удается найти этот код, он вызывает **неразрешенный внешний** ошибки.

## <a name="the-inclusion-model"></a>Включение модели

Поместить определения в файле заголовка, сам является простейшим и наиболее распространенным способом сделать видимой во всей записи преобразования, определения шаблона.  Все CPP-файл, который использует шаблон просто должен #include заголовок. Этот подход используется в стандартной библиотеке.

```cpp
#ifndef MYARRAY
#define MYARRAY
#include <iostream>

template<typename T, size_t N>
class MyArray
{
    T arr[N];
public:
    // Full definitions:
    MyArray(){}
    void Print()
    {
        for (const auto v : arr)
        {
            std::cout << v << " , ";
        }
    }

    T& operator[](int i)
   {
       return arr[i];
   } 
};
#endif
```

В этом случае компилятор имеет доступ к определению полный шаблон и можно создавать экземпляры шаблонов по требованию для любого типа. Это простой и относительно легко поддерживать. Тем не менее Включение модели со стоимостью с точки зрения времени компиляции.   Эта стоимость может оказаться значительным в больших приложениях, особенно в том случае, если заголовок шаблона #includes другие заголовки. .Cpp каждого файла, который #includes заголовок получает собственную копию шаблонов функций и все определения. Компоновщик обычно сможет устранять вещей, что вы не получаете несколько определений для функции, но требуется времени для этой цели. В небольших программах, лишние компиляции, скорее всего, не имеет значения.

## <a name="the-explicit-instantiation-model"></a>Явное создание экземпляра модели

Если вы точно знаете набор типов, которые будут использоваться для создания экземпляра шаблона включения модель не является приемлемым для вашего проекта, можно отделить код шаблона в h и CPP-файл и в CPP-файле явного создания экземпляров шаблонов. Это приведет к объекта для создаваемого кода, что компилятор будут видеть при обнаружении экземпляров пользователя.

Создать явное создание экземпляра с помощью шаблона ключевого слова следуют подпись сущность, которой необходимо создать. Это может быть типом или членом. Если вы явно создать экземпляр типа, создаются все элементы.

```cpp
template MyArray<double, 5>;
```

```cpp
//MyArray.h
#ifndef MYARRAY
#define MYARRAY

template<typename T, size_t N>
class MyArray
{
    T arr[N];
public:
    MyArray();
    void Print();
    T& operator[](int i);
};
#endif

//MyArray.cpp
#include "stdafx.h"
#include <iostream>
#include "MyArray.h"

using namespace std;

template<typename T, size_t N>
MyArray<T,N>::MyArray(){}

template<typename T, size_t N>
void MyArray<T,N>::Print()
{
    for(const auto v : arr)
    {
        cout << v << "'";
    }
    cout << endl;
}

template MyArray<double, 5>;template MyArray<string, 5>;
```

В предыдущем примере явное создание экземпляров, в нижней части CPP-файл. Объект `MyArray` может использоваться только для **двойные** или **строка** типов.

> [!NOTE]
> В C ++ 11 **Экспорт** ключевое слово был объявлен устаревшим в контексте определения шаблонов. На практике это имеет почти не влияет, поскольку он никогда не поддерживается большинство компиляторов.
