---
title: "Шаблоны (C++) | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-language
ms.tgt_pltfrm: 
ms.topic: language-reference
f1_keywords:
- template_cpp
dev_langs:
- C++
helpviewer_keywords:
- templates, C++
- templates [C++]
ms.assetid: 90fcc14a-2092-47af-9d2e-dba26d25b872
caps.latest.revision: 
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: 935bee8447ad0d49ae965fb92538d2e260ec68ef
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="templates-c"></a>Шаблоны (C++)
Шаблоны являются основой для обобщенное программирование в C++. Как строго типизированным языком C++ необходимы все переменные, определенные типом, явно объявленные программистом или выведен компилятором. Тем не менее многие структуры данных и алгоритмы выглядят одинаково, независимо от того, какой тип они работают на. Включить шаблоны для определения операций, класса или функции и позволяет пользователю задать конкретный какие типы этих операций должен работать на.  
  
## <a name="defining-and-using-templates"></a>Определение и использование шаблонов  
 Шаблон — это конструкция, которая формирует обычного типа или функции во время компиляции, в зависимости от аргументов, пользователь предоставляет для параметров шаблона. Например можно определить шаблон функции следующим образом:  
  
```cpp  
template <typename T>  
T minimum(const T& lhs, const T& rhs)  
{  
    return lhs < rhs ? lhs : rhs;  
}  
```  
  
 Приведенный выше код описание шаблона для универсальной функции с помощью одного параметра типа `T`, чьи возвращаемое значение и вызовите параметров (lhs и rhs) — это все этого типа. Параметр типа можно назвать произвольным образом, но по соглашению одной букв верхнего регистра чаще всего используются. `T`является параметром шаблона. `typename` ключевое слово говорит, что этот параметр используется заполнитель для типа. При вызове функции компилятор заменяет все вхождения `T` с аргументом конкретный тип, указанный пользователем или выведен компилятором. Процесс, в котором компилятор создает класс или функция на основе шаблона, называют *создание экземпляра шаблона*;   `minimum<int>` создания экземпляра шаблона `minimum<T>`.  
  
 В других случаях пользователь может объявить экземпляр шаблона, предназначенного для int. Предположим, что get_a() и get_b() являются функции, возвращающие int:  
  
```  
int a = get_a();  
int b = get_b();  
int i = minimum<int>(a, b);  
```  
  
 Тем не менее, поскольку это шаблон функции и компилятор может вывести тип `T` из аргументов `a` и `b`, его можно вызвать так же, как обычной функции:  
  
```cpp  
int i = minimum(a, b);  
```  
  
 Когда компилятор обнаруживает, что последней инструкцией, он создает новую функцию, в которой все вхождения *T* в шаблоне заменяется `int`:  
  
```  
  
      int minimum(const int& lhs, const int& rhs)  
{  
    return lhs < rhs ? lhs : rhs;  
}  
```  
  
 Как компилятор выполняет выведение типов в шаблонах функций правила основаны на правилах для обычных функций. Дополнительные сведения см. в разделе [перегрузки разрешения из вызовов шаблонов функций](../cpp/overload-resolution-of-function-template-calls.md).  
  
## <a id="type_parameters"></a>Параметры типа  
 В `minimum` шаблона выше, обратите внимание, что параметр типа `T` не обработаны квалификатором каким-либо образом до использования в параметры вызова функции, где добавляются const и квалификаторы ссылки.  
  
 Нет ограничения на число параметров типа. Несколько параметров следует разделяйте запятыми:  
  
```cpp  
template <typename T, typename U, typename V> class Foo{};  
  
```  
  
 Ключевое слово `class` эквивалентно `typename` в данном контексте. Можно выразить в предыдущем примере:  
  
```  
template <class T, class U, class V> class Foo{};   
```  
  
 Чтобы определить шаблон, который принимает произвольное число ноль или несколько параметров типа можно использовать оператор многоточие (...):  
  
```cpp  
template<typename... Arguments> class vtclass;  
  
vtclass< > vtinstance1;  
vtclass<int> vtinstance2;  
vtclass<float, bool> vtinstance3;  
```  
  
 Как аргумент типа, можно использовать любой тип встроенной или определяемой пользователем. Например, можно использовать std::vector стандартной библиотеки для хранения целых чисел, числа с двойной точностью, строки, MyClass, MyClass const *, MyClass &. Основной ограничения при использовании шаблонов, что аргумент типа должен поддерживать все операции, которые применяются для параметров типа. Например, если мы называем минимальное с помощью MyClass, как показано в примере:  
  
```cpp  
class MyClass  
{  
public:  
    int num;  
    std::wstring description;  
};  
  
int main()  
{      
    MyClass mc1 {1, L"hello"};  
    MyClass mc2 {2, L"goodbye"};  
    auto result = minimum(mc1, mc2); // Error! C2678  
}  
  
```  
  
 Ошибка компилятора будет создаваться, так как MyClass не предоставляют перегрузки для < оператор.  
  
 Нет необходимости специфические, аргументы типа для любого конкретного шаблона все принадлежать той же иерархии объекта, несмотря на то, что можно определить шаблон, который обеспечивает выполнение такого ограничения. Объектно ориентированного методов можно объединить с шаблоны. Например, можно хранить Derived * в векторе\<базы\*>.    Обратите внимание, что аргументы должны быть указателями  
  
```  
vector<MyClass*> vec;  
   MyDerived d(3, L"back again", time(0));  
   vec.push_back(&d);  
  
   // or more realistically:  
   vector<shared_ptr<MyClass>> vec2;  
   vec2.push_back(make_shared<MyDerived>());  
```  
  
 Основные требования, которые вектора и другие контейнеры стандартной библиотеки ресурсов на элементы `T` является то, что `T` копии может быть назначен и построить для копирования.  
  
## <a name="non-type-parameters"></a>Не являющиеся типами параметров  
 В отличие от универсальные типы в других языках, например C# и Java шаблонами языка C++ поддерживают параметры типа, также называется параметрами значений. Например вы можете предоставить константное целочисленное значение для указания длины массива, как в этом примере, который похож на класс std::array в стандартной библиотеке:  
  
```  
template<typename T, size_t L>  
class MyArray  
{  
    T arr[L];  
public:  
    MyArray() { ... }  
};  
  
```  
  
 Обратите внимание, синтаксис в объявлении шаблона. Значение size_t передается в качестве аргумента шаблона во время компиляции и должен быть константой или выражением constexpr. Вы можете использовать его следующим образом:  
  
```cpp  
MyArray<MyClass*, 10> arr;  
```  
  
 Другие типы значений, включая указатели и ссылки на может быть передана в качестве параметры типа. Например можно передать в указатель на функцию или объект функции для настройки некоторых операций внутри код шаблона.  
  
## <a id="template_parameters"></a>Шаблоны в качестве параметров шаблона  
 Шаблон может быть параметр шаблона. В этом примере MyClass2 имеет два параметра шаблона: параметр typename `T` и параметром шаблона `Arr`:  
  
```cpp  
template<typename T, template<typename U, int I> class Arr>  
class MyClass2  
{  
    T t; //OK  
    Arr<T, 10> a;  
    U u; //Error. U not in scope  
};  
```  
  
 Поскольку `Arr` сам параметр не имеет тела, его имена параметров не требуются. По сути, это ошибка для обращения к `Arr`typename или класс имена параметров из тела `MyClass2`. По этой причине `Arr`его можно опустить имена параметров типов, как показано в следующем примере:  
  
```cpp  
template<typename T, template<typename, int> class Arr>  
class MyClass2  
{  
    T t; //OK  
    Arr<T, 10> a;  
};  
```  
  
## <a name="default-template-arguments"></a>Аргументы шаблона по умолчанию  
 Шаблоны классов и функций могут иметь аргументы по умолчанию. Если шаблон содержит аргумент по умолчанию, можно оставить его не указан при использовании. Например шаблон std::vector имеет аргумент распределителя по умолчанию:  
  
```cpp  
template <class T, class Allocator = allocator<T>> class vector;  
```  
  
 В большинстве случаев класс std::allocator по умолчанию является допустимым, поэтому использовать вектор следующим образом:  
  
```cpp  
vector<int> myInts;  
```  
  
 Но при необходимости можно указать пользовательский распределитель следующим образом.  
  
```cpp  
vector<int, MyAllocator> ints;  
```  
  
 При наличии нескольких аргументов шаблона все аргументы после первого аргумента по умолчанию должны иметь аргументы по умолчанию.  
  
 При использовании шаблона, параметры которого задаются все по умолчанию, используйте пустые угловые скобки:  
  
```cpp  
template<typename A = int, typename B = double>  
class Bar  
{  
    //...  
};  
...  
int main()  
{  
    Bar<> bar; // use all default type arguments  
}  
  
```  
  
## <a name="template-specialization"></a>Специализация шаблона  
 В некоторых случаях не невозможно или нежелательно для шаблона определить тот же код, для любого типа. Например необходимо определить пути к коду для выполнения только в том случае, если аргумент является указателем, или std::wstring или типом, производным от определенного базового класса.  В таких случаях можно определить *специализации* шаблона для конкретного типа. Когда пользователь создает шаблон с этим типом, компилятор использует специализации для создания классов и для всех других типов, компилятор выбирает более общий шаблон. Специализации, в которых специализируются все параметры являются *завершения специализации*. Если только некоторые параметры специализируются называется *частичной специализации*.  
  
```cpp  
template <typename K, typename V>  
class MyMap{/*...*/};  
  
// partial specialization for string keys  
template<typename V>  
class MyMap<string, V> {/*...*/};  
...  
MyMap<int, MyClass> classes; // uses original template  
MyMap<string, MyClass> classes2; // uses the partial specialization  
  
```  
  
 Шаблон может иметь любое количество специализации, при условии, что каждый параметр специализированным типом, который является уникальным.   Только шаблоны классов могут частично настроить. Все полную или частичную специализацию шаблона должен быть объявлен в пространстве имен, исходный шаблон.  
  
 Дополнительные сведения см. в разделе [специализации шаблона](../cpp/template-specialization-cpp.md).