---
title: "Функции (C++) | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-language
ms.tgt_pltfrm: 
ms.topic: language-reference
dev_langs: C++
helpviewer_keywords:
- defaults, arguments
- function definitions
- function definitions, about function definitions
- default arguments
- declarators, functions
ms.assetid: 33ba01d5-75b5-48d2-8eab-5483ac7d2274
caps.latest.revision: "19"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: a5fa20f0a2236d6458490784d2fa0f1b53b13241
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="functions-c"></a>Функции (C++)
Функции — это блоки кода, выполняющие определенные операции. Если требуется, функция может определять входные параметры, позволяющие вызывающим объектам передавать ей аргументы. При необходимости функция также может возвращать значение как выходное. Функции полезны для инкапсуляции основных операций в едином блоке, который может многократно использоваться. В идеальном случае имя этого блока должно четко описывать назначение функции. Следующая функция принимает два целых числа от вызывающего объекта и возвращает их сумму. `a` и `b` , *параметры* типа `int`.  
  
```  
int sum(int a, int b)  
{  
    return a + b;  
}  
```  
  
 Функция может быть "вызове или *вызывается*, от любого числа местах программы. Значения, которые передаются в функцию *аргументы*, их типы должны быть совместимы с типами параметров в определении функции.  
  
```  
int main()  
{  
    int i = sum(10, 32);  
    int j = sum(i, 66);  
    cout << "The value of j is" << j << endl; // 108  
}  
```  
  
 Длина функции практически не ограничена, однако для максимальной эффективности кода целесообразно использовать функции, каждая из которых выполняет одиночную, четко определенную задачу. Сложные алгоритмы лучше разбивать на более короткие и простые для понимания функции, если это возможно.  
  
 Функции, определенные в области видимости класса, называются функциями-членами. В C++, в отличие от других языков, функции можно также определять в области видимости пространства имен (включая неявное глобальное пространство имен). Такие функции называются *свободные функции* или *не являющихся членами*; они широко используются в стандартной библиотеке.  
  
## <a name="parts-of-a-function-declaration"></a>Части объявления функции  
 Функции, как минимум *объявление* состоит из типа возвращаемого значения, имя функции и список параметров (может быть пустым), необязательные ключевые слова, сообщающие Дополнительные инструкции компилятору. Следующий пример является объявление функции:

 ```cpp
 int sum(int a, int b);
 ```

 Определение функции состоит из ее объявления, а также *текст*, являющееся весь код между фигурными скобками:
 
 ```cpp
int sum(int a, int b)  
{  
    return a + b;  
}  
```
 Объявление функции, за которым следует точка с запятой, может многократно встречаться в разных местах кода программы. Оно необходимо перед любыми вызовами этой функции в каждой записи преобразования. По правилу одного определения, определение функции должно фигурировать в коде программы лишь один раз.  
  
 При объявлении функции необходимо указать:  
  
1.  Возвращаемый тип, представляющий собой тип значения, возвращаемого функцией. Если возвращать значение не требуется, укажите `void`. В C ++ 11 `auto` является допустимым типом возврата, который сообщает компилятору вывести тип с оператором return. Тип decltype (auto) также используется в C++14. Дополнительные сведения см. в подразделе "Выведение возвращаемых типов" ниже.  
  
2.  Имя функции, которое должно начинаться с буквы или символа подчеркивания и не должно содержать пробелов. В стандартной библиотеке со знака подчеркивания обычно начинаются имена закрытых функций-членов или функций, не являющихся членами и не предназначенных для использования в вашем коде. 
  
3.  Список параметров, заключенный в скобки. В этом списке через запятую указывается нужное (возможно, нулевое) число параметров, задающих тип и, при необходимости, локальное имя, по которому к значениям можно получить доступ в теле функции. 
  
 Необязательные элементы объявления функции:  
  
1.  `constexpr` — указывает, что возвращаемое значение функции является константой, значение которой может быть определено во время компиляции.  
  
    ```  
    constexpr float exp(float x, int n)  
    {  
        return n == 0 ? 1 :  
            n % 2 == 0 ? exp(x * x, n / 2) :  
            exp(x * x, (n - 1) / 2) * x;  
    };  
    ```  
  
2.  Это спецификация `linkage`, `extern` или `static`.  
  
    ```  
    Declare printf with C linkage.  
    extern "C" int printf( const char *fmt, ... );  
  
    ```  
  
     Дополнительные сведения см. в разделе [программа и компоновка](../cpp/program-and-linkage-cpp.md).  
  
3.  `inline` — отдает компилятору команду заменять каждый вызов функции ее кодом. Подстановка может улучшить эффективность кода в сценариях, где функция выполняется быстро и многократно вызывается во фрагментах, являющихся критическими для производительности программы.  
  
    ```  
    inline double Account::GetBalance()  
    {  
        return balance;  
    }  
    ```  
  
     Дополнительные сведения см. в разделе [встроенные функции](../cpp/inline-functions-cpp.md).  
  
4.  Объект `noexcept` выражения, которое указывает, может ли функция вызывать исключение. В следующем примере функция не вызывает исключение, если результатом выражения `is_pod` является `true`.  
  
    ```  
    #include <type_traits>  
  
    template <typename T>  
    T copy_object(T& obj) noexcept(std::is_pod<T>) {...}  
    ```  
  
     Дополнительные сведения см. в разделе [noexcept](../cpp/noexcept-cpp.md).  
  
5.  (Только для функций-членов.) cv-квалификаторы — определяют, является функция `const` или `volatile`.  
  
6.  (Только для функций-членов.) `virtual`, `override` или `final`. `virtual` — указывает, что функция может быть переопределена в производном классе. `override` — означает, что функция в производном классе переопределяет виртуальную функцию. `final` — означает, что функция не может быть переопределена ни в одном из последующих производных классов. Дополнительные сведения см. в разделе [виртуальные функции](../cpp/virtual-functions.md).  
  
7.  (Только для функций-членов.) `static` — в применении к функции-члену означает, что функция не связана ни с одним из экземпляров объектов, входящих в класс.  
  
8.  (Только для не являющегося статическим члена функции) Ref квалификатор, который указывает компилятору, какую перегрузку функции следует выбрать, если неявный объект-параметр (* это) является ссылкой rvalue или ссылкой lvalue.  
  
 На следующем рисунке показаны компоненты определения функции. Затененная область является телом функции.  
  
 ![Компоненты определения функции](../cpp/media/vc38ru1.gif "vc38RU1")  
Компоненты определения функции  
  
## <a name="function-definitions"></a>Определения функций  
 Переменные, объявленные в теле функции, называются локальными. Они исчезают из области видимости при выходе из функции, поэтому функция никогда не должна возвращать ссылку на локальную переменную.  
  
## <a name="function-templates"></a>Шаблоны функций  
 Шаблоны функций подобны шаблонам классов. Их задача заключается в создании конкретных функций на основе аргументов шаблонов. Во многих случаях шаблоны могут определять типы аргументов, поэтому их не требуется явно указывать.  
  
```  
template<typename Lhs, typename Rhs>  
auto Add2(const Lhs& lhs, const Rhs& rhs)  
{  
    return lhs + rhs;  
}  
  
auto a = Add2(3.13, 2.895); // a is a double  
auto b = Add2(string{ "Hello" }, string{ " World" }); // b is a std::string  
```  
  
 Дополнительные сведения см. в разделе [шаблонов функций](../cpp/function-templates.md)  
  
## <a name="function-parameters-and-arguments"></a>Параметры и аргументы функций  
 У функции имеется список параметров, в котором через запятую перечислено необходимое (возможно, нулевое) число типов. Каждому параметру присваивается имя, по которому к нему можно получить доступ в теле функции. В шаблоне функции могут указываться дополнительные типы или значения параметров. Вызывающий объект передает аргументы, представляющие собой конкретные значения, типы которых совместимы со списком параметров.  
  
 По умолчанию аргументы передаются функции по значению, то есть функция получает копию передаваемого объекта. Копирование крупных объектов может быть ресурсозатратным и неоправданным. Для передачи аргументов по ссылкам (в частности, по ссылкам lvalue) для параметра следует задать квалификатор ссылки:  
  
```  
void DoSomething(std::string& input){...}  
```  
  
 Если функция изменяет аргумент, передаваемый по ссылке, изменяется исходный объект, а не его локальная копия. Чтобы предотвратить изменение такого аргумента функцией, его следует определить как const&:  
  
```  
void DoSomething(const std::string& input){...}  
```  
  
 **C ++ 11:** для явной обработки аргументов, передаваемых по ссылкам rvalue или ссылкой lvalue, двойной амперсанд для параметра следует использовать, чтобы указать универсальную ссылку:  
  
```  
void DoSomething(const std::string&& input){...}  
```  
  
 Функции, объявленные с одним ключевым словом `void` в списке объявления параметров не принимают аргументов, пока ключевое слово `void` является первым и единственным членом списка объявления аргументов. Аргументы типа `void` в любых других местах списка создают ошибки. Пример:  
  
```  
  
// OK same as GetTickCount()  
long GetTickCount( void );   
```  
  
 Обратите внимание, что в то время как недопустимо задать аргумент `void` каким-либо иным способом, кроме описанного здесь, типы, унаследованные от типа `void` (например, указатели на `void` и массивы `void`), могут находиться в любом месте списка объявления аргументов.  
  
### <a name="default-arguments"></a>Аргументы по умолчанию  
 Последним параметрам в сигнатуре функции можно назначить аргумент по умолчанию, т. е. вызывающий объект сможет опустить аргумент при вызове функции, если не требуется указать какое-либо другое значение.  
  
```  
int DoSomething(int num,   
    string str,   
    Allocator& alloc = defaultAllocator)  
{ ... }  
  
// OK both parameters are at end  
int DoSomethingElse(int num,   
    string str = string{ "Working" },   
    Allocator& alloc = defaultAllocator)  
{ ... }  
  
// C2548: 'DoMore': missing default parameter for parameter 2  
int DoMore(int num = 5, // Not a trailing parameter!  
    string str,  
    Allocator& = defaultAllocator)  
{...}  
```  
  
 Дополнительные сведения см. в разделе [аргументы по умолчанию](../cpp/default-arguments.md).  
  
## <a name="function-return-types"></a>типов возвращаемых функциями значений;  
 Функция не может возвращать другие функции и встроенные массивы; Однако возможен возврат указателей на эти типы, или *лямбда-выражение*, который выдает объект функции. За исключением этих случаев функция может вернуть значение любого типа, входящего в ее область видимости, а также не возвращать никакого значения. В последнем случае возвращаемый тип — `void`.  
  
### <a name="trailing-return-types"></a>Завершающие возвращаемые типы  
 "Обычные" типы возвращаемого значения расположены слева от сигнатуры функции. Объект *завершающего возвращаемого типа* находится в правой части сигнатуры и перед ними находится оператор ->. Завершающие типы возвращаемого значения особенно полезны в шаблонах функций, когда тип возвращаемого значения зависит от параметров шаблона.  
  
```  
template<typename Lhs, typename Rhs>  
auto Add(const Lhs& lhs, const Rhs& rhs) -> decltype(lhs + rhs)  
{  
    return lhs + rhs;   
}  
```  
  
 Когда `auto` используется в сочетании с завершающим возвращающим типом, он просто служит в качестве местозаполнителя для результатов действия выражения decltype, не выполняя выведения самостоятельно.  

   
## <a name="function-local-variables"></a>Локальные переменные функции  
 Переменная, объявленная внутри тела другой функции вызывается *локальной переменной* или просто *локальной*. Нестатические локальные переменные видны только в теле функции. Если локальные переменные объявляются в стеке, они исчезают из области видимости при выходе из функции. При создании локальной переменной и ее возвращении по значению компилятор обычно выполняет оптимизацию возвращаемого значения, чтобы избежать ненужных операций копирования. Если локальная переменная возвращается по ссылке, компилятор выдаст предупреждение, поскольку любые попытки вызывающего объекта использовать эту ссылку произойдут после уничтожения локальной переменной.  
  
 Локальные статические объекты удаляются во время завершения, определенного директивой `atexit`. Если статический объект не был создан из-за того, что поток кода программы обошел соответствующее объявление, попытка уничтожения этого объект не предпринимается.  
  
### <a name="static-local-variables"></a>Статические локальные переменные  
 В C++ локальные переменные можно объявлять как статические. Переменная является видимой только в теле функции, однако для всех экземпляров функции существует только одна копия переменной.  
  
###  <a name="type_deduction"></a>Выведение возвращаемых типов (C ++ 14)  
 В C++14 можно использовать `auto`, чтобы дать компилятору команду получения возвращаемого типа из тела функции без использования завершающего возвращаемого типа. Обратите внимание, что `auto` всегда сводится к возвращению по значению. Используйте `auto&&`, чтобы дать компилятору команду выведения ссылки.  
  
 В этом примере демонстрируется выведение `auto` как копии непостоянного значения суммы lhs и rhs.  
  
```  
template<typename Lhs, typename Rhs>  
auto Add2(const Lhs& lhs, const Rhs& rhs)  
{  
    return lhs + rhs; //returns a non-const object by value  
}  
```  
  
 Обратите внимание, что `auto` не сохраняет константность постоянность типа. Для функций пересылки, возвращаемые значения которых должны сохранять постоянность (const) или привязанность (ref) аргументов, вы можете использовать ключевое слово `decltype(auto)`, использующее правила вывода типа `decltype` и сохраняющее всю информацию о типе. `decltype(auto)` может использоваться как обычное возвращаемое значение с левой стороны или как завершающее возвращаемое значение.  
  
 В следующем примере (основанном на коде из [N3493](http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3493.html)), показаны `decltype(auto)` используется для оптимального перенаправления аргументов функции в возвращаемый тип, неизвестный до создания экземпляра шаблона.  
  
```  
template<typename F, typename Tuple = tuple<T...>, int... I>  
decltype(auto) apply_(F&& f, Tuple&& args, index_sequence<I...>)   
{  
    return std::forward<F>(f)(std::get<I>(std::forward<Tuple>(args))...);  
}  
  
template<typename F, typename Tuple = tuple<T...>,  
    typename Indices = make_index_sequence<tuple_size<Tuple>::value >>  
   decltype( auto)  
    apply(F&& f, Tuple&& args)      
{  
    return apply_(std::forward<F>(f), std::forward<Tuple>(args), Indices());  
}  
}  
```  
## <a name="returning-multiple-values-from-a-function"></a>Возвращение несколько значений из функции
Существует несколько способов для получения более одного значения из функции:

1. Инкапсуляция значения в объект с именем класса или структуры. Требуется определение класса или структуры, чтобы быть видимым для вызывающего объекта:

```cpp
#include <string>
#include <iostream>

using namespace std;

struct S
{
    string name;
    int num;
};

S g()
{
    string t{ "hello" };
    int u{ 42 };
    return { t, u };
}

int main()
{
    S s = g();
    cout << s.name << " " << s.num << endl;
    return 0;
}
```

2. Возвращает объект std::tuple или std::pair:

```cpp
#include <tuple>
#include <string>
#include <iostream>

using namespace std;


tuple<int, string, double> f()
{
    int i{ 108 };
    string s{ "Some text" };
    double d{ .01 };
    return { i,s,d };
}

int main()
{
    auto t = f();
    cout << get<0>(t) << " " << get<1>(t) << " " << get<2>(t) << endl;
    
    // --or--

    int myval;
    string myname;
    double mydecimal;
    tie(myval, myname, mydecimal) = f();
    cout << myval << " " << myname << " " << mydecimal << endl;

    return 0;
}
```

3. **Visual Studio 2017 г 15,3 и более поздних версий** (с [/std: c ++ 17](../build/reference/std-specify-language-standard-version.md)): использование структурированной привязок. Преимуществом структурированных привязки является, переменные возвращаемого значения которых инициализируются в то же время, в которой они объявлены, что в некоторых случаях может быть значительно эффективнее. В этом операторе--`auto[x, y, z] = f();`--квадратные скобки, вводят и инициализируйте имена, которые находятся в области видимости блока всей функции.  

```cpp
#include <tuple>
#include <string>
#include <iostream>

using namespace std;

tuple<int, string, double> f()
{
    int i{ 108 };
    string s{ "Some text" };
    double d{ .01 };
    return { i,s,d };
}
struct S
{
    string name;
    int num;
};

S g()
{
    string t{ "hello" };
    int u{ 42 };
    return { t, u };
}

int main()
{
    auto[x, y, z] = f(); // init from tuple
    cout << x << " " << y << " " << z << endl;

    auto[a, b] = g(); // init from POD struct
    cout << a << " " << b << endl;
    return 0;
}
```

4. Помимо использования само возвращаемое значение, можно «вернуть» значения путем определения любое количество параметров для использования передачи по ссылке, чтобы функция может изменить или инициализации значений объектов, вызывающим. Дополнительные сведения см. в разделе [аргументы функции ссылочного типа](reference-type-function-arguments.md).
  
## <a name="function-pointers"></a>Указатели на функции  
 Как и в C, в C++ поддерживаются указатели на функции. Однако более типобезопасной альтернативой обычно служит использование объекта-функции.  
  
 При объявлении функции, которая возвращает тип указателя на функцию, рекомендуется использовать ключевое слово `typedef`, чтобы объявить псевдоним для типа указателя на функцию.  Пример  
  
```  
typedef int (*fp)(int);  
fp myFunction(char* s); // function returning function pointer  
```  
  
 Если оно не используется, то правильный синтаксис объявления функции можно вывести из синтаксиса декларатора для указателя на функцию, заменив идентификатор (в приведенном выше примере — `fp`) на имя функции и список аргументов, как показано выше:  
  
```  
int (*myFunction(char* s))(int);  
```  
  
 Это объявление эквивалентно объявлению при помощи ключевого слова typedef, которое приводилось выше.  
  
## <a name="see-also"></a>См. также  
 [Перегрузка функции](../cpp/function-overloading.md)   
 [Функции со списками аргументов переменных](../cpp/functions-with-variable-argument-lists-cpp.md)   
 [Явно заданные и удаленные функции](../cpp/explicitly-defaulted-and-deleted-functions.md)   
 [Поиск имени с зависимостью от аргументов (поиск Koenig) функций](../cpp/argument-dependent-name-koenig-lookup-on-functions.md)   
 [Аргументы по умолчанию](../cpp/default-arguments.md)   
 [Встраиваемые функции](../cpp/inline-functions-cpp.md)