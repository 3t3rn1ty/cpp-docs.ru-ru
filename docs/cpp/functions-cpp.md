---
title: "Функции (C++) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "language-reference"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "деклараторы, функции"
  - "аргументы по умолчанию"
  - "по умолчанию, аргументы"
  - "определения функций"
  - "определения функций, об определениях функций"
ms.assetid: 33ba01d5-75b5-48d2-8eab-5483ac7d2274
caps.latest.revision: 19
caps.handback.revision: 19
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Функции (C++)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Функции — это блоки кода, выполняющие определенные операции.  Если требуется, функция может определять входные параметры, позволяющие вызывающим объектам передавать ей аргументы.  При необходимости функция также может возвращать значение как выходное.  Функции полезны для инкапсуляции основных операций в едином блоке, который может многократно использоваться. В идеальном случае имя этого блока должно четко описывать назначение функции.  Следующая функция принимает от вызывающего ее объекта два целых числа и возвращает их сумму. `a` и `b` — *параметры* типа `int`.  
  
```  
int sum(int a, int b)  
{  
    return a + b;  
}  
```  
  
 Функции могут запускаться \(*вызываться*\) в коде программы любое нужное число раз.  Значения, которые передаются функции, называются *аргументами*. Их типы должны быть совместимы с типами параметров в определении функции.  
  
```  
int main()  
{  
    int i = sum(10, 32);  
    int j = sum(i, 66);  
    cout << "The value of j is" << j << endl; // 108  
}  
```  
  
 Длина функции практически не ограничена, однако для максимальной эффективности кода целесообразно использовать функции, каждая из которых выполняет одиночную, четко определенную задачу.  Сложные алгоритмы лучше разбивать на более короткие и простые для понимания функции, если это возможно.  
  
 Функции, определенные в области видимости класса, называются функциями\-членами.  В C\+\+, в отличие от других языков, функции можно также определять в области видимости пространства имен \(включая неявное глобальное пространство имен\).  Подобные функции называются *свободными* или *не являющимися членами*. Они часто используются в стандартной библиотеке.  
  
## Части объявления функции  
 При *объявлении* функции, как минимум, необходимо указать возвращаемый тип и имя функции, а также задать список параметров \(может быть пустым\) и, при необходимости, ключевые слова, сообщающие дополнительные инструкции компилятору.  Определение функции включает в себя код ее объявления, а также *тело*, представляющее собой весь код между фигурными скобками.  Объявление функции, за которым следует точка с запятой, может многократно встречаться в разных местах кода программы.  Оно необходимо перед любыми вызовами этой функции в каждой записи преобразования.  По правилу одного определения, определение функции должно фигурировать в коде программы лишь один раз.  
  
 При объявлении функции необходимо указать:  
  
1.  Возвращаемый тип, представляющий собой тип значения, возвращаемого функцией. Если возвращать значение не требуется, укажите `void`.  Например, в C\+\+11 можно использовать возвращаемый тип auto, отдающий компилятору команду определять тип в соответствии с оператором return.  Тип decltype \(auto\) также используется в C\+\+14.  Дополнительные сведения см. в подразделе "Выведение возвращаемых типов" ниже.  
  
2.  Имя функции, которое должно начинаться с буквы или символа подчеркивания и не должно содержать пробелов.  В стандартной библиотеке со знака подчеркивания обычно начинаются имена закрытых функций\-членов или функций, не являющихся членами и не предназначенных для использования в вашем коде.  
  
3.  Список параметров, заключенный в скобки. В этом списке через запятую указывается нужное \(возможно, нулевое\) число параметров, задающих тип и, при необходимости, локальное имя, по которому к значениям можно получить доступ в теле функции.  
  
 Необязательные элементы объявления функции:  
  
1.  `constexpr` — указывает, что возвращаемое значение функции является константой, значение которой может быть определено во время компиляции.  
  
    ```  
  
                  constexpr float exp(float x, int n)  
    {  
        return n == 0 ? 1 :  
            n % 2 == 0 ? exp(x * x, n / 2) :  
            exp(x * x, (n - 1) / 2) * x;  
    };  
    ```  
  
2.  Это спецификация `linkage`, `extern` или `static`.  
  
    ```  
    Declare printf with C linkage.  
    extern "C" int printf( const char *fmt, ... );  
  
    ```  
  
     Дополнительные сведения см. в разделе [Программа и компоновка](../cpp/program-and-linkage-cpp.md).  
  
3.  `inline` — отдает компилятору команду заменять каждый вызов функции ее кодом.  Подстановка может улучшить эффективность кода в сценариях, где функция выполняется быстро и многократно вызывается во фрагментах, являющихся критическими для производительности программы.  
  
    ```  
    inline double Account::GetBalance()  
    {  
        return balance;  
    }  
    ```  
  
     Дополнительные сведения см. в разделе [Подставляемые функции](../Topic/Inline%20Functions%20\(C++\).md).  
  
4.  `noexcept` — определяет, может ли функция вызывать исключения.  В следующем примере функция не вызывает исключение, если результатом выражения `is_pod` является `true`.  
  
    ```  
    #include <type_traits>  
  
    template <typename T>  
    T copy_object(T& obj) noexcept(std::is_pod<T>) {...}  
    ```  
  
     Дополнительные сведения см. в разделе [noexcept](../Topic/noexcept%20\(C++\).md).  
  
5.  \(Только для функций\-членов.\) cv\-квалификаторы — определяют, является функция `const` или `volatile`.  
  
6.  \(Только для функций\-членов.\) `virtual`, `override` или `final`.  `virtual` — указывает, что функция может быть переопределена в производном классе.  `override` — означает, что функция в производном классе переопределяет виртуальную функцию.  `final` — означает, что функция не может быть переопределена ни в одном из последующих производных классов.  Дополнительные сведения см. в разделе [Виртуальные функции](../cpp/virtual-functions.md).  
  
7.  \(Только для функций\-членов.\) `static` — в применении к функции\-члену означает, что функция не связана ни с одним из экземпляров объектов, входящих в класс.  
  
8.  \(Только для нестатических функций\-членов.\) Квалификатор ref указывает компилятору, какую перегрузку функции следует выбрать, если неявный объект\-параметр \(\*this\) является ссылкой rvalue или   ссылкой lvalue.  
  
 На следующем рисунке показаны компоненты определения функции.  Затененная область является телом функции.  
  
 ![Части определения функции](../cpp/media/vc38ru1.png "vc38RU1")  
Компоненты определения функции  
  
## Определения функций  
 Переменные, объявленные в теле функции, называются локальными.  Они исчезают из области видимости при выходе из функции, поэтому функция никогда не должна возвращать ссылку на локальную переменную.  
  
## Шаблоны функций  
 Шаблоны функций подобны шаблонам классов. Их задача заключается в создании конкретных функций на основе аргументов шаблонов.  Во многих случаях шаблоны могут определять типы аргументов, поэтому их не требуется явно указывать.  
  
```  
template<typename Lhs, typename Rhs>  
auto Add2(const Lhs& lhs, const Rhs& rhs)  
{  
    return lhs + rhs;  
}  
  
auto a = Add2(3.13, 2.895); // a is a double  
auto b = Add2(string{ "Hello" }, string{ " World" }); // b is a std::string  
```  
  
 Дополнительные сведения см. в разделе [Шаблоны функций](../cpp/function-templates.md).  
  
## Параметры и аргументы функций  
 У функции имеется список параметров, в котором через запятую перечислено необходимое \(возможно, нулевое\) число типов. Каждому параметру присваивается имя, по которому к нему можно получить доступ в теле функции.  В шаблоне функции могут указываться дополнительные типы или значения параметров.  Вызывающий объект передает аргументы, представляющие собой конкретные значения, типы которых совместимы со списком параметров.  
  
 По умолчанию аргументы передаются функции по значению, то есть функция получает копию передаваемого объекта.  Копирование крупных объектов может быть ресурсозатратным и неоправданным.  Для передачи аргументов по ссылкам \(в частности, по ссылкам lvalue\) для параметра следует задать квалификатор ссылки:  
  
```  
void DoSomething(std::string& input){...}  
```  
  
 Если функция изменяет аргумент, передаваемый по ссылке, изменяется исходный объект, а не его локальная копия.  Чтобы предотвратить изменение такого аргумента функцией, его следует определить как const&:  
  
```  
void DoSomething(const std::string& input){...}  
```  
  
 **C\+\+11:**  для явной обработки аргументов, передаваемых по ссылкам rvalue или lvalue, для параметра следует использовать двойной амперсанд, чтобы указать универсальную ссылку:  
  
```  
void DoSomething(const std::string&& input){...}  
```  
  
 Функции, объявленные с одним ключевым словом `void` в списке объявления параметров не принимают аргументов, пока ключевое слово `void` является первым и единственным членом списка объявления аргументов.  Аргументы типа `void` в любых других местах списка создают ошибки.  Пример:  
  
```  
  
// OK same as GetTickCount()  
long GetTickCount( void );   
```  
  
 Обратите внимание, что в то время как недопустимо задать аргумент `void` каким\-либо иным способом, кроме описанного здесь, типы, унаследованные от типа `void` \(например, указатели на `void` и массивы `void`\), могут находиться в любом месте списка объявления аргументов.  
  
### Аргументы по умолчанию  
 Последним параметрам в сигнатуре функции можно назначить аргумент по умолчанию, т. е. вызывающий объект сможет опустить аргумент при вызове функции, если не требуется указать какое\-либо другое значение.  
  
```  
int DoSomething(int num,   
    string str,   
    Allocator& alloc = defaultAllocator)  
{ ... }  
  
// OK both parameters are at end  
int DoSomethingElse(int num,   
    string str = string{ "Working" },   
    Allocator& alloc = defaultAllocator)  
{ ... }  
  
// C2548: 'DoMore': missing default parameter for parameter 2  
int DoMore(int num = 5, // Not a trailing parameter!  
    string str,  
    Allocator& = defaultAllocator)  
{...}  
```  
  
 Дополнительные сведения см. в разделах [Аргументы по умолчанию](../Topic/Default%20Arguments.md) и [Аргументы по умолчанию для шаблонов классов](../Topic/Default%20Arguments%20for%20Class%20Templates.md).  
  
## Типы возвращаемых функциями значений  
 Функция не может возвращать другие функции и встроенные массивы. Однако возможен возврат указателей на эти типы, а также *лямбда\-выражений*, создающих объект\-функцию.  За исключением этих случаев функция может вернуть значение любого типа, входящего в ее область видимости, а также не возвращать никакого значения. В последнем случае возвращаемый тип — `void`.  
  
### Завершающие возвращаемые типы  
 "Обычные" возвращаемые типы расположены слева от сигнатуры функции.  *Завершающие возвращаемые типы* находится в правой части сигнатуры, и перед ними находится оператор \-\>.  Завершающие возвращаемые типы особенно полезны в шаблонах функций, когда тип возвращаемого значения зависит от параметров шаблона.  
  
```  
template<typename Lhs, typename Rhs>  
auto Add(const Lhs& lhs, const Rhs& rhs) -> decltype(lhs + rhs)  
{  
    return lhs + rhs;   
}  
```  
  
 Когда `auto` используется в сочетании с завершающим возвращающим типом, он просто служит в качестве местозаполнителя для результатов действия выражения decltype, не выполняя выведения самостоятельно.  
  
###  <a name="type_deduction"></a> Выведение возвращаемых типов \(C\+\+14\)  
 В C\+\+14 можно использовать `auto`, чтобы дать компилятору команду получения возвращаемого типа из тела функции без использования завершающего возвращаемого типа.  Обратите внимание, что `auto` всегда сводится к возвращению по значению.  Используйте `auto&&`, чтобы дать компилятору команду выведения ссылки.  
  
 В этом примере демонстрируется выведение `auto` как копии непостоянного значения суммы lhs и rhs.  
  
```  
template<typename Lhs, typename Rhs>  
auto Add2(const Lhs& lhs, const Rhs& rhs)  
{  
    return lhs + rhs; //returns a non-const object by value  
}  
```  
  
 Обратите внимание, что `auto` также не сохраняет постоянность выводимого типа.  Для функций пересылки, возвращаемые значения которых должны сохранять постоянность \(const\) или привязанность \(ref\) аргументов, вы можете использовать ключевое слово `decltype(auto)`, использующее правила вывода типа `decltype` и сохраняющее всю информацию о типе.  `decltype(auto)` может использоваться как обычное возвращаемое значение с левой стороны или как завершающее возвращаемое значение.  
  
 В следующем примере \(основанном на коде из [N3493](http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3493.html)\) демонстрируется использование `decltype(auto)` для оптимального перенаправления аргументов функции в возвращаемый тип, неизвестный до создания экземпляра шаблона.  
  
```  
template<typename F, typename Tuple = tuple<T...>, int... I>  
decltype(auto) apply_(F&& f, Tuple&& args, index_sequence<I...>)   
{  
    return std::forward<F>(f)(std::get<I>(std::forward<Tuple>(args))...);  
}  
  
template<typename F, typename Tuple = tuple<T...>,  
    typename Indices = make_index_sequence<tuple_size<Tuple>::value >>  
   decltype( auto)  
    apply(F&& f, Tuple&& args)      
{  
    return apply_(std::forward<F>(f), std::forward<Tuple>(args), Indices());  
}  
}  
```  
  
## Локальные переменные функции  
 Переменная, объявленная в теле функции, называется *локальной*.  Нестатические локальные переменные видны только в теле функции. Если локальные переменные объявляются в стеке, они исчезают из области видимости при выходе из функции.  При создании локальной переменной и ее возвращении по значению компилятор обычно выполняет оптимизацию возвращаемого значения, чтобы избежать ненужных операций копирования.  Если локальная переменная возвращается по ссылке, компилятор выдаст предупреждение, поскольку любые попытки вызывающего объекта использовать эту ссылку произойдут после уничтожения локальной переменной.  
  
 Локальные статические объекты удаляются во время завершения, определенного директивой `atexit`.  Если статический объект не был создан из\-за того, что поток кода программы обошел соответствующее объявление, попытка удаления этого объект не предпринимается.  
  
### Статические локальные переменные  
 В C\+\+ локальные переменные можно объявлять как статические.  Переменная является видимой только в теле функции, однако для всех экземпляров функции существует только одна копия переменной.  
  
## Указатели на функции  
 Как и в C, в C\+\+ поддерживаются указатели на функции.  Однако более типобезопасной альтернативой обычно служит использование объекта\-функции.  
  
 При объявлении функции, которая возвращает тип указателя на функцию, рекомендуется использовать ключевое слово `typedef`, чтобы объявить псевдоним для типа указателя на функцию.  Пример  
  
```  
typedef int (*fp)(int);  
fp myFunction(char* s); // function returning function pointer  
```  
  
 Если оно не используется, то правильный синтаксис объявления функции можно вывести из синтаксиса декларатора для указателя на функцию, заменив идентификатор \(в приведенном выше примере — `fp`\) на имя функции и список аргументов, как показано выше:  
  
```  
int (*myFunction(char* s))(int);  
```  
  
 Это объявление эквивалентно объявлению при помощи ключевого слова typedef, которое приводилось выше.  
  
## См. также  
 [Перегрузка функций](../cpp/function-overloading.md)   
 [Функции со списками аргументов переменных](../cpp/functions-with-variable-argument-lists-cpp.md)   
 [Явно используемые по умолчанию и удаленные функции](../Topic/Explicitly%20Defaulted%20and%20Deleted%20Functions.md)   
 [Поиск имен функций с зависимостью от аргументов \(поиск Koenig\)](../Topic/Argument-Dependent%20Name%20\(Koenig\)%20Lookup%20on%20Functions.md)   
 [Аргументы по умолчанию](../Topic/Default%20Arguments.md)   
 [Подставляемые функции](../Topic/Inline%20Functions%20\(C++\).md)