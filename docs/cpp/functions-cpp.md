---
title: Функции (C++) | Документы Microsoft
ms.custom: ''
ms.date: 01/25/2018
ms.technology:
- cpp-language
ms.topic: language-reference
dev_langs:
- C++
helpviewer_keywords:
- defaults, arguments
- function definitions
- function definitions, about function definitions
- default arguments
- declarators, functions
ms.assetid: 33ba01d5-75b5-48d2-8eab-5483ac7d2274
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 720147992540b53c51e731db361cd9946a7a5313
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
---
# <a name="functions-c"></a>Функции (C++)

Функции — это блоки кода, выполняющие определенные операции. Если требуется, функция может определять входные параметры, позволяющие вызывающим объектам передавать ей аргументы. При необходимости функция также может возвращать значение как выходное. Функции полезны для инкапсуляции основных операций в едином блоке, который может многократно использоваться. В идеальном случае имя этого блока должно четко описывать назначение функции. Следующая функция принимает два целых числа от вызывающего объекта и возвращает их сумму. `a` и `b` , *параметры* типа **int**.

```cpp
int sum(int a, int b)
{
    return a + b;
}
```

Функции могут быть вызваны, или *вызывается*, от любого числа местах программы. Значения, которые передаются в функцию *аргументы*, их типы должны быть совместимы с типами параметров в определении функции.

```cpp
int main()
{
    int i = sum(10, 32);
    int j = sum(i, 66);
    cout << "The value of j is" << j << endl; // 108
}
```

Длина функции практически не ограничена, однако для максимальной эффективности кода целесообразно использовать функции, каждая из которых выполняет одиночную, четко определенную задачу. Сложные алгоритмы лучше разбивать на более короткие и простые для понимания функции, если это возможно.

Функции, определенные в области видимости класса, называются функциями-членами. В C++, в отличие от других языков, функции можно также определять в области видимости пространства имен (включая неявное глобальное пространство имен). Такие функции называются *свободные функции* или *не являющихся членами*; они широко используются в стандартной библиотеке.

Функции могут быть *перегружены*, что означает различные версии функции могут совместно использовать то же имя, если они отличаются от количества или типов формальных параметров. Дополнительные сведения см. в разделе [перегрузка функций](../cpp/function-overloading.md).

## <a name="parts-of-a-function-declaration"></a>Части объявления функции

Функции, как минимум *объявление* состоит из типа возвращаемого значения, имя функции и список параметров (может быть пустым), необязательные ключевые слова, сообщающие Дополнительные инструкции компилятору. Следующий пример является объявление функции:

```cpp
int sum(int a, int b);
```

Определение функции состоит из ее объявления, а также *текст*, являющееся весь код между фигурными скобками:

```cpp
int sum(int a, int b)
{
    return a + b;
}
```

Объявление функции, за которым следует точка с запятой, может многократно встречаться в разных местах кода программы. Оно необходимо перед любыми вызовами этой функции в каждой записи преобразования. По правилу одного определения, определение функции должно фигурировать в коде программы лишь один раз.

При объявлении функции необходимо указать:

1. Тип возвращаемого значения, который задает тип значения, возвращаемого функцией, или **void** Если значение не возвращается. В C ++ 11 **автоматически** является допустимым типом возврата, который сообщает компилятору вывести тип с оператором return. Тип decltype (auto) также используется в C++14. Дополнительные сведения см. в подразделе "Выведение возвращаемых типов" ниже.

1. Имя функции, которое должно начинаться с буквы или символа подчеркивания и не должно содержать пробелов. В стандартной библиотеке со знака подчеркивания обычно начинаются имена закрытых функций-членов или функций, не являющихся членами и не предназначенных для использования в вашем коде.

1. Список параметров, заключенный в скобки. В этом списке через запятую указывается нужное (возможно, нулевое) число параметров, задающих тип и, при необходимости, локальное имя, по которому к значениям можно получить доступ в теле функции.

Необязательные элементы объявления функции:

1. **constexpr**, который указывает, что возвращаемое значение функции является постоянное значение может быть вычислено во время компиляции.

    ```cpp
    constexpr float exp(float x, int n)
    {
        return n == 0 ? 1 :
            n % 2 == 0 ? exp(x * x, n / 2) :
            exp(x * x, (n - 1) / 2) * x;
    };
    ```

1. Его спецификация компоновки **extern** или **статических**.

    ```cpp
    //Declare printf with C linkage.
    extern "C" int printf( const char *fmt, ... );

    ```

     Дополнительные сведения см. в разделе [программа и компоновка](../cpp/program-and-linkage-cpp.md).

1. **Встроенная**, отдает компилятору команду заменять каждый вызов функции с код самой функции. Подстановка может улучшить эффективность кода в сценариях, где функция выполняется быстро и многократно вызывается во фрагментах, являющихся критическими для производительности программы.

    ```cpp
    inline double Account::GetBalance()
    {
        return balance;
    }
    ```

     Дополнительные сведения см. в разделе [встроенные функции](../cpp/inline-functions-cpp.md).

1. Объект **noexcept** выражения, которое указывает, может ли функция вызывать исключение. В следующем примере функция не вызывает исключение, если `is_pod` выражение, результатом которого является **true**.

    ```cpp
    #include <type_traits>

    template <typename T>
    T copy_object(T& obj) noexcept(std::is_pod<T>) {...}
    ```

     Дополнительные сведения см. в разделе [noexcept](../cpp/noexcept-cpp.md).

1. (Только функции-члены) Cv квалификаторы, которые указывают, может ли функция **const** или **volatile**.

1. (Только функции-члены) **виртуальных**, **переопределить**, или **окончательного**. **виртуальный** указывает, что функция быть переопределена в производном классе. **переопределить** означает, что функция в производном классе переопределяет виртуальную функцию. **Окончательный** означает функция не может быть переопределена в любом дальнейшей производного класса. Дополнительные сведения см. в разделе [виртуальные функции](../cpp/virtual-functions.md).

1. (только функции-члены) **статических** применения члену функции означает, что функция не связан с экземпляры объектов класса.

1. (Только для не являющегося статическим члена функции) Ref квалификатор, который указывает компилятору, какую перегрузку функции следует выбрать, если неявный объект-параметр (\*это) является ссылкой rvalue или ссылкой lvalue. Дополнительные сведения см. в разделе [перегрузка функций](function-overloading.md#ref-qualifiers).

На следующем рисунке показаны компоненты определения функции. Затененная область является телом функции.

 ![Компоненты определения функции](../cpp/media/vc38ru1.gif "vc38RU1") части определения функции

## <a name="function-definitions"></a>Определения функций

Объект *определение функции* состоит из объявления и текст, заключенный в фигурные скобки, содержащий объявления переменных, операторы и выражения. В следующем примере показано определение полноценную функцию.

```cpp
    int foo(int i, std::string s)
    {
       int value {i};
       MyClass mc;
       if(strcmp(s, "default") != 0)
       {
            value = mc.do_something(i);
       }
       return value;
    }
```

Переменные, объявленные в теле функции, называются локальными. Они исчезают из области видимости при выходе из функции, поэтому функция никогда не должна возвращать ссылку на локальную переменную.

```cpp
    MyClass& boom(int i, std::string s)
    {
       int value {i};
       MyClass mc;
       mc.Initialize(i,s);
       return mc;
    }
```

## <a name="const-and-constexpr-functions"></a>функции const и constexpr

Можно объявить функцию-член как **const** для указания, что функция не разрешено изменять значения членов данных в классе. Путем объявления функции-члена как **const**, позволяет компилятору обеспечить *правильность const*. Если кто-то по ошибке предпринимается попытка изменить объект с помощью функции, объявленные как **const**, возникает ошибка компилятора. Дополнительные сведения см. в разделе [const](const-cpp.md).

Объявить функцию как **constexpr** когда он выдает значение возможно можно определить во время компиляции. Функция constexpr обычно выполняется быстрее, чем обычные функции. Дополнительные сведения см. в разделе [constexpr](constexpr-cpp.md).

## <a name="function-templates"></a>Шаблоны функций

Шаблоны функций подобны шаблонам классов. Их задача заключается в создании конкретных функций на основе аргументов шаблонов. Во многих случаях шаблоны могут определять типы аргументов, поэтому их не требуется явно указывать.

```cpp
template<typename Lhs, typename Rhs>
auto Add2(const Lhs& lhs, const Rhs& rhs)
{
    return lhs + rhs;
}

auto a = Add2(3.13, 2.895); // a is a double
auto b = Add2(string{ "Hello" }, string{ " World" }); // b is a std::string
```

Дополнительные сведения см. в разделе [шаблонов функций](../cpp/function-templates.md)

## <a name="function-parameters-and-arguments"></a>Параметры и аргументы функций

У функции имеется список параметров, в котором через запятую перечислено необходимое (возможно, нулевое) число типов. Каждому параметру присваивается имя, по которому к нему можно получить доступ в теле функции. В шаблоне функции могут указываться дополнительные типы или значения параметров. Вызывающий объект передает аргументы, представляющие собой конкретные значения, типы которых совместимы со списком параметров.

По умолчанию аргументы передаются функции по значению, то есть функция получает копию передаваемого объекта. Копирование крупных объектов может быть ресурсозатратным и неоправданным. Аргументы для передачи по ссылке (в частности ссылки lvalue), ссылкам квантификатор ссылку на параметр:

```cpp
void DoSomething(std::string& input){...}
```

Если функция изменяет аргумент, передаваемый по ссылке, изменяется исходный объект, а не его локальная копия. Чтобы предотвратить изменение такого аргумента функцией, его следует определить как const&:

```cpp
void DoSomething(const std::string& input){...}
```

 **C ++ 11:** для явной обработки аргументов, передаваемых по ссылка rvalue или ссылку lvalue, двойной амперсанд для параметра следует использовать, чтобы указать универсальную ссылку:

```cpp
void DoSomething(const std::string&& input){...}
```

Функции, объявленные с одним ключевым словом **void** в объявлении параметра список не принимает аргументы, при условии, что ключевое слово **void** является первым и единственным членом списка объявления аргументов. Аргументы типа **void** в других местах списка создают ошибки. Пример:

```cpp

// OK same as GetTickCount()
long GetTickCount( void );
```

Обратите внимание, что, хотя и существует нельзя указать **void** аргумента, за исключением того, как описано здесь, типы, унаследованные от типа **void** (например, указатели на **void** и массивы **void**) может находиться в любом месте списка объявления аргументов.

### <a name="default-arguments"></a>Аргументы по умолчанию

Последним параметрам в сигнатуре функции можно назначить аргумент по умолчанию, т. е. вызывающий объект сможет опустить аргумент при вызове функции, если не требуется указать какое-либо другое значение.

```cpp
int DoSomething(int num,
    string str,
    Allocator& alloc = defaultAllocator)
{ ... }

// OK both parameters are at end
int DoSomethingElse(int num,
    string str = string{ "Working" },
    Allocator& alloc = defaultAllocator)
{ ... }

// C2548: 'DoMore': missing default parameter for parameter 2
int DoMore(int num = 5, // Not a trailing parameter!
    string str,
    Allocator& = defaultAllocator)
{...}
```

Дополнительные сведения см. в разделе [аргументы по умолчанию](../cpp/default-arguments.md).

## <a name="function-return-types"></a>типов возвращаемых функциями значений;

Функция не может возвращать другие функции и встроенные массивы; Однако возможен возврат указателей на эти типы, или *лямбда-выражение*, который выдает объект функции. За исключением этих случаев функция может вернуть значение любого типа, который находится в области, а также может возвращать никакого значения, в этом случае возвращаемый тип — **void**.

### <a name="trailing-return-types"></a>Завершающие возвращаемые типы

"Обычные" типы возвращаемого значения расположены слева от сигнатуры функции. Объект *завершающего возвращаемого типа* находится в правой части сигнатуры и перед ними находится оператор ->. Завершающие типы возвращаемого значения особенно полезны в шаблонах функций, когда тип возвращаемого значения зависит от параметров шаблона.

```cpp
template<typename Lhs, typename Rhs>
auto Add(const Lhs& lhs, const Rhs& rhs) -> decltype(lhs + rhs)
{
    return lhs + rhs;
}
```

Когда **автоматически** используется в сочетании с завершающего возвращаемого типа, он просто служит как заполнитель для выражения decltype, а не выполняя выведения типа.


## <a name="function-local-variables"></a>Локальные переменные функции

Переменная, объявленная внутри тела другой функции вызывается *локальной переменной* или просто *локальной*. Нестатические локальные переменные видны только в теле функции. Если локальные переменные объявляются в стеке, они исчезают из области видимости при выходе из функции. При создании локальной переменной и ее возвращении по значению компилятор обычно выполняет оптимизацию возвращаемого значения, чтобы избежать ненужных операций копирования. Если локальная переменная возвращается по ссылке, компилятор выдаст предупреждение, поскольку любые попытки вызывающего объекта использовать эту ссылку произойдут после уничтожения локальной переменной.

В C++ локальные переменные можно объявлять как статические. Переменная является видимой только в теле функции, однако для всех экземпляров функции существует только одна копия переменной. Локальные статические объекты удаляются во время завершения, определенного директивой **atexit**. Если статический объект не был создан из-за того, что поток кода программы обошел соответствующее объявление, попытка уничтожения этого объект не предпринимается.

##  <a name="type_deduction"></a> Выведение возвращаемых типов (C ++ 14)

В C ++ 14 можно использовать **автоматически** компилятору вывести тип возвращаемого значения из тела функции без использования завершающего возвращаемого типа. Обратите внимание, что **автоматически** всегда выводит возврата по значению. Используйте **Авто & &** чтобы компилятор определил ссылку.

В этом примере **автоматически** как копии непостоянного значения суммы lhs и rhs.

```cpp
template<typename Lhs, typename Rhs>
auto Add2(const Lhs& lhs, const Rhs& rhs)
{
    return lhs + rhs; //returns a non-const object by value
}
```

Обратите внимание, что **автоматически** не сохраняет константность постоянность типа. Для функций пересылки, возвращаемое значение должны сохранить константность или (ref) аргументов, можно использовать **decltype(auto)** ключевое слово, которое использует **decltype** правила определения типов и сохраняет сведения о типе. **decltype(AUTO)** может использоваться как обычное возвращаемое значение с левой стороны или как завершающее возвращаемое значение.

Следующий пример (основанном на коде из [N3493](http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3493.html)), показаны **decltype(auto)** используется для оптимального перенаправления аргументов функции в возвращаемый тип, неизвестный до шаблон Создание экземпляров.

```cpp
template<typename F, typename Tuple = tuple<T...>, int... I>
decltype(auto) apply_(F&& f, Tuple&& args, index_sequence<I...>)
{
    return std::forward<F>(f)(std::get<I>(std::forward<Tuple>(args))...);
}

template<typename F, typename Tuple = tuple<T...>,
    typename Indices = make_index_sequence<tuple_size<Tuple>::value >>
   decltype( auto)
    apply(F&& f, Tuple&& args)
{
    return apply_(std::forward<F>(f), std::forward<Tuple>(args), Indices());
}
}
```

## <a name="returning-multiple-values-from-a-function"></a>Возвращение несколько значений из функции

Существует несколько способов для получения более одного значения из функции:

1. Инкапсуляция значения в объект с именем класса или структуры. Требуется определение класса или структуры, чтобы быть видимым для вызывающего объекта:

    ```cpp
    #include <string>
    #include <iostream>
    
    using namespace std;
    
    struct S
    {
        string name;
        int num;
    };
    
    S g()
    {
        string t{ "hello" };
        int u{ 42 };
        return { t, u };
    }
    
    int main()
    {
        S s = g();
        cout << s.name << " " << s.num << endl;
        return 0;
    }
    ```
    
1. Возвращает объект std::tuple или std::pair:

    ```cpp
    #include <tuple>
    #include <string>
    #include <iostream>
    
    using namespace std;
        
    tuple<int, string, double> f()
    {
        int i{ 108 };
        string s{ "Some text" };
        double d{ .01 };
        return { i,s,d };
    }
    
    int main()
    {
        auto t = f();
        cout << get<0>(t) << " " << get<1>(t) << " " << get<2>(t) << endl;
     
        // --or--
    
        int myval;
        string myname;
        double mydecimal;
        tie(myval, myname, mydecimal) = f();
        cout << myval << " " << myname << " " << mydecimal << endl;
    
        return 0;
    }
    ```

1. **Visual Studio 2017 г 15,3 и более поздних версий** (с [/std: c ++ 17](../build/reference/std-specify-language-standard-version.md)): использование структурированной привязок. Преимуществом структурированных привязки является, переменные возвращаемого значения которых инициализируются в то же время, в которой они объявлены, что в некоторых случаях может быть значительно эффективнее. В этом операторе--`auto[x, y, z] = f();`--квадратные скобки, вводят и инициализируйте имена, которые находятся в области видимости блока всей функции.

    ```cpp
    #include <tuple>
    #include <string>
    #include <iostream>
    
    using namespace std;
    
    tuple<int, string, double> f()
    {
        int i{ 108 };
        string s{ "Some text" };
        double d{ .01 };
        return { i,s,d };
    }
    struct S
    {
        string name;
        int num;
    };
    
    S g()
    {
        string t{ "hello" };
        int u{ 42 };
        return { t, u };
    }
    
    int main()
    {
        auto[x, y, z] = f(); // init from tuple
        cout << x << " " << y << " " << z << endl;
    
        auto[a, b] = g(); // init from POD struct
        cout << a << " " << b << endl;
        return 0;
    }
    ```
    
1. Помимо использования само возвращаемое значение, можно «вернуть» значения путем определения любое количество параметров для использования передачи по ссылке, чтобы функция может изменить или инициализации значений объектов, вызывающим. Дополнительные сведения см. в разделе [аргументы функции ссылочного типа](reference-type-function-arguments.md).

## <a name="function-pointers"></a>Указатели на функции

Как и в C, в C++ поддерживаются указатели на функции. Однако более типобезопасной альтернативой обычно служит использование объекта-функции.

Рекомендуется **typedef** могут использоваться для объявления псевдонима для типа указателя функции, если объявление функции, которая возвращает тип указателя на функцию.  Пример

```cpp
typedef int (*fp)(int);
fp myFunction(char* s); // function returning function pointer
```

Если оно не используется, то правильный синтаксис объявления функции можно вывести из синтаксиса декларатора для указателя на функцию, заменив идентификатор (в приведенном выше примере — `fp`) на имя функции и список аргументов, как показано выше:

```cpp
int (*myFunction(char* s))(int);
```

Это объявление эквивалентно объявлению при помощи ключевого слова typedef, которое приводилось выше.

## <a name="see-also"></a>См. также

- [Перегрузка функции](../cpp/function-overloading.md)
- [Функции с переменными списками аргументов](../cpp/functions-with-variable-argument-lists-cpp.md)
- [Явно используемые по умолчанию и удаленные функции](../cpp/explicitly-defaulted-and-deleted-functions.md)
- [Поиск имен функций с зависимостью от аргументов (поиск Koenig)](../cpp/argument-dependent-name-koenig-lookup-on-functions.md)
- [Аргументы по умолчанию](../cpp/default-arguments.md)
- [Встраиваемые функции](../cpp/inline-functions-cpp.md)
