---
title: "decltype (C++) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "language-reference"
f1_keywords: 
  - "decltype"
  - "decltype_cpp"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "decltype - оператор"
  - "операторы [C++], decltype"
  - "операторы [C++], выведение типа выражения"
  - "операторы [C++], тип выражения"
ms.assetid: 6dcf8888-8196-4f13-af50-51e3797255d4
caps.latest.revision: 14
caps.handback.revision: 14
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# decltype (C++)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Описатель типа `decltype` предоставляет тип заданного выражения.  Описатель типа `decltype` вместе с [ключевое слово " auto "](../cpp/auto-cpp.md), используется главным образом для разработчиков, которые создают библиотеки шаблонов.  Используйте `auto` и `decltype` для объявления функции шаблонов, возвращаемый тип которой зависит от типов аргументов его шаблонов.  Либо используйте `auto` и `decltype` для объявления функции шаблона, которая создает программу\-оболочку для вызова другой функции, а затем возвращает возвращаемый тип функции с программой\-оболочкой.  
  
## Синтаксис  
  
```  
decltype( expression )  
```  
  
#### Параметры  
  
|Параметр|Описание|  
|--------------|--------------|  
|`expression`|Выражения.  Дополнительные сведения см. в статье [Выражения](../cpp/expressions-cpp.md).|  
  
## Возвращаемое значение  
 Тип параметра `expression`.  
  
## Заметки  
 Описатель типа `decltype` поддерживается в Visual C\+\+ 2010 или более поздних версиях и может использоваться с машинным или управляемым кодом.  `decltype(auto)` \(C\+\+ 14\) поддерживается в Visual Studio 2015 и более поздних версиях.  
  
 Компилятор использует следующие правила для определения типа параметра `expression`.  
  
-   Если параметр `expression` является идентификатором или [контролирует доступ к элементу класса](../Topic/Member%20Access%20Operators:%20.%20and%20-%3E.md), `decltype(``expression``)` — это тип сущности с именем `expression`.  Если такая сущность отсутствует или параметр `expression` именует набор перегруженных функций, компилятор создает сообщение об ошибке.  
  
-   Если параметр `expression` является вызовом функции или перегруженной функцией оператора, `decltype(``expression``)` — это возвращаемый тип функции.  Скобки вокруг перегруженного оператора игнорируются.  
  
-   Если параметр `expression` — [rvalue](../Topic/Lvalues%20and%20Rvalues%20\(Visual%20C++\).md), `decltype(``expression``)` — это тип `expression`.  Если параметр `expression` — это значение [lvalue](../Topic/Lvalues%20and%20Rvalues%20\(Visual%20C++\).md), `decltype(``expression``)` — это [ссылка значения lvalue](../Topic/Lvalue%20Reference%20Declarator:%20&.md) на тип `expression`.  
  
 В следующем примере кода продемонстрированы некоторые варианты использования описателя типов `decltype`.  Допустим, во\-первых, что были закодированы следующие операторы.  
  
```  
int var;  
const int&& fx();   
struct A { double x; }  
const A* a = new A();  
```  
  
 Затем изучите типы, возвращаемые четырьмя операторами `decltype`, в таблице ниже.  
  
|Оператор|Тип|Примечания|  
|--------------|---------|----------------|  
|`decltype(fx());`|`const int&&`|[Ссылка rvalue](../cpp/rvalue-reference-declarator-amp-amp.md) на `const int`.|  
|`decltype(var);`|`int`|Тип переменной `var`.|  
|`decltype(a->x);`|`double`|Тип членского доступа.|  
|`decltype((a->x));`|`const double&`|Внутренние скобки вызывают оценку оператора в качестве выражения, а не членского доступа.  А поскольку `a` объявляется как указатель `const`, тип является ссылкой на `const double`.|  
  
## Decltype и Auto  
 В C\+\+ 14 можно использовать  `decltype(auto)` без завершающего возвращаемого типа для объявления функции\-шаблона, возвращаемый тип которой зависит от типов его аргументов шаблона.  
  
 В C\+\+ 11 можно использовать описатель типа `decltype` для завершающего возвращаемого типа вместе с ключевым словом `auto`, чтобы объявить функцию\-шаблон, возвращаемый тип которой зависит от типов его аргументов шаблона.  Например, рассмотрим следующий пример кода, в котором возвращаемый тип функции шаблона зависит от типов аргументов шаблона.  В примере кода заполнитель *UNKNOWN* указывает, что возвращаемый тип не может быть указан.  
  
```  
template<typename T, typename U>  
UNKNOWN func(T&& t, U&& u){ return t + u; };   
```  
  
 Внедрение описателя типа `decltype` позволяет разработчику получить тип выражения, возвращаемого функцией шаблона.  Используйте *альтернативный синтаксис объявления функций* \(см. ниже\), ключевое слово `auto` и описатель типа `decltype` для объявления *поздно заданный* возвращаемого типа.  Поздно заданный возвращаемый тип определяется, когда происходит компиляция, а не кодирование объявления.  
  
 Следующий прототип иллюстрирует синтаксис альтернативного объявления функции.  Обратите внимание, что квалификаторы `const`, `volatile` и спецификация `throw` [exception](../cpp/exception-specifications-throw-cpp.md) являются необязательными.  Заполнитель *тело\_функции* представляет составную инструкцию, которая определяет действия функции.  При написании кода рекомендуется сделать так, чтобы заполнитель *выражение* в операторе `decltype` соответствовал выражению, заданному оператором `return`, если имеется, в *тело\_функции*.  
  
 `auto` *имя\_функции*`(`*параметры*необ`)` `const`необ `volatile`необ `−>` `decltype(`*выражение*`)` `throw`необ `{`*тело\_функции*`};`  
  
 В следующем примере кода поздно заданный возвращаемый тип функции шаблона `myFunc` определяется типами аргументов шаблона `t` и `u`.  В соответствии с рекомендацией в данном примере кода также используются ссылки rvalue и шаблон функций `forward`, поддерживающий *точную пересылку*.  Дополнительные сведения см. в статье [Декларатор ссылки Rvalue: &&](../cpp/rvalue-reference-declarator-amp-amp.md).  
  
```  
//C++11  
 template<typename T, typename U>  
auto myFunc(T&& t, U&& u) -> decltype (forward<T>(t) + forward<U>(u))   
        { return forward<T>(t) + forward<U>(u); };  
  
//C++14  
template<typename T, typename U>  
decltype(auto) myFunc(T&& t, U&& u)   
        { return forward<T>(t) + forward<U>(u); };  
  
```  
  
## Decltype и функции пересылки \(C\+\+ 11\)  
 Функции пересылки создают программы\-оболочек для вызовов других функций.  Рассмотрим шаблон функции, который пересылает свои аргументы \(или результаты выражения с этими аргументами\) другой функции.  Кроме того, функция пересылки возвращает результат вызова другой функции.  В этом сценарии возвращаемый тип функции пересылки должен совпадать с возвращаемым типом функции в программе\-оболочке.  
  
 В этом сценарии невозможно создать подобающее выражение типа без описателя типа `decltype`.  Описатель типа `decltype` включает универсальные функции пересылки, поскольку не теряет необходимой информации о том, возвращает ли функция ссылочный тип.  Пример кода функции пересылки см. в предыдущем примере шаблонной функции `myFunc`.  
  
## Пример  
 В следующем примере кода объявляется поздно заданный возвращаемый тип шаблонной функции `Plus()`.  Функция `Plus` обрабатывает два свои операнда с перегрузкой `operator+`.  Следовательно, интерпретация добавочного оператора \(\+\) и возвращаемый тип функции `Plus` зависят от типов аргументов функции.  
  
```  
// decltype_1.cpp  
// compile with: /EHsc  
//  
#include "stdafx.h"  
#include <iostream>  
#include <string>  
#include <utility>  
#include <iomanip>  
  
using namespace std;  
  
template<typename T1, typename T2>  
auto Plus(T1&& t1, T2&& t2) ->   
   decltype(forward<T1>(t1) + forward<T2>(t2))  
{  
   return forward<T1>(t1) + forward<T2>(t2);  
}  
  
class X  
{  
   friend X operator+(const X& x1, const X& x2)  
   {  
      return X(x1.m_data + x2.m_data);  
   }  
  
public:  
   X(int data) : m_data(data) {}  
   int Dump() const { return m_data;}  
private:  
   int m_data;  
};  
  
int main()  
{  
   // Integer   
   int i = 4;  
   cout <<   
      "Plus(i, 9) = " <<   
      Plus(i, 9) << endl;  
  
   // Floating point  
   float dx = 4.0;  
   float dy = 9.5;  
   cout <<     
      setprecision(3) <<   
      "Plus(dx, dy) = " <<  
      Plus(dx, dy) << endl;  
  
   // String        
   string hello = "Hello, ";  
   string world = "world!";  
   cout << Plus(hello, world) << endl;  
  
   // Custom type  
   X x1(20);  
   X x2(22);  
   X x3 = Plus(x1, x2);  
   cout <<   
      "x3.Dump() = " <<   
      x3.Dump() << endl;  
}  
```  
  
 **Вывод**  
  
 Данный пример кода дает следующие результаты.  
  
 13  
  
 13.5  
  
 Здравствуй, мир\!  
  
 42  
  
## Требования  
 Visual C\+\+ 2010 и выше.  
  
 Для decltype\(auto\) требуется Visual Studio 2015 или более поздняя версия.  
  
## См. также  
 [Простые имена типов](http://msdn.microsoft.com/ru-ru/333f45cb-2c72-4d81-8e59-e346b05f55e3)