---
title: "Строковые и символьные литералы (C++) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "language-reference"
f1_keywords: 
  - "R"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "escape-последовательности"
  - "L - константа"
  - "строковые литералы"
  - "строковые литералы, C++"
  - "строки null"
  - "строки null, строки, заканчивающиеся null"
  - "NULL, константа символов"
  - "строковые литералы"
  - "строковые литералы, синтаксис"
  - "строки [C++], строковые литералы"
  - "расширенные символы, strings"
ms.assetid: 61de8f6f-2714-4e7b-86b6-a3f885d3b9df
caps.latest.revision: 36
caps.handback.revision: 34
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Строковые и символьные литералы (C++)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

В C\+\+ поддерживаются различные типы строк и символов, а также доступны различные способы выражения значений литералов каждого из этих типов. В исходном коде содержимое символьных и строковых литералов выражается с помощью кодировки. Универсальные имена символов и escape\-символы позволяют представить любую строку, используя только основную кодировку исходного кода. Необработанные строковые литералы позволяют не использовать escape\-символы и могут применяться для выражения всех типов строковых литералов. Можно также создать литералы std::string без необходимости выполнять дополнительные действия по созданию или преобразованию.  
  
```cpp  
#include <string> using namespace std::string_literals; // enables s-suffix for std::string literals int main() { // Character literals auto c0 =   'A'; // char auto c1 = u8'A'; // char auto c2 =  L'A'; // wchar_t auto c3 =  u'A'; // char16_t auto c4 =  U'A'; // char32_t // String literals auto s0 =   "hello"; // const char* auto s1 = u8"hello"; // const char*, encoded as UTF-8 auto s2 =  L"hello"; // const wchar_t* auto s3 =  u"hello"; // const char16_t*, encoded as UTF-16 auto s4 =  U"hello"; // const char32_t*, encoded as UTF-32 // Raw string literals containing unescaped \ and " auto R0 =   R"("Hello \ world")"; // const char* auto R1 = u8R"("Hello \ world")"; // const char*, encoded as UTF-8 auto R2 =  LR"("Hello \ world")"; // const wchar_t* auto R3 =  uR"("Hello \ world")"; // const char16_t*, encoded as UTF-16 auto R4 =  UR"("Hello \ world")"; // const char32_t*, encoded as UTF-32 // Combining string literals with standard s-suffix auto S0 =   "hello"s; // std::string auto S1 = u8"hello"s; // std::string auto S2 =  L"hello"s; // std::wstring auto S3 =  u"hello"s; // std::u16string auto S4 =  U"hello"s; // std::u32string // Combining raw string literals with standard s-suffix auto S5 =   R"("Hello \ world")"s; // std::string from a raw const char* auto S6 = u8R"("Hello \ world")"s; // std::string from a raw const char*, encoded as UTF-8 auto S7 =  LR"("Hello \ world")"s; // std::wstring from a raw const wchar_t* auto S8 =  uR"("Hello \ world")"s; // std::u16string from a raw const char16_t*, encoded as UTF-16 auto S9 =  UR"("Hello \ world")"s; // std::u32string from a raw const char32_t*, encoded as UTF-32 }  
```  
  
 Строковые литералы могут не иметь префикса или включать префиксы `u8`, `L`, `u` и `U` для обозначения кодировок обычных символов \(однобайтовых или многобайтовых\), UTF\-8, расширенных символов \(UCS\-2 или UTF\-16\), UTF\-16 и UTF\-32, соответственно. Необработанные строковые литералы могут включать префиксы `R`, `u8R`, `LR`, `uR` и `UR` для эквивалентов необработанных версий кодировок.  Чтобы создать временные или статические значения std::string, можно использовать строковые литералы или необработанные строковые литералы с суффиксом `s`. Дополнительные сведения см. в разделе "Строковые литералы" ниже. Дополнительные сведения об основной кодировке исходного кода, универсальных именах символов и использовании символов из расширенных кодовых страниц в исходном коде см. в разделе [Наборы символов](../cpp/character-sets2.md).  
  
## Символьные литералы  
 *Символьный литерал* состоит из символьной константы. Она представлена символом, заключенным в одинарные кавычки. Существует четыре типа символьных литералов:  
  
-   Узкие символьные литералы типа `char`, например `'a'`.  
  
-   Расширенные символьные литералы типа `wchar_t`, например `L'a'`.  
  
-   Расширенные символьные литералы типа `char16_t`, например `u'a'`.  
  
-   Расширенные символьные литералы типа `char32_t`, например `U'a'`.  
  
 Для символьных литералов могут использоваться любые символы, за исключением зарезервированных символов обратной косой черты \("\\"\), одинарных кавычек \('\) или новой строки. Зарезервированные символы можно указывать с помощью escape\-последовательности. Символы можно указывать с помощью универсальных имен символов, при условии что тип является достаточно крупным для размещения символа.  
  
###  <a name="bkmk_Escape"></a> Escape\-последовательность  
 Существует три вида escape\-последовательностей: простая, восьмеричная и шестнадцатеричная. Возможны следующие типы escape\-последовательностей:  
  
|Значение|Escape\-последовательность|Значение|Escape\-последовательность|  
|--------------|--------------------------------|--------------|--------------------------------|  
|новая строка|\\n|обратная косая черта|\\\\|  
|горизонтальная табуляция|\\t|вопросительный знак|? или \\?|  
|вертикальная табуляция|\\v|одинарная кавычка|\\'|  
|стирание назад|\\b|двойная кавычка|\\"|  
|возврат каретки|\\r|нуль\-символ|\\0|  
|перевод страницы|\\f|восьмеричный|\\ooo|  
|оповещение \(колокольчик\)|\\a|шестнадцатеричный|\\xhhh|  
  
 В следующем коде показаны некоторые примеры escape\-символов \(с использованием узких строковых литералов\). Этот синтаксис также актуален для других типов строковых литералов.  
  
```cpp  
#include <iostream> using namespace std; int main() { char newline = '\n'; char tab = '\t'; char backspace = '\b'; char backslash = '\\'; char nullChar = '\0'; cout << "Newline character: " << newline << "ending" << endl; // Newline character: //  ending cout << "Tab character: " << tab << "ending" << endl; // Tab character : ending cout << "Backspace character: " << backspace << "ending" << endl; // Backspace character : ending cout << "Backslash character: " << backslash << "ending" << endl; // Backslash character : \ending cout << "Null character: " << nullChar << "ending" << endl; //Null character:  ending }  
```  
  
 **Блок, относящийся только к системам Microsoft**  
  
 Для создания значения из символьного литерала без префикса компилятор преобразует символ или последовательность символов между одинарными кавычками в 8\-разрядные значения в 32\-разрядном целом числе. Несколько символов в литерале заполняют соответствующие байты по мере необходимости от высокого до низкого порядка. Для создания значения `char` компилятор принимает младший байт. Для создания значения `wchar_t` или  `char16_t` компилятор принимает младшее слово. Компилятор выдает предупреждение о том, что результат усекается, если какие\-либо биты заданы выше назначенного байта или слова.  
  
```cpp  
char c0    = 'abcd';    // C4305, C4309, truncates to 'd' wchar_t w0 = 'abcd';    // C4305, C4309, truncates to '\x6364'  
```  
  
 Восьмеричная escape\-последовательность — это обратная косая черта, за которой следует последовательность восьмеричных цифр \(не более трех\). Восьмеричная escape\-последовательность, которая содержит более трех цифр, обрабатывается как восьмеричная последовательность из трех цифр, за которой следуют цифры, обозначающие символы. Это может приводить к неожиданным результатам. Пример:  
  
```cpp  
char c1 = '\100';   // '@' char c2 = '\1000';  // C4305, C4309, truncates to '0'   
```  
  
 Escape\-последовательности, которые содержат невосьмеричные символы, вычисляются как восьмеричные последовательности до последнего восьмеричного символа, за которым следуют остальные символы. Пример:  
  
```cpp  
char c3 = '\009';   // '9' char c4 = '\089';   // C4305, C4309, truncates to '9' char c5 = '\qrs';   // C4129, C4305, C4309, truncates to 's'  
```  
  
 Шестнадцатеричная escape\-последовательность — это обратная косая черта, за которой следует символ `x` и последовательность шестнадцатеричных цифр. Escape\-последовательности, которые не содержат шестнадцатеричные цифры, вызывают ошибку компилятора C2153. Эта ошибка сообщает, что шестнадцатеричные литералы должны содержать по крайней мере одну шестнадцатеричную цифру. Начальные нули пропускаются. Escape\-последовательность, которая содержит шестнадцатеричные и другие символы, вычисляется как шестнадцатеричная escape\-последовательность до последнего шестнадцатеричного символа, за которым следуют другие символы.   В обычном символьном литерале без префикса или с префиксом u8 максимальное шестнадцатеричное значение — 0xFF. В расширенном символьном литерале с префиксом L или u максимальное шестнадцатеричное значение — 0xFFFF. В расширенном символьном литерале с префиксом U максимальное шестнадцатеричное значение — 0xFFFFFFFF.  
  
```cpp  
char c6 = '\x0050'; // 'P' char c7 = '\x0pqr'; // C4305, C4309, truncates to 'r'  
```  
  
 Если расширенный символьный литерал с префиксом `L` содержит более одного символа, значение берется из первого символа. Последующие символы игнорируются, в отличие от поведения эквивалентного обычного символьного литерала без префикса.  
  
```cpp  
wchar_t w1 = L'\100';   // L'@' wchar_t w2 = L'\1000';  // C4066 L'@', 0 ignored wchar_t w3 = L'\009';   // C4066 L'\0', 9 ignored wchar_t w4 = L'\089';   // C4066 L'\0', 89 ignored wchar_t w5 = L'\qrs';   // C4129, C4066 L'q' escape, rs ignored wchar_t w6 = L'\x0050'; // L'P' wchar_t w7 = L'\x0pqr'; // C4066 L'\0', pqr ignored  
```  
  
 **Завершение блока, относящегося только к системам Майкрософт**  
  
 Символ обратной косой черты \(\\\) — это символ продолжения строки, если он стоит в конце строки. Если символ обратной косой черты требуется использовать как символьный литерал, необходимо ввести две косые черты подряд \(`\\`\). Дополнительные сведения о символе продолжения строки см. в разделе [Фазы трансляции](../preprocessor/phases-of-translation.md).  
  
###  <a name="bkmk_UCN"></a> Универсальные имена символов  
 В символьных литералах и машинных \(не являющихся необработанными\) строковых литералах любой символ может быть представлен универсальным именем символа.  Универсальные имена символов образуются префиксом \\U, за которым следует восьмизначная кодовая точка Юникода, или префиксом \\u, за которым следует четырехзначная кодовая точка Юникода. Все восемь или четыре знака, соответственно, должны присутствовать для создания корректного универсального имени символа.  
  
```cpp  
char u1 = 'A';          // 'A' char u2 = '\101';       // octal, 'A' char u3 = '\x41';       // hexadecimal, 'A' char u4 = '\u0041';     // \u UCN 'A' char u5 = '\U00000041'; // \U UCN 'A'  
```  
  
 **Суррогатные пары**  
  
 С помощью универсальных имен символов нельзя закодировать значения в диапазоне суррогатных кодовых точек D800–DFFF. Для суррогатных пар Юникода укажите универсальное имя символа, используя `\UNNNNNNNN`, где NNNNNNNN — восьмизначная кодовая точка для символа. При необходимости компилятор создаст суррогатную пару.  
  
 В C\+\+03 языком допускалось, чтобы универсальными именами символов представлялось лишь определенное подмножество символов. Также могли существовать универсальные имена символов, не представляющие никаких допустимых символов Юникода. В стандарте C\+\+11 этот недочет был исправлен. В C\+\+11 в символьных и строковых литералах и идентификаторах можно использовать универсальные имена символов.  Дополнительные сведения об универсальных именах символов см. в разделе [Наборы символов](../cpp/character-sets2.md). Дополнительные сведения о Юникоде см. в статье [Unicode](http://msdn.microsoft.com/library/dd374081\(v=vs.85\).aspx). Дополнительные сведения о суррогатных парах см. в статье [Surrogate Pairs and Supplementary Characters](http://msdn.microsoft.com/library/dd374069\(v=vs.85\).aspx) \(Суррогатные пары и дополнительные символы\).  
  
## Строковые литералы  
 Строковый литерал представляет последовательность символов, которые вместе образуют строку с завершающим нулем. Символы должны быть заключены в двойные кавычки. Существуют следующие типы строковых литералов.  
  
### Узкие строковые литералы  
 Обычный строковый литерал представляет собой завершающийся нулем ограниченный двойными кавычками массив типа `const`  `char`\[`n`\] без префикса, где n — длина массива в байтах. Обычный строковый литерал может содержать любые графические символы, за исключением двойных кавычек \(`"`\), обратной косой черты \(`\`\) или символа новой строки. Обычный строковый литерал также может содержать перечисленные выше escape\-последовательности и универсальные имена символов, которые помещаются в байте.  
  
```cpp  
const char *narrow = "abcd"; // represents the string: yes\no const char *escaped = "yes\\no";  
```  
  
 **Строки в кодировке UTF\-8**  
  
 Строка в кодировке UTF\-8 представляет собой завершающийся нулем ограниченный двойными кавычками массив типа `const` `char`\[`n`\] с префиксом u8, где n — длина закодированного массива в байтах. Строковый литерал с префиксом u8 может содержать любые графические символы, за исключением двойных кавычек \(`"`\), обратной косой черты \(`\`\) или символа новой строки. Строковый литерал с префиксом u8 может также содержать перечисленные выше escape\-последовательности и любые универсальные имена символов.  
  
```cpp  
const char* str1 = u8"Hello World"; const char* str2 = u8"\U0001F607 is O:-)";  
```  
  
### Расширенные строковые литералы  
 Расширенный строковый литерал — это завершающийся нулем массив констант `wchar_t`, начинающийся с префикса `L`. В этот массив могут входить любые графические символы, за исключением двойных кавычек \("\), обратной косой черты \(\\\) и символа новой строки. Расширенный строковый литерал может содержать перечисленные выше escape\-последовательности и любые универсальные имена символов.  
  
```cpp  
const wchar_t* wide = L"zyxw"; const wchar_t* newline = L"hello\ngoodbye";  
```  
  
 **char16\_t и char32\_t \(C\+\+11\)**  
  
 В C\+\+11 доступны символьные типы `char16_t` \(портативный, 16\-разрядный Юникод\) и `char32_t` \(32\-разрядный Юникод\):  
  
```cpp  
auto s3 = u"hello"; // const char16_t* auto s4 = U"hello"; // const char32_t*  
```  
  
### Необработанные строковые литералы \(C\+\+11\)  
 Необработанный строковый литерал — это завершающийся нулевым значением массив символов любого типа, в который могут входить любые графические символы, включая двойные кавычки \("\), обратную косую черту \(\\\) и символ новой строки. Необработанные строковые литералы часто применяются в регулярных выражениях, которые используют классы символов, а также в строках HTML и XML. Примеры см. в следующей статье: [Bjarne Stroustrup's FAQ on C\+\+11](http://go.microsoft.com/fwlink/?LinkId=401172) \(Вопросы и ответы о C\+\+11 от Бьерна Страуструпа\).  
  
```cpp  
// represents the string: An unescaped \ character const char* raw_narrow = R"(An unescaped \ character)"; const wchar_t* raw_wide = LR"(An unescaped \ character)"; const char*       raw_utf8  = u8R"(An unescaped \ character)"; const char16_t* raw_utf16 = uR"(An unescaped \ character)"; const char32_t* raw_utf32 = UR"(An unescaped \ character)";  
```  
  
 Разделитель — это содержащая до 16 символов пользовательская последовательность, которая стоит непосредственно перед открывающей круглой скобкой и сразу после закрывающей круглой скобки необработанного строкового литерала.  Например, в `R"abc(Hello"\()abc"` последовательность разделителей — `abc`, а содержимое строки — `Hello"\(`. Разделители можно использовать для различения необработанных строк, содержащих двойные кавычки и круглые скобки. Следующая строка приводит к ошибке компилятора:  
  
```cpp  
// meant to represent the string: )” const char* bad_parens = R"()")";  // error C2059  
```  
  
 Однако ошибку можно устранить с помощью разделителя:  
  
```cpp  
const char* good_parens = R"xyz()")xyz";  
```  
  
 Можно создать необработанный строковый литерал, содержащий символ новой строки \(не escape\-символ\) в исходном коде:  
  
```cpp  
// represents the string: hello //goodbye const wchar_t* newline = LR"(hello goodbye)";  
```  
  
### Литералы std::string \(C\+\+14\)  
 Литералы std::string представляют собой реализацию пользовательских литералов на основе стандартной библиотеки \(см. ниже\) и получаются путем добавления префикса "xyx"s \(вместе с суффиксом `s`\). Этот тип строковых литералов создает временные объекты типа std::string, std::wstring, std::u32string или std::u16string, в зависимости от указанного префикса. Если префикс не используется, как показано выше, создается объект типа std::string. Если используется префикс L"xyz"s, создается объект типа std::wstring. При использовании префикса u"xyz"s создается объект типа [std::u16string](../Topic/u16string.md), а префикса U"xyz"s — объект типа [std::u32string](../Topic/u32string.md).  
  
```cpp  
//#include <string> //using namespace std::string_literals; string str{ "hello"s }; string str2{ u8"Hello World" }; wstring str3{ L"hello"s }; u16string str4{ u"hello"s }; u32string str5{ U"hello"s };  
```  
  
 Суффикс "s" также может использоваться для необработанных строковых литералов:  
  
```cpp  
u32string str6{ UR"(She said "hello.")"s };  
```  
  
 Литералы std::string определены в пространстве имен `std::literals::string_literals` в файле заголовка \<string\>. Поскольку `std::literals::string_literals` и `std::literals` объявляются как [встроенные пространства имен](../cpp/namespaces-cpp.md), `std::literals::string_literals` автоматически считается напрямую принадлежащим пространству имен `std`.  
  
### Размер строковых литералов  
 Для строк типа char\* в кодировке ANSI и других однобайтовых кодировках \(не UTF\-8\) размер строкового литерала \(в байтах\) на единицу больше числа символов в строке \(с учетом завершающего нуля\). Для строк остальных типов размер напрямую не связан с количеством символов. В кодировке UTF\-8 для кодирования некоторых *единиц кода* используется до четырех символьных элементов, а для типов char16\_t и wchar\_t в кодировке UTF\-16 — два элемента \(всего четыре байта\) для кодирования одной *единицы кода*.   В примере ниже показан размер расширенного строкового литерала в байтах.  
  
```cpp  
const wchar_t* str = L"Hello!"; const size_t byteSize = (wcslen(str) + 1) * sizeof(wchar_t);  
```  
  
 Обратите внимание, что `strlen()` и `wcslen()` не учитывают размер символа завершающего нуля, равного размеру элемента строкового типа: один байт для строки char\*, два байта для строк wchar\_t\* и char16\_t\*, и четыре байта для строк char32\_t\*.  
  
 Максимальная длина строкового литерала — 65535 байт. Это ограничение применимо как к узким, так и к расширенным строковым литералам.  
  
### Изменение строковых литералов  
 Поскольку строковые литералы представляют собой константы \(кроме литералов std:string\), попытки их изменения \(пример: str\[2\] \= 'A' \) ведут к ошибке компилятора.  
  
 **Блок, относящийся только к системам Microsoft**  
  
 В Visual C\+\+ строковый литерал можно использовать для инициализации указателя не являющимся константным значением типа `char` или `wchar_t`. Это разрешено в коде C99, но не рекомендуется в С\+\+98 и удалено из С\+\+11. Попытка изменить строку вызовет нарушение прав доступа, как показано в следующем примере:  
  
```cpp  
wchar_t* str = L"hello"; str[2] = L'a'; // run-time error: access violation  
```  
  
 Чтобы указать компилятору выдавать ошибку при преобразовании строкового литерала в символ указателя non\_const, можно задать параметр компилятора [\/Zc:strictStrings \(отключение преобразования типов строковых литералов\)](../build/reference/zc-strictstrings-disable-string-literal-type-conversion.md). Рекомендуется использовать его для создания переносимого кода, соответствующего стандартам. Кроме того, рекомендуется объявлять инициализируемые строковым литералом указатели с помощью ключевого слова `auto`. Таким образом происходит преобразование в правильный тип \(const\). В следующем примере кода перехватывается во время компиляции попытка записать в строковый литерал:  
  
```cpp  
auto str = L"hello"; str[2] = L'a'; // C3892: you cannot assign to a variable that is const.  
```  
  
 В некоторых случаях идентичные строковые литералы могут быть объединены в пул для экономии места в исполняемом файле. При объединении строковых литералов в пулы компилятор делает так, что все ссылки на определенный строковый литерал указывают на одну и ту же область в памяти, вместо того чтобы каждая ссылка указывала на отдельный экземпляр строкового литерала. Для включения объединения строковых литералов в пулы используется параметр компилятора [\/GF](../Topic/-GF%20\(Eliminate%20Duplicate%20Strings\).md).  
  
 **Завершение блока, относящегося только к системам Майкрософт**  
  
### Сцепление смежных строковых литералов  
 Все смежные расширенные и узкие строковые литералы соединяются. Данное объявление:  
  
```cpp  
char str[] = "12" "34";  
```  
  
 идентично следующему объявлению:  
  
```cpp  
char atr[] = "1234";  
```  
  
 и следующему объявлению:  
  
```cpp  
char atr[] =  "12\ 34";  
```  
  
 Использование внедренных шестнадцатеричных escape\-кодов для задания строковых литералов может привести к непредвиденным результатам. В следующем примере выполняется попытка создать строковый литерал, содержащий символ ASCII 5, за которым следуют символы f, i, v и e:  
  
```cpp  
"\x05five"  
```  
  
 Фактический результат \(шестнадцатеричное значение 5F\) является кодом ASCII для символа подчеркивания, за которым следуют символы i, v и e. Чтобы  получить правильный результат, можно воспользоваться одним из следующих способов:  
  
```cpp  
"\005five"     // Use octal literal. "\x05" "five"  // Use string splicing.  
```  
  
 Поскольку литералы std::string представляют собой типы std::string, их можно соединить с оператором "\+", определенном для типов [basic\_string](../standard-library/basic-string-class.md). Эти литералы также можно соединить аналогично смежным строковым литералам. В обоих случаях кодировка строки и суффикс должны совпадать:  
  
```cpp  
auto x1 = "hello" " " " world"; // OK auto x2 = U"hello" " " L"world"; // C2308: disagree on prefix auto x3 = u8"hello" " "s u8"world"s; // OK, agree on prefixes and suffixes auto x4 = u8"hello" " "s u8"world"z; // C3688, disagree on suffixes  
```  
  
### Строковые литералы с универсальными именами символов  
 Машинные \(не являющиеся необработанными\) строковые литералы могут использовать универсальные имена символов для представления любого символа, при условии что универсальные имена можно кодировать как один или несколько символов в строковом типе.  Например, универсальное имя символа, представляющее символ национального алфавита, не может быть закодировано в строку обычных символов с помощью кодовой страницы ANSI. Тем не менее его можно закодировать в строку обычных символов в некоторых многобайтовых кодовых страницах, в строках UTF\-8 или в двухбайтовой строке. В C\+\+11 поддержка Юникода расширена благодаря использованию строковых типов char16\_t \* и char32\_t \*:  
  
```cpp  
// ASCII smiling face const char*     s1 = ":-)"; // UTF-16 (on Windows) encoded WINKING FACE (U+1F609) const wchar_t*  s2 = L"😉 = \U0001F609 is ;-)"; // UTF-8  encoded SMILING FACE WITH HALO (U+1F607) const char*     s3 = u8"😇 = \U0001F607 is O:-)"; // UTF-16 encoded SMILING FACE WITH OPEN MOUTH (U+1F603) const char16_t* s4 = u"😃 = \U0001F603 is :-D"; // UTF-32 encoded SMILING FACE WITH SUNGLASSES (U+1F60E) const char32_t* s5 = U"😎 = \U0001F60E is B-)";  
```  
  
## См. также  
 [Наборы символов](../cpp/character-sets2.md)   
 [Числовые, логические литералы и литералы\-указатели](../cpp/numeric-boolean-and-pointer-literals-cpp.md)   
 [Определенные пользователем литералы](../Topic/User-Defined%20Literals%20%20\(C++\).md)