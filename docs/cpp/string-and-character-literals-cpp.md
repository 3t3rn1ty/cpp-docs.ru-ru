---
title: Строковые и символьные литералы (C++) | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-language
ms.topic: language-reference
f1_keywords:
- R
dev_langs:
- C++
helpviewer_keywords:
- L constant
- escape sequences
- Null strings, null-terminated strings
- literal strings, C++
- Null strings
- string literals, syntax
- string literals
- literal strings
- strings [C++], string literals
- NULL, character constant
- wide characters, strings
ms.assetid: 61de8f6f-2714-4e7b-86b6-a3f885d3b9df
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: cede3ee6efb063141fc9ba7db58c6ec1dbcae845
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
ms.locfileid: "32424606"
---
# <a name="string-and-character-literals--c"></a>Строковые и символьные литералы (C++)
В C++ поддерживаются различные типы строк и символов, а также доступны различные способы выражения значений литералов каждого из этих типов. В исходном коде содержимое символьных и строковых литералов выражается с помощью кодировки. Универсальные имена символов и escape-символы позволяют представить любую строку, используя только основную кодировку исходного кода. Необработанные строковые литералы позволяют не использовать escape-символы и могут применяться для выражения всех типов строковых литералов. Можно также создать литералы std::string без необходимости выполнять дополнительные действия по созданию или преобразованию.  
  
```cpp  
#include <string>  
using namespace std::string_literals; // enables s-suffix for std::string literals  
  
int main()  
{  
    // Character literals  
    auto c0 =   'A'; // char  
    auto c1 = u8'A'; // char  
    auto c2 =  L'A'; // wchar_t  
    auto c3 =  u'A'; // char16_t  
    auto c4 =  U'A'; // char32_t  
  
    // String literals  
    auto s0 =   "hello"; // const char*  
    auto s1 = u8"hello"; // const char*, encoded as UTF-8  
    auto s2 =  L"hello"; // const wchar_t*  
    auto s3 =  u"hello"; // const char16_t*, encoded as UTF-16  
    auto s4 =  U"hello"; // const char32_t*, encoded as UTF-32  
  
    // Raw string literals containing unescaped \ and "  
    auto R0 =   R"("Hello \ world")"; // const char*  
    auto R1 = u8R"("Hello \ world")"; // const char*, encoded as UTF-8  
    auto R2 =  LR"("Hello \ world")"; // const wchar_t*  
    auto R3 =  uR"("Hello \ world")"; // const char16_t*, encoded as UTF-16  
    auto R4 =  UR"("Hello \ world")"; // const char32_t*, encoded as UTF-32  
  
    // Combining string literals with standard s-suffix  
    auto S0 =   "hello"s; // std::string  
    auto S1 = u8"hello"s; // std::string  
    auto S2 =  L"hello"s; // std::wstring  
    auto S3 =  u"hello"s; // std::u16string  
    auto S4 =  U"hello"s; // std::u32string  
  
    // Combining raw string literals with standard s-suffix  
    auto S5 =   R"("Hello \ world")"s; // std::string from a raw const char*  
    auto S6 = u8R"("Hello \ world")"s; // std::string from a raw const char*, encoded as UTF-8  
    auto S7 =  LR"("Hello \ world")"s; // std::wstring from a raw const wchar_t*  
    auto S8 =  uR"("Hello \ world")"s; // std::u16string from a raw const char16_t*, encoded as UTF-16  
    auto S9 =  UR"("Hello \ world")"s; // std::u32string from a raw const char32_t*, encoded as UTF-32  
}  
```  
  
 Строковые литералы могут не иметь префикса или включать префиксы `u8`, `L`, `u`и  `U` для обозначения кодировок обычных символов (однобайтовых или многобайтовых), UTF-8, расширенных символов (UCS-2 или UTF-16), UTF-16 и UTF-32, соответственно. Необработанные строковые литералы могут включать префиксы `R`, `u8R`, `LR`, `uR` и `UR` для эквивалентов необработанных версий кодировок.  Чтобы создать временные или статические значения std::string, можно использовать строковые литералы или необработанные строковые литералы с суффиксом `s` . Дополнительные сведения см. в разделе "Строковые литералы" ниже. Дополнительные сведения об основной кодировке исходного набор универсальных именах символов и использовании символов из расширенных кодовых страниц в исходном коде см. в разделе [наборов символов](../cpp/character-sets.md).  
  
## <a name="character-literals"></a>Символьные литералы  
 *Символьный литерал* состоит из символьной константы. Она представлена символом, заключенным в одинарные кавычки. Существует пять типов, символьных литералов:  
  
-   Обычный символьные литералы типа `char`, например `'a'`  
  
-   UTF-8 символьные литералы типа `char`, например `u8'a'`  
  
-   Расширенные символьные литералы типа `wchar_t`, например `L'a'`.  
  
-   UTF-16 символьные литералы типа `char16_t`, например `u'a'`  
  
-   UTF-32 символьные литералы типа `char32_t`, например `U'a'`  
  
 Символ, используемый для символьных литералов могут быть любые символы, за исключением зарезервированных символов обратной косой черты ("\\"), одинарная кавычка (') или новой строки. Зарезервированные символы можно указывать с помощью escape-последовательности. Символы можно указывать с помощью универсальных имен символов, при условии что тип является достаточно крупным для размещения символа.  
  
### <a name="encoding"></a>кодировка  
 Символьные литералы кодируются по-разному на основе их префикс.  
  
-   Символьный литерал без префикса является обычный символ литерала. Значение литерала обычный символ содержащая один символ, escape-последовательности или универсальное имя символа, может быть представлено в кодировке выполнения имеет значение, равное числовое значение кодировки в набор символов исполнения. Обычный символ литерала, содержит более одного символа, универсальное имя символа или escape-последовательность — это *литерал из нескольких символов*. Символьный литерал или литералом обычный символ, не могут быть представлены в кодировке выполнения условно поддерживаемых, имеет тип int и его значение определяется реализацией.  
  
-   Символьный литерал, который начинается с префиксом L является литералом расширенных символов. Значение литерала расширенных символов, содержащая один символ, escape-последовательности или универсальное имя символа имеет значение, равное числовое значение кодировки в расширенных символов выполнения устанавливается значение, если символ литерала не имеет представления набор расширенных символов выполнения в этом случае значение определяется реализацией. Значение литерала расширенных символов, содержащая несколько символов, escape-последовательности и универсальные имена символов определяется реализацией.  
  
-   Символьный литерал, который начинается с префикса u8 является UTF-8 литералом. Значение литерала символ UTF-8 содержащая один символ, escape-последовательности или универсальное имя символа имеет значение, равное значению точки кода ISO 10646, если представленный единый блок кода UTF-8 (соответствующий C0 элементов управления и Basic Latin Блок Юникода). Если значение не может быть представлен одной единицы кода UTF-8, программа сформирована некорректно. Символьный литерал, содержащий более одного символа, escape-последовательности или универсальное имя символа UTF-8, некорректно.  
  
-   Символьный литерал, который начинается с префикса u является UTF-16 литералом. Значение литерала символ UTF-16 содержащая один символ, escape-последовательности или универсальное имя символа имеет значение, равное значению точки кода ISO 10646 если представленный единый блок кода UTF-16 (соответствующий основные многоязыковой плоскости ). Если значение не может быть представлен одной единицы кода UTF-16, программа сформирована некорректно. Символьный литерал, содержащий более одного символа, escape-последовательности или универсальное имя символа UTF-16, некорректно.  
  
-   Символьный литерал, который начинается с префикса U является UTF-32 литералом. Значение UTF-32 символьных литералов содержащая один символ, escape-последовательности или значение, равное значению точки кода ISO 10646 имеет универсальное имя символа. Символьный литерал, содержащий более одного символа, escape-последовательности или универсальное имя символа UTF-8, некорректно.  
  
###  <a name="bkmk_Escape"></a> Escape-последовательность  
 Существует три вида escape-последовательностей: простая, восьмеричная и шестнадцатеричная. Возможны следующие типы escape-последовательностей:  
  
|Значение|Escape-последовательность|Значение|Escape-последовательность|  
|-----------|---------------------|-----------|---------------------|  
|новая строка|\n|обратная косая черта|\\\|  
|горизонтальная табуляция|\t|вопросительный знак|? или \\?|  
|вертикальная табуляция|\v|одинарная кавычка|\\'|  
|стирание назад|\b|двойная кавычка|\\"|  
|возврат каретки|\r|нуль-символ|\0|  
|перевод страницы|\f|восьмеричный|\ooo|  
|оповещение (колокольчик)|\a|шестнадцатеричный|\xhhh|  
  
 Ниже показаны некоторые примеры escape-символов с помощью литералов обычный символ. Тот же синтаксис escape-последовательности является допустимым для других типов литералов символ.  
  
```cpp  
#include <iostream>  
using namespace std;  
  
int main() {  
    char newline = '\n';  
    char tab = '\t';  
    char backspace = '\b';  
    char backslash = '\\';  
    char nullChar = '\0';  
  
    cout << "Newline character: " << newline << "ending" << endl; // Newline character:  
                                                                  //  ending  
    cout << "Tab character: " << tab << "ending" << endl; // Tab character : ending  
    cout << "Backspace character: " << backspace << "ending" << endl; // Backspace character : ending  
    cout << "Backslash character: " << backslash << "ending" << endl; // Backslash character : \ending  
    cout << "Null character: " << nullChar << "ending" << endl; //Null character:  ending  
}  
```  
  
 **Блок, относящийся только к системам Microsoft**  
  
 Чтобы создать значение из обычный символ литерала (которые без префикса), компилятор преобразует символ или последовательность символов между одинарными кавычками в 8-разрядных значений в 32-разрядное целое число. Несколько символов в литерале заполняют соответствующие байты по мере необходимости от высокого до низкого порядка. Для создания значения `char` компилятор принимает младший байт. Для создания значения `wchar_t` или `char16_t` компилятор принимает младшее слово. Компилятор выдает предупреждение о том, что результат усекается, если какие-либо биты заданы выше назначенного байта или слова.  
  
```cpp  
char c0    = 'abcd';    // C4305, C4309, truncates to 'd'  
wchar_t w0 = 'abcd';    // C4305, C4309, truncates to '\x6364'  
```  
  
 Восьмеричная escape-последовательность — это обратная косая черта, за которой следует последовательность восьмеричных цифр (не более трех). Восьмеричная escape-последовательность, которая содержит более трех цифр, обрабатывается как восьмеричная последовательность из трех цифр, за которой следуют цифры, обозначающие символы. Это может приводить к неожиданным результатам. Пример:  
  
```cpp  
char c1 = '\100';   // '@'  
char c2 = '\1000';  // C4305, C4309, truncates to '0'   
```  
  
 Escape-последовательности, которые содержат невосьмеричные символы, вычисляются как восьмеричные последовательности до последнего восьмеричного символа, за которым следуют остальные символы. Пример:  
  
```cpp  
char c3 = '\009';   // '9'  
char c4 = '\089';   // C4305, C4309, truncates to '9'  
char c5 = '\qrs';   // C4129, C4305, C4309, truncates to 's'  
```  
  
 Шестнадцатеричная escape-последовательность — это обратная косая черта, за которой следует символ `x`и последовательность шестнадцатеричных цифр. Escape-последовательности, которые не содержат шестнадцатеричные цифры, вызывают ошибку компилятора C2153. Эта ошибка сообщает, что шестнадцатеричные литералы должны содержать по крайней мере одну шестнадцатеричную цифру. Начальные нули пропускаются. Escape-последовательность, которая содержит шестнадцатеричные и другие символы, вычисляется как шестнадцатеричная escape-последовательность до последнего шестнадцатеричного символа, за которым следуют другие символы.   В обычных или с префиксом u8 символьном литерале максимальное шестнадцатеричное значение — 0xFF. В расширенном символьном литерале с префиксом L или u максимальное шестнадцатеричное значение — 0xFFFF. В расширенном символьном литерале с префиксом U максимальное шестнадцатеричное значение — 0xFFFFFFFF.  
  
```cpp  
char c6 = '\x0050'; // 'P'  
char c7 = '\x0pqr'; // C4305, C4309, truncates to 'r'  
```  
  
 Если расширенный символьный литерал с префиксом `L` содержит более одного символа, значение берется из первого символа. Последующие символы игнорируются, в отличие от эквивалентные обычный символ литерала.  
  
```cpp  
wchar_t w1 = L'\100';   // L'@'  
wchar_t w2 = L'\1000';  // C4066 L'@', 0 ignored   
wchar_t w3 = L'\009';   // C4066 L'\0', 9 ignored  
wchar_t w4 = L'\089';   // C4066 L'\0', 89 ignored  
wchar_t w5 = L'\qrs';   // C4129, C4066 L'q' escape, rs ignored  
wchar_t w6 = L'\x0050'; // L'P'  
wchar_t w7 = L'\x0pqr'; // C4066 L'\0', pqr ignored  
```  
  
 **Завершение блока, относящегося только к системам Майкрософт**  
  
 Символ обратной косой черты (\\) — это символ продолжения строки если он стоит в конце строки. Если символ обратной косой черты требуется использовать как символьный литерал, необходимо ввести две косые черты подряд (`\\`). Дополнительные сведения о символе продолжения строки см. в разделе [Phases of Translation](../preprocessor/phases-of-translation.md).  
  
###  <a name="bkmk_UCN"></a> Универсальные имена символов  
 В символьных литералах и машинных (не являющихся необработанными) строковых литералах любой символ может быть представлен универсальным именем символа.  Универсальные имена символов образуются префиксом \U, за которым следует восьмизначная кодовая точка Юникода, или префиксом \u, за которым следует четырехзначная кодовая точка Юникода. Все восемь или четыре знака, соответственно, должны присутствовать для создания корректного универсального имени символа.  
  
```cpp  
char u1 = 'A';          // 'A'  
char u2 = '\101';       // octal, 'A'   
char u3 = '\x41';       // hexadecimal, 'A'  
char u4 = '\u0041';     // \u UCN 'A'  
char u5 = '\U00000041'; // \U UCN 'A'  
```  
  
 **Суррогатные пары**  
  
 С помощью универсальных имен символов нельзя закодировать значения в диапазоне суррогатных кодовых точек D800–DFFF. Для суррогатных пар Юникода укажите универсальное имя символа, используя `\UNNNNNNNN`, где NNNNNNNN — восьмизначная кодовая точка для символа. При необходимости компилятор создаст суррогатную пару.  
  
 В C++03 языком допускалось, чтобы универсальными именами символов представлялось лишь определенное подмножество символов. Также могли существовать универсальные имена символов, не представляющие никаких допустимых символов Юникода. В стандарте C++11 этот недочет был исправлен. В C++11 в символьных и строковых литералах и идентификаторах можно использовать универсальные имена символов.  Дополнительные сведения об универсальных именах символов см. в разделе [наборов символов](../cpp/character-sets.md). Дополнительные сведения о Юникоде см. в статье [Unicode](http://msdn.microsoft.com/library/dd374081\(v=vs.85\).aspx). Дополнительные сведения о суррогатных парах см. в статье [Surrogate Pairs and Supplementary Characters](http://msdn.microsoft.com/library/dd374069\(v=vs.85\).aspx)(Суррогатные пары и дополнительные символы).  
  
## <a name="string-literals"></a>Строковые литералы  
 Строковый литерал представляет последовательность символов, которые вместе образуют строку с завершающим нулем. Символы должны быть заключены в двойные кавычки. Существуют следующие типы строковых литералов.  
  
### <a name="narrow-string-literals"></a>Узкие строковые литералы  
 Обычный строковый литерал представляет собой без префикса, двойной кавычки с разделителями, заканчивающаяся нулем массив типа `const char[n]`, где n — длина массива в байтах. Обычный строковый литерал может содержать любые графические символы, за исключением двойных кавычек (`"`), обратной косой черты (`\`) или символа новой строки. Обычный строковый литерал также может содержать перечисленные выше escape-последовательности и универсальные имена символов, которые помещаются в байте.  
  
```cpp  
const char *narrow = "abcd";  
  
// represents the string: yes\no  
const char *escaped = "yes\\no";  
```  
  
#### <a name="utf-8-encoded-strings"></a>Строки в кодировке UTF-8  
  
 Строка в кодировке UTF-8 — с префиксом u8, двойной кавычки с разделителями, заканчивающаяся нулем массивом типа `const char[n]`, где n — длина закодированного массива в байтах. Строковый литерал с префиксом u8 может содержать любые графические символы, за исключением двойных кавычек (`"`), обратной косой черты (`\`) или символа новой строки. Строковый литерал с префиксом u8 может также содержать перечисленные выше escape-последовательности и любые универсальные имена символов.  
  
```cpp  
const char* str1 = u8"Hello World";  
const char* str2 = u8"\U0001F607 is O:-)";  
```  
  
### <a name="wide-string-literals"></a>Расширенные строковые литералы  
 Расширенный строковый литерал — нулем массив констант `wchar_t` , начинающийся с префикса "`L`" и любые графические символы, за исключением двойных кавычек ("«), обратной косой черты (\\), или символ перевода строки. Расширенный строковый литерал может содержать перечисленные выше escape-последовательности и любые универсальные имена символов.  
  
```cpp  
const wchar_t* wide = L"zyxw";  
const wchar_t* newline = L"hello\ngoodbye";  
```  
  
#### <a name="char16t-and-char32t-c11"></a>char16_t и char32_t (C++11)  
  
 В C++11 доступны символьные типы `char16_t` (портативный, 16-разрядный Юникод) и `char32_t` (32-разрядный Юникод):  
  
```cpp  
auto s3 = u"hello"; // const char16_t*  
auto s4 = U"hello"; // const char32_t*  
```  
  
### <a name="raw-string-literals-c11"></a>Необработанные строковые литералы (C++11)  
 Необработанный строковый литерал является завершающуюся нулевым значением — любого типа —, содержащий любые графические символы, включая двойных кавычек ("«), обратной косой черты (\\), или символ перевода строки. Необработанные строковые литералы часто применяются в регулярных выражениях, которые используют классы символов, а также в строках HTML и XML. Примеры, см. в следующей статье: [Bjarne Stroustrup вопросы и ответы о C ++ 11](http://go.microsoft.com/fwlink/p/?linkid=401172).  
  
```cpp  
// represents the string: An unescaped \ character  
const char* raw_narrow = R"(An unescaped \ character)";  
const wchar_t* raw_wide = LR"(An unescaped \ character)";  
const char*       raw_utf8  = u8R"(An unescaped \ character)";  
const char16_t* raw_utf16 = uR"(An unescaped \ character)";  
const char32_t* raw_utf32 = UR"(An unescaped \ character)";  
```  
  
 Разделитель — это содержащая до 16 символов пользовательская последовательность, которая стоит непосредственно перед открывающей круглой скобкой и сразу после закрывающей круглой скобки необработанного строкового литерала.  Например, в `R"abc(Hello"\()abc"` последовательность разделителей — `abc` , а содержимое строки — `Hello"\(`. Разделители можно использовать для различения необработанных строк, содержащих двойные кавычки и круглые скобки. Следующая строка приводит к ошибке компилятора:  
  
```cpp  
// meant to represent the string: )"  
const char* bad_parens = R"()")";  // error C2059  
```  
  
 Однако ошибку можно устранить с помощью разделителя:  
  
```cpp  
const char* good_parens = R"xyz()")xyz";  
```  
  
 Можно создать необработанный строковый литерал, содержащий символ новой строки (не escape-символ) в исходном коде:  
  
```cpp  
// represents the string: hello  
//goodbye  
const wchar_t* newline = LR"(hello  
goodbye)";  
```  
  
### <a name="stdstring-literals-c14"></a>Литералы std::string (C++14)  
 Литералы std::string представляют собой реализацию пользовательских литералов на основе стандартной библиотеки (см. ниже) и получаются путем добавления префикса "xyx"s (вместе с суффиксом `s` ). Этот тип строковых литералов создает временные объекты типа std::string, std::wstring, std::u32string или std::u16string, в зависимости от указанного префикса. Если префикс не используется, как показано выше, создается объект типа std::string. Если используется префикс L"xyz"s, создается объект типа std::wstring. При использовании префикса u"xyz"s создается объект типа [std::u16string](../standard-library/string-typedefs.md#u16string), а префикса U"xyz"s — объект типа [std::u32string](../standard-library/string-typedefs.md#u32string).  
  
```cpp  
//#include <string>  
//using namespace std::string_literals;  
string str{ "hello"s };  
string str2{ u8"Hello World" };  
wstring str3{ L"hello"s };  
u16string str4{ u"hello"s };  
u32string str5{ U"hello"s };  
```  
  
 Суффикс "s" также может использоваться для необработанных строковых литералов:  
  
```cpp  
u32string str6{ UR"(She said "hello.")"s };  
```  
  
 литералы std::String определены в пространстве имен `std::literals::string_literals` в \<строка > файла заголовка. Поскольку `std::literals::string_literals`и `std::literals` объявляются как [встроенные пространства имен](../cpp/namespaces-cpp.md), `std::literals::string_literals` автоматически считается напрямую принадлежащим пространству имен `std`.  
  
### <a name="size-of-string-literals"></a>Размер строковых литералов  
 Для ANSI char\* строки и других однобайтовых кодировках (не UTF-8) размер строкового литерала (в байтах) — количество знаков плюс 1 для завершающего символа null. Для строк остальных типов размер напрямую не связан с количеством символов. В кодировке UTF-8 для кодирования некоторых *единиц кода*используется до четырех символьных элементов, а для типов char16_t и wchar_t в кодировке UTF-16 — два элемента (всего четыре байта) для кодирования одной *единицы кода*.   В примере ниже показан размер расширенного строкового литерала в байтах.  
  
```cpp  
const wchar_t* str = L"Hello!";  
const size_t byteSize = (wcslen(str) + 1) * sizeof(wchar_t);  
```  
  
 Обратите внимание, что `strlen()` и `wcslen()` не включает размер с учетом завершающего нуля, размер которого равен размеру элемента строкового типа: один байт для строки char*, два байта для wchar_t\* или char16_t\* строк и четыре байта для char32_t\* строки.  
  
 Максимальная длина строкового литерала — 65535 байт. Это ограничение применимо как к узким, так и к расширенным строковым литералам.  
  
### <a name="modifying-string-literals"></a>Изменение строковых литералов  
 Поскольку строковые литералы представляют собой константы (кроме литералов std:string), попытки их изменения (пример: str[2] = 'A' ) ведут к ошибке компилятора.  
  
 **Блок, относящийся только к системам Microsoft**  
  
 В Visual C++ строковый литерал можно использовать для инициализации указателя не являющимся константным значением типа `char` или `wchar_t`. Это разрешено в коде C99, но не рекомендуется в С++98 и удалено из С++11. Попытка изменить строку вызовет нарушение прав доступа, как показано в следующем примере:  
  
```cpp  
wchar_t* str = L"hello";  
str[2] = L'a'; // run-time error: access violation  
```  
  
 Может привести к компилятору выдавать ошибку при преобразовании строкового литерала в символ указателя non_const при установке [/Zc: strictstrings (отключение преобразования типов строковых литералов)](../build/reference/zc-strictstrings-disable-string-literal-type-conversion.md) параметр компилятора. Рекомендуется использовать его для создания переносимого кода, соответствующего стандартам. Кроме того, рекомендуется объявлять инициализируемые строковым литералом указатели с помощью ключевого слова `auto` . Таким образом происходит преобразование в правильный тип (const). В следующем примере кода перехватывается во время компиляции попытка записать в строковый литерал:  
  
```cpp  
auto str = L"hello";  
str[2] = L'a'; // C3892: you cannot assign to a variable that is const.  
```  
  
 В некоторых случаях идентичные строковые литералы могут быть объединены в пул для экономии места в исполняемом файле. При объединении строковых литералов в пулы компилятор делает так, что все ссылки на определенный строковый литерал указывают на одну и ту же область в памяти, вместо того чтобы каждая ссылка указывала на отдельный экземпляр строкового литерала. Для включения объединения строковых литералов в пулы используется параметр компилятора [/GF](../build/reference/gf-eliminate-duplicate-strings.md) .  
  
 **End Microsoft Specific**  
  
### <a name="concatenating-adjacent-string-literals"></a>Сцепление смежных строковых литералов  
 Все смежные расширенные и узкие строковые литералы соединяются. Данное объявление:  
  
```cpp  
char str[] = "12" "34";  
```  
  
 идентично следующему объявлению:  
  
```cpp  
char atr[] = "1234";  
```  
  
 и следующему объявлению:  
  
```cpp  
char atr[] =  "12\  
34";  
```  
  
 Использование внедренных шестнадцатеричных escape-кодов для задания строковых литералов может привести к непредвиденным результатам. В следующем примере выполняется попытка создать строковый литерал, содержащий символ ASCII 5, за которым следуют символы f, i, v и e:  
  
```cpp  
"\x05five"  
```  
  
 Фактический результат (шестнадцатеричное значение 5F) является кодом ASCII для символа подчеркивания, за которым следуют символы i, v и e. Чтобы получить правильный результат, можно воспользоваться одним из следующих способов:  
  
```cpp  
"\005five"     // Use octal literal.  
"\x05" "five"  // Use string splicing.  
```  
  
 Поскольку литералы std::string представляют собой типы std::string, их можно соединить с оператором "+", определенном для типов [basic_string](../standard-library/basic-string-class.md) . Эти литералы также можно соединить аналогично смежным строковым литералам. В обоих случаях кодировка строки и суффикс должны совпадать:  
  
```cpp  
auto x1 = "hello" " " " world"; // OK  
auto x2 = U"hello" " " L"world"; // C2308: disagree on prefix  
auto x3 = u8"hello" " "s u8"world"s; // OK, agree on prefixes and suffixes  
auto x4 = u8"hello" " "s u8"world"z; // C3688, disagree on suffixes  
```  
  
### <a name="string-literals-with-universal-character-names"></a>Строковые литералы с универсальными именами символов  
 Машинные (не являющиеся необработанными) строковые литералы могут использовать универсальные имена символов для представления любого символа, при условии что универсальные имена можно кодировать как один или несколько символов в строковом типе.  Например, универсальное имя символа, представляющее символ национального алфавита, не может быть закодировано в строку обычных символов с помощью кодовой страницы ANSI. Тем не менее его можно закодировать в строку обычных символов в некоторых многобайтовых кодовых страницах, в строках UTF-8 или в двухбайтовой строке. В C ++ 11 поддержка Юникода расширена благодаря char16_t * и char32_t\* строковые типы:  
  
```cpp  
// ASCII smiling face  
const char*     s1 = ":-)";    
  
// UTF-16 (on Windows) encoded WINKING FACE (U+1F609)  
const wchar_t*  s2 = L"😉 = \U0001F609 is ;-)";    
  
// UTF-8  encoded SMILING FACE WITH HALO (U+1F607)  
const char*     s3 = u8"😇 = \U0001F607 is O:-)";  
  
// UTF-16 encoded SMILING FACE WITH OPEN MOUTH (U+1F603)  
const char16_t* s4 = u"😃 = \U0001F603 is :-D";  
  
// UTF-32 encoded SMILING FACE WITH SUNGLASSES (U+1F60E)  
const char32_t* s5 = U"😎 = \U0001F60E is B-)";  
```  
  
## <a name="see-also"></a>См. также  
 [Наборы символов](../cpp/character-sets.md)   
 [Числовые, логические литералы и литералы-указатели](../cpp/numeric-boolean-and-pointer-literals-cpp.md)   
 [Определенные пользователем литералы](../cpp/user-defined-literals-cpp.md)