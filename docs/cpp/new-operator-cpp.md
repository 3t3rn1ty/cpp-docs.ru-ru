---
title: "Оператор new (C++) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "language-reference"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "new - ключевое слово [C++]"
ms.assetid: 69fee812-1c28-4882-8fda-d1ad17860004
caps.latest.revision: 11
caps.handback.revision: 11
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Оператор new (C++)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Выделяет память для объекта или массива объектов *имя\-типа* из свободного хранилища и возвращает подходящим образом типизированный ненулевой указатель на объект.  
  
> [!NOTE]
>  Расширения компонентов Microsoft C\+\+ обеспечивают поддержку ключевого слова `new` для добавления записей слота vtable.  Дополнительные сведения см. в разделе [new \(новый слот в vtable\)](../windows/new-new-slot-in-vtable-cpp-component-extensions.md)  
  
## Синтаксис  
  
```  
[::] new [placement] new-type-name [new-initializer]  
[::] new [placement] ( type-name ) [new-initializer]  
```  
  
## Заметки  
 Если операция завершилась неудачей, **new** возвращает ноль или создает исключение; дополнительные сведения см. в разделе [Операторы new и delete](../cpp/new-and-delete-operators.md).  Можно изменить эту реакцию на событие по умолчанию, можно создать пользовательскую процедуру обработки исключений и вызова функции библиотеки времени выполнения [\_set\_new\_handler](../Topic/_set_new_handler.md) вместе с именем функции в качестве аргумента.  
  
 Дополнительные сведения о создании объекта в управляемой куче см. в разделе [gcnew](../windows/ref-new-gcnew-cpp-component-extensions.md).  
  
 Если **new** используется, чтобы выделить память для объекта класса C\+\+, конструктор объекта вызывается после выделения памяти.  
  
 Используйте оператор [delete](../cpp/delete-operator-cpp.md) для отмены памяти, выделенной с помощью оператора **new**.  
  
 В следующем примере выделяется и затем освобождается двумерный массив символов размером `dim` на 10.  При выделении многомерного массива все измерения, кроме первого, должны быть константными выражениями, которые возвращают положительные значения; самое левое измерение массива может являться любым выражением, результатом которого является положительное значение.  При выделении массива с использованием оператора **new** первое измерение может быть нулевым — оператор **new** возвращает уникальный указатель.  
  
```  
char (*pchar)[10] = new char[dim][10];  
delete [] pchar;  
```  
  
 *Имя\-типа* не может содержать **константу**, `volatile` объявления класса или объявления перечислений.  Таким образом, следующее выражение является недопустимым:  
  
```  
volatile char *vch = new volatile char[20];  
```  
  
 Оператор **new** не выделяет ссылочные типы, поскольку они не являются объектами.  
  
 Оператор **new** невозможно использовать для выделения функции, но его можно использовать для выделения указателей на функции.  В следующем примере выделяется и затем освобождается массив из семи указателей на функции, которые возвращают целые числа.  
  
```  
int (**p) () = new (int (*[7]) ());  
delete *p;  
```  
  
 Если оператор **new** используется без дополнительных аргументов и компиляция производится с параметром [\/GX](../Topic/-GX%20\(Enable%20Exception%20Handling\).md), [\/EHa](../build/reference/eh-exception-handling-model.md) или [\/EHs](../build/reference/eh-exception-handling-model.md), компилятор создаст код, вызывающий оператор **delete**, если в конструкторе возникнет исключение.  
  
 В следующем списке представлены грамматические элементы **new**.  
  
 *размещение*  
 Предоставляет способ передачи дополнительных аргументов при перегрузке **new**.  
  
 *имя\-типа*  
 Определяет тип для распределения; может быть встроенным или пользовательским типом.  Если спецификация типа является сложной, она может быть окружена круглыми скобками, чтобы принудительно реализовать порядок привязки.  
  
 *инициализатор*  
 Предоставляет значение для инициализированного объекта.  Инициализаторы невозможно задать для массивов.  Оператор **new** создает массив объектов, только если класс имеет конструктор по умолчанию.  
  
## Пример  
 В следующем примере кода выделяется и освобождается массив символов и объект класса `CName`.  
  
```  
// expre_new_Operator.cpp  
// compile with: /EHsc  
#include <string.h>  
  
class CName {  
public:  
   enum {  
      sizeOfBuffer = 256  
   };  
  
   char m_szFirst[sizeOfBuffer];  
   char m_szLast[sizeOfBuffer];  
  
public:  
   void SetName(char* pszFirst, char* pszLast) {  
     strcpy_s(m_szFirst, sizeOfBuffer, pszFirst);  
     strcpy_s(m_szLast, sizeOfBuffer, pszLast);  
   }  
  
};  
  
int main() {  
   // Allocate memory for the array  
   char* pCharArray = new char[CName::sizeOfBuffer];  
   strcpy_s(pCharArray, CName::sizeOfBuffer, "Array of characters");  
  
   // Deallocate memory for the array  
   delete [] pCharArray;             
   pCharArray = NULL;  
  
   // Allocate memory for the object  
   CName* pName = new CName;  
   pName->SetName("Firstname", "Lastname");  
  
   // Deallocate memory for the object  
   delete pName;  
   pName = NULL;  
}  
```  
  
## Пример  
 При использовании новой формы размещения оператора **new**, формы с аргументами в дополнение к размеру выделения, компилятор не поддерживает форму размещения оператора **delete**, если конструктор вызывает исключение.  Пример:  
  
```  
// expre_new_Operator2.cpp  
// C2660 expected  
class A {  
public:  
   A(int) { throw "Fail!"; }  
};  
void F(void) {  
   try {  
      // heap memory pointed to by pa1 will be deallocated  
      // by calling ::operator delete(void*).  
      A* pa1 = new A(10);  
   } catch (...) {  
   }  
   try {  
      // This will call ::operator new(size_t, char*, int).  
      // When A::A(int) does a throw, we should call  
      // ::operator delete(void*, char*, int) to deallocate  
      // the memory pointed to by pa2.  Since  
      // ::operator delete(void*, char*, int) has not been implemented,  
      // memory will be leaked when the deallocation cannot occur.  
  
      A* pa2 = new(__FILE__, __LINE__) A(20);  
   } catch (...) {  
   }  
}  
  
int main() {  
   A a;  
}  
```  
  
## Инициализация объектов, выделенных с помощью оператора new  
 Необязательное поле *инициализатора* включено в грамматику оператора **new**.  Это позволяет инициализировать новые объекты с помощью пользовательских конструкторов.  Дополнительные сведения о выполнении инициализации см. в разделе [Инициализаторы](../cpp/initializers.md).  В следующем примере показано использование выражения инициализации с оператором **new**.  
  
```  
// expre_Initializing_Objects_Allocated_with_new.cpp  
class Acct  
{  
public:  
    // Define default constructor and a constructor that accepts  
    //  an initial balance.  
    Acct() { balance = 0.0; }  
    Acct( double init_balance ) { balance = init_balance; }  
private:  
    double balance;  
};  
  
int main()  
{  
    Acct *CheckingAcct = new Acct;  
    Acct *SavingsAcct = new Acct ( 34.98 );  
    double *HowMuch = new double ( 43.0 );  
    // ...  
}  
```  
  
 В этом примере объект `CheckingAcct` выделяется с оператором **new**, но инициализация по умолчанию не определена.  Поэтому вызывается конструктор по умолчанию для класса `Acct()`.  Затем аналогичным образом выделяется объект `SavingsAcct` с единственным отличием: он явно инициализируется значением 34,98.  Поскольку значение 34,98 принадлежит типу **double**, для обработки инициализации вызывается конструктор, принимающий аргумент этого типа.  Наконец, неклассовый тип `HowMuch` инициализируется значением 43,0.  
  
 Если объект принадлежит типу класса и этот класс содержит конструкторы \(как в предыдущем примере\), объект можно инициализировать с помощью оператора **new**, только если выполняется одно из следующих условий.  
  
-   Аргументы, предоставленные в инициализаторе, согласуются с аргументами конструктора.  
  
-   Класс имеет конструктор по умолчанию \(конструктор, который можно вызвать без аргументов\).  
  
 Управление доступом и управление неоднозначностью осуществляется в `operator new` и в конструкторах согласно правилам, указанным в разделах [Неоднозначность](http://msdn.microsoft.com/ru-ru/0b399cab-40a7-4e79-9278-05f40139a0e1) и [Инициализация с помощью специальных функций\-членов](http://msdn.microsoft.com/ru-ru/82223d73-64cb-4923-b678-78f9568ff3ca).  
  
 Выполнить явную инициализацию каждого элемента невозможно при выделении массивов с оператором **new**; вызывается только конструктор по умолчанию, если он имеется.  Дополнительные сведения см. в разделе [Аргументы по умолчанию](../Topic/Default%20Arguments.md).  
  
 Если выделение памяти завершается с ошибкой \(`operator new` возвращает значение 0\), то инициализация не выполняется.  Это обеспечивает защиту от попыток инициализировать данные, которые не существуют.  
  
 Как и в случае вызова функций, порядок вычисления выражений инициализации не определен.  Кроме того, не следует полагаться на то, что эти выражения полностью вычислены до выделения памяти.  Если выделение памяти завершается с ошибкой и оператор **new** возвращает нуль, некоторые выражения в инициализаторе могут быть вычислены не полностью.  
  
## Время жизни объектов, выделенных с помощью оператора new  
 Объекты, создаваемые с помощью оператора **new**, не удаляются при выходе из области видимости, в которой они определены.  Поскольку оператор **new** возвращает указатель на объекты, которые он создает, то для обращения к этим объектам программа должна определить указатель с соответствующей областью видимости.  Пример:  
  
```  
// expre_Lifetime_of_Objects_Allocated_with_new.cpp  
// C2541 expected  
int main()  
{  
    // Use new operator to allocate an array of 20 characters.  
    char *AnArray = new char[20];  
  
    for( int i = 0; i < 20; ++i )  
    {  
        // On the first iteration of the loop, allocate  
        //  another array of 20 characters.  
        if( i == 0 )  
        {  
            char *AnotherArray = new char[20];  
        }  
    }  
  
    delete [] AnotherArray; // Error: pointer out of scope.  
    delete [] AnArray;      // OK: pointer still in scope.  
}  
```  
  
 После того как указатель `AnotherArray` в этом примере вышел за пределы области видимости, объект невозможно удалить.  
  
## Принцип работы оператора new  
 *выражение\-выделения* — выражение, содержащее оператор **new**, — выполняет три действия:  
  
-   Находит и резервирует хранилище для объекта или объектов, которым нужно выделить память.  После завершения этого этапа выделен требуемый объем памяти, но это еще не объект.  
  
-   Инициализирует объекты.  После завершения инициализации имеется достаточно информации, чтобы выделенная память являлась объектом.  
  
-   Возвращает для объектов указатель с типом, являющимся производным от *имени\-нового\-типа* или *имени\-типа*.  Программа использует этот указатель для доступа к новому объекту, которому выделена память.  
  
 Оператор **new** вызывает функцию `operator new`.  Для массивов любого типа и для объектов, не имеющих типа **class**, `struct` или **union**, с целью выделения памяти вызывается глобальная функция **::operator new**.  Объекты типа класса могут определять собственную статическую функцию\-член `operator new` на уровне класса.  
  
 Когда компилятор встречает оператор **new** для выделения памяти объекту типа `type`, он вызывает функцию `type`**::operator new\( sizeof\(** `type` **\) \)** или, при отсутствии определенной пользователем функции `operator new`, функцию **::operator new\( sizeof\(** `type` **\) \)**.  Таким образом, оператор **new** может выделить для объекта правильный объем памяти.  
  
> [!NOTE]
>  Аргументом функции `operator new` является тип **size\_t**.  Этот тип определяется в DIRECT.H, MALLOC.H, MEMORY.H, SEARCH.H, STDDEF.H, STDIO.H, STDLIB.H, STRING.H и TIME.H.  
  
 В грамматике допускается указание необязательного параметра *размещение* \(см. грамматику для [оператора new](../cpp/new-operator-cpp.md)\).  Параметр *размещение* может использоваться только для определяемых пользователем реализаций функции `operator new`; это позволяет передавать в функцию `operator new` дополнительные сведения.  Выражение с полем *размещение*, например `T *TObject = new ( 0x0040 ) T;`, преобразуется в выражение `T *TObject = T::operator new( sizeof( T ), 0x0040 );`, если в классе T имеется член operator new, или в выражение, `T *TObject = ::operator new( sizeof( T ), 0x0040 );`, если такой член отсутствует.  
  
 Изначально поле *размещение* было введено, чтобы выделять аппаратно\-зависимым объектам память по адресам, определенным пользователем.  
  
> [!NOTE]
>  Хотя в предыдущем примере показан только один аргумент в поле *размещение*, не существует никаких ограничений на количество дополнительных аргументов, передаваемых в функцию `operator new` этим способом.  
  
 Даже если для типа класса определена функция `operator new`, приведенная в следующем примере форма позволяет использовать глобальный оператор.  
  
```  
T *TObject =::new TObject;  
```  
  
 Оператор разрешения области действия \(`::`\) задает принудительное использование глобального оператора **new**.  
  
## См. также  
 [Выражения с унарными операторами](../Topic/Expressions%20with%20Unary%20Operators.md)   
 [Ключевые слова в C\+\+](../cpp/keywords-cpp.md)   
 [Функция оператор new](../misc/operator-new-function.md)