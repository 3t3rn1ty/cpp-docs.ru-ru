---
title: "Перегрузка функций | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "language-reference"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "объявление функций, перегрузка"
  - "перегрузка функции"
  - "перегрузка функции, о перегрузке функции"
ms.assetid: 3c9884cb-1d5e-42e8-9a49-6f46141f929e
caps.latest.revision: 10
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 10
---
# Перегрузка функций
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

C\+\+ позволяет определять несколько функций с одинаковым именем в одной области.  Такие функции называются перегруженными и подробно описываются в разделе "Перегрузка".  Перегруженные функции позволяют программистам указывать для функций разную семантику в зависимости от типов и числа аргументов.  
  
 Например, функция **print**, принимающая строковый аргумент \(или **char \***\), выполняет задачи, совершенно отличающиеся от задач, выполняемых функцией, принимающей аргумент типа **double**.  Перегрузка позволяет использовать универсальные имена и препятствует применению программистами таких имен, как `print_sz` или `print_d`.  В следующей таблице указаны компоненты объявления функций, используемые языком C\+\+ для различения групп функций с одинаковым именем в одной области.  
  
### Заметки по перегрузке  
  
|Элемент объявления функции|Использование для перегрузки|  
|--------------------------------|----------------------------------|  
|Тип возвращаемого функцией значения|Нет|  
|Число аргументов|Да|  
|Тип аргументов|Да|  
|Наличие или отсутствие многоточия|Да|  
|Использование имен `typedef`|Нет|  
|Незаданные границы массива|Нет|  
|**const** или `volatile` \(см. ниже\)|Да|  
  
 Несмотря на то, что функции можно классифицировать по возвращаемому типу, однако они не могут быть перегружены на его основании.  Модификаторы `Const` или `volatile` используются в качестве основы для перегрузки, только если они применяются в классе для указателя **this**, а не для типа возвращаемого значения функции.  Другими словами, перегрузка применяется, только если ключевое слово **const** или `volatile` следует за списком аргументов функции в объявлении.  
  
## Пример  
 В следующем примере показано использование перегрузки.  
  
```  
// function_overloading.cpp  
// compile with: /EHsc  
#include <iostream>  
#include <math.h>  
  
// Prototype three print functions.  
int print( char *s );                  // Print a string.  
int print( double dvalue );            // Print a double.  
int print( double dvalue, int prec );  // Print a double with a  
//  given precision.  
using namespace std;  
int main( int argc, char *argv[] )  
{  
const double d = 893094.2987;  
if( argc < 2 )  
    {  
// These calls to print invoke print( char *s ).  
print( "This program requires one argument." );  
print( "The argument specifies the number of" );  
print( "digits precision for the second number" );  
print( "printed." );  
exit(0);  
    }  
  
// Invoke print( double dvalue ).  
print( d );  
  
// Invoke print( double dvalue, int prec ).  
print( d, atoi( argv[1] ) );  
}  
  
// Print a string.  
int print( char *s )  
{  
cout << s << endl;  
return cout.good();  
}  
  
// Print a double in default precision.  
int print( double dvalue )  
{  
cout << dvalue << endl;  
return cout.good();  
}  
  
// Print a double in specified precision.  
//  Positive numbers for precision indicate how many digits  
//  precision after the decimal point to show. Negative  
//  numbers for precision indicate where to round the number  
//  to the left of the decimal point.  
int print( double dvalue, int prec )  
{  
// Use table-lookup for rounding/truncation.  
static const double rgPow10[] = {   
10E-7, 10E-6, 10E-5, 10E-4, 10E-3, 10E-2, 10E-1, 10E0,  
10E1,  10E2,  10E3,  10E4, 10E5,  10E6  
    };  
const int iPowZero = 6;  
// If precision out of range, just print the number.  
if( prec < -6 || prec > 7 )  
return print( dvalue );  
// Scale, truncate, then rescale.  
dvalue = floor( dvalue / rgPow10[iPowZero - prec] ) *  
rgPow10[iPowZero - prec];  
cout << dvalue << endl;  
return cout.good();  
}  
```  
  
 В приведенном выше коде отображается перегрузка функции `print` в области видимости файла.  
  
 Аргумент по умолчанию не считается частью типа функции.  Следовательно, он не используется для выбора перегруженных функций.  Две функции, которые различаются только в своих аргументах, считаются множественными определениями, а не перегруженными функциями.  
  
 Аргументы по умолчанию не поставляются для перегруженных операторов.  
  
 Сведения об ограничениях по перегрузке и ее влиянии на другие элементы C\+\+ см. в разделе [Перегрузка](../misc/overloading-cpp.md).  
  
## Сопоставление аргументов  
 Перегруженные функции выбираются для оптимального соответствия объявлений функций в текущей области аргументам, предоставленным в вызове функции.  Если подходящая функция найдена, эта функция вызывается.  "Подходящая" в данном контексте означает одно из следующего.  
  
-   Точное соответствие найдено.  
  
-   Тривиальное преобразование выполнено.  
  
-   Восходящее приведение целого типа выполнено.  
  
-   Стандартное преобразование в требуемый тип аргумента существует.  
  
-   Пользовательское преобразование \(оператор преобразования или конструктор\) в требуемый тип аргумента существует.  
  
-   Аргументы, представленные многоточием, найдены.  
  
 Компилятор создает набор функций\-кандидатов для каждого аргумента.  Функции\-кандидаты — это функции, в которых фактический аргумент в данной позиции можно преобразовать в тип формального аргумента.  
  
 Для каждого аргумента создается набор наиболее подходящих функций, и выбранная функция представляет собой пересечение всех наборов.  Если на пересечении находится несколько функций, перегрузка является неоднозначной и выдает ошибку.  Функция, которая выбирается в конечном итоге, всегда является самой подходящей по сравнению с остальными функциями в группе по крайней мере для одного аргумента.  В противном случае \(если невозможно определить наиболее подходящую функцию\) при вызове функции выдается ошибка.  
  
 Рассмотрим следующие объявления \(функции отмечены как `Variant 1`, `Variant 2` и `Variant 3` для ссылки в последующем обсуждении\).  
  
```  
Fraction &Add( Fraction &f, long l );       // Variant 1  
Fraction &Add( long l, Fraction &f );       // Variant 2  
Fraction &Add( Fraction &f, Fraction &f );  // Variant 3  
  
Fraction F1, F2;  
```  
  
 Рассмотрим следующий оператор.  
  
```  
F1 = Add( F2, 23 );  
```  
  
 Представленный выше оператор создает два набора.  
  
|Набор 1. Функции\-кандидаты, имеющие первый аргумент дробного типа|Набор 2. Функции\-кандидаты, второй аргумент которых можно преобразовать в тип int|  
|------------------------------------------------------------------------|----------------------------------------------------------------------------------------|  
|Variant 1|Variant 1 \(`int` можно преобразовать в `long` с помощью стандартного преобразования\)|  
|Variant 3||  
  
 Функции в наборе 2 представляют собой функции, для которых выполнены неявные преобразования из типа фактического параметра в тип формального параметра. Среди таких функций имеется функция, для которой затраты преобразования из типа фактического параметра в тип формального параметра являются наименьшими.  
  
 Пересечением этих двух наборов является функция Variant 1.  Ниже представлен пример неоднозначного вызова функции.  
  
```  
F1 = Add( 3, 6 );  
```  
  
 В предыдущем вызове функции создаются следующие наборы.  
  
|Набор 1. Функции\-кандидаты, имеющие первый аргумент типа int|Набор 2. Функции\-кандидаты, имеющие второй аргумент типа int|  
|-------------------------------------------------------------------|-------------------------------------------------------------------|  
|Variant 2 \(`int` можно преобразовать в `long` с помощью стандартного преобразования\)|Variant 1 \(`int` можно преобразовать в `long` с помощью стандартного преобразования\)|  
  
 Обратите внимание, что на пересечении этих наборов функция отсутствует.  Поэтому компилятор создает сообщение об ошибке.  
  
 Для сопоставления аргументов функция с аргументами по умолчанию *n* обрабатывается как отдельные функции *n*\+1, при этом каждая функция имеет разное количество аргументов.  
  
 Многоточие \(...\) выступает в качестве подстановочного знака; оно соответствует любому фактическому аргументу.  Это может привести к появлению множества неоднозначных наборов, если не соблюдать предельную осторожность при разработке наборов перегруженных функций.  
  
> [!NOTE]
>  Неоднозначность перегруженных функций невозможно определить, пока не будет обнаружен вызов функции.  На этом этапе наборы создаются для каждого аргумента в вызове функции, и можно определить, существует ли неоднозначная перегрузка.  Это означает, что неоднозначности могут оставаться в коде до тех пор, пока они не будут вызваны конкретным вызовом функции.  
  
## Различия типов аргументов  
 Перегруженные функции различают типы аргументов, имеющие разные инициализаторы.  Следовательно, аргумент заданного типа и ссылка на этот тип считаются одинаковыми для перегрузки,  поскольку имеют одни и те же инициализаторы.  Например, `max( double, double )` — то же самое, что и `max( double &, double & )`.  Объявление двух таких функций приводит к ошибке.  
  
 По этой же причине аргументы функций, тип которых изменен с помощью объекта **const** или `volatile`, интерпретируются для перегрузки как базовый тип.  
  
 Однако механизм перегрузки функций может различать ссылки, определяемые объектами **const** и `volatile`, и ссылки на базовый тип.  Это позволяет создать код, аналогичный приведенному ниже.  
  
```  
// argument_type_differences.cpp  
// compile with: /EHsc /W3  
// C4521 expected  
#include <iostream>  
  
using namespace std;  
class Over {  
public:  
   Over() { cout << "Over default constructor\n"; }  
   Over( Over &o ) { cout << "Over&\n"; }  
   Over( const Over &co ) { cout << "const Over&\n"; }  
   Over( volatile Over &vo ) { cout << "volatile Over&\n"; }  
};  
  
int main() {  
   Over o1;            // Calls default constructor.  
   Over o2( o1 );      // Calls Over( Over& ).  
   const Over o3;      // Calls default constructor.  
   Over o4( o3 );      // Calls Over( const Over& ).  
   volatile Over o5;   // Calls default constructor.  
   Over o6( o5 );      // Calls Over( volatile Over& ).  
}  
```  
  
### Вывод  
  
```  
Over default constructor  
Over&  
Over default constructor  
const Over&  
Over default constructor  
volatile Over&  
```  
  
 Указатели на объекты **const** и `volatile` также считаются отличными от указателей на базовый тип для перегрузки.  
  
## Сопоставление аргументов и преобразования  
 Когда компилятор пытается сопоставить фактические аргументы с аргументами в объявлениях функций и точное соответствие найти не удается, для получения правильного типа он может выполнять стандартные или пользовательские преобразования.  Для преобразований действуют следующие правила:  
  
-   последовательности преобразований, содержащие несколько пользовательских преобразований, не учитываются;  
  
-   последовательности преобразований, которые могут быть сокращены путем удаления промежуточных преобразований, не учитываются.  
  
 Получающаяся последовательность преобразований \(если таковые имеются\), называется наилучшей последовательностью сопоставления.  Существует несколько способов преобразования объекта типа `int` в объект типа `unsigned long`с помощью стандартных преобразований \(описанных в разделе [Стандартные преобразования](../cpp/standard-conversions.md)\):  
  
-   преобразование из типа `int` в тип `long` и затем из типа `long` в тип `unsigned long`;  
  
-   преобразование из типа `int` в тип `unsigned long`.  
  
 Первая последовательность, хотя и обеспечивает достижение требуемой цели, не является наилучшей последовательностью сопоставления, так как существует более короткая последовательность.  
  
 В представленной ниже таблице показана группа преобразований, называемых тривиальными. Они оказывают ограниченное влияние на определение наилучшей последовательности сопоставления.  В списке, приведенном после таблицы, рассматриваются экземпляры, в которых тривиальные преобразования влияют на выбор последовательности.  
  
### Тривиальные преобразования  
  
|Тип, из которого выполняется преобразование|Тип, в который выполняется преобразование|  
|-------------------------------------------------|-----------------------------------------------|  
|*имя\-типа*|*имя\-типа* **&**|  
|*имя\-типа* **&**|*имя\-типа*|  
|*имя\-типа* **\[ \]**|*имя\-типа\**|  
|*имя\-типа* **\(** *список\-аргументов* **\)**|**\(** *\*имя\-типа* **\) \(** *список\-аргументов* **\)**|  
|*имя\-типа*|**const** *имя\-типа*|  
|*имя\-типа*|`volatile` *имя\-типа*|  
|*имя\-типа\**|**const** *имя\-типа\**|  
|*имя\-типа\**|`volatile` *имя\-типа\**|  
  
 Ниже приведена последовательность, в которой делаются попытки выполнения преобразований.  
  
1.  Точное соответствие.  Точное соответствие между типами, с которыми функция вызывается, и типами, объявленными в прототипе функции, всегда является наилучшим соответствием.  Последовательности тривиальных преобразований классифицируются как точные соответствия.  Однако последовательности, не выполняющие никакие из этих преобразований, считаются лучше, чем последовательности, осуществляющие следующие преобразования:  
  
    -   из указателя в указатель на **const** \(`type` **\*** в **const** `type` **\***\);  
  
    -   из указателя в указатель на `volatile` \(`type` **\*** в `volatile` `type` **\***\);  
  
    -   из указателя в указатель на **const** \(`type` **&** в **const** `type` **&**\).  
  
    -   из указателя в указатель на `volatile` \(`type` **&** в `volatile` `type` **&**\).  
  
2.  Сопоставление с использованием повышений.  Любая последовательность, не классифицированная как точное соответствие и содержащая только восходящие приведения целого типа, преобразования из **float** в **double** и тривиальные преобразования, классифицируется как сопоставление с использованием повышений.  Хотя сопоставление с использованием повышений не такое хорошее, как точное, оно лучше сопоставления с использованием стандартных преобразований.  
  
3.  Сопоставление с использованием стандартных преобразований.  Любая последовательность, не классифицированная как точное соответствие или сопоставление с использованием повышений и содержащая только стандартные и тривиальные преобразования, классифицируется как сопоставление с использованием стандартных преобразований.  В этой категории применяются следующие правила:  
  
    -   преобразование из указателя на производный класс в указатель на прямой или косвенный базовый класс предпочтительнее преобразования в **void \*** или **const void \***;  
  
    -   преобразование из указателя на производный класс в указатель на базовый класс создает тем более хорошее соответствие, чем ближе базовый класс к прямому базовому классу.  Предположим, что иерархия классов имеет вид, показанный на следующем рисунке.  
  
 ![Предпочтительные преобразования](../cpp/media/vc391t1.png "vc391T1")  
Граф, иллюстрирующий предпочтительные преобразования  
  
 Преобразование из типа `D*` в тип `C*` предпочтительнее преобразования из типа `D*` в тип `B*`.  Аналогично, преобразование из типа `D*` в тип `B*` предпочтительнее преобразования из типа `D*` в тип `A*`.  
  
 Это же правило применяется для преобразований ссылок.  Преобразование из типа `D&` в тип `C&` предпочтительнее преобразования из типа `D&` в тип `B&` и т. д.  
  
 Это же правило применяется для преобразований указателей на член.  Преобразование из типа `T D::*` в тип `T C::*` предпочтительнее преобразования из типа `T D::*` в тип `T B::*` и т. д. \(`T` — тип члена.\)  
  
 Предыдущее правило применяется только в определенном пути наследования.  Рассмотрим граф, показанный на следующем рисунке.  
  
 ![Множественное наследование, показывающее предпочтительные преобразования](../cpp/media/vc391t2.png "vc391T2")  
Граф множественного наследования, иллюстрирующий предпочтительные преобразования  
  
 Преобразование из типа `C*` в тип `B*` предпочтительнее преобразования из типа `C*` в тип `A*`.  Причина заключается в том, что эти преобразования находятся на одном пути и узел `B*` ближе.  Однако преобразование из типа `C*` в тип `D*` не предпочтительнее преобразования в тип `A*`. Предпочтение отсутствует, поскольку преобразования осуществляются с использованием разных путей.  
  
1.  Сопоставление с пользовательскими преобразованиями.  Эту последовательность невозможно классифицировать как точное сопоставление, сопоставление с использованием повышений или сопоставление с использованием стандартных преобразований.  Чтобы последовательность можно было классифицировать как сопоставление с пользовательскими преобразованиями, она должна содержать только пользовательские, стандартные или тривиальные преобразования.  Сопоставление с пользовательскими преобразованиями лучше сопоставления с многоточием, но хуже сопоставления со стандартными преобразованиями.  
  
2.  Сопоставление с многоточием.  Любая последовательность, соответствующая многоточию в объявлении, классифицируется как сопоставление с многоточием.  Это самое слабое соответствие.  
  
 Пользовательские преобразования применяются при отсутствии встроенного повышения или преобразования.  Эти преобразования выбираются на основе типа сопоставляемого аргумента.  Рассмотрим следующий код.  
  
```  
// argument_matching1.cpp  
class UDC  
{  
public:  
   operator int()  
   {  
      return 0;  
   }  
   operator long();  
};  
  
void Print( int i )  
{  
};  
  
UDC udc;  
  
int main()  
{  
   Print( udc );  
}  
```  
  
 Для класса `UDC` доступны следующие пользовательские преобразования: из типа `int` в тип **long**.  Поэтому компилятор проверяет преобразования для типа сопоставляемого объекта: `UDC`.  Преобразование в `int` существует и оно выбирается.  
  
 В процессе сопоставления аргументов стандартные преобразования можно применять как к аргументу, так и к результату пользовательского преобразования.  Поэтому следующий код работает.  
  
```  
void LogToFile( long l );  
...  
UDC udc;  
LogToFile( udc );  
```  
  
 В приведенном выше примере пользовательское преобразование **operator long** вызывается для преобразования `udc` в тип **long**.  Если бы пользовательское преобразование в тип **long** не было задано, преобразование продолжилось бы следующим образом: тип `UDC` был бы преобразован в тип `int` с помощью пользовательского преобразования.  Затем было бы выполнено стандартное преобразование из типа `int` в тип **long**, чтобы сопоставить аргумент в объявлении.  
  
 Если для сопоставления аргумента необходимы какие\-либо пользовательские преобразования, стандартные преобразования при оценке наилучшего соответствия не используются.  Это утверждение верно даже в том случае, если пользовательское преобразование требуется нескольким функциям\-кандидатам; в таком случае функции считаются одинаковыми.  Пример:  
  
```  
// argument_matching2.cpp  
// C2668 expected  
class UDC1  
{  
public:  
   UDC1( int );  // User-defined conversion from int.  
};  
  
class UDC2  
{  
public:  
   UDC2( long ); // User-defined conversion from long.  
};  
  
void Func( UDC1 );  
void Func( UDC2 );  
  
int main()  
{  
   Func( 1 );  
}  
```  
  
 Обеим версиям функции `Func` требуется пользовательское преобразование для преобразования типа `int` в аргумент типа класса.  Возможные преобразования:  
  
-   преобразование из типа `int` в тип `UDC1` \(пользовательское преобразование\);  
  
-   преобразование из типа `int` в тип **long**; затем преобразование в тип `UDC2` \(двухступенчатое преобразование\).  
  
 Даже несмотря на то, что для второго из этих преобразований требуются стандартное преобразование и пользовательское преобразование, эти два преобразования все равно считаются одинаковыми.  
  
> [!NOTE]
>  Пользовательские преобразования считаются преобразованиями посредством создания или инициализации \(функции преобразования\).  При рассмотрении наилучшего соответствия оба метода считаются одинаковыми.  
  
## Сопоставление аргументов и указатель this  
 Функции\-члены класса обрабатываются по\-разному в зависимости от того, были ли они объявлены с ключевым словом `static`.  Поскольку нестатические функции имеют неявный аргумент, который предоставляет указатель `this`, считается, что они имеют на один аргумент больше, чем статические. В остальном они объявляются одинаково.  
  
 Такие нестатические функции\-члены требуют, чтобы неявный указатель `this` соответствовал типу объекта, через который выполняется вызов функции. Или же \(для перегруженных операторов\) они требуют, чтобы первый аргумент совпадал с объектом, к которому применяется оператор.  \(Дополнительные сведения о перегруженных операторах см. в разделе [Перегруженные операторы](../cpp/operator-overloading.md).\)  
  
 В отличие от других аргументов в перегруженных функциях, при попытке сопоставить аргумент указателя `this` не создаются никакие временные объекты и не предпринимается никаких попыток преобразования.  
  
 Если для обращения к функции\-члену используется оператор выбора члена `– >`, то аргумент указателя `this` имеет тип `class-name` `* const`.  Если элементы объявлены как `const` или `volatile`, то используются типы `const` `class-name``* const` и `volatile` `class-name` `* const` соответственно.  
  
 Оператор выбора члена `.` работает точно так же, за исключением того, что в качестве префикса к имени объекта подставляется неявный оператор взятия адреса `&`.  В следующем примере показано, как это делается:  
  
```  
// Expression encountered in code  
obj.name  
  
// How the compiler treats it  
(&obj)->name  
```  
  
 С точки зрения сопоставления аргументов, левый операнд операторов `–>*` и `.*` \(указатель на член\) обрабатывается так же, как и для операторов `.` и `–>` \(выбор члена\).  
  
## Ограничения  
 К допустимому набору перегруженных функций применяется несколько ограничений.  
  
-   Любые две функции в наборе перегруженных функций должны иметь разные списки аргументов.  
  
-   Перегрузка функций со списками аргументов одного типа лишь на основании возвращаемого типа недопустима.  
  
     **Блок, относящийся только к системам Microsoft**  
  
 Оператор **new** можно перегрузить только на основании возвращаемого типа, в частности, на основании указанного модификатора модели памяти.  
  
## Завершение блока, относящегося только к системам Майкрософт  
  
-   Функции\-члены невозможно перегружать исключительно на основании того, что одна из них является статической, а вторая — нестатической.  
  
-   Объявления `typedef` не определяют новые типы; они представляют синонимы для существующих типов.  Они не влияют на механизм перегрузки.  Рассмотрим следующий код.  
  
    ```  
    typedef char * PSTR;  
  
    void Print( char *szToPrint );  
    void Print( PSTR szToPrint );  
    ```  
  
     Две указанные выше функции имеют идентичные списки аргументов.  `PSTR` является синонимом типа **char \***.  В области члена этот код возвращает ошибку.  
  
-   Перечисляемые типы являются отдельными типами и могут использоваться для различения перегруженных функций.  
  
-   Типы "массив" и "указатель" считаются идентичными при различении перегруженных функций.  Это верно только для одномерных массивов.  Поэтому следующие перегруженные функции вступают в конфликт и выдают сообщение об ошибке.  
  
    ```  
    void Print( char *szToPrint );  
    void Print( char szToPrint[] );  
    ```  
  
     В случае многомерных массивов второе и все последующие измерения являются частью типа.  Поэтому они используются для различения перегруженных функций.  
  
    ```  
    void Print( char szToPrint[] );  
    void Print( char szToPrint[][7] );  
    void Print( char szToPrint[][9][42] );  
    ```  
  
## Сопоставление объявлений  
 Любые два объявления функции с одинаковым именем в одной области видимости могут ссылаться на одну функцию или на две разные перегруженные функции.  Если списки аргументов в объявлениях содержат аргументы эквивалентных типов \(как описано в предыдущем разделе\), эти объявления относятся к одной и той же функции.  В противном случае они ссылаются на две различные функции, которые выбираются с использованием перегрузки.  
  
 Область видимости класса строго соблюдается; поэтому функция, объявленная в базовом классе, не находится в той же области видимости, что и функция, объявленная в производном классе.  Если функция в производном классе объявлена с тем же именем, что и функция в базовом классе, функция производного класса скрывает функцию базового класса, а не вызывает перегрузку.  
  
 Область видимости блока строго соблюдается; поэтому функция, объявленная в области видимости файла, не находится в той же области видимости, что и функция, объявленная локально.  Если локально объявленная функция имеет то же имя, что и функция, объявленная в области файла, локально объявленная функция скрывает функцию области файла, не вызывая перегрузки.  Пример:  
  
```  
// declaration_matching1.cpp  
// compile with: /EHsc  
#include <iostream>  
  
using namespace std;  
void func( int i )  
{  
    cout << "Called file-scoped func : " << i << endl;  
}  
  
void func( char *sz )  
{  
   cout << "Called locally declared func : " << sz << endl;  
}  
  
int main()  
{  
   // Declare func local to main.  
   extern void func( char *sz );  
  
   func( 3 );   // C2664 Error. func( int ) is hidden.  
   func( "s" );  
}  
```  
  
 В предыдущем коде показаны два определения функции `func`.  Определение, которое принимает аргумент типа `char *`, является локальным для функции `main` из\-за оператора `extern`.  Поэтому определение, которое принимает аргумент типа `int`, скрыто, и первый вызов функции `func` завершается ошибкой.  
  
 В случае перегруженных функций\-членов различным версиям функции могут предоставляться разные права доступа.  Они по\-прежнему считаются находящимися в области видимости включающего класса и, таким образом, являются перегруженными функциями.  Рассмотрим следующий код, в котором функция\-член `Deposit` перегружена; одна версия является открытой, вторая — закрытой.  
  
 Целью кода в примере является предоставление класса `Account`, в котором для внесения средств требуется правильный пароль.  Для этого используется перегрузка.  
  
 Обратите внимание, что при вызове функции `Deposit` в операторе `Account::Deposit` вызывается закрытая функция\-член.  Это правильный вызов, поскольку функция `Account::Deposit` является функцией\-членом и, следовательно, имеет доступ к закрытым членам класса.  
  
```  
// declaration_matching2.cpp  
class Account  
{  
public:  
   Account()  
   {  
   }  
   double Deposit( double dAmount, char *szPassword );  
  
private:  
   double Deposit( double dAmount )  
   {  
      return 0.0;  
   }  
   int Validate( char *szPassword )  
   {  
      return 0;  
   }  
  
};  
  
int main()  
{  
    // Allocate a new object of type Account.  
    Account *pAcct = new Account;  
  
    // Deposit $57.22. Error: calls a private function.  
    // pAcct->Deposit( 57.22 );  
  
    // Deposit $57.22 and supply a password. OK: calls a  
    //  public function.  
    pAcct->Deposit( 52.77, "pswd" );  
}  
  
double Account::Deposit( double dAmount, char *szPassword )  
{  
   if ( Validate( szPassword ) )  
      return Deposit( dAmount );  
   else  
      return 0.0;  
}  
```  
  
## См. также  
 [Функции \(C\+\+\)](../cpp/functions-cpp.md)