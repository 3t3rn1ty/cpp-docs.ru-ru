---
title: "friend (C++) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "language-reference"
f1_keywords: 
  - "Friend"
  - "friend_cpp"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "дружественные классы"
  - "friend - ключевое слово [C++]"
  - "доступ к членам, от дружественных функций"
ms.assetid: 8fe9ee55-d56f-40cd-9075-d9fb1375aff4
caps.latest.revision: 10
caps.handback.revision: 6
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# friend (C++)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

В некоторых случаях удобнее предоставить доступ на уровне члена к функциям, которые не являются членами класса, или ко всем функциям в отдельном классе.  Только реализатор класса может объявить, что является для него дружественным элементом.  Функция или класс не могут объявить себя дружественным элементом для любого класса.  В объявлении класса используйте ключевое слово `friend` и имя функции, не являющейся членом, или другой класс, чтобы предоставить доступ к закрытым и защищенным членам класса.  
  
## Синтаксис  
  
```  
  
        friend class-name;  
friend function-declarator;  
```  
  
## Объявления дружественных элементов  
 При объявлении дружественной функции, которая не была объявлена ранее, эта функция экспортируется во включающую область вне класса.  
  
 Функции, объявленные в объявлении friend, обрабатываются так, как если бы они были объявлены с ключевым словом `extern`.  \(Дополнительные сведения о ключевом слове `extern` см. в разделе [Статические спецификаторы класса хранения](http://msdn.microsoft.com/ru-ru/3ba9289a-a412-4a17-b319-ceb2c087df48).\)  
  
 Хотя функции с глобальной областью действия могут быть объявлены как дружественные до объявления своих прототипов, функции\-члены не могут быть объявлены как дружественные функции до полного объявления их класса.  В следующем коде показано, почему при этом возникает ошибка.  
  
```  
class ForwardDeclared;   // Class name is known.  
class HasFriends  
{  
    friend int ForwardDeclared::IsAFriend();   // C2039 error expected  
};  
```  
  
 В предыдущем примере в области действия вводится имя класса `ForwardDeclared`, но полное объявление — в частности, часть, в которой объявляется функция `IsAFriend`, — отсутствует.  Поэтому объявление `friend` в классе `HasFriends` вызывает ошибку.  
  
 Чтобы объявить два класса как дружественные друг другу, весь второй класс должен быть указан как дружественный для первого класса.  Причина такого ограничения заключается в том, что компилятор получает достаточные сведения для объявления отдельных дружественных функций только в момент объявления второго класса.  
  
> [!NOTE]
>  Хотя весь второй класс должен быть дружественным для первого класса, можно выбрать, какие функции первого класса будут дружественными для второго класса.  
  
## дружественные функции  
 Функция `friend` — это функция, которая не является членом класса, но имеет доступ к закрытым и защищенным членам класса.  Дружественные функции не считаются членами класса; это обычные внешние функции с особыми правами доступа.  Дружественные функции не входят в область видимости класса и не вызываются с помощью операторов выбора члена \(**.** и –**\>**\), если они не являются членами другого класса.  Функция `friend` объявляется с помощью класса, который предоставляет доступ.  Объявление `friend` можно поместить в любом месте объявления класса.  На него не влияют ключевые слова управления доступом.  
  
 В следующем примере показан класс `Point` и дружественная функция `ChangePrivate`.  Функция `friend` имеет доступ к закрытому члену данных объекта `Point`, который она получает в качестве параметра.  
  
```  
// friend_functions.cpp  
// compile with: /EHsc  
#include <iostream>  
  
using namespace std;  
class Point  
{  
    friend void ChangePrivate( Point & );  
public:  
    Point( void ) : m_i(0) {}  
    void PrintPrivate( void ){cout << m_i << endl; }  
  
private:  
    int m_i;  
};  
  
void ChangePrivate ( Point &i ) { i.m_i++; }  
  
int main()  
{  
   Point sPoint;  
   sPoint.PrintPrivate();  
   ChangePrivate(sPoint);  
   sPoint.PrintPrivate();  
// Output: 0  
           1  
}  
```  
  
## Члены класса как дружественные элементы  
 Функции\-члены класса могут быть объявлены в других классах как дружественные.  Рассмотрим следующий пример.  
  
```  
// classes_as_friends1.cpp  
// compile with: /c  
class B;  
  
class A {  
public:  
   int Func1( B& b );  
  
private:  
   int Func2( B& b );  
};  
  
class B {  
private:  
   int _b;  
  
   // A::Func1 is a friend function to class B  
   // so A::Func1 has access to all members of B  
   friend int A::Func1( B& );  
};  
  
int A::Func1( B& b ) { return b._b; }   // OK  
int A::Func2( B& b ) { return b._b; }   // C2248  
```  
  
 В предыдущем примере дружественный доступ к классу `A::Func1( B& )` предоставляется только функции `B`.  Поэтому доступ к закрытому члену `_b` допускается только в функции `Func1` класса `A` , но не в функции `Func2`.  
  
 Класс `friend` — это класс, все функций\-члены которого являются дружественными функциями класса, то есть функции\-члены которого имеют доступ к закрытым и защищенным членам другого класса.  Предположим, что в классе `friend` было следующее объявление `B`:  
  
```  
friend class A;  
```  
  
 В этом случае все функции\-члены из класса `A` имели бы дружественный доступ к классу `B`.  В следующем коде приведен пример дружественного класса.  
  
```  
// classes_as_friends2.cpp  
// compile with: /EHsc  
#include <iostream>  
  
using namespace std;  
class YourClass {  
friend class YourOtherClass;  // Declare a friend class  
public:  
   YourClass() : topSecret(0){}  
   void printMember() { cout << topSecret << endl; }  
private:  
   int topSecret;  
};  
  
class YourOtherClass {  
public:  
   void change( YourClass& yc, int x ){yc.topSecret = x;}  
};  
  
int main() {  
   YourClass yc1;  
   YourOtherClass yoc1;  
   yc1.printMember();  
   yoc1.change( yc1, 5 );  
   yc1.printMember();  
}  
```  
  
 Дружественные отношения не являются взаимными, если это не указано явным образом.  В предыдущем примере функции\-члены класса `YourClass` не имеют доступа к закрытым членам класса `YourOtherClass`.  
  
 Управляемый тип не может иметь дружественные функции, классы и интерфейсы.  
  
 Дружественные отношения не наследуются; это означает, что классы, производные от `YourOtherClass`, не могут обращаться к закрытым членам класса `YourClass`.  Дружественные отношения не являются переходящими, поэтому классы, дружественные классу `YourOtherClass`, не могут обращаться к закрытым членам класса `YourClass`.  
  
 На следующем рисунке показаны объявления 4 классов: `Base`, `Derived`, `aFriend` и `anotherFriend`.  Только класс `aFriend` имеет прямой доступ к закрытым членам класса `Base` \(и к любым возможным унаследованным членам класса `Base`\).  
  
 ![Последствия дружественных отношений](../cpp/media/vc38v41.png "vc38V41")  
Следствия дружественных отношений  
  
## Встроенные определения дружественных элементов  
 Дружественные функции можно определить внутри объявлений класса.  Эти функции являются подставляемыми, и как подставляемые функции членов они ведут себя так, как если бы они были определены сразу после просмотра всех членов класса, но до закрытия области класса \(конец объявления класса\).  
  
 Считается, что дружественные функции, определенные в объявлениях класса, не находятся в области включающего класса; они находятся в области видимости файла.  
  
## См. также  
 [Ключевые слова в C\+\+](../cpp/keywords-cpp.md)