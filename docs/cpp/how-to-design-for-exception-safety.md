---
title: "Практическое руководство. Разработка с учетом безопасности исключений | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
ms.assetid: 19ecc5d4-297d-4c4e-b4f3-4fccab890b3d
caps.latest.revision: 20
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 20
---
# Практическое руководство. Разработка с учетом безопасности исключений
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Одним из преимуществ механизма исключения среда выполнения вместе с данными об исключении, гиперссылки непосредственно из выписки, создающей исключение в первой инструкцию catch, обрабатывает его.  Обработчик может быть любое количество уровней вверх в стеке вызовов.  Не знают, что функции, вызванные между выпиской try, а выпиской хода никаких сведений о исключении возникает.  Однако они должны быть разработаны таким образом, чтобы они могли перейти из области «неожиданно» в любой момент, когда исключение может распространяться снизу вверх, а также, чтобы без выходить за частично созданными объектами, потерянной памяти, или структурами данных, неиспользуемые в состояниях.  
  
## Базовые методы  
 Надежная политики обработки исключений для осторожной мысли и должна быть частью процесса проектирования.  Как правило, большинство исключений обнаружены и созданы на более низкие уровни программного модуля, но обычно эти уровни не владеет достаточным контекстом для обработки ошибки сообщение или предоставления пользователям.  В средних уровнях, функции могут перехватывать и повторно создавать исключение при их необходимо проверить объект исключения, или они имеют дополнительные полезные сведения, чтобы обеспечить для верхнего уровня, в конечном счете перехватывает исключение.  Функция должна перехватывать исключение» и «заглотайте только в том случае, если она может полностью восстановить из нее.  Во многих случаях соответствующее расширение функциональности в средних уровнях включить исключению распространения вверх по стеку вызовов.  Даже на самом высоком уровне, может быть невыгодно включить необработанному исключению завершить программу, если исключение покидает программы в состояние, в котором нельзя гарантировать его правильности.  
  
 Независимо от того, как функция обрабатывает исключение, чтобы помочь гарантировать, что «исключения» безопасно, ее необходимо создавать в соответствии с следующим основным правилам.  
  
### Защита ресурсов простым классы  
 При ресурсами ручное управление ресурсами в классах, используйте класс, ничего не делает еще управления каждый ресурс; в противном случае можно вставить утечки.  По возможности используйте [интеллектуального указателя](../cpp/smart-pointers-modern-cpp.md), как показано в следующем примере.  Этот пример намеренно искусственен и примитивен для выделения различия при `shared_ptr`.  
  
```cpp  
// old-style new/delete version  
class NDResourceClass {  
private:  
    int*   m_p;  
    float* m_q;  
public:  
    NDResourceClass() : m_p(0), m_q(0) {  
        m_p = new int;  
        m_q = new float;  
    }  
  
    ~NDResourceClass() {  
        delete m_p;  
        delete m_q;  
    }  
    // Potential leak! When a constructor emits an exception,   
    // the destructor will not be invoked.     
};  
  
// shared_ptr version  
#include <memory>  
  
using namespace std;  
  
class SPResourceClass {  
private:  
    shared_ptr<int> m_p;  
    shared_ptr<float> m_q;  
public:  
    SPResourceClass() : m_p(new int), m_q(new float) { }  
    // Implicitly defined dtor is OK for these members,   
    // shared_ptr will clean up and avoid leaks regardless.  
};  
  
// A more powerful case for shared_ptr  
  
class Shape {  
    // ...  
};  
  
class Circle : public Shape {  
    // ...  
};  
  
class Triangle : public Shape {  
    // ...  
};  
  
class SPShapeResourceClass {  
private:  
    shared_ptr<Shape> m_p;  
    shared_ptr<Shape> m_q;  
public:  
    SPShapeResourceClass() : m_p(new Circle), m_q(new Triangle) { }  
};  
  
```  
  
### Используйте является RAII для управления ресурсами  
 Чтобы быть исключений является безопасной, функция должна убедиться, что объекты, на которые он выбранной с помощью `malloc` или `new` удаляется и закрыты или ресурсы освобождаются все дескрипторы файлов, даже если возникнет исключение.  Эта *Получение ресурса инициализация* \(RAII\) передает управление таких ресурсов сравнивается линии жизни автоматические переменные.  Если функция выходит за пределы области, или путем возвращения обычно или из\-за исключения, вызываются деструкторы для всех полностью построенных автоматические переменные.  Объект оболочки RAII как интеллектуального указателя вызывает соответствующую функцию удаления или конца в деструкторе его.  В коде исключений безопасным, критически важно передать владение каждого ресурса сразу к определенному типу объекта шаблона RAII.  Обратите внимание, что `vector`, `string`, `make_shared`, `fstream` и аналогичные классы отвечают получение ресурса автоматически.  Однако `unique_ptr` и обычных построения `shared_ptr` зарезервированы, поскольку получение ресурса выполняется пользователем вместо объекта; поэтому они засчитываются как *Выпуск ресурсов уничтожение*, но спорны как RAII.  
  
## 3 Гарантии исключения  
 Как правило, безопасность исключений данный момент рассматривается в терминах 3 гарантиям исключения, функция может предоставить: *гарантии без недостатка*, *обеспечивает надежную* и *базовая гарантии*.  
  
### Гарантии без недостатка  
 Гарантии без недостатка \(или «,» ход наиболее\) обеспечивает надежную, функция может предоставить.  Она заявляет, что функция не создает исключение или не допускает одно для распространения.  Однако нельзя надежно, чтобы предоставлять такую гарантию, если \(a\) не будет знать, что все функции, этот метод вызывает функции также не недостаток, и \(б\) известно, что перехватываются любые исключения, созданные до их достигают эти функции или \(C\), известны способы перехвата и правильно обрабатывать все исключения, которые могут достичь этой функции.  
  
 И обеспечивает надежную и базовая гарантии используют допущении, деструкторы не отрицательные.  Все типы контейнеров и стандартная гарантии библиотеки, их деструкторы не вызывают.  Также наоборот требования. Стандартная библиотека требует пользовательские типы, указанными в оно\- для примеру, как шаблон аргумент\- должен иметь не функцию деструкторы.  
  
### Обеспечивает надежную  
 Обеспечивает надежную состояний, если функция выходит за пределы области из\-за исключения, оно не будет предупреждения утечки памяти и состояние программы не изменяется.  Функция, которая предоставляет сильную гарантию фактически транзакция, которая обладает семантикой фиксации или отката. или она полностью удалась, и она не имеет эффекта.  
  
### Базовая гарантии  
 Базовая обеспечивает наиболее слабые 3.  Однако может быть самым лучшим выбором обеспечивает надежную при использовании слишком дорогая в памяти или в производительности.  Базовая гарантии заявляет, что при возникновении исключения, то нет память не протекаена и объект находится в годном к использованию состоянии даже в том случае, если данные могут быть изменены.  
  
## Безопасные классы исключений  
 Класс может гарантировать собственную безопасность исключений, даже если она используется функциями, опасными, запретив из частично выполнить построение частично или удалению.  Если конструктор класса покидает перед завершением, объект никогда не создается и его деструктор никогда не вызывается.  Хотя автоматические, переменные, которые инициализируются до исключения будут иметь их деструктор, динамически будут протекаены выделяемая память или ресурсы, не управляемых интеллектуального указателя или аналогичной автоматической переменной.  
  
 Все встроенные типы, отрицательные и стандартные типы библиотек поддерживают базовую гарантию как минимум.  Следуйте приведенным ниже рекомендациям для любого пользовательского типа, должен быть исключений является безопасным.  
  
-   Используйте интеллектуального указателя или другие программы\-оболочки RAII\- типа, чтобы управлять ресурсами.  Избегайте использования функции управления ресурсами в деструкторе класса, поскольку деструктор не вызывается, если конструктор вызывает исключение.  Однако если класс, выбранного диспетчера ресурсов, элементы управления только один ресурс, то допускается использовать деструктор для управления ресурсами.  
  
-   Понять, что исключение, вызванное в конструктор базового класса не может быть заглотать в конструкторе производного класса.  Если требуется преобразовать исключение и повторное выполнение базового класса в производном конструкторе, используйте блок try функции.  Для получения дополнительной информации см. [Практическое руководство. Обработка исключений в конструкторах базового класса \(C\+\+\)](http://msdn.microsoft.com/ru-ru/53bb822e-785b-4581-9517-210dd05060a3).  
  
-   Возможно, для хранения любых состояние класса в элементе данных, который создает экземпляры программу\-оболочку в интеллектуального указателя, если класс имеет смысл «инициализации, если она включена, чтобы " ошибка». Хотя C\+\+ позволяет неинициализированных элементов данных, они не поддерживает неинициализированных или частично инициализируются экземпляры класса.  Конструктор должен завершиться успешно или или завершиться ошибкой; ни один объект не создается, если конструктор не выполняются до завершения.  
  
-   Не допускайте исключений для выхода из деструктора.  Базовая аксиома C\+\+ деструктор никогда не разрешить исключение для распространения вверх по стеку вызовов.  Если деструктор должен выполняться потенциально исключений функцию операцию, он должен делать в блоке try catch и заглотать исключение.  Стандартная библиотека предоставляет такую гарантию на всех деструкторах. он определяет.  
  
## См. также  
 [Обработка ошибок и исключений](../cpp/errors-and-exception-handling-modern-cpp.md)   
 [Практическое руководство. Интерфейс между кодом с исключениями и без исключений](../cpp/how-to-interface-between-exceptional-and-non-exceptional-code.md)