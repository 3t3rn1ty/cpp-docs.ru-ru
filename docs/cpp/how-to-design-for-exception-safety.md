---
title: "Как: конструктора для исключения безопасности | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-language
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
ms.assetid: 19ecc5d4-297d-4c4e-b4f3-4fccab890b3d
caps.latest.revision: "20"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: 7d15df2f810848bb9349bc98c722ac02ff8cda17
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="how-to-design-for-exception-safety"></a>Практическое руководство. Разработка с учетом безопасности исключений
Одно из преимуществ механизм обработки исключений является исполнения, а также данные об исключении, переход непосредственно из инструкции, вызвавшей исключение с первым catch инструкцию, которая обрабатывает его. Обработчик может быть любое количество уровней вверх в стеке вызовов. Функции, вызываемые между оператор try и оператор throw не требуются какие-либо об исключении, которое выдается.  Тем не менее они должны быть разработано таким образом, чтобы их можно выхода из области «неожиданно» в любой точке, где могут распространяться вверх от ниже исключение и таким образом, не выходя из позади частично созданный объектов, утечки памяти или структур данных, которые находятся в состоянии, непригодном для использования.  
  
## <a name="basic-techniques"></a>Основные методы  
 Надежные политики обработки исключений необходимо тщательно продумать и должны быть частью процесса проектирования. Как правило обнаруживаются и выводится на нижних уровнях программный модуль большинство исключений, но обычно эти уровни не имеют достаточно информации для обработки ошибки или предоставлять конечным пользователям сообщения. На средней слоях функции можно взять и повторно создавать исключение при их нужно будет проверять объекта исключения, или они имеют дополнительные полезные сведения для предоставления верхнего уровня, который в конечном счете перехватывает исключение. Функция следует перехватывать и «проглотить» исключение, только в том случае, если это возможно, для полного восстановления из него. Во многих случаях правильного поведения в среднем слои требуется разрешить исключение распространяется вверх по стеку вызовов. Даже на уровень вверх может понадобиться разрешить завершение программы, если исключение покидает программу в состояние, в котором невозможно гарантировать его правильность необработанное исключение.  
  
 Независимо от того, как функция обрабатывает исключения, которые позволяют гарантировать, что это «безопасный в отношении исключений,» оно должно быть создано согласно следующим правилам basic.  
  
### <a name="keep-resource-classes-simple"></a>Усложнять классов ресурсов  
 При инкапсулировать управление ресурсами вручную в классах, используйте класс, который не выполняет никаких действий, чтобы управлять каждого ресурса; в противном случае может возникнуть утечки. Используйте [интеллектуальные указатели](../cpp/smart-pointers-modern-cpp.md) по возможности, как показано в следующем примере. В этом примере намеренно искусственный и упрощен, чтобы выделить различия при `shared_ptr` используется.  
  
```cpp  
// old-style new/delete version  
class NDResourceClass {  
private:  
    int*   m_p;  
    float* m_q;  
public:  
    NDResourceClass() : m_p(0), m_q(0) {  
        m_p = new int;  
        m_q = new float;  
    }  
  
    ~NDResourceClass() {  
        delete m_p;  
        delete m_q;  
    }  
    // Potential leak! When a constructor emits an exception,   
    // the destructor will not be invoked.     
};  
  
// shared_ptr version  
#include <memory>  
  
using namespace std;  
  
class SPResourceClass {  
private:  
    shared_ptr<int> m_p;  
    shared_ptr<float> m_q;  
public:  
    SPResourceClass() : m_p(new int), m_q(new float) { }  
    // Implicitly defined dtor is OK for these members,   
    // shared_ptr will clean up and avoid leaks regardless.  
};  
  
// A more powerful case for shared_ptr  
  
class Shape {  
    // ...  
};  
  
class Circle : public Shape {  
    // ...  
};  
  
class Triangle : public Shape {  
    // ...  
};  
  
class SPShapeResourceClass {  
private:  
    shared_ptr<Shape> m_p;  
    shared_ptr<Shape> m_q;  
public:  
    SPShapeResourceClass() : m_p(new Circle), m_q(new Triangle) { }  
};  
  
```  
  
### <a name="use-the-raii-idiom-to-manage-resources"></a>Использовать идиому RAII для управления ресурсами  
 Для исключений, функцию необходимо убедиться, что объекты, что он включает выделенные с помощью `malloc` или `new` , удаляются, и все ресурсы, такие как дескрипторы файлов закрыты или освободить, даже если создается исключение. *Получение ресурса есть инициализация* идиому (RAII) связывает управления таких ресурсов времени существования автоматические переменные. Когда функции выходит из области видимости, возвращая обычно или из-за исключения, вызываются деструкторы для все полностью созданные автоматические переменные. Объект-оболочка RAII, таких как смарт-указатель вызывает соответствующий удалить или закрыть функции в деструкторе. В коде исключений критически важными для передачи владения каждого ресурса какого-либо вида объекта RAII немедленно. Обратите внимание, что `vector`, `string`, `make_shared`, `fstream`, и аналогичные классы обработки Получение ресурса для вас.  Тем не менее `unique_ptr` и традиционные `shared_ptr` конструкции являются особыми, поскольку получением ресурса выполняется пользователем, а не объект; таким образом, они считаются *уничтожения — выпуск ресурсов* , но сомнительные как RAII.  
  
## <a name="the-three-exception-guarantees"></a>Три гарантии исключения  
 Как правило, безопасность исключений рассматривается с точки зрения гарантии три исключения, которые могут предоставлять функции: *гарантии нет сбоев*, *надежные гарантии*и *основные гарантии* .  
  
### <a name="no-fail-guarantee"></a>Гарантии нет сбоев  
 Гарантии нет сбоев (или «нет-throw») является сильные гарантии, что может предоставить функцию. В нем сообщается, что функция будет не порождает исключение или разрешить одному распространение. Тем не менее, нельзя задавать надежно такой гарантии Если (a) нет уверенности, что все функции, которые эта функция вызывает, также нет сбоев, (б) вы знаете, перехватывает все исключения, вызванные прежде чем они достигнут эту функцию или (c) вы знаете, как перехватить и правильно обрабатывать все исключения, которые могут достичь этой функции.  
  
 Надежные гарантии и основные гарантии полагаться на предположении, что деструкторы нет сбоев. Все контейнеры и типы в стандартной библиотеке гарантирует, что деструкторы, не вызывают. Имеется требование обратное: стандартной библиотеке требует, что определяемые пользователем типы, заданному для него — например, как аргументы шаблонов — должен иметь деструкторы, не создающие.  
  
### <a name="strong-guarantee"></a>Надежные гарантии  
 Надежные гарантии состояния, если функция выходит за пределы области видимости из-за исключения, он будет не приводят к утечке памяти и программа не будет обновлено состояние. Функция, которая предоставляет надежные гарантии является по сути транзакцию, которая имеет семантики commit или rollback: полностью завершится успешно или не оказывает никакого эффекта.  
  
### <a name="basic-guarantee"></a>Основные гарантии  
 Основные гарантии является самым слабым из трех. Тем не менее возможно, лучшим вариантом при надежные гарантии слишком дорого в потребление памяти или производительности. Базовая гарантирует, что состояния, если возникает исключение, утечки памяти и является объект по-прежнему в нерабочем состоянии, несмотря на то, что данные были изменены.  
  
## <a name="exception-safe-classes"></a>Классы исключений  
 Класс может обеспечить безопасность свои собственные исключения, даже в том случае, если он используется небезопасные функции, так как сам частично созданный или частично удаляется. Если конструктор класса завершает работу до завершения, объект никогда не создается, и его деструктор, никогда не вызывается. Несмотря на то, что будет иметь автоматические переменные, инициализированные до исключения вызывается деструкторы, динамически выделяемую память или ресурсы, которые не управляются смарт-указателем или аналогичные автоматической переменной попасть.  
  
 Встроенные типы являются все нет сбоев и стандартные библиотечные типы поддерживают основные гарантии, по крайней мере. Руководствуйтесь следующими рекомендациями для любого определяемого пользователем типа, должен быть безопасным исключение.  
  
-   Используйте интеллектуальные указатели или других RAII тип оболочки для управления ресурсами. Избегайте функциональные возможности управления ресурсами в вашей деструктор класса, так как деструктор не будет вызываться, если конструктор вызывает исключение. Тем не менее если класс является диспетчер выделенных ресурсов, управляет только один ресурс, то это вполне можно использовать для управления ресурсами деструктор.  
  
-   Понимать, исключение, которое создается в конструкторе базового класса, не может быть пропущенное в конструкторе производного класса. Если требуется преобразовать и заново создать исключение, базовый класс в конструктор производного класса, используйте функции блока try.   
  
-   Рассмотрите возможность хранения всех состояние класса члена данных, который упаковывается в интеллектуальный указатель, особенно в том случае, если у класса имеется понятие «инициализацию, которая может завершиться ошибкой». Хотя C++ допускает для неинициализированных данных элементов, он не поддерживает экземпляры класса неинициализированным или частично инициализирована. Конструктор должен завершиться успешно или завершиться ошибкой; объект не создается, если конструктор не выполняется до завершения.  
  
-   Не разрешать исключения для выхода из деструктора. Основные аксиомой C++ является деструкторы никогда не должны допускать исключению распространяться вверх по стеку вызовов. Если деструктор должен выполнять операции потенциально исключения, он должен таким образом в блок try блок catch и проглатывать исключение. Стандартная библиотека предоставляет такую гарантию на все деструкторы, которые он определяет.  
  
## <a name="see-also"></a>См. также  
 [Обработка ошибок и исключений](../cpp/errors-and-exception-handling-modern-cpp.md)   
 [Практическое руководство. Интерфейс между кодом с исключениями и без исключений](../cpp/how-to-interface-between-exceptional-and-non-exceptional-code.md)