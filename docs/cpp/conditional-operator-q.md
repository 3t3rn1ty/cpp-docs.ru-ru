---
title: "Условный оператор:? : | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-language
ms.tgt_pltfrm: 
ms.topic: language-reference
f1_keywords:
- '?:'
- '?'
dev_langs: C++
helpviewer_keywords:
- conditional operators [C++]
- '? : operator'
ms.assetid: 88643ee8-7100-4f86-880a-705ec22b6271
caps.latest.revision: "10"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: 296ced0754dd12017353469845b3bc4b30e0dc11
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="conditional-operator--"></a>Условный оператор:? :
## <a name="syntax"></a>Синтаксис  
  
```  
  
expression ? expression : expression  
```  
  
## <a name="remarks"></a>Примечания  
 Условный оператор (**?:**) является троичным оператором (принимает три операнда). Условный оператор работает следующим образом.  
  
-   Первый операнд неявно преобразуется в `bool`. Он вычисляется, и все побочные эффекты завершаются перед продолжением.  
  
-   Если первый операнд имеет значение **true** (1), оценивается второй операнд.  
  
-   Если первый операнд имеет значение **false** (0), оценивается третий операнд.  
  
 Результатом условного оператора является оцененного операнда — второго или третьего. В условном выражении оценивается только один из последних двух операндов.  
  
 Условные выражения имеют ассоциативность справа налево. Первый операнд должен иметь целочисленный тип или тип указателя. Следующие правила применяются ко второму и третьему операндам.  
  
-   Если оба операнда имеют один и тот же тип, результат имеет тот же тип.  
  
-   Если оба операнда имеют арифметический тип или тип перечисления, обычные арифметические преобразования (охваченных [стандартные преобразования](standard-conversions.md)) для преобразования их в общий тип.  
  
-   Если оба операнда имеют тип указателя или один операнд относится к типу указателя, а другой является выражением константы со значением 0, преобразования указателя выполняются с целью преобразования их к общему типу.  
  
-   Если оба операнда имеют ссылочные типы, для преобразования их в общий тип используются ссылочные преобразования.  
  
-   Если оба операнда имеют тип void, общий тип также имеет тип void.  
  
-   Если оба операнда относятся к одному определяемому пользователем типу, общий тип также относится к этому типу.  
  
-   Если операнды относятся к разным типам и по крайней мере один из операндов относится к определяемому пользователем типу, для определения общего типа используются правила языка (см. предупреждение ниже).  
  
 Какие-либо сочетания второго и третьего операндов, отсутствующие в предыдущем списке, недопустимы. Тип результата — это общий тип и l-значение, если и второй, и третий операнды имеют один и тот же тип и представляют собой l-значения.  
  
> [!WARNING]
>  Если типы второго и третьего операндов не идентичны, вызываются правила преобразования сложных типов в соответствии со стандартом C++. Эти преобразования могут привести к непредвиденному поведению, включая создание и удаление временных объектов. По этой причине мы настоятельно рекомендуем вам (1) либо избегать использования определяемых пользователем типов в качестве операндов в условных операторах, (2) либо, если определяемые пользователем типы все же используются, явно приводить каждый операнд к общему типу.  
  
## <a name="example"></a>Пример  
  
```  
// expre_Expressions_with_the_Conditional_Operator.cpp  
// compile with: /EHsc  
// Demonstrate conditional operator  
#include <iostream>  
using namespace std;  
int main() {  
   int i = 1, j = 2;  
   cout << ( i > j ? i : j ) << " is greater." << endl;  
}  
```  
  
## <a name="see-also"></a>См. также  
 [Встроенный C++ операторы, приоритет и ассоциативность операторов](../cpp/cpp-built-in-operators-precedence-and-associativity.md)   
 [Оператор Conditional-Expression](../c-language/conditional-expression-operator.md)