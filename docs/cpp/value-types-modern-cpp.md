---
title: "Типы значений (современный C++) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
ms.assetid: f63bb62c-60da-40d5-ac14-4366608fe260
caps.latest.revision: 15
caps.handback.revision: 13
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Типы значений (современный C++)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Классы C\+\+ по умолчанию типа значения.  В этом разделе представлен обзор вводный типов значений и проблемы, относящиеся к их использования.  
  
## Значение и ссылочных типов  
 Как ранее заявленный, классы C\+\+ по умолчанию типа значения.  Их можно задать ссылочные типы, которые позволяют полиморфных расширение функциональности поддерживать объектно\-ориентированного программирования.  Типы значений иногда просматриваются с точки зрения памяти и элементов управления макетом, тогда как ссылочные типы о базовых классах и функциях виртуального для полиморфных целей.  По умолчанию типы значений копируемым, это означает, что всегда конструктор копий и оператор присваивания копий.  Для ссылочных типов, чтобы сделать класс non\-copyable \(отключение оператор присваивания конструктор копий и копирования\) и использовать виртуальный деструктор, поддерживающий их плановый полиморфизм.  Типы значений также о содержимом, когда они копируются, всегда дает 2 независимых значений, которые могут изменяться отдельно.  Ссылочные типы об идентификаторе, какой тип объекта — это?  По этой причине «ссылочные типы также называются» полиморфных типов».  
  
 Если действительно нужно — это ссылка на тип \(базовый класс, виртуальные функции\), необходимо явно отключить копирования, как показано в классе `MyRefType` в следующем коде.  
  
```cpp  
  
// cl /EHsc /nologo /W4  
  
class MyRefType {  
private:  
    MyRefType & operator=(const MyRefType &);  
    MyRefType(const MyRefType &);  
public:  
    MyRefType () {}  
};  
  
int main()  
{  
    MyRefType Data1, Data2;  
    // ...  
    Data1 = Data2;  
}  
```  
  
 Компилировать приведенный выше код приведет к ошибке ошибке:  
  
  **test.cpp \(15\). ошибка C2248: MyRefType::operator «\=»: не удается получить закрытый элемент, объявленный в MyRefType классов»**  
 **meow.cpp \(5\). просмотреть объявление «\=» MyRefType::operator**  
 **meow.cpp \(3\). см. раздел» объявление «MyRefType**   
## Типы значений и повысить эффективность перемещения  
 Нагрузка выделения копирования, избежали медленным из\-за дополнительного новым оптимизациям копирования.  Например, при вводе строки в процессе двух строк, не будет нагрузка переразмещения копии только перемещать, даже если это приводит к в самом вектора расти.  Это также применяется в другие операции, например выполняя операцию добавления на 2 очень больших объектов.  Способ использования этих операций оптимизации значение?  В некоторых компиляторах C\+\+, компилятор включит это автоматически неявно, подобно конструкторы копирования может быть автоматически создается компилятором.  Однако в Visual C\+\+, в класс будет «согласиться на» перемещение назначения и конструкторы, объявив его в определении класса.  Это выполняется с помощью дважды ссылки rvalue амперсанда \(&&\) в соответствующих объявлениях функции\-члена и определения методов перемещения конструктора и назначения перемещения.  Также необходимо добавить соответствующий код «крадете действия воли» из исходного объекта.  
  
 Решения о необходимости, если необходимо переместить включено?  Если известно, необходимо активное построение, возможно, следует переместить копирования включена, если оно может быть больше, чем почему глубокая копия.  Однако если известно, необходима поддержка перемещения, это не обязательно означает, что требуется активное копию.  Это время последнего доступа вызывается «только для движени типом».  Пример уже в стандартной библиотеке `unique_ptr`.  Как примечание, старое `auto_ptr` стали сопоставления и заменяется `unique_ptr` точно должным с отсутствием соответствующих поддержки семантики перемещения в предыдущей версии C C\+\+.  
  
 С помощью семантики перемещения можно RETURN \-\- или вставка\-в\- среднее значение.  Перемещение оптимизация копирования.  Необходимость для выделения памяти в качестве ошибки.  Рассмотрим следующий псевдокод:  
  
```cpp  
  
#include <set>  
#include <vector>  
#include <string>  
using namespace std;  
  
//...  
set<widget> LoadHugeData() {  
    set<widget> ret;  
    // ... load data from disk and populate ret  
    return ret;  
}  
//...  
widgets = LoadHugeData();   // efficient, no deep copy  
  
vector<string> v = IfIHadAMillionStrings();  
v.insert( begin(v)+v.size()/2, "scott" );   // efficient, no deep copy-shuffle  
v.insert( begin(v)+v.size()/2, "Andrei" );  // (just 1M ptr/len assignments)  
//...  
HugeMatrix operator+(const HugeMatrix& , const HugeMatrix& );  
HugeMatrix operator+(const HugeMatrix& ,       HugeMatrix&&);  
HugeMatrix operator+(      HugeMatrix&&, const HugeMatrix& );  
HugeMatrix operator+(      HugeMatrix&&,       HugeMatrix&&);  
//...  
hm5 = hm1+hm2+hm3+hm4+hm5;   // efficient, no extra copies  
```  
  
### Включение переместить для типов соответствующего значения  
 Для похожего на значение класса перемещение может быть больше, чем почему глубокая копия, включать построение перемещения и назначение перемещения для повышения эффективности работы.  Рассмотрим следующий псевдокод:  
  
```cpp  
  
#include <memory>  
#include <stdexcept>  
using namespace std;  
// ...  
class my_class {  
    unique_ptr<BigHugeData> data;  
public:  
    my_class( my_class&& other )   // move construction  
        : data( move( other.data ) ) { }  
    my_class& operator=( my_class&& other )   // move assignment  
    { data = move( other.data ); return *this; }  
    // ...  
    void method() {   // check (if appropriate)  
        if( !data )   
            throw std::runtime_error("RUNTIME ERROR: Insufficient resources!");  
    }  
};  
  
```  
  
 При включении построение\/назначения копии, необходимо также включить построение\/назначение перемещения, если оно может быть, почему, чем глубокая копия.  
  
 Некоторые типы *не значение* только для движени, например, когда невозможно копия ресурса, только владельца передачи.  Пример: `unique_ptr`.  
  
## Раздел  
 Content  
  
## См. также  
 [Тип системы C\+\+](../Topic/C++%20Type%20System%20\(Modern%20C++\).md)   
 [Возвращение к C\+\+](../Topic/Welcome%20Back%20to%20C++%20\(Modern%20C++\).md)   
 [Справочник по языку C\+\+](../cpp/cpp-language-reference.md)   
 [Стандартная библиотека C\+\+](../standard-library/cpp-standard-library-reference.md)