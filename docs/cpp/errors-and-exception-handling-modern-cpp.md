---
title: "Ошибки и исключения обработки (современный C++) | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-language
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
ms.assetid: a6c111d0-24f9-4bbb-997d-3db4569761b7
caps.latest.revision: "19"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.openlocfilehash: ab5b54c820095b54be28a5868505d07f9b0e39d3
ms.sourcegitcommit: ebec1d449f2bd98aa851667c2bfeb7e27ce657b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/24/2017
---
# <a name="errors-and-exception-handling-modern-c"></a>Обработка ошибок и исключений (современный C++)
В современном C++, в большинстве случаев предпочтительным способом для отчетов и обработки логические ошибки и ошибки времени выполнения является в использовании исключений. Это особенно важно в тех случаях, когда стек может содержать несколько вызовов функций между функция, которая обнаруживает ошибку и функция, которая имеет контекст о том, как его обработки. Исключения обеспечивают формальных, четко определенных для кода, который сообщает об ошибках для передачи информации по стеку вызовов.  
  
 Ошибки приложений обычно делятся на две категории: логические ошибки, вызванные программирования ошибок, например, ошибка «индекс вне диапазона» и ошибки времени выполнения, выходящих за рамки управления программиста, например, «сетевая служба недоступна» Произошла ошибка. Управляется программирования C-стиле и в модели COM, отчеты об ошибках, возвращая значение, представляющее код ошибки или код состояния для определенной функции или задав глобальной переменной, которая вызывающий объект может при необходимости получать после каждого вызова функции, см. является ли ошибки. Например программирование COM использует возвращаемое значение HRESULT для сообщения об ошибках в вызывающий объект, и API-интерфейса Win32 имеет GetLastError функции для получения последней ошибки, сообщил стека вызовов. В обоих случаях зависит вызывающей стороне, чтобы распознать код и соответствующим образом реагировать на них. Если вызывающий объект не явным образом обрабатывает код ошибки, программа может произойти сбой без предупреждения или продолжить выполнение с неверные данные и привести к неверным результатам.  
  
 В современном C++ предпочтительные исключения по следующим причинам:  
  
-   Исключение принудительно вызывающий код, чтобы распознать ошибку и его обработки. Необработанные исключения остановки выполнения программы.  
  
-   Исключение переходит к точке в стеке вызовов, который может обработать ошибку. Промежуточные функции можно позволить распространить исключение. У пользователя нет для координации с других слоев.  
  
-   Механизм очистки стека исключений уничтожает все объекты в области в соответствии с четко определенных правилах после возникает исключение.  
  
-   Исключение обеспечивает четкое разделение между кодом, который обнаружил ошибку и код, который обрабатывает ошибку.  
  
 Следующий упрощенный пример показывает синтаксис, необходимые для создания и перехвата исключений в C++.  
  
```cpp  
#include <stdexcept>  
#include <limits>  
#include <iostream>  
  
using namespace std;  
class MyClass  
{  
public:  
   void MyFunc(char c)  
   {  
      if(c < numeric_limits<char>::max())  
         throw invalid_argument("MyFunc argument too large.");  
      //...  
   }  
};  
  
int main()  
{  
   try  
   {  
      MyFunc(256); //cause an exception to throw  
   }  
  
   catch(invalid_argument& e)  
   {  
      cerr << e.what() << endl;  
      return -1;  
   }  
   //...  
   return 0;  
}  
  
```  
  
 Исключений в C++ опираются на языках, например C# и Java. В `try` блокировать, если исключение находится *исключение* будет *перехвачено* первым связанные `catch` блока, тип которого совпадает с подписью исключения. Другими словами, выполнение переходит из `throw` инструкции `catch` инструкции. Если блок catch можно использовать не найден, `std::terminate` вызывается и программа завершает работу. В C++ может быть сгенерировано любого типа; Тем не менее, мы рекомендуем генерировать тип, производный прямо или косвенно от `std::exception`. В предыдущем примере, тип исключения, [invalid_argument](../standard-library/invalid-argument-class.md), определенные в стандартной библиотеке в [ \<stdexcept >](../standard-library/stdexcept.md) файл заголовка. C++ не предоставляет и не требует `finally` блок, чтобы убедиться в том, что все ресурсы будут освобождены, если возникает исключение. Для получения ресурсов — идиому инициализация (RAII), которая использует интеллектуальные указатели, предоставляющее требуемую функциональность для очистки ресурсов. Дополнительные сведения см. в разделе [как: проектирования в целях безопасности исключение](../cpp/how-to-design-for-exception-safety.md). Сведения о механизме очистки стека C++ см. в разделе [исключения и очистки стека](../cpp/exceptions-and-stack-unwinding-in-cpp.md).  
  
## <a name="basic-guidelines"></a>Основные рекомендации  
 Обработка ошибок надежным является сложным на любом языке программирования. Несмотря на то, что исключения предоставляют несколько возможностей для поддержки хорошо обработки ошибок, они не могут делать всю работу за вас. Чтобы использовать преимущества механизм обработки исключений, учитывайте исключения при разработке кода.  
  
-   Используйте утверждения для проверки ошибок, которые не должны происходить. Используйте исключения для проверки ошибок, которые могут возникнуть, например, ошибки проверки входных данных для параметров общих функций. Дополнительные сведения см. в разделе **исключения и. Утверждения**.  
  
-   Используйте исключения, когда код, который обрабатывает ошибки могут быть разделены из кода, который обнаруживает ошибку промежуточных вызовов функций. Рассмотрите возможность используйте коды ошибок в циклах, критический с точки зрения производительности при тесно связанными в код, который определяет его код, который обрабатывает ошибки. 
  
-   Для каждой функции, которая может выдать или распространить исключение, предоставляют три исключения гарантии: надежные гарантии, основные гарантии или гарантии nothrow (noexcept). Дополнительные сведения см. в разделе [как: проектирования в целях безопасности исключение](../cpp/how-to-design-for-exception-safety.md).  
  
-   Создавать исключения по значению, перехватить по ссылке. Не перехватываются, не может обработать. 
  
-   Не используйте спецификации исключений, которые являются устаревшими в C ++ 11. Дополнительные сведения см. в разделе **спецификации исключений и noexcept**.  
  
-   Используйте стандартную библиотеку типов исключений, если они применяются. Наследовать пользовательские типы исключений из [класс exception](../standard-library/exception-class.md) иерархии.  
  
-   Не разрешать исключения выйдите из деструкторы или функции освобождения памяти.  
  
## <a name="exceptions-and-performance"></a>Исключения и производительности  
 Механизм обработки исключений имеет очень низкая производительность, если исключение не возникает. Если исключение создается, затрат обхода стека и очистки сравнимы с затраты на вызов функции. Дополнительных структур данных необходимы для отслеживания стека вызовов после `try` введен блок и необходимые дополнительные инструкции для очистки стека, если возникает исключение. Однако в большинстве случаев затрат производительности и объема памяти не имеет значения. Скорее всего, будут значительно только в системах с ограниченным объемом памяти очень отрицательное влияние исключений на производительность или в важных для производительности циклы где ошибку вероятнее всего выполняются регулярно, и код для обработки, она тесно связана с код, который сообщает об этом. В любом случае определить фактические затраты исключений без профилирования и измерения. Даже в тех редких случаях, когда стоимость имеет большое значение, вы может весить от повышения правильности, проще удобство поддержки и другие преимущества, предоставляемые политики хорошо спроектированной исключений.  
  
## <a name="exceptions-vs-assertions"></a>Исключения и утверждения  
 Исключения и подтверждает являются два механизма обнаружения ошибок во время выполнения в программе. Используйте утверждения для проверки условий во время разработки, которые никогда не должно быть значение true, если ваш код программы написан правильно. Нет смысла в обработке такой ошибки с помощью исключения, поскольку ошибка означает, что что-нибудь в коде должен быть фиксированным и не представляет условие, которое должен восстановиться во время выполнения программы. Метод assert остановке выполнения на инструкцию, чтобы можно было проверить состояние программы в режиме отладки; исключение продолжает выполнение в первый обработчик catch соответствующие. Использование исключений для проверки ошибок, которые могут возникнуть во время выполнения, даже если код программы написан правильно, например, «файл не найден» или «недостаточно памяти». Может потребоваться восстановление из этих условий, даже в том случае, если восстановление только выводит сообщение в журнал и завершает программу. Всегда проверяйте аргументы для функций, открытые с помощью исключения. Даже если функции без ошибок, возможно не полный контроль над аргументы, которые пользователь может передать ему.  
  
## <a name="c-exceptions-versus-windows-seh-exceptions"></a>Исключения C++ и исключениями Windows SEH  
 Программы C и C++ могут использовать механизм структурированной обработки исключений (SEH) в операционной системе Windows. Основные понятия в SEH опираются в исключения C++, за исключением того, что использует SEH `__try`, `__except`, и `__finally` создает вместо `try` и `catch`. В Visual C++ для SEH реализованы исключения C++. Однако при написании кода C++, используйте синтаксис исключения C++.  
  
 Дополнительные сведения о SEH см. в разделе [структурированная обработка исключений (C/C++)](../cpp/structured-exception-handling-c-cpp.md).  
  
## <a name="exception-specifications-and-noexcept"></a>Спецификации исключений и noexcept  
 Спецификации исключений появились в C++, чтобы указать исключения, которые может вызывать функции. Однако спецификации исключений оказался проблемный на практике и являются устаревшими в стандарте C ++ 11 черновик. Рекомендуется не использовать спецификации исключений, за исключением `throw()`, указывающая, что функция позволяет без исключений для выхода. Если необходимо использовать спецификации исключений типа `throw(` *тип*`)`, имейте в виду, что Visual C++ не соответствует стандарту определенными способами. Дополнительные сведения см. в разделе [спецификации исключений (throw)](../cpp/exception-specifications-throw-cpp.md). `noexcept` Описатель впервые появилось в C ++ 11 предпочтительный вариант для `throw()`.  
  
## <a name="see-also"></a>См. также  
 [Как: интерфейс между кодом с исключениями и без исключений](../cpp/how-to-interface-between-exceptional-and-non-exceptional-code.md)   
 [Возвращение к C++](../cpp/welcome-back-to-cpp-modern-cpp.md)   
 [Справочник по языку C++](../cpp/cpp-language-reference.md)   
 [Стандартная библиотека C++](../standard-library/cpp-standard-library-reference.md)
