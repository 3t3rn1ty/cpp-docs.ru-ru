---
title: "Обработка ошибок и исключений (современный C++) | Microsoft Docs"
ms.custom: ""
ms.date: "12/15/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
ms.assetid: a6c111d0-24f9-4bbb-997d-3db4569761b7
caps.latest.revision: 19
caps.handback.revision: 19
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Обработка ошибок и исключений (современный C++)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

В современном C++, в большинстве случаев предпочтительным способом для регистрации и обработки ошибок времени выполнения и логические ошибки является использование исключений. Это особенно важно в тех случаях, когда стек может содержать несколько вызовов функций между функции, который обнаруживает ошибку и контекстом знать, как его обрабатывать. Исключения предоставляют способ формальных, четко определенные для кода, который обнаруживает ошибки для передачи информации по стеку вызовов.  
  
 Ошибки программы обычно разделяются на две категории: логических ошибок, вызванных программирования ошибок, например, ошибка «индекс вне допустимого диапазона» и ошибки времени выполнения, например, выходящих за рамки управления программист ошибку «сетевая служба недоступна». Программирование в стиле C и в модели COM отчеты об ошибках осуществляется, возвращая значение, представляющее код ошибки или код состояния для конкретной функции или задав глобальной переменной, вызывающий объект может при необходимости получить после каждого вызова функции, были ли сообщений об ошибках. Например программировании COM использует возвращаемое значение HRESULT для сообщения об ошибках для вызывающего объекта и Win32 API есть функция GetLastError для получения последняя ошибка, произошедшая в стеке вызовов. В обоих случаях именно вызывающей стороне, чтобы распознать код и реагировать на них соответствующим образом. Если вызывающий объект не явным образом обрабатывает код ошибки, программа может аварийно завершить работу без предупреждения или продолжить выполнение с неверные данные и привести к неверным результатам.  
  
 Предпочтительные исключений в C++ по следующим причинам:  
  
-   Исключение принудительно вызывающий код, чтобы распознать ошибку и обработать его. Необработанные исключения остановить выполнение программы.  
  
-   Исключение переходит к точке в стеке вызовов, можно обработать ошибку. Промежуточные функций позволяет распространить исключение. Они не должны согласовать с другими слоями.  
  
-   Механизм очистки стека исключений уничтожает все объекты в области в соответствии с правилами четко определенных после исключения.  
  
-   Исключение обеспечивает четкое разделение между кодом, который обнаруживает ошибку и код, который обрабатывает ошибку.  
  
 Следующий упрощенный пример показывает синтаксис, необходимые для создания и перехвата исключений в C++.  
  
```cpp  
  
#include <stdexcept>  
#include <limits>  
#include <iostream>  
  
using namespace std;  
class MyClass  
{  
public:  
   void MyFunc(char c)  
   {  
      if(c < numeric_limits<char>::max())  
         throw invalid_argument("MyFunc argument too large.");  
      //...  
   }  
};  
  
int main()  
{  
   try  
   {  
      MyFunc(256); //cause an exception to throw  
   }  
  
   catch(invalid_argument& e)  
   {  
      cerr << e.what() << endl;  
      return -1;  
   }  
   //...  
   return 0;  
}  
  
```  
  
 Исключения в C++ напоминать показанные на такие языки, как C# и Java. В `try` Блокировать, если исключение *исключение* будет *перехвачено* первым связанные `catch` блока, тип которого соответствует исключения. Другими словами, выполнение переходит от `throw` инструкции `catch` инструкции. Если блок catch можно использовать не найден, `std::terminate` вызывается и программа завершает работу. В C++ любой тип может быть создано исключение; Тем не менее, рекомендуется генерировать тип, который прямо или косвенно наследует `std::exception`. В предыдущем примере тип исключения, [invalid_argument](../standard-library/invalid-argument-class.md), определенных в стандартной библиотеке в [\< stdexcept>](../standard-library/stdexcept.md) файл заголовка. C++ не поддерживает и не требует `finally` блок, чтобы убедиться в том, что все ресурсы будут освобождены, если возникнет исключение. Приобретение ресурсов является происходит инициализация (RAII), который использует интеллектуальные указатели, предоставляет необходимые функции для очистки ресурсов. Дополнительные сведения см. в разделе [Практическое руководство: разработка с учетом безопасности исключений](../cpp/how-to-design-for-exception-safety.md). Сведения о механизме очистки стека C++ содержатся [исключения и очистка стека](../cpp/exceptions-and-stack-unwinding-in-cpp.md).  
  
## <a name="basic-guidelines"></a>Основные рекомендации  
 Обработка ошибок надежные является сложной задачей, на любом языке программирования. Несмотря на то, что исключения предоставляют несколько возможностей для поддержки обработки ошибок, хорошо, они не могут делать всю работу за вас. Чтобы использовать преимущества механизм обработки исключений, учитывайте исключений при разработке кода.  
  
-   Используйте утверждения для проверки ошибок, которые не должны происходить. Используйте исключения для проверки ошибок, которые могут возникнуть, например, ошибки при проверке вводимых данных для параметров общих функций. Дополнительные сведения см. в разделе **vs исключения. Утверждения**.  
  
-   Используйте исключения, когда код, обрабатывающий ошибки могут быть разделены из кода, который обнаруживает ошибку промежуточных вызовов функций. Рассмотрите возможность использования кодов ошибок вместо в циклах, важных для производительности, когда код, обрабатывающий ошибку, тесно связанные код, который определяет его. Дополнительные сведения о том, когда не следует использовать исключения в разделе [(NOTINBUILD) когда не следует использовать исключения](http://msdn.microsoft.com/ru-ru/e810df8b-2217-4e81-bae5-02f0a69f1346).  
  
-   Для каждой функции, которая может создавать или распространять исключения, предоставляют гарантии три исключения: надежный гарантии, основные гарантии или гарантии nothrow (noexcept). Дополнительные сведения см. в разделе [Практическое руководство: разработка с учетом безопасности исключений](../cpp/how-to-design-for-exception-safety.md).  
  
-   Создавать исключения по значению, захватывать их ссылкой. Не перехватываются, не может обработать. Дополнительные сведения см. в разделе [(NOTINBUILD) рекомендации по генерации и перехват исключений (C++)](http://msdn.microsoft.com/ru-ru/0a9b0a3a-64c5-43f5-a080-fca69b89e839).  
  
-   Не используйте спецификации исключений, которые являются устаревшими в C ++ 11. Дополнительные сведения см. в разделе **спецификации исключений и noexcept**.  
  
-   Используйте стандартную библиотеку типы исключений, когда они применяются. Наследовать пользовательские типы исключений из [класс exception](../standard-library/exception-class1.md) иерархии. Дополнительные сведения см. в разделе [(NOTINBUILD) как: использовать стандартные объекты исключение библиотеки](http://msdn.microsoft.com/ru-ru/ad1fb785-ed4e-4d94-8e84-964353aed7b6).  
  
-   Не разрешать исключения выйдите из деструкторы или функции освобождения памяти.  
  
## <a name="exceptions-and-performance"></a>Исключения и производительность  
 Механизм обработки исключений имеет очень минимальных затрат, если исключение не возникает. Если создается исключение затрат обхода стека и очистки мало сравнимы с затраты на вызов функции. Требуются дополнительные структуры данных для отслеживания стека вызовов после `try` введен блок и необходимые дополнительные инструкции для очистки стека, если возникнет исключение. Однако в большинстве случаев стоимость, производительность и объем памяти не имеет значения. Неблагоприятное влияние исключений на производительность будет занимать значительных только в системах очень ограниченного памяти или в важных для производительности циклы где ошибка вероятнее всего выполняются регулярно, и код для его обработки тесно связана с кода, который сообщает о нем. В любом случае это невозможно знать фактическая стоимость исключений без профилирования и измерения. Даже в тех редких случаях, когда стоимость имеет значение, можно сравнить его от повышения правильности, проще поддерживаемость и других преимуществ, предоставляемых политики хорошо спроектированной исключений.  
  
## <a name="exceptions-vs-assertions"></a>Исключения и утверждения  
 Исключения и утверждает являются два механизма обнаружения ошибок во время выполнения в программе. Используйте утверждения для проверки условий во время разработки, никогда не должно быть значение true, если ваш код программы написан правильно. Нет смысла в обработке такой ошибки с помощью исключения, поскольку ошибка означает, что что-то в коде должен быть фиксированным и не представляет условие, которое должен восстановиться во время выполнения программы. Метод assert останавливает выполнение инструкции, чтобы можно было проверять состояние программы в режиме отладки; исключение продолжает выполнение из обработчика первый соответствующий catch. Использовать исключения для проверки ошибок, которые могут возникнуть во время выполнения, даже если код является правильным, например, «файл не найден» или «недостаточно памяти». Может потребоваться восстановление из этих условий, даже если восстановления просто выводит сообщение в журнал и завершает программу. Всегда Проверьте аргументы открытых функций с помощью исключения. Даже если функции без ошибок, может не имеют полный контроль над аргументы, которые пользователь может передать ему.  
  
## <a name="c-exceptions-versus-windows-seh-exceptions"></a>Исключения C++ и исключения Windows SEH  
 C и C++ программы могут использовать механизм структурированной обработки исключений (SEH) в операционной системе Windows. Основные понятия в SEH напоминать показанные в исключения C++, за исключением того, что использует SEH `__try`, `__except`, и `__finally` создает вместо `try` и `catch`. В Visual C++ для SEH реализованы исключения C++. Однако при написании кода C++, используйте синтаксис исключений C++.  
  
 Дополнительные сведения о SEH см. в разделе [структурированной обработки исключений (C/C++)](../cpp/structured-exception-handling-c-cpp.md).  
  
## <a name="exception-specifications-and-noexcept"></a>Спецификации исключений и noexcept  
 Спецификации исключений появились в C++, как способ указания исключений, которые могут вызвать функцию. Однако спецификации исключений оказалась проблемы на практике и являются устаревшими в стандарте C ++ 11 черновика. Рекомендуется не использовать спецификации исключений, за исключением `throw()`, который указывает, что исключение разрешает без исключений для выхода. Если необходимо использовать спецификации исключений типа `throw(`*тип*`)`, имейте в виду, [!INCLUDE[vcprvc](../build/includes/vcprvc_md.md)] не соответствует стандарту определенным образом. Дополнительные сведения см. в разделе [спецификации исключений (throw)](../cpp/exception-specifications-throw-cpp.md).  `noexcept` Описатель введен в C ++ 11 предпочтительный альтернативой `throw()`.  
  
## <a name="see-also"></a>См. также  
 [Практическое руководство: интерфейс между кодом с исключениями и без исключений](../cpp/how-to-interface-between-exceptional-and-non-exceptional-code.md)   
 [Добро пожаловать в C++](../Topic/Welcome%20Back%20to%20C++%20\(Modern%20C++\).md)   
 [Справочник по языку C++](../cpp/cpp-language-reference.md)   
 [Стандартная библиотека C++](../standard-library/cpp-standard-library-reference.md)