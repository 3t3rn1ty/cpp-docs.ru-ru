---
title: "Управление временем жизни и ресурсами объекта (современный C++) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
ms.assetid: 8aa0e1a1-e04d-46b1-acca-1d548490700f
caps.latest.revision: 18
caps.handback.revision: 18
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Управление временем жизни и ресурсами объекта (современный C++)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

В отличие от управляемые языки C\+\+ не имеет сборку мусора \(GC\), которой автоматически выпуски не\-длинн\- использовать ресурсы памяти по мере выполнения программы;.  В C\+\+, управление ресурсами напрямую привязан к времени существования объекта.  В этом документе описываются факторы, влияющие на время существования объектов в C\+\+, как управлять его.  
  
 C C\+\+ не имеет основной СБОРКИ, поскольку оно не обрабатывает ресурсы не памяти.  Только \(деструкторы такие же, как и в C\+\+ могут обрабатывать ресурсы памяти и не имеют памяти.  СБОРКИ имеются другие ошибки, например более высокой нагрузки в памяти и использовании ЦП и местоположение.  Но всеобщность коренная проблемы, которые не ухищренные принимает меры по оптимизации.  
  
## Основные понятия  
 Важная прежде всего в элементе управления временем существования объекта инкапсуляция\- включена для них с помощью объекта не должна знать, какие ресурсы, объект имеет, как получить освобождал их, или даже имеет ли он любые ресурсы вообще.  Просто должен удалить объект.  Язык C к основной предназначен для обеспечения объектов уничтожаются правильных во времени, т е как блоки слева, в обратном порядке порядок построения.  При удалении объекта, его базы данных и члены удаляется в определенном порядке.  Язык автоматически удаляет объекты, без крайней специальные действия как выделение кучи или размещение новых.  Например, [интеллектуального указателя](../cpp/smart-pointers-modern-cpp.md) как контейнеры `unique_ptr` и `shared_ptr` и \(STL\) стандартной библиотеки шаблонов, как `vector`, инкапсулирует `new`\/`delete` и `new[]`\/`delete[]` в объектах, содержащих деструкторы.  Поэтому, поэтому важно использовать интеллектуального указателя и контейнеров STL.  
  
 Другим важным принципом в управлении временем существования. деструкторы.  Деструкторы инкапсулируют выпуск ресурса.  \(Часто используется мнемоника RRID, выпуск ресурсов уничтожение\).  Ресурс элемент, полученные от «системы» и должны быть обратно позже.  Память наиболее общий ресурс, а также файлы, сокетов текстуры, и другие ресурсы, памяти. «Иметь» ресурс означает его можно использовать, когда требуется, но необходимо также освобождение его после окончания работы с ним.  При удалении объекта, его выпуски деструктора ресурсы, он имел.  
  
 Полная концепция команда обеспечения доступности базы данных \(непосредственно ациклический граф\).  Структура владения в программе формирует группу обеспечения доступности базы данных.  Ни один объект не может иметь сам\- они не только невозможное, но также служат не имеет смысла.  Но 2 объекта могут совместно использовать третьего владельца объекта.  Несколько типов ссылок создавать в группе обеспечения доступности базы данных следующим образом: Член a B \(a, B, C\) хранит `vector<D>` \(C, D\) каждый элемент, сохраняет `shared_ptr<F>` \(E имеет владельца F, возможно, с другими объектами\) и т д  Если нет циклов и каждая ссылка в группе обеспечения доступности базы данных представлена объектом, имеющий деструктор \(вместо начального указателя, дескриптор, или другого механизма\), а затем утечки ресурсов невозможно, поскольку язык предотвращает их.  Ресурсы освобождаются немедленно после они больше не требуются, без выполнения сборщика мусора.  Отслеживание времени существования свободно от нагрузка в область стека, базы данных, члены и другие случаи и недорогой для `shared_ptr`.  
  
### Время существования Куча\-.  
 В течение времени существования объекта кучи, используйте [интеллектуального указателя](../cpp/smart-pointers-modern-cpp.md).  Используйте `shared_ptr` и `make_shared` в качестве указателя и распределитель по умолчанию.  Используйте `weak_ptr` для разделения циклов, создавать кэширование и отследить объектами, не затрагивая или иметь никаких сведений о времени их существования.  
  
```cpp  
void func() {  
  
auto p = make_shared<widget>(); // no leak, and exception safe  
...  
p->draw();   
  
} // no delete required, out-of-scope triggers smart pointer destructor  
  
```  
  
 Используйте `unique_ptr` для уникальных владения, например, в идиоматизме *pimpl*. \(См. раздел [Pimpl для инкапсуляции времени компиляции](../cpp/pimpl-for-compile-time-encapsulation-modern-cpp.md)\). Выполните `unique_ptr` головную цель всех явных выражений `new`.  
  
```cpp  
unique_ptr<widget> p(new widget());  
```  
  
 Можно использовать указатели необработанные для физических владения и наблюдения.  Указатель, не может качать, но он не может именно.  
  
```cpp  
class node {  
  ...  
  vector<unique_ptr<node>> children; // node owns children  
  node* parent; // node observes parent, which is not a concern  
  ...  
};  
node::node() : parent(...) { children.emplace_back(new node(...) ); }  
  
```  
  
 Если необходима оптимизация производительности, можно использовать *хорошо инкапсулированный* имеет указатели и явные вызовы для удаления.  Пример при реализации собственную низкоуровневую структуру данных.  
  
### Время существования стека.  
 В современном C\+\+ *область стека.* мощный способ записи надежный код, поскольку он объединяет автоматическое *штабелируйте время существования* и *время существования элемента данных* с высоким для эффективност\- времени существования — свободно нагрузки.  Время существования объектов кучи старательно требует ручного управления и может быть источником утечки ресурсов и неэффективностей, особенно при работе с сырцовыми указателями.  Рассмотрим этот код, который показывает область на основе стека:  
  
```cpp  
class widget {  
private:  
  gadget g;   // lifetime automatically tied to enclosing object  
public:  
  void draw();  
};  
  
void functionUsingWidget () {  
  widget w;   // lifetime automatically tied to enclosing scope  
              // constructs w, including the w.g gadget member  
  …  
  w.draw();  
  …  
} // automatic destruction and deallocation for w and w.g  
  // automatic exception safety,   
  // as if "finally { w.dispose(); w.g.dispose(); }"  
  
```  
  
 Используйте статическое время существования осторожно \(статическое глобальных статических функций, локальное\), поскольку могут возникнуть проблемы.  Что происходит, когда конструктор глобального объекта создает исключение?  Как правило, приложение ошибается способом, может оказаться трудной задачей для отладки.  Порядок построения также для статических объектов времени существования и не является безопасным в режиме параллелизма.  Не только конструирование объекта проблему, порядок удаления может быть сложно, особенно если полиморфизм включен.  Даже если в объект или переменная не полиморфных и не имеют сложное построение и уничтожение упорядочения, по\-прежнему потокобезопасного проблемы параллелизма.  Многопоточные приложения не допускается изменение данных в статических объектов без наличия локальной памяти потока, ресурс блокирует и другие специальные меры предосторожности.  
  
## См. также  
 [Возвращение к C\+\+](../Topic/Welcome%20Back%20to%20C++%20\(Modern%20C++\).md)   
 [Справочник по языку C\+\+](../cpp/cpp-language-reference.md)   
 [Стандартная библиотека C\+\+](../standard-library/cpp-standard-library-reference.md)