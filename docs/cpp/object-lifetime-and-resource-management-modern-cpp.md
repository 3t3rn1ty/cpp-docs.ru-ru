---
title: "Времени жизни объекта и управления ресурсами (современный C++) | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-language
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
ms.assetid: 8aa0e1a1-e04d-46b1-acca-1d548490700f
caps.latest.revision: 
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: 4e2b48630fab9d27bf5db442617a5184bd26de5d
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="object-lifetime-and-resource-management-modern-c"></a>Управление временем жизни и ресурсами объекта (современный C++)
В отличие от управляемых языков C++ нет сборщик мусора (GC), который автоматически освобождает ресурсы, нет больше используемых памяти во время выполнения программы. В C++ управление ресурсами непосредственно связаны с временем жизни объекта. В этом документе описываются факторы, которые влияют на время существования объекта в C++ и как управлять им.  
  
 C++ не имеет сборки Мусора в основном, так как он не обрабатывает ресурсов не памяти. Только детерминированные деструкторы, как в C++ может обрабатывать столь же ресурсы памяти и неоптимизированными для памяти. Сборщик Мусора также имеет других подобных нагрузка в памяти и ЦП и местоположению. Но universality серьезную проблему, которую не удается устранить через некий оптимизации.  
  
## <a name="concepts"></a>Основные понятия  
 В управлении жизненным циклом объекта важно инкапсуляция, кто использует объект не должен знать, что ресурсы, которые объект является владельцем, или как избавиться от них или даже он владеет ли какие-либо ресурсы во всех. Он содержит только для уничтожения объекта. Ядро языка C++ разработан для обеспечения уничтожение объектов правильность времени, то есть, как блоки завершился в обратном порядке построения. При уничтожении объекта его базовых классов и членов, удаляются в определенном порядке.  Язык автоматически уничтожает объекты, если вам выполнить специальные действия, как выделение кучи или размещаемого оператора new.  Например [интеллектуальные указатели](../cpp/smart-pointers-modern-cpp.md) как `unique_ptr` и `shared_ptr`, а контейнеры стандартной библиотеки C++, как `vector`, инкапсулируют `new` / `delete` и `new[]` / `delete[]` в объектах, которые имеют деструкторы. Вот почему так важно использовать интеллектуальные указатели и контейнеры стандартной библиотеки C++.  
  
 Другим важным принципом в управлении жизненным циклом: деструкторы. Деструкторы инкапсулируют освобождения ресурса.  (Часто используемые является RRID уничтожения — выпуск ресурсов.)  Ресурс — это то, что вы получаете от «система» и снова назначить позже.  — Это наиболее распространенные ресурс, но существуют также файлы, сокеты, текстуры и другие ресурсы неоптимизированными для памяти. Ресурс «владелец» означает, что его можно использовать, когда он нужен, но также необходимо освободить после окончания работы с ним.  При уничтожении объекта, его деструктор освобождает ресурсы, которые он принадлежит.  
  
 Окончательный является DAG (ориентированного ациклического графа).  Структура владения в программе forms DAG. Объект не может владеть самим собой — это не только невозможно, но по своей природе также бессмысленной. Однако два объекта может совместно использоваться владения третий объект.  Возможны несколько типов ссылок в DAG следующим образом: A является членом группы B (B владеет A), сохраняет C `vector<D>` (C принадлежит каждый элемент D), E хранилищ `shared_ptr<F>` (E использует владения F, возможно совместно с другими объектами), и т. д.  Пока нет циклы и каждого канала в DAG, представленного объектом, имеет деструктор (а не исходный указатель, дескриптор или другого механизма), а затем утечку ресурсов их невозможно, поскольку язык не позволяет их. Ресурсы освобождаются сразу после они больше не требуются, без выполнения сборщику мусора. Время существования отслеживания бесплатные издержки для области стека, базовые типы, члены и связанных вариантах и недорогих для `shared_ptr`.  
  
### <a name="heap-based-lifetime"></a>Время жизни на основе кучи  
 Время существования объектов кучи, использование [интеллектуальные указатели](../cpp/smart-pointers-modern-cpp.md). Используйте `shared_ptr` и `make_shared` как указатель по умолчанию и распределителя. Используйте `weak_ptr` прерывание циклов, кэширование и наблюдать объекты, не влияя и при условии, что никаких сведений о времени их существования.  
  
```cpp  
void func() {  
  
auto p = make_shared<widget>(); // no leak, and exception safe  
...  
p->draw();   
  
} // no delete required, out-of-scope triggers smart pointer destructor  
  
```  
  
 Используйте `unique_ptr` для уникальное владение, например, в *pimpl* идиому. (См. [Pimpl для инкапсуляции времени компиляции](../cpp/pimpl-for-compile-time-encapsulation-modern-cpp.md).) Сделать `unique_ptr` основной целью все явные `new` выражения.  
  
```cpp  
unique_ptr<widget> p(new widget());  
```  
  
 Можно использовать необработанные указатели для владения, отличных от и наблюдения. Указатель-владелец может помеха, но он не может вызвать утечку.  
  
```cpp  
class node {  
  ...  
  vector<unique_ptr<node>> children; // node owns children  
  node* parent; // node observes parent, which is not a concern  
  ...  
};  
node::node() : parent(...) { children.emplace_back(new node(...) ); }  
  
```  
  
 Если необходима оптимизация производительности, может потребоваться использовать *хорошо инкапсулированный* владеет указатели и явные вызовы для удаления. Например, при реализации структуры данных низкого уровня.  
  
### <a name="stack-based-lifetime"></a>Время жизни на основе стека  
 В современном C++ *область стека* представляет собой эффективный способ написания надежного кода, так как она объединяет автоматического *время существования стека* и *время жизни член данных* с высокой эффективностью — по существу отслеживания времени существования предоставляется издержки. Время существования объекта в куче требует тщательного ручной режим управления и может быть источником утечку ресурсов и повысить эффективность работы, особенно в том случае, если вы работаете с необработанными указателями. Рассмотрим следующий код, который показывает область стека.  
  
```cpp  
class widget {  
private:  
    gadget g;   // lifetime automatically tied to enclosing object  
public:  
    void draw();  
};  
  
void functionUsingWidget () {  
    widget w;   // lifetime automatically tied to enclosing scope  
                // constructs w, including the w.g gadget member  
    // ...
    w.draw();  
    // ...
} // automatic destruction and deallocation for w and w.g  
  // automatic exception safety,   
  // as if "finally { w.dispose(); w.g.dispose(); }"  
```  
  
 Как можно реже используйте статическое время жизни (глобальные статические, локальную статическую функцию), так как могут возникнуть проблемы. Что происходит при создании исключения в конструктор глобального объекта? Как правило приложение сбоев в способом, который может быть трудно отлаживать. Порядок построения проблематично статическое время жизни объектов и не является безопасным в режиме параллелизма. Проблема, не только является создание объектов порядок удаления может быть сложной задачей, особенно там, где полиморфизм, то. Даже в том случае, если объект или переменная не полиморфным, не имеет сложных упорядочение конструктора или деструктора, по-прежнему проблемы параллелизма потокобезопасным. Многопоточного приложения не может безопасно изменять данные в статических объектов без необходимости локальной памяти потока, блокировки ресурсов и другие специальные меры предосторожности.  
  
## <a name="see-also"></a>См. также  
 [Возвращение к C++](../cpp/welcome-back-to-cpp-modern-cpp.md)   
 [Справочник по языку C++](../cpp/cpp-language-reference.md)   
 [Стандартная библиотека C++](../standard-library/cpp-standard-library-reference.md)