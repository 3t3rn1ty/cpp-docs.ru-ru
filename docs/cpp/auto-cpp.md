---
title: "auto (C++) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "language-reference"
dev_langs: 
  - "C++"
ms.assetid: e9d495d7-601c-4547-b897-998389a311f4
caps.latest.revision: 18
caps.handback.revision: 15
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# auto (C++)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Выводит тип объявленной переменной из выражения инициализации.  
  
## Синтаксис  
  
```  
auto declarator initializer;  
```  
  
```  
[](auto param1, auto param2) {};  
```  
  
## Заметки  
 Ключевое слово `auto` указывает компилятору использовать выражение инициализации объявленной переменной, или параметр лямбда\-выражения, чтобы вывести ее тип.  
  
 Ключевое слово `auto` рекомендуется использовать в большинстве ситуаций \(кроме тех, когда требуется преобразование\), поскольку оно обладает рядом преимуществ:  
  
-   **Надежность.** Если тип выражения изменился \(в том числе если изменен возвращаемый тип функции\), это не влияет на его работу.  
  
-   **Эффективность.** Преобразование гарантированно не будет выполнено.  
  
-   **Удобство использования.** Можно не беспокоиться об опечатках и ошибках.  
  
-   **Эффективность.** Быстрое написание кода.  
  
 Случаи преобразования, для которых не подходит ключевое слово `auto`:  
  
-   Если необходимо получить конкретный тип.  
  
-   Вспомогательные типы шаблона выражения \(например, `(valarray+valarray)` или списки инициализаторов\), хотя и в редких случаях, если вы намереваетесь написать строку кода `auto x = { 1 };` и ожидаете получить значение типа `int`.  
  
 Чтобы использовать ключевое слово `auto`, укажите его вместо типа для определения переменной, а затем задайте выражение инициализации.  Кроме того, ключевое слово `auto` можно изменить с помощью спецификаторов и деклараторов, например `const`, `volatile`, указателя \(`*`\), ссылки \(`&`\) и ссылки rvalue `(&&`\).  Компилятор вычисляет выражение инициализации, а затем использует эти сведения, чтобы вывести тип переменной.  
  
 Выражение инициализации может представлять собой присваивание \(синтаксис со знаком равенства\), прямую инициализацию \(синтаксис в стиле функции\), выражение [operator new](../Topic/operator%20new%20\(%3Cnew%3E\).md). Кроме того, выражение инициализации может представлять собой параметр *for\-range\-declaration* в выражении [Основанное на диапазоне выражение for \(C\+\+\)](../Topic/Range-based%20for%20Statement%20\(C++\).md).  Дополнительные сведения см. в статье [Инициализаторы](../cpp/initializers.md), а также в примерах кода в этом документе.  
  
 Ключевое слово `auto` является местозаполнителем для типа, однако само по себе не означает тип.  Таким образом, ключевое слово `auto` не может использоваться в приведениях типов или в таких операторах, как [sizeof](../cpp/sizeof-operator.md) и [typeid](../Topic/typeid%20%20\(C++%20Component%20Extensions\).md).  
  
## Удобство  
 Ключевое слово `auto` — это простой способ объявить переменную, которая имеет сложный тип.  Например, с помощью `auto` можно объявить переменную, в которой выражение инициализации содержит шаблоны, указатели на функции или указатели на члены.  
  
 Кроме того, с помощью `auto` можно объявить и инициализировать переменную в лямбда\-выражение.  Вы не сможете самостоятельно объявить тип переменной, поскольку тип лямбда\-выражения известен только компилятору.  Дополнительные сведения см. в статье [Примеры лямбда\-выражений](../cpp/examples-of-lambda-expressions.md).  
  
## Отслеживание возвращаемых типов  
 Ключевое слово `auto` и спецификатор `decltype` помогают в написании библиотек шаблонов.  Используйте `auto` и `decltype` для объявления функции шаблонов, возвращаемый тип которой зависит от типов аргументов его шаблонов.  Кроме того, при помощи `auto` и `decltype` можно объявить шаблонную функцию, которая создает оболочку для вызова другой функции, а потом возвращает полученный результат, какой бы возвращаемый тип ни имела вторая функция.  Дополнительные сведения см. в статье [decltype](../cpp/decltype-cpp.md).  
  
## Ссылки и cv\-квалификаторы  
 Обратите внимание, что использование `auto` удаляет ссылки, квалификаторы const и квалификаторы volatile.  Рассмотрим следующий пример.  
  
```cpp  
// cl.exe /analyze /EHsc /W4  
#include <iostream>  
  
using namespace std;  
  
int main( )  
{  
    int count = 10;  
    int& countRef = count;  
    auto myAuto = countRef;  
  
    countRef = 11;  
    cout << count << " ";  
  
    myAuto = 12;  
    cout << count << endl;  
}  
  
```  
  
 Вы полагаете, что myAuto представляет собой ссылку на тип int, однако на самом деле это не так.  На самом деле myAuto является объектом типа int, поэтому программа выводит `11 11`, а не `11 12`, как было бы в том случае, если бы ссылка не была удалена при добавлении ключевого слова `auto`.  
  
## Ограничения и сообщения об ошибках  
 В приведенной ниже таблице перечислены ограничения на использование ключевого слова `auto` и соответствующие диагностические сообщения об ошибках, которые выводит компилятор.  
  
|Номер ошибки|Описание|  
|------------------|--------------|  
|[C3530](../Topic/Compiler%20Error%20C3530.md)|Ключевое слово `auto` не может использоваться в сочетании с другим спецификатором типа.|  
|[C3531](../error-messages/compiler-errors-2/compiler-error-c3531.md)|Символ, объявленный с помощью ключевого слова `auto`, должен иметь инициализатор.|  
|[C3532](../error-messages/compiler-errors-2/compiler-error-c3532.md)|Неверно используется ключевое слово `auto` для объявления типа.  Например, был объявлен тип возвращаемого значения метода или массив.|  
|[C3533](../Topic/Compiler%20Error%20C3533.md), [C3539](../Topic/Compiler%20Error%20C3539.md)|Аргумент параметра или шаблона не может объявляться с помощью ключевого слова `auto`.|  
|[C3534](../Topic/Compiler%20Error%20C3534.md)|Символ, объявленный с помощью ключевого слова `auto` в выражении с оператором `new`, должен иметь инициализатор.  Дополнительные сведения см. в статье [оператор new](../Topic/operator%20new%20\(%3Cnew%3E\).md).|  
|[C3535](../error-messages/compiler-errors-2/compiler-error-c3535.md)|Параметр метода или шаблона не может объявляться с помощью ключевого слова `auto`.|  
|[C3536](../error-messages/compiler-errors-2/compiler-error-c3536.md)|Символ не может быть использован до инициализации.  Практически это означает, что переменную нельзя использовать для инициализации самой себя.|  
|[C3537](../error-messages/compiler-errors-2/compiler-error-c3537.md)|Выполнить приведение к типу, объявленному с помощью ключевого слова `auto`, невозможно.|  
|[C3538](../error-messages/compiler-errors-2/compiler-error-c3538.md)|Все символы в списке деклараторов, объявленные при помощи ключевого слова `auto`, должны разрешаться к одному и тому же типу.  Дополнительные сведения см. в статье [Объявления](../misc/declarations.md).|  
|[C3540](../error-messages/compiler-errors-2/compiler-error-c3540.md), [C3541](../error-messages/compiler-errors-2/compiler-error-c3541.md)|Операторы [sizeof](../cpp/sizeof-operator.md) и [typeid](../Topic/typeid%20%20\(C++%20Component%20Extensions\).md) не могут быть применены к символам, объявленным с помощью ключевого слова `auto`.|  
  
## Примеры  
 В следующих фрагментах кода показаны ситуации, в которых может использоваться ключевое слово `auto`.  
  
 Следующие объявления эквивалентны.  В первом операторе переменная `j` объявлена с типом `int`.  Во втором операторе выводится, что переменная `k` имеет тип `int`, поскольку выражение инициализации \(0\) является целым числом.  
  
```cpp  
  
int j = 0;  // Variable j is explicitly type int.  
auto k = 0; // Variable k is implicitly type int because 0 is an integer.  
```  
  
 Следующие объявления эквивалентны, но второе объявление проще первого.  Одной из важнейших причин, по которым следует использовать ключевое слово `auto`, является простота.  
  
```cpp  
  
map<int,list<string>>::iterator i = m.begin();   
auto i = m.begin();   
```  
  
 В следующем фрагменте кода тип переменных `iter` и `elem` объявляется при запуске цикла `for` и диапазона `for`.  
  
```cpp  
  
// cl /EHsc /nologo /W4  
#include <deque>  
using namespace std;  
  
int main()  
{  
    deque<double> dqDoubleData(10, 0.1);  
  
    for (auto iter = dqDoubleData.begin(); iter != dqDoubleData.end(); ++iter)  
    { /* ... */ }  
  
    // prefer range-for loops with the following information in mind  
    // (this applies to any range-for with auto, not just deque)  
  
    for (auto elem : dqDoubleData) // COPIES elements, not much better than the previous examples  
    { /* ... */ }  
  
    for (auto& elem : dqDoubleData) // observes and/or modifies elements IN-PLACE  
    { /* ... */ }  
  
    for (const auto& elem : dqDoubleData) // observes elements IN-PLACE  
    { /* ... */ }  
}  
  
```  
  
 В следующем примере кода объявляется указатель. Для этого используется оператор `new` и объявление указателя.  
  
```cpp  
  
double x = 12.34;  
auto *y = new auto(x), **z = new auto(&x);  
```  
  
 В следующем примере кода объявлено несколько символов в каждом операторе объявления.  Обратите внимание, что все символы во всех операторах разрешаются к одному и тому же типу.  
  
```cpp  
  
auto x = 1, *y = &x, **z = &y; // Resolves to int.  
auto a(2.01), *b (&a);         // Resolves to double.  
auto c = 'a', *d(&c);          // Resolves to char.  
auto m = 1, &n = m;            // Resolves to int.  
```  
  
 В этом примере кода используется условный оператор \(`?:`\). Переменная `x` здесь объявляется как целочисленная переменная со значением 200.  
  
```cpp  
  
int v1 = 100, v2 = 200;  
auto x = v1 > v2 ? v1 : v2;  
```  
  
 В следующем примере кода переменная `x` инициализируется как тип `int`, переменная `y` — как ссылка на тип `const` `int`, а переменная `fp` — как указатель на функцию, которая возвращает тип `int`.  
  
```cpp  
  
int f(int x) { return x; }  
int main()  
{  
    auto x = f(0);  
    const auto & y = f(1);  
    int (*p)(int x);  
    p = f;  
    auto fp = p;  
    //...  
}  
  
```  
  
## См. также  
 [Ключевое слово auto](../cpp/auto-keyword.md)   
 [\(NOTINBUILD\)Storage\-Class Specifiers](http://msdn.microsoft.com/ru-ru/10b3d22d-cb40-450b-994b-08cf9a211b6c)   
 [Ключевые слова в C\+\+](../cpp/keywords-cpp.md)   
 [\/Zc:auto \(выведение типа переменной\)](../build/reference/zc-auto-deduce-variable-type.md)   
 [Оператор sizeof](../cpp/sizeof-operator.md)   
 [typeid](../Topic/typeid%20%20\(C++%20Component%20Extensions\).md)   
 [оператор new](../Topic/operator%20new%20\(%3Cnew%3E\).md)   
 [Объявления](../misc/declarations.md)   
 [Примеры лямбда\-выражений](../cpp/examples-of-lambda-expressions.md)   
 [Инициализаторы](../cpp/initializers.md)   
 [decltype](../cpp/decltype-cpp.md)