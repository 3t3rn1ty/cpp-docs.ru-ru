---
title: "Конструкторы копий и операторы присваивания копий (C++) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "language-reference"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "= - оператор, копирование объектов"
  - "назначение значений для копирования объектов"
  - "операторы присваивания, для копирования объектов"
  - "операторы назначения, копирование объектов"
  - "копирование объектов"
  - "инициализация объектов, копированием объектов"
  - "объекты [C++], копирование"
ms.assetid: a94fe1f9-0289-4fb9-8633-77c654002c0d
caps.latest.revision: 12
caps.handback.revision: 12
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Конструкторы копий и операторы присваивания копий (C++)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

> [!NOTE]
>  Начиная с версии C\+\+ 11 в языке поддерживаются два вида присваивания: *присваивание копированием* и *присваивание перемещением*.  В этой статье "присваивание" означает "присваивание копированием", если явно не указано другое.  Сведения о присваивании перемещением см. в статье [Конструкторы перемещения и операторы присваивания перемещением \(C\+\+\)](http://msdn.microsoft.com/ru-ru/1442de5f-37a5-42a1-83a6-ec9cfe0414db).  
>   
>  Как при операции назначения, так и при операции инициализации выполняется копирование объектов.  
  
-   **Присваивание** — если значение одного объекта присваивается другому объекту, первый объект копируется во второй объект.  Поэтому  
  
    ```cpp  
    Point a, b;  
    ...  
    a = b;  
    ```  
  
     приводит к тому, что значение `b` копируется в значение `a`.  
  
-   **Инициализация** — инициализация выполняется в следующих случаях: объявляется новый объект, аргументы передаются в функции по значению или значения возвращаются из функций по значению.  
  
 Можно определить семантику копии объектов типа класса.  Например, рассмотрим следующий код.  
  
```cpp  
TextFile a, b;  
a.Open( "FILE1.DAT" );  
b.Open( "FILE2.DAT" );  
b = a;  
```  
  
 Предыдущий код может означать "копировать содержимое FILE1.DAT в FILE2.DAT" или "игнорировать FILE2.DAT и сделать `b` вторым дескриптором FILE1.DAT". Необходимо вложить соответствующую семантику копирования в каждый класс следующим образом.  
  
-   С помощью оператора присваивания `operator=` вместе со ссылкой на тип класса в качестве возвращаемого типа и параметра, передаваемого ссылкой `const`, например `ClassName& operator=(const ClassName& x);`.  
  
-   С помощью конструктора копии.  Дополнительные сведения о конструкторе копии см. в статье [Правила объявления конструкторов](../misc/rules-for-declaring-constructors.md).  
  
 Если конструктор копии не объявлен, компилятор создает конструктор копии для каждого члена.  Если оператор присваивания копированием не объявлен, компилятор создает оператор присваивания копированием для каждого члена. Объявление конструктора копии не подавляет созданный компилятором оператор присваивания копий, и наоборот.  При реализации любого из этих способов рекомендуется также реализовать другой способ, чтобы значение кода было четким.  
  
 Поэлементное присваивание рассматривается более подробно в статье [\(NOTINBUILD\) Memberwise Assignment and Initialization](http://msdn.microsoft.com/ru-ru/94048213-8b49-4416-8069-b1b7a6f271f9).  
  
 Конструктор копии принимает аргумент типа *имя\_класса***&**, где *имя\_класса* — это имя класса, для которого определен конструктор.  Пример:  
  
```cpp  
// spec1_copying_class_objects.cpp  
class Window  
{  
public:  
    Window( const Window& ); // Declare copy constructor.  
    // ...  
};  
  
int main()  
{  
}  
```  
  
> [!NOTE]
>  По возможности сделайте тип аргумента конструктора копии *const имя\-класса***&**.  Это поможет избежать случайного изменения копируемого объекта конструктором копии.  Это также позволит выполнять копирование из объектов **const**.  
  
## Конструкторы копии, создаваемые компилятором  
 Создаваемые компилятором конструкторы копии, например конструкторы копии, определяемые пользователем, имеют один аргумент типа "ссылка на *имя\-класса*". Исключением является ситуация, когда для всех базовых классов и классов\-членов объявлены конструкторы копии, принимающие один аргумент типа **const** *имя\_класса***&**.  В этом случае аргумент конструктора копии, созданного компилятором, также имеет вид **const**.  
  
 Если тип аргумента для конструктора копии — не **const**, инициализация путем копирования объекта **const** возвращает ошибку.  Обратное утверждение не верно. Если аргумент — **const**, можно выполнить инициализацию путем копирования объекта, отличного от **const**.  
  
 Операторы присваивания, созданные компилятором, следуют одному и тому же правилу в отношении **const.** Они принимают один аргумент типа *имя\_класса***&**, если не определено, что операторы присваивания во всех базовых классах и классах\-членах принимают аргументы типа **const** *имя\_класса&.* В этом случае оператор присваивания, созданный классом, принимает аргумент **const**.  
  
> [!NOTE]
>  Если виртуальные базовые классы инициализируются конструкторами копии, создаются компиляторами или определяются пользователем, они инициализируются только один раз, во время создания.  
  
 Последствия аналогичны тем, которые имеет конструктор копии.  Если тип аргумента отличается от **const**, присваивание из объекта **const** возвращает ошибку.  Обратное утверждение не верно. Если значение **const** присвоено отличному от **const** значению, присваивание завершается успешно.  
  
 Дополнительные сведения о перегруженных операторах присваивания см. в разделе [Присваивание](../cpp/assignment.md).  
  
## См. также  
 [Специальные функции\-члены](../misc/special-member-functions-cpp.md)