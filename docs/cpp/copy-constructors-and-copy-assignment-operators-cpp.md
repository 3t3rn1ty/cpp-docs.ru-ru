---
title: Конструкторы копий и операторы присваивания копий (C++) | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-language
ms.topic: language-reference
dev_langs:
- C++
helpviewer_keywords:
- = operator [C++], copying objects
- assignment statements [C++], copying objects
- assignment operators [C++], for copying objects
- objects [C++], copying
- initializing objects, by copying objects
- copying objects
- assigning values to copy objects
ms.assetid: a94fe1f9-0289-4fb9-8633-77c654002c0d
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: a1292240e5343c461142e8c6029c277175f6a62f
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
---
# <a name="copy-constructors-and-copy-assignment-operators-c"></a>Конструкторы копий и операторы присваивания копий (C++)
> [!NOTE]
>  Начиная с версии C ++ 11, в языке поддерживаются два вида присваивания: *Копировать назначение* и *присваивание перемещением*. В этой статье "присваивание" означает "присваивание копированием", если явно не указано другое. Сведения о присваивании перемещением см. в разделе [конструкторы перемещения и операторы присваивания перемещения (C++)](http://msdn.microsoft.com/en-us/1442de5f-37a5-42a1-83a6-ec9cfe0414db).  
>   
>  Как при операции назначения, так и при операции инициализации выполняется копирование объектов.  
  
-   **Назначение**: когда значение одного объекта присваивается другому объекту, первый объект копируется ко второму объекту. Поэтому  
  
    ```cpp  
    Point a, b;  
    ...  
    a = b;  
    ```  
  
     приводит к тому, что значение `b` копируется в значение `a`.  
  
-   **Инициализация**: инициализация выполняется при объявлении объекта, если аргументы функции передаются по значению или значения возвращаются из функций по значению.  
  
 Можно определить семантику копии объектов типа класса. Например, рассмотрим следующий код.  
  
```cpp  
TextFile a, b;  
a.Open( "FILE1.DAT" );  
b.Open( "FILE2.DAT" );  
b = a;  
```  
  
 Предыдущий код может означать "копировать содержимое FILE1.DAT в FILE2.DAT" или "игнорировать FILE2.DAT и сделать `b` вторым дескриптором FILE1.DAT". Необходимо вложить соответствующую семантику копирования в каждый класс следующим образом.  
  
-   С помощью оператора присваивания `operator=` вместе со ссылкой на тип класса в качестве возвращаемого типа и параметра, передаваемого ссылкой `const`, например `ClassName& operator=(const ClassName& x);`.  
  
-   С помощью конструктора копии.   
  
 Если конструктор копии не объявлен, компилятор создает конструктор копии для каждого члена.  Если оператор присваивания копированием не объявлен, компилятор создает оператор присваивания копированием для каждого члена. Объявление конструктора копии не подавляет созданный компилятором оператор присваивания копий, и наоборот. При реализации любого из этих способов рекомендуется также реализовать другой способ, чтобы значение кода было четким.  
   
 Конструктор копии принимает аргумент типа * класс-name ***&**, где *имя класса* имя класса, для которого определен конструктор. Пример:  
  
```cpp  
// spec1_copying_class_objects.cpp  
class Window  
{  
public:  
    Window( const Window& ); // Declare copy constructor.  
    // ...  
};  
  
int main()  
{  
}  
```  
  
> [!NOTE]
>  Сделайте тип аргумента конструктора копии *const класс-имя *** &** возможности. Это поможет избежать случайного изменения копируемого объекта конструктором копии. Он также включает копирование из **const** объектов.  
  
## <a name="compiler-generated-copy-constructors"></a>Конструкторы копии, создаваемые компилятором  
 Конструкторы копии, созданные компилятором, например конструкторы копии, определяемые пользователем, имеют один аргумент типа «ссылка на *имя класса*.» Исключением является после всех базовых классов и классов-членов объявлены конструкторы копии, принимающие один аргумент типа **const** * класс-name ***&**. В этом случае аргумент конструктора копии, созданные компилятором также имеет **const**.  
  
 Если тип аргумента для конструктора копии не **const**, инициализация путем копирования **const** возвращает ошибку. Обратное неверно: Если аргумент является **const**, можно выполнить инициализацию путем копирования объекта, не **const**.  
  
 Операторы присваивания, созданные компилятором следуют тому же шаблону относится к **const.** Они принимают один аргумент типа *класс-имя *** &** Если операторы присваивания во всех классах базового и член не принимают аргументы типа **const** *имя_класса &.* В этом случае созданный классом, принимает оператор присваивания **const** аргумент.  
  
> [!NOTE]
>  Если виртуальные базовые классы инициализируются конструкторами копии, создаются компиляторами или определяются пользователем, они инициализируются только один раз, во время создания.  
  
 Последствия аналогичны тем, которые имеет конструктор копии. Если тип аргумента не **const**, присваивание из **const** возвращает ошибку. Обратное неверно: Если **const** значение присваивается значение, которое не является **const**, присваивание завершается успешно.  
  
 Дополнительные сведения о перегруженных операторах присваивания см. в разделе [назначения](../cpp/assignment.md).  
  
