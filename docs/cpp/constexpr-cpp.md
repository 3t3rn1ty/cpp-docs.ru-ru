---
title: "constexpr (C++) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "language-reference"
f1_keywords: 
  - "constexpr"
  - "constexpr_cpp"
dev_langs: 
  - "C++"
ms.assetid: c6458ccb-51c6-4a16-aa61-f69e6f4e04f7
caps.latest.revision: 3
caps.handback.revision: 3
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# constexpr (C++)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Ключевое слово `constexpr` появилось в C\+\+11 и было усовершенствовано в C\+\+14.  Оно означает *константное выражение*.  По аналогии с `const` оно может применяться к переменным. Поэтому если код пытается изменить значение, появится сообщение об ошибке компилятора.  В отличие от `const`, `constexpr` также может применяться к функциям и конструкторам классов.  `constexpr` указывает, что значение или возвращаемое значение является константой и, если это возможно, будет вычислено во время компиляции.  Целочисленное значение `constexpr` может использоваться везде, где требуется const integer, например в аргументах шаблонов и объявлениях массивов.  Если значение может быть вычислено во время компиляции, а не во время выполнения, это может позволить программе работать быстрее и использовать меньше памяти.  
  
## Синтаксис  
  
```vb  
  
constexpr  literal-type  identifier = constant-expression;  
constexpr  literal-type  identifier { constant-expression };  
constexpr literal-type identifier(params );  
constexpr ctor (params);  
```  
  
#### Параметры  
 `params`  
 Один или несколько параметров, которые должны относиться к типу литерала \(как указано ниже\), а сами должны быть константным выражением.  
  
## Возвращаемое значение  
 Переменная или функция constexpr должна возвращать один из типов литералов, указанных ниже.  
  
## Типы литералов  
 Для ограничения уровня сложности вычисления констант во время компиляции и уменьшения степени их влияния на время компиляции в стандарте C\+\+14 требуется, чтобы типы, применяемые в константных выражениях, были ограничены типами литералов.  Тип литерала — это такой тип, макет которого может быть определен во время компиляции.  Ниже указаны типы литералов.  
  
1.  void  
  
2.  скалярные типы  
  
3.  ссылки  
  
4.  Массивы void, скалярных типов или ссылок  
  
5.  Класс, имеющий тривиальный деструктор, а также один или несколько конструкторов constexpr, которые не являются конструкторами перемещений или копий.  Кроме того, все его нестатические данные\-члены и базовые классы должны быть типами литералов и не должны изменяться.  
  
## переменные constexpr  
 Основное различие между переменными const и constexpr заключается в том, что инициализация переменной const может быть отложена до времени выполнения, тогда как переменная constexpr должна быть инициализирована во время компиляции.  Все переменные constexpr относятся к типу const.  
  
```  
constexpr float x = 42.0;  
constexpr float y{108};  
constexpr float z = exp(5, 3);  
constexpr int i; // Error! Not initialized  
int j = 0;  
constexpr int k = j + 1; //Error! j not a constant expression  
```  
  
## функции constexpr  
 Функция `constexpr` относится к тем функциям, возвращаемое значение которых может быть вычислено во время компиляции, когда оно требуется коду\-потребителю.  Функция `constexpr` должна принимать и возвращать только типы литералов.  Если ее аргументы являются значениями `constexpr`, а для кода\-потребителя требуется возвращаемое значение во время компиляции. Например, для инициализации переменной `constexpr` или предоставления аргумента шаблона, не являющегося типом, функция создает константу времени компиляции.  В случае вызова с аргументами, отличными от `constexpr`, или если значение функции не требуется во время компиляции, она создает значение во время выполнения, как это делают обычные функции.  \(Такое двойственное поведение устраняет необходимость написания версии `constexpr`, а также версий, отличных от `constexpr` той же функции.\)  
  
```  
constexpr float exp(float x, int n)  
{  
    return n == 0 ? 1 :  
        n % 2 == 0 ? exp(x * x, n / 2) :  
        exp(x * x, (n - 1) / 2) * x;  
};  
```  
  
> [!TIP]
>  Примечание. Если в отладчике Visual Studio в функции `constexpr` разместить точку останова, то она будет вычисляться во время компиляции.  Попадание в точку останова означает, что функция была вызвана во время выполнения.  Если попадания в точку останова не происходит, это означает, что функция была вызвана во время компиляции.  
  
## Общие правила для constexpr  
 Чтобы функцию, переменную, конструктор или статические данные\-члены определить как `constexpr`, они должны соответствовать определенным требованиям.  
  
-   Функция `constexpr` может быть рекурсивной.  Она не может быть [виртуальной](../cpp/virtual-cpp.md), а ее тип возвращаемого значения и типы параметров должны быть типами литералов.  Тело может быть определено как `= default` или `= delete`.  В противном случае необходимо соблюдать следующие правила: оно не содержит операторов `goto`, блоков try, неинициализированных переменных или определений переменных, которые не относятся к типам литералов либо являются статическими или локальными для потока.  Кроме того, конструктор не может быть определен как constexpr, если включающий класс содержит какие\-либо виртуальные базовые классы.  
  
-   Переменная может быть объявлена с помощью `constexpr`, если она имеет тип литерала и инициализирована.  Если инициализация выполняется конструктором, то сам конструктор должен быть объявлен как `constexpr`.  
  
-   Ссылка может быть объявлена как constexpr, если объект, на который она ссылается, был инициализирован с помощью константного выражения, а любые неявные преобразования, вызываемые во время инициализации, также являются константными выражениями.  
  
-   Все объявления переменной или функции `constexpr` должны иметь спецификатор `constexpr`.  
  
-   Явная специализация шаблона, отличного от constexpr, может быть объявлена как `constexpr`:  
  
-   Явная специализация шаблона `constexpr` не обязательно также должна быть `constexpr`:  
  
-   Функция или конструктор `constexpr` неявно является `inline`.  
  
## Пример  
 В следующем примере показаны переменные, функции и пользовательские типы `constexpr`.  Обратите внимание, что в последнем операторе в main\(\) функция\-член `constexpr` GetValue\(\) является вызовом времени выполнения, так как во время компиляции значение знать не нужно.  
  
```  
#include <iostream>  
  
using namespace std;  
  
// Pass by value   
constexpr float exp(float x, int n)  
{  
    return n == 0 ? 1 :  
        n % 2 == 0 ? exp(x * x, n / 2) :  
        exp(x * x, (n - 1) / 2) * x;  
};  
  
// Pass by reference  
constexpr float exp2(const float& x, const int& n)  
{  
    return n == 0 ? 1 :  
        n % 2 == 0 ? exp2(x * x, n / 2) :  
        exp2(x * x, (n - 1) / 2) * x;  
};  
  
// Compile time computation of array length  
template<typename T, int N>  
constexpr int length(const T(&ary)[N])   
{   
    return N;   
}   
  
// Recursive constexpr function  
constexpr int fac(int n)  
{   
    return n == 1 ? 1 : n*fac(n - 1);   
}  
  
// User-defined type  
class Foo  
{  
public:  
    constexpr explicit Foo(int i) : _i(i) {}  
    constexpr int GetValue()  
    {  
        return _i;  
    }  
private:  
    int _i;  
};  
  
int main()  
{  
    //foo is const:  
    constexpr Foo foo(5);   
    // foo = Foo(6); //Error!  
  
    //Compile time:  
    constexpr float x = exp(5, 3);   
    constexpr float y { exp(2, 5) };  
    constexpr int val = foo.GetValue();   
    constexpr int f5 = fac(5);  
    const int nums[] { 1, 2, 3, 4 };  
    const int nums2[length(nums) * 2] { 1, 2, 3, 4, 5, 6, 7, 8 };  
  
    //Run time:   
    cout << "The value of foo is " << foo.GetValue() << endl;   
  
}  
  
```  
  
## Требования  
 Visual Studio 2015  
  
## См. также  
 [Объявления и определения](../cpp/declarations-and-definitions-cpp.md)   
 [const](../cpp/constexpr-cpp.md)