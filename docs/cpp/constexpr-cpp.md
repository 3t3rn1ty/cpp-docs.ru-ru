---
title: "constexpr (C++) | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-language
ms.tgt_pltfrm: 
ms.topic: language-reference
f1_keywords: constexpr_cpp
dev_langs: C++
ms.assetid: c6458ccb-51c6-4a16-aa61-f69e6f4e04f7
caps.latest.revision: "3"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: cf1094be23074fe71e65a3077de51263f01a81c6
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="constexpr-c"></a>constexpr (C++)
Ключевое слово `constexpr` появилось в C++11 и было усовершенствовано в C++14. Это означает *константное выражение*. По аналогии с `const` оно может применяться к переменным. Поэтому если код пытается изменить значение, появится сообщение об ошибке компилятора. В отличие от `const`, `constexpr` также может применяться к функциям и конструкторам классов. `constexpr` указывает, что значение или возвращаемое значение является константой и, если это возможно, будет вычислено во время компиляции.  Целочисленное значение `constexpr` может использоваться везде, где требуется const integer, например в аргументах шаблонов и объявлениях массивов. И, если значение может быть вычислено во время компиляции, а не во время выполнения, он может позволить программе работать быстрее и использовать меньше памяти.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
constexpr  literal-type  identifier = constant-expression;
constexpr  literal-type  identifier { constant-expression };
constexpr literal-type identifier(params );
constexpr ctor (params);  
```  
  
#### <a name="parameters"></a>Параметры  
 `params`  
 Один или несколько параметров, которые должны относиться к типу литерала (как указано ниже), а сами должны быть константным выражением.  
  
## <a name="return-value"></a>Возвращаемое значение  
 Переменная или функция constexpr должна возвращать один из типов литералов, указанных ниже.  
  
## <a name="literal-types"></a>Типы литералов  
 Для ограничения уровня сложности вычисления констант во время компиляции и уменьшения степени их влияния на время компиляции в стандарте C++14 требуется, чтобы типы, применяемые в константных выражениях, были ограничены типами литералов. Тип литерала — это такой тип, макет которого может быть определен во время компиляции. Ниже указаны типы литералов.  
  
1.  void  
  
2.  скалярные типы  
  
3.  ссылки  
  
4.  Массивы void, скалярных типов или ссылок  
  
5.  Класс, имеющий тривиальный деструктор, а также один или несколько конструкторов constexpr, которые не являются конструкторами перемещений или копий. Кроме того, все его нестатические данные-члены и базовые классы должны быть типами литералов и не должны изменяться.  
  
## <a name="constexpr-variables"></a>переменные constexpr  
 Основное различие между переменными const и constexpr заключается в том, что инициализация переменной const может быть отложена до времени выполнения, тогда как переменная constexpr должна быть инициализирована во время компиляции.  Все переменные constexpr относятся к типу const.  

-  Переменная может быть объявлена с помощью `constexpr`, если она имеет тип литерала и инициализирована. Если инициализация выполняется конструктором, то сам конструктор должен быть объявлен как `constexpr`.  
  
-   Ссылка может быть объявлена как constexpr, если объект, на который она ссылается, был инициализирован с помощью константного выражения, а любые неявные преобразования, вызываемые во время инициализации, также являются константными выражениями.  
  
-   Все объявления переменной или функции `constexpr` должны иметь спецификатор `constexpr`.  
  
 
  
 
  
```cpp  
constexpr float x = 42.0;  
constexpr float y{108};  
constexpr float z = exp(5, 3);  
constexpr int i; // Error! Not initialized  
int j = 0;  
constexpr int k = j + 1; //Error! j not a constant expression  
```  
  
## <a name="constexpr-functions"></a>функции constexpr  
 Функция `constexpr` относится к тем функциям, возвращаемое значение которых может быть вычислено во время компиляции, когда оно требуется коду-потребителю.  Если ее аргументы являются значениями `constexpr`, а для кода-потребителя требуется возвращаемое значение во время компиляции. Например, для инициализации переменной `constexpr` или предоставления аргумента шаблона, не являющегося типом, функция создает константу времени компиляции. В случае вызова с аргументами, отличными от `constexpr`, или если значение функции не требуется во время компиляции, она создает значение во время выполнения, как это делают обычные функции.  (Такое двойственное поведение устраняет необходимость написания версии `constexpr`, а также версий, отличных от `constexpr` той же функции.)  
 
 Функция или конструктор `constexpr` неявно является `inline`. 
 
 В функции constexpr применяются следующие правила:

- Функция `constexpr` должна принимать и возвращать только типы литералов. 

- Функция `constexpr` может быть рекурсивной. 

- Он не может быть [виртуальный](../cpp/virtual-cpp.md). Объект конструктора не может быть определен как constexpr, если включающий класс содержит все виртуальные базовые классы.

- Тело может быть определено как `= default` или `= delete`. 

- Текст может содержать нет `goto` инструкций или блоков try. 

- Явная специализация шаблона, отличного от constexpr, может быть объявлена как `constexpr`:  
  
- Явная специализация шаблона `constexpr` не обязательно также должна быть `constexpr`: 


<!--conformance note-->
В функции constexpr в Visual Studio 2017 г. и более поздних версий, применяются следующие правила: 

- Он может содержать Если и переключитесь инструкций и все операторы цикла, включая, на основе диапазонов, во время и выполните-во время
    
- Он может содержать объявления локальных переменных, но переменной должны инициализироваться, должны относиться к типу литерала и не может быть статическими или локальными для потока. Локально объявленные переменной не обязательно const и может изменить.

- Функция-член constexpr не обязательно неявно const.

  
```cpp  
constexpr float exp(float x, int n)  
{  
    return n == 0 ? 1 :  
        n % 2 == 0 ? exp(x * x, n / 2) :  
        exp(x * x, (n - 1) / 2) * x;  
};  
```  
  
> [!TIP]
>  Примечание. Если в отладчике Visual Studio в функции `constexpr` разместить точку останова, то она будет вычисляться во время компиляции. Попадание в точку останова означает, что функция была вызвана во время выполнения.  Если попадания в точку останова не происходит, это означает, что функция была вызвана во время компиляции.  
  
 
## <a name="example"></a>Пример  
 В следующем примере показаны переменные, функции и пользовательские типы `constexpr`. Обратите внимание, что в последнем операторе в main() функция-член `constexpr` GetValue() является вызовом времени выполнения, так как во время компиляции значение знать не нужно.  
  
```  
#include <iostream>  
  
using namespace std;  
  
// Pass by value   
constexpr float exp(float x, int n)  
{  
    return n == 0 ? 1 :  
        n % 2 == 0 ? exp(x * x, n / 2) :  
        exp(x * x, (n - 1) / 2) * x;  
};  
  
// Pass by reference  
constexpr float exp2(const float& x, const int& n)  
{  
    return n == 0 ? 1 :  
        n % 2 == 0 ? exp2(x * x, n / 2) :  
        exp2(x * x, (n - 1) / 2) * x;  
};  
  
// Compile time computation of array length  
template<typename T, int N>  
constexpr int length(const T(&ary)[N])   
{   
    return N;   
}   
  
// Recursive constexpr function  
constexpr int fac(int n)  
{   
    return n == 1 ? 1 : n*fac(n - 1);   
}  
  
// User-defined type  
class Foo  
{  
public:  
    constexpr explicit Foo(int i) : _i(i) {}  
    constexpr int GetValue()  
    {  
        return _i;  
    }  
private:  
    int _i;  
};  
  
int main()  
{  
    //foo is const:  
    constexpr Foo foo(5);   
    // foo = Foo(6); //Error!  
  
    //Compile time:  
    constexpr float x = exp(5, 3);   
    constexpr float y { exp(2, 5) };  
    constexpr int val = foo.GetValue();   
    constexpr int f5 = fac(5);  
    const int nums[] { 1, 2, 3, 4 };  
    const int nums2[length(nums) * 2] { 1, 2, 3, 4, 5, 6, 7, 8 };  
  
    //Run time:   
    cout << "The value of foo is " << foo.GetValue() << endl;   
  
}  
  
```  
  
## <a name="requirements"></a>Требования  
 Visual Studio 2015  
  
## <a name="see-also"></a>См. также  
 [Объявления и определения](../cpp/declarations-and-definitions-cpp.md)   
 [const](../cpp/const-cpp.md)