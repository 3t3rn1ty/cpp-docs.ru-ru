---
title: "Классы хранения (C++) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "language-reference"
f1_keywords: 
  - "thread_local_cpp"
  - "external_cpp"
  - "static_cpp"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "классы хранения, основные понятия"
ms.assetid: f10e1c56-6249-4eb6-b08f-09ab1eef1992
caps.latest.revision: 13
caps.handback.revision: 11
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Классы хранения (C++)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Объект *класс хранения* в контексте объявления переменных C\+\+ — это описатель типа, который управляет временем существования, компоновкой и расположением объектов в памяти.  Каждый объект может иметь только один класс хранения.  Переменные, определяемые в блоке, имеют автоматическое хранилище, если не указано иное с помощью описателей `extern`, `static` или `thread_local`.  Автоматически создаваемые объекты и переменные не имеют компоновки. Они не доступны для кода за пределами блока.  
  
 **Примечания**  
  
1.  Ключевое слово [mutable](../cpp/mutable-data-members-cpp.md) может рассматриваться как спецификатор класса хранения.  Однако он доступен только в списке членов в определении класса.  
  
2.  Начиная с версии [!INCLUDE[cpp_dev10_long](../Token/cpp_dev10_long_md.md)], ключевое слово `auto` не является описателем класса хранения C\+\+, а ключевое слово `register` считается устаревшим.  
  
-   [Static](#static)  
  
-   [extern](#extern)  
  
-   [thread\_local](#thread_local)  
  
## статический  
 Ключевое слово `static` может использоваться для объявления переменных и функций в глобальной области видимости, в области видимости пространства имен и области видимости класса.  Статические переменные также могут быть объявлены в локальной области видимости.  
  
 Статическая длительность означает, что объект или переменная выделяется при запуске программы и освобождается при ее завершении.  Внешняя компоновка означает, что имя переменной видно за пределами файла, в котором эта переменная объявлена.  Внутренняя компоновка означает, что имя не видно за пределами файла, в котором объявлена переменная.  По умолчанию объект или переменная, определенные в глобальном пространстве имен, имеют статическую длительность и внешнюю компоновку.  Ключевое слово `static` можно использовать в следующих случаях.  
  
1.  При объявлении переменной или функции в области видимости файла \(в глобальной области видимости и \(или\) области видимости пространства имен\) ключевое слово `static` указывает, что переменная или функция имеет внутреннюю компоновку.  При объявлении переменной она имеет статическую длительность и компилятор инициализирует ее со значением 0, если не указано другое значение.  
  
2.  При объявлении переменной в функции ключевое слово `static` указывает, что переменная сохраняет свое состояние между вызовами этой функции.  
  
3.  При объявлении данных\-члена в объявлении класса ключевое слово `static` указывает, что всеми экземплярами этого класса совместно используется одна копия этого члена.  Статические данные\-член должны быть определены в области видимости файла.  Целочисленные данные\-член, объявляемые как `const` `static`, могут иметь инициализатор.  
  
4.  При объявлении функции\-члена в объявлении класса ключевое слово `static` указывает, что эта функция совместно используется всеми экземплярами данного класса.  Статическая функция\-член не может получать доступ к члену экземпляра, поскольку она не имеет неявного указателя `this`.  Для доступа к члену экземпляра следует объявить функцию с параметром, являющимся указателем или ссылкой на экземпляр.  
  
5.  Объявление членов объединения как статических невозможно.  Однако глобально объявляемое анонимное объединение должно явно объявляться как `static`.  
  
 В следующем примере показано, как переменная, объявленная как `static` в функции, сохраняет свое состояние между вызовами этой функции.  
  
```  
// static1.cpp  
// compile with: /EHsc  
#include <iostream>  
  
using namespace std;  
void showstat( int curr ) {  
   static int nStatic;    // Value of nStatic is retained  
                          // between each function call  
   nStatic += curr;  
   cout << "nStatic is " << nStatic << endl;  
}  
  
int main() {  
   for ( int i = 0; i < 5; i++ )  
      showstat( i );  
}  
```  
  
  **nStatic — 0**  
**nStatic — 1**  
**nStatic — 3**  
**nStatic — 6**  
**nStatic — 10** В следующем примере показано использование ключевого слова `static` в классе.  
  
```  
// static2.cpp  
// compile with: /EHsc  
#include <iostream>  
  
using namespace std;  
class CMyClass {  
public:  
   static int m_i;  
};  
  
int CMyClass::m_i = 0;  
CMyClass myObject1;  
CMyClass myObject2;  
  
int main() {  
   cout << myObject1.m_i << endl;  
   cout << myObject2.m_i << endl;  
  
   myObject1.m_i = 1;  
   cout << myObject1.m_i << endl;  
   cout << myObject2.m_i << endl;  
  
   myObject2.m_i = 2;  
   cout << myObject1.m_i << endl;  
   cout << myObject2.m_i << endl;  
  
   CMyClass::m_i = 3;  
   cout << myObject1.m_i << endl;  
   cout << myObject2.m_i << endl;  
}  
```  
  
  **0**  
**0**  
**1**  
**1**  
**2**  
**2**  
**3**  
**3** В следующем примере показана локальная переменная, объявленная как `static` в функции\-члене.  Статическая переменная доступна всей программе; все экземпляры типа будут совместно использовать одну и ту же копию этой переменной.  
  
```  
// static3.cpp  
// compile with: /EHsc  
#include <iostream>  
using namespace std;  
struct C {  
   void Test(int value) {  
      static int var = 0;  
      if (var == value)   
         cout << "var == value" << endl;  
      else  
         cout << "var != value" << endl;  
  
      var = value;  
   }  
};   
  
int main() {  
   C c1;  
   C c2;  
   c1.Test(100);  
   c2.Test(100);  
}  
```  
  
  **пер \!\= значение**  
**пер \=\= значение** Начиная с версии C\+\+ 11 для инициализации статических локальных переменных гарантируется потокобезопасность.  Эта функция иногда называется *магическая статика*.  Однако в многопоточном приложении все последующие назначения должны быть синхронизированы.  Функцию потокобезопасной статики можно отключить с помощью флага \/Zc:threadSafeInit\-. Это позволит избежать создания зависимости от CRT.  
  
## extern  
 Объекты и переменные, объявленные как `extern`, объявляют объект, определенный в другой записи преобразования или во внешней области видимости, как имеющий внешнюю компоновку.  
  
 Объявление переменных **const** с классом хранения `extern` принудительно задают для переменной внешнюю компоновку.  Инициализация переменной **extern const** допускается в записи преобразования, в которой эта переменная определена.  Инициализации в записях преобразования, отличных от записи, содержащей определение, дает неопределенные результаты.  Дополнительные сведения см. в статье [Использование ключевого слова extern для задания компоновки](../cpp/using-extern-to-specify-linkage.md)  
  
 В следующем коде показаны два объявления `extern`, `DefinedElsewhere` \(обозначает имя, определенное в другой записи преобразования\) и `DefinedHere` \(обозначает имя, определенное во внешней области видимости\):  
  
```  
// external.cpp  
// defined in another translation unit  
extern int DefinedElsewhere;     
int main() {  
   int DefinedHere;   
   {  
      // refers to DefinedHere in the enclosing scope  
      extern int DefinedHere;  
    }  
}  
```  
  
## thread\_local \(C\+\+11\)  
 Переменная, объявленная с описателем `thread_local`, доступна только в том потоке, в котором она была создана.  Переменная создается при создании потока и уничтожается при его уничтожении.  Каждый поток имеет свою собственную копию переменной.  В Windows `thread_local` функционально эквивалентен атрибуту [\_\_declspec\( thread \)](../cpp/thread.md), который тесно связан с системами Майкрософт.  
  
```  
thread_local float f = 42.0; //global namespace  
  
struct C // cannot be applied to type definition  
{  
thread_local int i; //local  
thread_local static char buf[10]; // local and static  
};  
  
void DoSomething()  
{  
thread_local C my_struct; // Apply  thread_local to a variable  
}  
```  
  
1.  Описатель thread\_local можно совместно использовать с `static` или `extern`.  
  
2.  `thread_local` можно применять только в объявлениях и определениях данных. **thread\_local** нельзя использовать в объявлениях и определениях функций.  
  
3.  Использование `thread_local` может помешать [отложенной загрузке](../build/reference/linker-support-for-delay-loaded-dlls.md) импортов DLL**.**  
  
4.  В системах XP `thread_local` может работать неправильно, если библиотека DLL использует данные `thread_local` и динамически загружается через LoadLibrary.  
  
5.  `thread_local` можно задавать только для элементов данных со статической длительностью хранения.  К ним относятся глобальные объекты данных \(**статические** и `extern`\), локальные статические объекты и статические данные\-члены классов.  Нельзя объявлять автоматические объекты данных с использованием **thread\_local**.  
  
6.  `thread_local` следует использовать для объявления и определения локального объекта потока независимо от того, выполняются ли объявление и определение в одном файле или в отдельных файлах.  
  
 В Windows `thread_local` функционально эквивалентно [\_\_declspec\(thread\)](../cpp/thread.md) за исключением того, что \_\_declspec\(thread\) может применяться для определения типа и является допустимым в коде C.  По возможности следует использовать `thread_local`, поскольку он является частью стандарта C\+\+ и поэтому обладает большей переносимостью.  
  
 Дополнительные сведения см. в статье [Локальное хранилище потока \(TLS\)](../parallel/thread-local-storage-tls.md).  
  
## register  
 В C\+\+ 11 ключевое слово **register** является устаревшим.  Оно указывает, что переменную по возможности следует сохранить в регистре компьютера.  В классе регистрового хранения можно объявлять только аргументы функций и локальные переменные.  
  
```  
register int num;  
```  
  
 Как и автоматические переменные, регистровые переменные существуют только до конца блока, в котором они были объявлены.  
  
 Компилятор не учитывает пользовательские запросы на регистровые переменные; вместо этого он самостоятельно назначает регистры, если включена глобальная оптимизация.  Однако компилятор учитывает всю остальную семантику, связанную с ключевым словом [register](http://msdn.microsoft.com/ru-ru/5b66905a-2f7f-4918-bb55-5e66d4bc50f9).  
  
 Если оператор взятия адреса \(**&**\) используется для объекта, объявленного с регистром, компилятор должен поместить объект в память, а не в регистр.  
  
## Пример. Автоматическая истатическая инициализация  
 Локальные автоматически создаваемые объекты или переменные инициализируются каждый раз, когда поток элемента управления достигает их определения.  Локальные статические объекты или переменные инициализируются, когда поток элемента управления достигает их определения в первый раз.  
  
 Рассмотрим следующий пример, в котором определяется класс, который регистрирует инициализацию и удаление объектов, а затем определяет три объекта: `I1`, `I2` и `I3`.  
  
```  
// initialization_of_objects.cpp  
// compile with: /EHsc  
#include <iostream>  
#include <string.h>  
using namespace std;  
  
// Define a class that logs initializations and destructions.  
class InitDemo {  
public:  
   InitDemo( const char *szWhat );  
   ~InitDemo();  
  
private:  
   char *szObjName;  
   size_t sizeofObjName;  
};  
  
// Constructor for class InitDemo  
InitDemo::InitDemo( const char *szWhat ) :  
   szObjName(NULL), sizeofObjName(0) {  
   if( szWhat != 0 && strlen( szWhat ) > 0 ) {  
      // Allocate storage for szObjName, then copy  
      // initializer szWhat into szObjName, using  
      // secured CRT functions.  
      sizeofObjName = strlen( szWhat ) + 1;  
  
      szObjName = new char[ sizeofObjName ];  
      strcpy_s( szObjName, sizeofObjName, szWhat );  
  
      cout << "Initializing: " << szObjName << "\n";  
   }  
   else  
      szObjName = 0;  
}  
  
// Destructor for InitDemo  
InitDemo::~InitDemo() {  
   if( szObjName != 0 ) {  
      cout << "Destroying: " << szObjName << "\n";  
      delete szObjName;  
   }  
}  
  
// Enter main function  
int main() {  
   InitDemo I1( "Auto I1" ); {  
      cout << "In block.\n";  
      InitDemo I2( "Auto I2" );  
      static InitDemo I3( "Static I3" );  
   }  
   cout << "Exited block.\n";  
}  
```  
  
  **Инициализация: Auto I1**  
**В блоке.  Инициализация: Auto I2**  
**Инициализация: Static I3**  
**Удаление: Auto I2**  
**Завершенный блок.  Удаление: Auto I1**  
**Удаление: Static I3**  В предыдущем примере показан способ и время инициализации объектов `I1`, `I2` и `I3`, а также время их удаления.  
  
 Следует обратить внимание на следующие моменты, связанные с программой.  
  
 Во\-первых, `I1` и `I2` автоматически удаляются, когда поток элемента управления выходит за пределы блока, в котором они определены.  
  
 Во\-вторых, в C\+\+ не обязательно объявлять объекты или переменные в начале блока.  Более того, эти объекты инициализируются, только если поток элемента управления достигает их определения.  \(Примерами таких определений являются `I2` и `I3`.\) С помощью выходных данных можно точно определить время их инициализации.  
  
 Наконец, статические локальные переменные, например `I3`, сохраняют свои значения длительности программы, но удаляются при завершении работы программы.  
  
## См. также  
 [Объявления и определения](../cpp/declarations-and-definitions-cpp.md)