---
title: "Битовые поля в C++ | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "битовые поля"
  - "разряды"
  - "поля [C++], bit"
ms.assetid: 6f4b62e3-cc1d-4e5d-bf34-05904104f71a
caps.latest.revision: 8
caps.handback.revision: 8
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Битовые поля в C++
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Классы и структуры могут содержать члены, которые занимают меньше пространства в памяти, чем целочисленный тип.  Эти члены определяются как битовые поля.  Спецификация *члена\-декларатора* битового поля имеет следующий синтаксис:  
  
## Синтаксис  
  
```  
  
declarator  : constant-expression  
```  
  
## Примечания  
 Параметр \(необязательный\) `declarator` представляет собой имя, по которому этот член будет доступен программе.  Он должен иметь один из целочисленных типов \(включая перечисляемые типы\).  Параметр *constant\-expression* задает количество битов, которые член занимает в структуре.  Анонимные битовые поля, \(т. е. битовые поля без идентификатора\) можно использовать для заполнения.  
  
> [!NOTE]
>  Неименованное битовое поле шириной 0 обеспечивает выравнивание следующего битового поля по следующей границе `type`, где `type` обозначает тип члена.  
  
 В следующем примере объявляется структура, которая содержит битовые поля:  
  
```  
// bit_fields1.cpp  
// compile with: /LD  
struct Date {  
   unsigned short nWeekDay  : 3;    // 0..7   (3 bits)  
   unsigned short nMonthDay : 6;    // 0..31  (6 bits)  
   unsigned short nMonth    : 5;    // 0..12  (5 bits)  
   unsigned short nYear     : 8;    // 0..100 (8 bits)  
};  
```  
  
 На следующем рисунке показана концептуальная структура памяти для объекта типа `Date`.  
  
 ![Структура памяти объекта данных](../cpp/media/vc38uq1.png "vc38UQ1")  
Структура памяти объекта типа Date  
  
 Обратите внимание, что `nYear` на 8 бит длиннее и может переполнить границу слова для объявленного типа, **unsigned short**.  Поэтому он находится в начале нового слова **unsigned short**.  Совсем не обязательно, чтобы все битовые поля помещались в один объект базового типа; в зависимости от количества бит, запрошенных в объявлении, выделяются новые единицы хранения.  
  
 **Блок, относящийся только к системам Microsoft**  
  
 Данные, объявленные в качестве битовых полей, упорядочиваются от младшего бита к старшему, как показано на рисунке выше.  
  
 **Завершение блока, относящегося только к системам Майкрософт**  
  
 Объявление структуры может содержать неименованное поле длиной 0, как показано в следующем примере.  
  
```  
// bit_fields2.cpp  
// compile with: /LD  
struct Date {  
   unsigned nWeekDay  : 3;    // 0..7   (3 bits)  
   unsigned nMonthDay : 6;    // 0..31  (6 bits)  
   unsigned           : 0;    // Force alignment to next boundary.  
   unsigned nMonth    : 5;    // 0..12  (5 bits)  
   unsigned nYear     : 8;    // 0..100 (8 bits)  
};  
```  
  
 Структура памяти для такого случая представлена на следующем рисунке.  
  
 ![Структура объекта даты с битовым полем нулевой длины](../cpp/media/vc38uq2.png "vc38UQ2")  
Структура объекта типа Date с битовым полем нулевой длины  
  
 Базовый тип битового поля должен иметь целочисленный тип, как описано в разделе [Основные типы](../cpp/fundamental-types-cpp.md).  
  
## Ограничения для битовых полей  
 В следующем списке указаны ошибочные операции с битовыми полями:  
  
1.  Получение адреса битового поля.  
  
2.  Инициализация ссылки с помощью битового поля.  
  
## См. также  
 [Классы и структуры](../Topic/Classes%20and%20Structs%20\(C++\).md)