---
title: "Битовые поля в C++ | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-language
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
helpviewer_keywords:
- bitfields [C++]
- fields [C++], bit
- bit fields
ms.assetid: 6f4b62e3-cc1d-4e5d-bf34-05904104f71a
caps.latest.revision: "8"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.openlocfilehash: 01a346054fff0f8f3a9a1407c17e28e8dc234a57
ms.sourcegitcommit: ebec1d449f2bd98aa851667c2bfeb7e27ce657b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/24/2017
---
# <a name="c-bit-fields"></a>Битовые поля в C++
Классы и структуры могут содержать члены, которые занимают меньше пространства в памяти, чем целочисленный тип. Эти члены определяются как битовые поля. Синтаксис для битового поля *члена декларатора* спецификации следующим образом:  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
declarator  : constant-expression  
```  
  
## <a name="remarks"></a>Примечания  
 Параметр (необязательный) `declarator` представляет собой имя, по которому этот член будет доступен программе. Он должен иметь один из целочисленных типов (включая перечисляемые типы). *Константное выражение* указывает на количество битов, которые член занимает в структуре. Анонимные битовые поля, (т. е. битовые поля без идентификатора) можно использовать для заполнения.  
  
> [!NOTE]
>  Неименованное битовое поле шириной 0 обеспечивает выравнивание следующего битового поля по следующей границе `type`, где `type` обозначает тип члена.  
  
 В следующем примере объявляется структура, которая содержит битовые поля:  
  
```  
// bit_fields1.cpp  
// compile with: /LD  
struct Date {  
   unsigned short nWeekDay  : 3;    // 0..7   (3 bits)  
   unsigned short nMonthDay : 6;    // 0..31  (6 bits)  
   unsigned short nMonth    : 5;    // 0..12  (5 bits)  
   unsigned short nYear     : 8;    // 0..100 (8 bits)  
};  
```  
  
 На следующем рисунке показана концептуальная структура памяти для объекта типа `Date`.  
  
 ![Структура памяти объекта даты](../cpp/media/vc38uq1.png "vc38UQ1")  
Структура памяти объекта типа Date  
  
 Обратите внимание, что `nYear` 8 бит длиннее и может переполнить границу слова для объявленного типа, **short без знака**. Таким образом, начался в начале нового **short без знака**. Совсем не обязательно, чтобы все битовые поля помещались в один объект базового типа; в зависимости от количества бит, запрошенных в объявлении, выделяются новые единицы хранения.  
  
 **Блок, относящийся только к системам Майкрософт**  
  
 Данные, объявленные в качестве битовых полей, упорядочиваются от младшего бита к старшему, как показано на рисунке выше.  
  
 **Завершение блока, относящегося только к системам Майкрософт**  
  
 Объявление структуры может содержать неименованное поле длиной 0, как показано в следующем примере.  
  
```  
// bit_fields2.cpp  
// compile with: /LD  
struct Date {  
   unsigned nWeekDay  : 3;    // 0..7   (3 bits)  
   unsigned nMonthDay : 6;    // 0..31  (6 bits)  
   unsigned           : 0;    // Force alignment to next boundary.  
   unsigned nMonth    : 5;    // 0..12  (5 bits)  
   unsigned nYear     : 8;    // 0..100 (8 bits)  
};  
```  
  
 Структура памяти для такого случая представлена на следующем рисунке.  
  
 ![Структура объекта даты с нуля &#45; длина битовое поле](../cpp/media/vc38uq2.png "vc38UQ2")  
Структура объекта типа Date с битовым полем нулевой длины  
  
 Базовый тип битового поля должен быть целочисленный тип, как описано в [базовые типы](../cpp/fundamental-types-cpp.md).  
  
## <a name="restrictions-on-bit-fields"></a>Ограничения для битовых полей  
 В следующем списке указаны ошибочные операции с битовыми полями:  
  
1.  Получение адреса битового поля.  
  
2.  Инициализация ссылки с помощью битового поля.  
  
## <a name="see-also"></a>См. также  
 [Классы и структуры](../cpp/classes-and-structs-cpp.md)