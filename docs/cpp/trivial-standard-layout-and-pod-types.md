---
title: Тривиальный, стандартная раскладка POD и типы литералов | Документы Microsoft
ms.custom: ''
ms.date: 04/05/2018
ms.topic: language-reference
ms.assetid: 2b23a7be-9bad-49fc-8298-31a9a7c556b0
ms.openlocfilehash: 7a80db109df1d9aa25f471312a9ff7103b90df7b
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
ms.locfileid: "32424855"
---
# <a name="trivial-standard-layout-pod-and-literal-types"></a>Тривиальный, стандартная раскладка POD и типы литералов

Термин *макета* ссылается на расположение членам объекта типа класса, структуры или объединения в памяти. В некоторых случаях макет четко определенных в спецификации языка. Однако, если класс или структура содержит некоторые возможности языка C++, такие как виртуальные базовые классы, виртуальные функции, члены с разные средства управления доступом, то компилятор не сможет выбрать макет. Этот макет может отличаться в зависимости от того, какие оптимизации выполняются и во многих случаях объект может даже занимает непрерывный блок памяти. Например если класс имеет виртуальные функции, все экземпляры этого класса могут совместно использовать таблицу одной виртуальной функции. Такие типы очень полезны, конечно, но также имеют ограничения. Поскольку макет не определен они не могут быть переданы программ, написанных на других языках, таких как C, и так как они могут быть несмежных их не удается скопировать надежно с fast низкоуровневые функции например `memcopy` или сериализации по сети.

 Чтобы включить компиляторы, а также программы на языке C++ и metaprograms причине относительно пригодности любого конкретного типа для операций, зависящих от макета конкретного памяти, C ++ 14 появились три категории простых классов и структур: *тривиальные*, *стандартная раскладка*, и *POD* или обычные старые данные. Стандартная библиотека содержит шаблоны функций `is_trivial<T>`, `is_standard_layout<T>` и `is_pod<T>` , определяет, принадлежит ли данный тип для данной категории.

## <a name="trivial-types"></a>Тривиальные типы

 Когда класс или структура в C++ имеет предоставляемые компилятором или явно установленные по умолчанию специальных функций-членов, а затем он является тривиальным. Он занимает область непрерывной памяти. Он может иметь члены с описателями различный уровень доступа. В C++ компилятор может выбрать способ упорядочить элементы в этой ситуации. Таким образом вы можете memcopy таких объектов, но нельзя надежно использовать их в программе на языке C. Тривиальное типа T можно копируется в массив char или char без знака и безопасно копируется в переменную T. Обратите внимание, что из-за требований к выравниванию, можно байтов заполнения между членов типа.

 Тривиальные типы имеют тривиальный конструктор по умолчанию, тривиальный конструктор копирования, тривиальный оператор присваивания копии и тривиальный деструктор. В каждом случае *тривиальные* означает конструктор или оператор или деструктор не предоставленные пользователем и принадлежит к классу, который имеет

- виртуальные базовые классы, ни виртуальные функции

- отсутствие базовых классов с соответствующей нетривиальный конструктор или оператор деструктор

- нет членов данных типа класса с соответствующей нетривиальный конструктор или оператор деструктор

В следующих примерах показано тривиальным типам. В Trivial2 наличие `Trivial2(int a, int b)` конструктору требуется предоставлять конструктор по умолчанию. Для типа, чтобы считаться тривиальный необходимо явным образом по умолчанию этот конструктор.

```cpp
struct Trivial
{
      int i;
private:
   int j;  
   };

struct Trivial2
{
   int i;
   Trivial2(int a, int b) : i(a), j(b) {}
   Trivial2() = default;
   private:
   int j;   // Different access control
};

```

## <a name="standard-layout-types"></a>Типы стандартных макета

 Если класс или структура не содержит некоторые возможности языка C++, такие как виртуальные функции, которые не находятся на языке C, а все члены имеют один и тот же элемент управления доступом, это стандартная раскладка тип. Он может memcopy и макет достаточно определено, он может использоваться в программ на языке C. Стандартная раскладка типы могут иметь определяемые пользователем специальные функции-члены. Кроме того стандартный макет типы обладают следующими характеристиками:

- без виртуальных функций или виртуальные базовые классы

- все члены нестатических данных имеют один и тот же элемент управления доступом

- стандартная раскладка все нестатические члены типа класса

- стандартная раскладка базовых классов

- имеет того же типа, что первый элемент нестатических данных отсутствие базовых классов.

- соответствует одно из следующих условий:

  - нет нестатических данных элемента в классе самого дальнего и не более чем одного базового класса с нестатических данных элементами, или

  - имеет отсутствие базовых классов с нестатические данные-члены

Ниже приведен один пример стандартная раскладка типа:

```cpp
struct SL
{
   // All members have same access:
   int i;
   int j;
   SL(int a, int b) : i(a), j(b) {} // User-defined constructor OK
};

```

 Последние два требования можно может быть лучше проиллюстрировать на примере кода. В следующем примере, даже если Base стандартная раскладка `Derived` не является стандартным макетом, так как она (наиболее производного класса) и `Base` у членов нестатических данных:

```cpp
struct Base
{
   int i;
   int j;
};

// std::is_standard_layout<<Derived> == false!
struct Derived : public Base
{
   int x;
   int y;
};

```

 В этом примере `Derived` — стандартная раскладка поскольку `Base` нет нестатических данных-членов:

```cpp
struct Base
{
   void Foo() {}
};

// std::is_standard_layout<<Derived> == true
struct Derived : public Base
{
   int x;
   int y;
};
```

 Производным также будут стандартная раскладка Если `Base` бы данные-члены и `Derived` бы только функции-члены.

## <a name="pod-types"></a>Типы POD

 Если класс или структура является тривиальным и стандартная раскладка, это тип POD (обычные старые данные). Структура памяти типа POD таким образом не прерывается и каждый элемент имеет старших адресов, чем элемент, который был перед ним, позволяя копирует байта и двоичные ввода-вывода может выполняться на эти типы.  Скалярные типы, такие как int также являются типами POD. Типы POD, которые являются классами может содержать только типы POD нестатических данных.

## <a name="example"></a>Пример

В следующем примере показано различия между обычным, стандартная раскладка и типы POD:

```cpp
#include <type_traits>
#include <iostream>

using namespace std;

struct B
{
protected:
   virtual void Foo() {}
};

// Neither trivial nor standard-layout
struct A : B
{
      int a;
   int b;
   void Foo() override {} // Virtual function
};

// Trivial but not standard-layout
struct C
   {
      int a;
private:
   int b;   // Different access control
};

// Standard-layout but not trivial
struct D
{
   int a;
   int b;
   D() {} //User-defined constructor
};

struct POD
{
   int a;
   int b;
};

int main()
{
   cout << boolalpha;
   cout << "A is trivial is " << is_trivial<A>() << endl; // false
   cout << "A is standard-layout is " << is_standard_layout<A>() << endl;  // false

   cout << "C is trivial is " << is_trivial<C>() << endl; // true
   cout << "C is standard-layout is " << is_standard_layout<C>() << endl;  // false

   cout << "D is trivial is " << is_trivial<D>() << endl;  // false
   cout << "D is standard-layout is " << is_standard_layout<D>() << endl; // true

   cout << "POD is trivial is " << is_trivial<POD>() << endl; // true
   cout << "POD is standard-layout is " << is_standard_layout<POD>() << endl; // true

   return 0;
}

```

## <a name="literal_types"></a> Типы литералов

Тип литерала — это такой тип, макет которого может быть определен во время компиляции. Ниже указаны типы литералов.

- void
- скалярные типы
- ссылки
- Массивы void, скалярных типов или ссылок
- Класс, имеющий тривиальный деструктор, а также один или несколько конструкторов constexpr, которые не являются конструкторами перемещений или копий. Кроме того, все его нестатические данные-члены и базовые классы должны быть типами литералов и не должны изменяться.

## <a name="see-also"></a>См. также

 [Основные понятия](../cpp/basic-concepts-cpp.md)