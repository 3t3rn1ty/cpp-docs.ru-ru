---
title: "Преобразования типов и безопасность типов (современный C++) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
ms.assetid: 629b361a-2ce1-4700-8b5d-ab4f57b245d5
caps.latest.revision: 23
caps.handback.revision: 23
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Преобразования типов и безопасность типов (современный C++)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

В этом документе определяет общие проблемы преобразования типов и описание можно избежать их в коде C C\+\+.  
  
 При написании программы C\+\+, важно убедиться, что является типобезопасным.  Это означает, что каждая переменная, аргумент функции и возвращаемое значение функции в допустимый тип данных, что и операции, которые содержат значения различных типов «иметь» и не приводят к потере данных, неверная интерпретацию битовых шаблонов или повреждение памяти.  Программа, которая никогда не явно или неявно преобразует значения из одного типа в другой является типобезопасным по определению.  Однако преобразование типов, даже небезопасные преобразования, иногда не требуются.  Например, можно сохранить результат операции с плавающей запятой в переменной типа `int`, или можно передать значение в неподписанном `int` с функцией, которая принимает со `int`.  Оба примерах показаны небезопасные преобразования, поскольку они могут привести к потере данных или переинтерпретацию значение.  
  
 Если компилятор обнаруживает опасное преобразование, он проблемы или ошибку или предупреждение.  Ошибка компиляции останавливается; предупреждение компиляция позволяет продолжать отображаться только на возможную ошибку в коде.  Однако даже если программа компилируется без предупреждений, она по\-прежнему может содержать код, приводит к неявных преобразований типов, приводящих к неверным результатам.  Ошибки типа также могут быть введены явными преобразованиями, или приведениями, в коде.  
  
## Неявные преобразования типов  
 Если выражение содержит операнды различных встроенных типов, и никакие явные приведения отсутствуют, компилятор использует встроенную *стандартные преобразования* для преобразования одного из операторов, чтобы типы совпадают.  Компилятор пытается преобразования в чёткой последовательности до тех пор, пока он не будет успешен.  Если выбранное преобразование повышение, компилятор не выдает предупреждение.  Если преобразование narrowing, компилятор выдает предупреждение о возможной потере данных.  Фактически, происходит потеря данных зависит от используемых фактических значений, но рекомендуется рассматривает предупреждения как ошибки.  Если пользовательский тип включен, компилятор пытается использовать преобразования, определенных в определении класса.  Если не удается найти приемлемое преобразование, компилятор выдает ошибку и не компилируют программы.  Дополнительные сведения о правила, управляющие стандартными преобразованиями, см. в разделе [Стандартные преобразования](../cpp/standard-conversions.md).  Определенное пользователем преобразование Дополнительные сведения о см. в разделе [Заданные пользователем преобразования](../dotnet/user-defined-conversions-cpp-cli.md).  
  
### Расширяющие преобразования \(повышение\)  
 В расширяющем преобразовании, значение в меньшей переменной присвоено большей переменной без потери данных.  Поскольку расширяющие преобразования всегда безопасны, компилятор выполняет их вмешательства пользователя не выдает предупреждений.  Следующие преобразования расширяющие преобразования.  
  
|Исходный тип|Целевой тип|  
|------------------|-----------------|  
|Целочисленный тип любого отложенной подписи или удаленный исключает `long long` или `__int64`|`double`|  
|`bool` или `char`|Любой другой встроенный тип|  
|`short` или `wchar_t`|`int`, `long`, `long long`|  
|`int`, `long`|`long long`|  
|`float`|`double`|  
  
### Сужающие преобразования приведение \(\)  
 Компилятор выполняет сужающие преобразования неявно, но он предупреждает о о потенциальной потере данных.  Сделайте эти предупреждения очень серьезно.  Если отсутствия потеря данных не происходит, поскольку значения в большой переменной всегда будут адаптация на небольшой переменную, а затем добавьте явное приведение, что компилятор не выводит предупреждение.  Если вы не уверены в том, что преобразование безопасно, добавьте в код определенный тип проверки среды выполнения обработки возможная потеря данных так, чтобы оно не вызовет программу привести к неверным результатам.  Для предложений об обработке этого сценария см. в разделе [Практическое руководство. Дескриптор суживая преобразования \(C\+\+\)](http://msdn.microsoft.com/ru-ru/e483237e-501e-4a12-ac24-51526f6ddeaa).  
  
 Любое преобразования из типа с плавающей запятой в целочисленный тип, поскольку сужающее преобразование отменяется и потеря дробную часть значение с плавающей запятой  
  
 В следующем примере кода показаны некоторые неявные сужающие преобразования и предупреждения компилятора подобные проблемы для них.  
  
```cpp  
  
int i = INT_MAX + 1; //warning C4307:'+':integral constant overflow  
wchar_t wch = 'A'; //OK  
char c = wch; // warning C4244:'initializing':conversion from 'wchar_t'  
              // to 'char', possible loss of data  
unsigned char c2 = 0xfffe; //warning C4305:'initializing':truncation from  
                           // 'int' to 'unsigned char'  
int j = 1.9f; // warning C4244:'initializing':conversion from 'float' to  
              // 'int', possible loss of data  
int k = 7.7; // warning C4244:'initializing':conversion from 'double' to  
             // 'int', possible loss of data  
  
```  
  
### Подписанный — неподписанных преобразования  
 Подписанный целочисленного типа и его эквивалент unsigned всегда одного размера, но они отличаются интерпретируется как битовый шаблон для преобразования значения.  В следующем примере кода показано, что происходит, когда тот же битовый шаблон интерпретируется как значение со знаком и в виде значения.  Битовый шаблон, хранящиеся в обоих `num` и `num2` никогда не меняется, в котором показано на предыдущем рисунке.  
  
```cpp  
  
using namespace std;  
unsigned short num = numeric_limits<unsigned short>::max(); // #include <limits>  
short num2 = num;  
cout << "unsigned val = " << num << " signed val = " << num2 << endl;  
// Prints: unsigned val = 65535 signed val = -1  
  
// Go the other way.  
num2 = -1;  
num = num2;  
cout << "unsigned val = " << num << " signed val = " << num2 << endl;  
// Prints: unsigned val = 65535 signed val = -1  
  
```  
  
 Обратите внимание, что значения reinterpreted в обоих направлениях.  Если программа предоставляет нечетные, в которых знак значения из перевернутой, что ожидался найдите неявные преобразования между подписанными и удаленными подпись целыми типами.  В следующем примере результат выражения \(от 0 до 1\) будет неявно преобразовано из `int` в `unsigned int` при его, хранящихся в `num`.  В этом случае битовый шаблон, reinterpreted.  
  
```cpp  
  
unsigned int u3 = 0 - 1;  
cout << u3 << endl; // prints 4294967295  
  
```  
  
 Компилятор не рассматривается неявных преобразованиях между подписанными и удаленными подпись целыми типами.  Поэтому рекомендуется избегать подписывать\-к\- удаленных подпись преобразований полностью.  Если не удается избежать их, добавьте в код проверки среды выполнения, чтобы определить, является ли преобразованное значение больше или равно нулю и меньше или равно максимальному значению типа со знаком.  Значения в этом диапазоне перемещают из подписанный является unsigned \(без знака\) или из неподписанного целое значение, не reinterpreted.  
  
### Преобразования указателей  
 Во многих выражений, а. массив в стиле языка C. неявно преобразованы в указатель на первый элемент массива и константы преобразования могут произойти в автоматическом режиме.  Хотя удобен, но также потенциально подвержено ошибкам.  Например, в следующем примере кода, разработанный поведением безумным, а также он будет компилироваться в Visual C\+\+ и дает «p».  Во\-первых, литерал строковой константы «справки» выполняется в `char*`, указывающей на первый элемент массива; затем этот указатель инкрементирован 3 элементами, чтобы оно теперь укажет к последнему элементу «p».  
  
```cpp  
  
char* s = "Help" + 3;  
  
```  
  
## Явные преобразования \(приведения\)  
 С помощью операции приведения, можно указать компилятору преобразования значения одного типа в другой тип.  Компилятор создаст ошибку в некоторых случаях, если 2 типа полностью являются несвязанными, но в других случаях он не вызывает ошибку, даже если операция не является типобезопасным.  Использовать осторожно, так как любое преобразование одного типа в другой потенциальный источник ошибки программы.  Однако иногда приведения необходимо, и не все приведения также небезопасными.  Одно эффективное использование приведения, когда код выполняет сужающее преобразование и известно, что преобразование не вызывает программу привести к неверным результатам.  Фактически, это сообщает компилятору, что известно, что необходимо сделать и остановки докучать с предупреждениями о них.  Использовать другое приведение из указатель\-к\- производного класса в класс указатель\-к\- базы данных.  Использовать другое представление об `const`\- мыс переменной, чтобы передать его в функцию, для которой требуется без аргумента `const`.  Большинство этих операций приведения включает некоторый риск.  
  
 В стиле программирования C\#, один оператор приведения типов в стиле используется для всех типов преобразований.  
  
```cpp  
  
(int) x; // old-style cast, old-style syntax  
int(x); // old-style cast, functional syntax  
  
```  
  
 Оператор приведения типов в стиле идентичен оператору вызова \(\) и поэтому небросок в коде и делать, чтобы быть пропущены.  Оба плохи, поскольку они трудно распознавать краткий обзор или поиск, и они несхожи достаточно, чтобы вызывать любое сочетание `static`, `const` и `reinterpret_cast`.  Вычисления, что прежнее фактически выполняет приведение может быть нелегко и подвержено ошибкам.  Для всех этих причин, если приведение не требуется, рекомендуется использовать один из следующих операторов приведения типа C\+\+, в некоторых случаях более типобезопасный и, выражающий гораздо более явно задавать цель:  
  
-   `static_cast`, для преобразований, проверяются только во время компиляции.  `static_cast` возвращает ошибку, если компилятор обнаруживает, что при попытке приведения между типами, которые полностью несовместимы.  Можно также использовать его приведение между базой указатель\-к\- и указатель\-к\- влево, но компилятор не сможет говоря, будут ли эти преобразования могут безопасно во время выполнения.  
  
    ```cpp  
  
    double d = 1.58947;  
    int i = d;  // warning C4244 possible loss of data  
    int j = static_cast<int>(d);       // No warning.  
    string s = static_cast<string>(d); // Error C2440:cannot convert from  
                                       // double to std:string  
  
    // No error but not necessarily safe.  
    Base* b = new Base();  
    Derived* d2 = static_cast<Derived*>(b);  
  
    ```  
  
     Дополнительные сведения см. в разделе [static\_cast](../cpp/static-cast-operator.md).  
  
-   `dynamic_cast`, для безопасными, выполнение\- проверило приведения указатель\-к\- базы в указатель\-к\- влево.  `dynamic_cast` более безопасным, чем `static_cast` для образований производных типов, но проверка среды выполнения создает некоторых дополнительных ресурсов.  
  
    ```cpp  
  
    Base* b = new Base();  
  
    // Run-time check to determine whether b is actually a Derived*  
    Derived* d3 = dynamic_cast<Derived*>(b);  
  
    // If b was originally a Derived*, then d3 is a valid pointer.  
    if(d3)  
    {  
       // Safe to call Derived method.  
       cout << d3->DoSomethingMore() << endl;  
    }  
    else  
    {  
       // Run-time check failed.  
       cout << "d3 is null" << endl;  
    }  
  
    //Output: d3 is null;  
  
    ```  
  
     Дополнительные сведения см. в разделе [dynamic\_cast](../cpp/dynamic-cast-operator.md).  
  
-   `const_cast`, для приведения исчезает `const`\- мыс переменной или преобразования, переменная `const`, чтобы быть `const`.  Что отсутствует `const`\-ство с помощью этого оператора, как подвержено ошибкам, который используется приведение в стиле C, за исключением того, что с `const-cast`, скорее всего, выполнить приведение случайным образом.  Иногда необходимо привести исчезает `const`\- мыс переменной, например, для передачи переменную `const` с функцией, которая принимает параметр,`const`.  Следующий пример показывает, как это сделать.  
  
    ```cpp  
  
    void Func(double& d) { ... }  
    void ConstCast()  
    {  
       const double pi = 3.14;  
       Func(const_cast<double&>(pi)); //No error.  
    }  
  
    ```  
  
     Дополнительные сведения см. в разделе [const\_cast](../Topic/const_cast%20Operator.md).  
  
-   `reinterpret_cast`, для преобразований между типами, например самостоятельными `pointer` в `int`.  
  
    > [!NOTE]
    >  Этот оператор приведения типов не используется так часто, как другие и не обязательно будет будет переносимым в другие компиляторы.  
  
     В следующем примере показано, как `reinterpret_cast` отличается от `static_cast`.  
  
    ```cpp  
  
    const char* str = "hello";  
    int i = static_cast<int>(str);//error C2440: 'static_cast' : cannot  
                                  // convert from 'const char *' to 'int'  
    int j = (int)str; // C-style cast. Did the programmer really intend  
                      // to do this?  
    int k = reinterpret_cast<int>(str);// Programming intent is clear.  
                                       // However, it is not 64-bit safe.  
  
    ```  
  
     Для получения дополнительной информации см. [Оператор reinterpret\_cast](../cpp/reinterpret-cast-operator.md).  
  
## См. также  
 [Тип системы C\+\+](../Topic/C++%20Type%20System%20\(Modern%20C++\).md)   
 [Возвращение к C\+\+](../Topic/Welcome%20Back%20to%20C++%20\(Modern%20C++\).md)   
 [Справочник по языку C\+\+](../cpp/cpp-language-reference.md)   
 [Стандартная библиотека C\+\+](../standard-library/cpp-standard-library-reference.md)