---
title: Преобразования типов и строгую типизацию (современный C++) | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-language
ms.topic: conceptual
dev_langs:
- C++
ms.assetid: 629b361a-2ce1-4700-8b5d-ab4f57b245d5
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 13dabba7b7cfc769d91471c2dfc6f92f1b414996
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
ms.locfileid: "32424780"
---
# <a name="type-conversions-and-type-safety-modern-c"></a>Преобразования типов и безопасность типов (современный C++)
В этом документе определяет распространенных проблем преобразования типа и описывает, как их избежать в коде C++.  
  
 При написании программы на языке C++, важно убедитесь, что он является типобезопасным. Это означает, что каждой переменной, аргумента функции и функции возвращают значение сохраняется допустимые виды данных, и что операции, включающие значения разных типов «смысла» и не привести к потере данных, неверной интерпретации битовых шаблонов, или повреждение памяти. Программа, которая никогда не явно или неявно преобразует значения из одного типа в другой является строго типизированным по определению. Тем не менее, преобразования типов, включая небезопасные преобразования, иногда требуются. Например, может потребоваться сохранить результат с плавающей точки операции в переменной типа `int`, или, возможно, потребуется передать значение без знака в `int` функции, которая принимает со знаком `int`. В обоих примерах иллюстрируют небезопасные преобразования, так как они могут привести к потере данных или повторной интерпретации значения.  
  
 Когда компилятор обнаруживает небезопасное преобразование, он выдает ошибку или предупреждение. Ошибка останавливает компиляции; Предупреждение позволяет компиляции продолжить, но указывает на возможную ошибку в коде. Тем не менее даже если программа компилируется без предупреждения, он по-прежнему может содержать код, который приводит к неявного преобразования типов, выдавать неверные результаты. Тип ошибок может также быть вызвана путем явного преобразования или приведения типов в коде.  
  
## <a name="implicit-type-conversions"></a>Неявное преобразование типов  
 Если выражение содержит различные встроенные типы операндов не явные приведения присутствуют, компилятор использует встроенные *стандартные преобразования* для преобразования одного из операндов, чтобы типы совпадают. Компилятор пытается преобразований в четко определенных последовательности до достижения успеха. Если выбранного преобразования рекламной акции, компилятор выдаст предупреждение. Если сужающее преобразование, компилятор выдает предупреждение о возможной потере данных. Происходит ли потеря фактических данных зависит от фактических значений участвующих, но рекомендуется, чтобы считать это предупреждение как ошибку. Если участвует определяемого пользователем типа, компилятор пытается использовать преобразования, которые указаны в определении класса. Если не удается найти приемлемое преобразование, компилятор выдает ошибку и не компилируется программа. Дополнительные сведения о правилах, которые управляют стандартные преобразования см. в разделе [стандартные преобразования](../cpp/standard-conversions.md). Дополнительные сведения о пользовательских преобразований см. в разделе [пользовательских преобразований (C + +/ CLI)](../dotnet/user-defined-conversions-cpp-cli.md).  
  
### <a name="widening-conversions-promotion"></a>Расширяющие преобразования (повышение уровня)  
 В расширяющего преобразования значение в переменной меньшего размера, присваивается переменной большего размера без потери данных. Так как расширяющие преобразования всегда безопасно, компилятор выполняет их без вмешательства пользователя, а не выдает предупреждения. Следующие преобразования расширяющие преобразования.  
  
|Исходный тип|Кому|  
|----------|--------|  
|Все подписанные или не подписанные целочисленного типа, за исключением `long long` или `__int64`|`double`|  
|`bool` или `char`|Встроенный тип|  
|`short` или `wchar_t`|`int`, `long`, `long long`|  
|`int`, `long`|`long long`|  
|`float`|`double`|  
  
### <a name="narrowing-conversions-coercion"></a>Сужающие преобразования (приведения)  
 Компилятор выполняет сужающего преобразования неявно, но выводится предупреждение о возможной потере данных. Эти предупреждения занять очень серьезно. Если вы уверены, что потери данных будет возникать, если значения в переменной большего всегда помещается в переменной меньше, добавьте явное приведение, чтобы компилятор больше не будет выдано предупреждение. Если точно не известно, что преобразование безопасна, добавьте в код какого-либо вида проверки среды выполнения для обработки потери данных, чтобы он не вызывает программу вырабатывать неверные результаты. 
  
 Какие-либо преобразования с плавающей точки тип в целочисленный тип является сужающим преобразованием, так как дробной части числа с плавающей запятой значение удаляется и теряются.  
  
 В следующем примере кода показаны некоторые неявные сужающие преобразования, а также предупреждений, которые компилятор создает для них.  
  
```cpp  
int i = INT_MAX + 1; //warning C4307:'+':integral constant overflow  
wchar_t wch = 'A'; //OK  
char c = wch; // warning C4244:'initializing':conversion from 'wchar_t'  
              // to 'char', possible loss of data  
unsigned char c2 = 0xfffe; //warning C4305:'initializing':truncation from  
                           // 'int' to 'unsigned char'  
int j = 1.9f; // warning C4244:'initializing':conversion from 'float' to  
              // 'int', possible loss of data  
int k = 7.7; // warning C4244:'initializing':conversion from 'double' to  
             // 'int', possible loss of data  
```  
  
### <a name="signed---unsigned-conversions"></a>Подписано - преобразования без знака  
 Целочисленным типом со знаком и без знака аналог всегда имеют тот же размер, но они различаются интерпретацию битовый шаблон для преобразования значения. В следующем примере кода показано, что произойдет, если тот же битовый шаблон интерпретируется как значение со знаком и как значение без знака. Битовый шаблон, хранимые в обоих `num` и `num2` никогда не меняется с показанной на предыдущем рисунке.  
  
```cpp  
using namespace std;  
unsigned short num = numeric_limits<unsigned short>::max(); // #include <limits>  
short num2 = num;  
cout << "unsigned val = " << num << " signed val = " << num2 << endl;  
// Prints: unsigned val = 65535 signed val = -1  
  
// Go the other way.  
num2 = -1;  
num = num2;  
cout << "unsigned val = " << num << " signed val = " << num2 << endl;  
// Prints: unsigned val = 65535 signed val = -1  
  
```  
  
 Обратите внимание, что значения являются интерпретировать в обоих направлениях. Если программа создает нечетное результаты, в которых кажется знак значения инвертированы по сравнению с ожидаемыми, найдите неявные преобразования целочисленных типов со знаком и без знака. В следующем примере результат выражения (0 - 1) неявное преобразование из `int` для `unsigned int` когда он хранится в `num`. В этом случае битовый шаблон повторной интерпретации.  
  
```cpp  
unsigned int u3 = 0 - 1;  
cout << u3 << endl; // prints 4294967295  
  
```  
  
 Компилятор не выдает предупреждения о неявных преобразованиях между целочисленных типов со знаком и без знака. Таким образом рекомендуется полностью избежать со знаком для без преобразования. Если их не удается избежать, добавьте в код проверку среды выполнения, чтобы определить, является ли преобразуемое значение больше или равно нулю и меньше или равно максимальное значение в тип со знаком. Значения в этом диапазоне будут перенесены из со знаком в числа без знака или из чисел без знака для подписанных без интерпретировать.  
  
### <a name="pointer-conversions"></a>Преобразования указателей  
 В многие выражения в массив в стиле языка C неявно преобразуется в указатель на первый элемент в массиве и постоянное преобразование может произойти автоматически. Несмотря на то, что это удобно, он потенциально ненадежным. Например в следующем примере кода плохо спроектированные кажется бессмысленные и еще будет компилироваться в Visual C++ и выдает результат «p». Во-первых, константой строковый литерал «Help» преобразуется в `char*` , указывающий на первый элемент массива; данный указатель затем увеличивается с тремя элементами, чтобы он теперь указывает на последний элемент «p».  
  
```cpp  
char* s = "Help" + 3;  
  
```  
  
## <a name="explicit-conversions-casts"></a>Явные преобразования (приведения)  
 С помощью операции приведения, можно указать компилятору, что для преобразования значения одного типа в другой тип. Компилятор создает ошибку, в некоторых случаях, если два типа не полностью связаны, но в других случаях он не возникнет ошибка даже, если операция не является строго типизированным. Только в случае необходимости используйте приведения, поскольку преобразование из одного типа в другой возможный источник ошибки в программе. Тем не менее иногда требуются приведения и приведения типов не все одинаково опасны. Действующие приведения к типу применяется при сужающего преобразования выполняются кодом и вы знаете, что преобразование не вызывает программу вырабатывать неверные результаты. По сути, это сообщает компилятору, что вы знаете, что делает и остановки беспокоить вы с предупреждениями о нем. Другим примером использования — преобразование из указателя на производный класс в указатель на базовый класс. Кроме можно использовать для снятия `const`- характеристики переменную для ее передачи в функцию, которая не требует -`const` аргумент. Большинство этих операций приведения включают в себя риску.  
  
 В C-стиль программирования, тот же оператор приведение в стиле C используется для всех видов приведения.  
  
```cpp  
(int) x; // old-style cast, old-style syntax  
int(x); // old-style cast, functional syntax  
  
```  
  
 Оператор C-стиль приведения идентична оператор вызова (), поэтому inconspicuous в коде и просто пропускаться. Оба являются неправильный, так как они трудно распознавать на обзора или поиска, и они разрозненных, чтобы вызвать любую комбинацию `static`, `const`, и `reinterpret_cast`. Изучив приведения старого стиля фактически может быть сложным и ненадежным. По этим причинам при приведение не требуется, рекомендуется использовать один из следующих операторов C++ приведение, что в некоторых случаях значительно более строго типизированным и который гораздо более явно express программирования цель:  
  
-   `static_cast`, только для приведения, которые проверяются во время компиляции времени. `static_cast` Возвращает ошибку, если компилятор обнаруживает, что вы пытаетесь приведения между типами, которые не являются полностью совместимыми. Его также можно использовать для приведения между указатель на базовый и указателя на производный, но компилятор всегда не может определить, будет ли безопасный во время выполнения таких преобразований.  
  
    ```cpp  
    double d = 1.58947;  
    int i = d;  // warning C4244 possible loss of data  
    int j = static_cast<int>(d);       // No warning.  
    string s = static_cast<string>(d); // Error C2440:cannot convert from  
                                       // double to std:string  
  
    // No error but not necessarily safe.  
    Base* b = new Base();  
    Derived* d2 = static_cast<Derived*>(b);  
  
    ```  
  
     Дополнительные сведения см. в разделе [static_cast](../cpp/static-cast-operator.md).  
  
-   `dynamic_cast`, для приведения указателя на базовый указатель производные безопасный, проверки времени выполнения. Объект `dynamic_cast` является более безопасным, чем `static_cast` downcasts, но среда выполнения проверки влечет за собой дополнительные издержки.  
  
    ```cpp  
    Base* b = new Base();  
  
    // Run-time check to determine whether b is actually a Derived*  
    Derived* d3 = dynamic_cast<Derived*>(b);  
  
    // If b was originally a Derived*, then d3 is a valid pointer.  
    if(d3)  
    {  
       // Safe to call Derived method.  
       cout << d3->DoSomethingMore() << endl;  
    }  
    else  
    {  
       // Run-time check failed.  
       cout << "d3 is null" << endl;  
    }  
  
    //Output: d3 is null;  
  
    ```  
  
     Дополнительные сведения см. в разделе [dynamic_cast](../cpp/dynamic-cast-operator.md).  
  
-   `const_cast`, для приведение с `const`- характеристики переменной или преобразование не является -`const` переменную `const`. Приведение с `const`-характеристики при помощи данного оператора является просто как ошибкам как используется приведение, за исключением того, что при использовании в стиле `const-cast` вероятность случайного выполнять приведение. Иногда необходимо отбросить квалификатор `const`-характеристики переменную, например, для передачи `const` в функцию, которая принимает значение, отличное от`const` параметра. Следующий пример показывает, как это сделать.  
  
    ```cpp  
    void Func(double& d) { ... }  
    void ConstCast()  
    {  
       const double pi = 3.14;  
       Func(const_cast<double&>(pi)); //No error.  
    }  
  
    ```  
  
     Дополнительные сведения см. в разделе [const_cast](../cpp/const-cast-operator.md).  
  
-   `reinterpret_cast`, для приведения между несвязанных типов, таких как `pointer` для `int`.  
  
    > [!NOTE]
    >  Этот оператор cast используется не так часто, как другие, и он имеет не обязательно будут в другие компиляторы.  
  
     В следующем примере показано как `reinterpret_cast` отличается от `static_cast`.  
  
    ```cpp  
    const char* str = "hello";  
    int i = static_cast<int>(str);//error C2440: 'static_cast' : cannot  
                                  // convert from 'const char *' to 'int'  
    int j = (int)str; // C-style cast. Did the programmer really intend  
                      // to do this?  
    int k = reinterpret_cast<int>(str);// Programming intent is clear.  
                                       // However, it is not 64-bit safe.  
  
    ```  
  
     Дополнительные сведения см. в разделе [оператор reinterpret_cast](../cpp/reinterpret-cast-operator.md).  
  
## <a name="see-also"></a>См. также  
 [Тип системы C++](../cpp/cpp-type-system-modern-cpp.md)   
 [Возвращение к C++](../cpp/welcome-back-to-cpp-modern-cpp.md)   
 [Справочник по языку C++](../cpp/cpp-language-reference.md)   
 [Стандартная библиотека C++](../standard-library/cpp-standard-library-reference.md)