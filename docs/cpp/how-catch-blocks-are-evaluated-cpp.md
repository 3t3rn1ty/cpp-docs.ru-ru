---
title: "Как блоки Catch, вычисляется (C++) | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-language
ms.tgt_pltfrm: 
ms.topic: language-reference
dev_langs: C++
helpviewer_keywords:
- try-catch keyword [C++], catchable types
- catch keyword [C++], types of catch handlers
- C++ exception handling, catch handlers
- exception handling, catching and deleting exceptions
- types [C++], exception handling
ms.assetid: 202dbf07-8ace-4b3b-b3ae-4b45c275e0b4
caps.latest.revision: "7"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: 744f75f86fd7d3e2ca2a2545a7914f923c4454b7
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="how-catch-blocks-are-evaluated-c"></a>Проверка блоков Catch (C++)
C++ позволяет создавать исключения любого типа, хотя обычно рекомендуется создавать типы, производные от std::exception. Может быть перехвачено исключение C++ **перехватывать** обработчик, который указывает тот же тип, как исключение или обработчиком, который способен перехватывать любой тип исключения.  
  
 Если созданное исключение имеет тип класса, у которого имеется один или несколько базовых классов, то его могут перехватывать обработчики, которые принимают базовые классы (и ссылки на базовые классы) этого типа исключения. Обратите внимание, что если исключение перехватывается по ссылке, то оно привязывается к самому объекту исключения; в противном случае обрабатывается его копия (как и в случае с аргументами функции).  
  
 При возникновении исключения оно может перехватываться следующие типы **перехватывать** обработчиков:  
  
-   Обработчик, который может принимать любой тип данных (синтаксис с многоточием).  
  
-   Обработчик, который принимает совпадает с типом объекта исключения; так как он представляет собой копию **const** и `volatile` модификаторы учитываются.  
  
-   Обработчик, который принимает ссылку на тот же тип, что и у объекта исключения.  
  
-   Обработчик, который принимает ссылку на **const** или `volatile` форме совпадает с типом объекта исключения.  
  
-   Обработчик, который принимает базовый класс того же типа, что и объект исключения; так как он представляет собой копию **const** и `volatile` модификаторы учитываются. **Перехватывать** обработчик для базового класса не должен предшествовать **перехватывать** обработчиком для производного класса.  
  
-   Обработчик, который принимает ссылку на базовый класс того же типа, что и у объекта исключения.  
  
-   Обработчик, который принимает ссылку на **const** или `volatile` формы базового класса того же типа, как объект исключения.  
  
-   Обработчик, который принимает указатель, в который можно преобразовать созданный объект указателя при помощи стандартных правил преобразования указателей.  
  
 Порядок, в котором **перехватывать** располагаются обработчики имеет большое значение, поскольку обработчики для данного **повторите** блок проверяются в порядке их следования. Например, ошибкой будет поместить обработчик для базового класса перед обработчиком для производного класса. После соответствующего **перехватывать** обработчик найден, последующие обработчики не проверяются. В результате многоточие **перехватывать** обработчик должен быть последним обработчиком для его **повторите** блока. Пример:  
  
```  
// ...  
try  
{  
    // ...  
}  
catch( ... )  
{  
    // Handle exception here.  
}  
// Error: the next two handlers are never examined.  
catch( const char * str )  
{  
    cout << "Caught exception: " << str << endl;  
}  
catch( CExcptClass E )  
{  
    // Handle CExcptClass exception here.  
}  
```  
  
 В этом примере многоточие **перехватывать** обработчик — будет проверен только обработчик.  
  
## <a name="see-also"></a>См. также  
 [Обработка исключений С++](../cpp/cpp-exception-handling.md)