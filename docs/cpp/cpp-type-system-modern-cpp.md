---
title: Тип системы C++ (современный C++) | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-language
ms.topic: conceptual
dev_langs:
- C++
ms.assetid: 553c0ed6-77c4-43e9-87b1-c903eec53e80
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 82c017b7048c8b62f58068d22b8efefd72f31d4f
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
---
# <a name="c-type-system-modern-c"></a>Тип системы C++ (современный C++)
Понятие *тип* очень важно в C++. Каждая переменная, аргумент функции и возвращаемое значение функции должны иметь тип, чтобы их можно было скомпилировать. Кроме того, перед вычислением каждого выражения (включая литеральные значения) компилятор неявно назначает ему тип. Некоторые примеры типов `int` для хранения целых значений `double` для хранения значений с плавающей запятой (также известный как *скалярные* типы данных), или класс стандартной библиотеки [std::basic_string](../standard-library/basic-string-class.md) для хранения текста. Можно создать собственный тип, определив `class` или `struct`. Тип определяет объем памяти, выделяемой для переменной (или результата выражения), типы значений, которые могут храниться в этой переменной, способ интерпретации значений (например, битовые шаблоны), и операции, допустимые с переменной. Эта статья содержит неформальный обзор основных особенностей системы типов C++.  
  
## <a name="terminology"></a>Терминология  
 **Переменной**: символическое имя некоторого количества данных, чтобы имя можно использовать для доступа к данным, он ссылается на во всей области кода, в котором он определен. В C++ *переменной* обычно используется для обращения к экземплярам скалярных типов данных, тогда как экземпляры других типов обычно называются *объектов*.  
  
 **Объект**: для простоты и согласованности в этой статье используется термин *объекта* ссылалась на любом экземпляре класса или структуры, а при использовании в общем смысле включает все типы, числе скалярные переменные.  
  
 **Тип POD** (обычные старые данные): Эта Неофициальная категория типов данных в C++ относится к типам, которые являются скалярными (см. в разделе Основные типы), или *классам POD*. Класс POD не содержит статических данных-членов, которые не являются типами POD, а также не содержит пользовательских конструкторов, пользовательских деструкторов или пользовательских операторов присваивания. Кроме того, класс POD не имеет виртуальных функций, базового класса и ни закрытых, ни защищенных нестатических данных-членов. Типы POD часто используются для внешнего обмена данными, например с модулем, написанным на языке С (в котором имеются только типы POD).  
  
## <a name="specifying-variable-and-function-types"></a>Указание типов переменных и функций  
 C++ — *со строго типизированными* языка и при этом *статически типизированные*; каждый объект имеет тип и, тип никогда не изменяется (не следует путать со статическими объектами данных).   
**При объявлении переменной** в коде, необходимо либо задать ее тип, либо использовать `auto` ключевое слово, чтобы компилятор определил тип на основе инициализатора.   
**При объявлении функции** в коде, необходимо указать тип каждого аргумента, а его возвращаемое значение или `void` , если значение не возвращается функцией. Исключением является использование шаблонов функции, которые допускают аргументы произвольных типов.  
  
 После объявления переменной изменить ее тип впоследствии уже невозможно. Однако можно скопировать значения переменной или возвращаемое значение функции в другую переменную другого типа. Такие операции называются *преобразования типов*, они иногда необходимы, но также являются потенциальными источниками потери данных или некорректности.  
  
 При объявлении переменной типа POD настоятельно рекомендуется инициализировать ее, т. е. указать начальное значение. Пока переменная не инициализирована, она имеет "мусорное" значение, определяемое значениями битов, которые ранее были установлены в этом месте памяти. Необходимо учитывать эту особенность языка C++, особенно при переходе с другого языка, который обрабатывает инициализацию автоматически. При объявлении переменной типа, не являющегося классом POD, инициализация обрабатывается конструктором.  
  
 В следующем примере показано несколько простых объявлений переменных с небольшим описанием для каждого объявления. В примере также показано, как компилятор использует сведения о типе, чтобы разрешить или запретить некоторые последующие операции с переменной.  
  
```cpp  
  
int result = 0;              // Declare and initialize an integer.  
double coefficient = 10.8;   // Declare and initialize a floating   
                             // point value.  
auto name = "Lady G.";       // Declare a variable and let compiler   
                             // deduce the type.  
auto address;                // error. Compiler cannot deduce a type   
                             // without an intializing value.  
age = 12;                    // error. Variable declaration must  
                             // specify a type or use auto!  
result = "Kenny G.";         // error. Can’t assign text to an int.  
string result = "zero";      // error. Can’t redefine a variable with  
                             // new type.  
int maxValue;                // Not recommended! maxValue contains   
                             // garbage bits until it is initialized.  
  
```  
  
## <a name="fundamental-built-in-types"></a>Базовые (встроенные) типы  
 В отличие от некоторых других языков, в C++ нет универсального базового типа, от которого наследуются все остальные типы. Реализация языка Visual C++ включает множество *базовые типы*, также известных как *встроенные типы*. К ним относятся числовые типы, такие как `int`, `double`, `long`, `bool`, а также типы `char` и `wchar_t` для символов ASCII и символов Юникода, соответственно. Большинство базовых типов (за исключением `bool`, `double`, `wchar_t` и связанных типов) имеют беззнаковые версии с другим диапазоном значений, которые можно хранить в переменной. Например, тип `int`, в котором хранится 32-разрядное целое число со знаком, может представлять значение от -2 147 483 648 до 2 147 483 647. Тип `unsigned int`, который также хранится в виде 32-разрядного значения, может хранить значения от 0 до 4 294 967 295. Общее количество возможных значений в каждом случае одинаково, отличается только диапазон.  
  
 Базовые типы распознаются компилятором, в котором предусмотрены встроенные правила, управляющие операциями, выполняемыми с такими типами, а также преобразованием в другие базовые типы. Полный список встроенных типов и их размер и числовые ограничения см. в разделе [базовые типы](../cpp/fundamental-types-cpp.md).  
  
 На следующем рисунке показаны относительные размеры встроенных типов:  
  
 ![Размер в байтах построен&#45;в типах](../cpp/media/built-intypesizes.png "Built-inTYpeSizes")  
  
 В следующей таблице перечислены наиболее часто используемые базовые типы:  
  
|Тип|Размер|Комментарий|  
|----------|----------|-------------|  
|int|4 байта|Выбор по умолчанию для целочисленных значений.|  
|double|8 байт|Выбор по умолчанию для значений с плавающей запятой.|  
|bool|1 байт|Представляет значения, которые могут быть или true, или false.|  
|char|1 байт|Используйте для символов ASCII в старых строках в стиле C или в объектах std::string, которые никогда не будут преобразовываться в Юникод.|  
|wchar_t|2 байта|Представляет "расширенные" символы, которые могут быть представлены в формате Юникод (UTF-16 в Windows, в других операционных системах возможно другое представление). Это символьный тип, используемый в строках типа `std::wstring`.|  
|unsigned char|1 байт|В C++ нет встроенного типа `byte`.  Для представления байтовых значений используйте тип unsigned char.|  
|unsigned int|4 байта|Вариант по умолчанию для битовых флагов.|  
|длинное длинное|8 байт|Представляет очень большие целочисленные значения.|  
  
## <a name="the-void-type"></a>Тип void  
 Тип `void` представляет собой особый тип; невозможно объявить переменную типа `void`, но можно объявить переменную типа `void *` (указатель на тип `void`), которая иногда требуется для выделения низкоуровневой (нетипизированной )памяти. Однако указатели на тип `void` не являются типобезопасными и обычно настоятельно не рекомендуются для использования в современном С++. В объявлении функции возвращаемое значение `void` означает, что функция не возвращает никакого значения; это распространенное и допустимое применение типа `void`. Хотя язык С требовал, чтобы в функции без параметров в списке параметров объявлялся тип `void` (например, `fou(void)`), в современном С++ это не рекомендуется и следует использовать объявление `fou()`. Дополнительные сведения см. в разделе [преобразования типов и строгую типизацию](../cpp/type-conversions-and-type-safety-modern-cpp.md).  
  
## <a name="const-type-qualifier"></a>Квалификатор типа const  
 Любой встроенный или пользовательский тип может квалифицироваться ключевым словом const. Кроме того, члены-функции могут иметь квалификатор `const` и даже перегрузку `const`. Значение типа `const` невозможно изменить после его инициализации.  
  
```cpp  
  
const double PI = 3.1415;  
PI = .75 //Error. Cannot modify const variable.  
  
```  
  
 Квалификатор `const` широко используется в объявлениях функций и переменных, при этом принцип "правильности константы" является важным принципом в C++; по существу это означает использование квалификатора `const` для исключения непреднамеренного изменения значений во время компиляции. Дополнительные сведения см. в разделе [const](../cpp/const-cpp.md).  
  
 Тип с квалификатором `const` отличается от своей "неконстантной" версии; например, тип `const int` — это отдельный тип, отличный от типа `int`. Можно использовать C++ `const_cast` оператор в редких случаях, когда необходимо отменить *константность* из переменной. Дополнительные сведения см. в разделе [преобразования типов и строгую типизацию](../cpp/type-conversions-and-type-safety-modern-cpp.md).  
  
## <a name="string-types"></a>Строковые типы  
 Строго говоря язык C++ не имеет встроенных строку типа; `char` и `wchar_t` хранения отдельных символов — необходимо объявить массива типов для аппроксимации строки, добавление завершающее значение null (например, ASCII `'\0'`) один элемент массива, за последним допустимым символом (также называется *Строки в стиле C*). Строки в стиле C требовали написания гораздо большего объема кода или использования внешних библиотек служебных функций. Однако в современном C++ имеются стандартные библиотечные типы `std::string` (для 8-разрядных символьных строк типа `char`) или `std::wstring` (для 16-разрядных символьных строк типа `wchar_t`). Эти контейнеры стандартной библиотеки C++ может рассматриваться как собственные строковые типы, так как они являются частью стандартной библиотеки, которые включаются в любой совместимой среде сборки C++. Просто используйте директиву `#include <string>`, чтобы эти типы были доступны в программе. (При использовании MFC или ATL также доступен класс CString, но он не является частью стандарта C++.) В современном языке C++ настоятельно не рекомендуется использовать массивы символов с завершающим значением NULL (вышеупомянутые строки в стиле C).  
  
## <a name="user-defined-types"></a>Пользовательские типы  
 При определении конструкции `class`, `struct`, `union` или `enum` она используется в остальной части кода, как если бы это был базовый тип. Он имеет известный размер в памяти, и в его отношении действуют определенные правила проверки во время компиляции и во время выполнения в течение срока использования программы. Основные различия между базовыми встроенными типами и пользовательскими типами указаны ниже:  
  
-   Компилятор не имеет встроенных сведений о пользовательском типе. При обнаружении определения во время компиляции, она узнает типа.  
  
-   Пользователь определяет, какие операции можно выполнять с типом и как его можно преобразовать в другие типы, задавая (через перегрузку) соответствующие операторы, либо в виде членов класса, либо в виде функций, не являющихся членами. Дополнительные сведения см. в разделе [перегрузка функций](function-overloading.md).  
  
-   Они не обязательно должны быть статически типизированы (правило, согласно которому тип объекта не изменяется). Через механизмы *наследования* и *полиморфизм*, переменная, объявленная как определяемый пользователем тип класса (называется экземпляр объекта класса) может иметь другой тип во время выполнения на время компиляции. Дополнительные сведения см. в разделе [Наследование](../cpp/inheritance-cpp.md).  
  
## <a name="pointer-types"></a>типы указателей;  
 Как и самые ранние версии языка C, язык C++ по-прежнему позволяет объявить переменную типа указателя с помощью специального декларатора `*` (звездочка). Тип указателя хранит адрес расположения в памяти, в котором хранится фактическое значение данных. В современном C++ они называются *необработанных указателей*и доступны только в коде осуществляется через специальные операторы `*` (звездочка) или `->` (дефис со знаком больше — чем). Это называется *разыменования*, и какой из них, которая используется зависит от разыменовываемого указатель на скаляр или указатель на член в объекте. Работа с типами указателя долгое время была одним из наиболее трудных и непонятных аспектов разработки программ на языках C и C++. В этом разделе приводятся некоторые факты и рекомендации, помогающие использовать необработанные указатели, если требуется, но в современном с ++ он больше не требуется (и рекомендуется) использовать необработанные указатели для владения объектом, связи с развитием [интеллектуального указателя](../cpp/smart-pointers-modern-cpp.md) () Подробнее см. в конце этого раздела). Все еще полезно и безопасно использовать необработанные указатели для отслеживания объектов, но если требуется использовать их для владения объектом, необходимо делать это с осторожностью и после тщательного анализа процедуры создания и уничтожения объектов, которые им принадлежат.  
  
 Первое, что необходимо знать, — это то, что при объявлении переменной необработанного указателя выделяется только память, необходимая для хранения адреса расположения памяти, на который будет ссылаться указатель при разыменовывании. Выделение памяти для самого значения данных (также называемый *резервное хранилище*) еще не выделен. Другими словами, объявив переменную необработанного указателя, вы создаете переменную адреса памяти, а не фактическую переменную данных. Разыменовывание переменной указателя до проверки того, что она содержит действительный адрес в резервном хранилище, приведет к неопределенному поведению (обычно неустранимой ошибке) программы. В следующем примере демонстрируется подобная ошибка:  
  
```cpp  
  
int* pNumber;       // Declare a pointer-to-int variable.  
*pNumber = 10;      // error. Although this may compile, it is  
                    // a serious error. We are dereferencing an  
                    // uninitialized pointer variable with no  
                    // allocated memory to point to.  
  
```  
  
 Пример разыменовывает тип указателя без выделения памяти для хранения фактических целочисленных данных или без выделенного допустимого адреса памяти. В следующем коде исправлены эти ошибки:  
  
```cpp  
  
    int number = 10;          // Declare and initialize a local integer  
                              // variable for data backing store.  
    int* pNumber = &number;   // Declare and initialize a local integer  
                              // pointer variable to a valid memory  
                              // address to that backing store.  
...  
    *pNumber = 41;            // Dereference and store a new value in   
                              // the memory pointed to by  
                              // pNumber, the integer variable called  
                              // "number". Note "number" was changed, not  
                              // "pNumber".  
  
```  
  
 В исправленном примере кода используется локальной память стека для создания резервного хранилища, на который указывает указатель `pNumber`. Базовый тип используется для простоты. На практике резервное хранилище для указателей — это большинство часто определяемые пользователем типы, динамически выделенной области памяти, называемой *кучи* (или *свободного хранилища*) с помощью `new` ключевое слово выражения (C-стиль программирования, более старый `malloc()` использовалась функция библиотеки времени выполнения C). После выделения памяти эти переменные, обычно называются объекты, особенно в том случае, если они основаны на определении класса. Память, выделенная с помощью оператора `new`, должна быть удалена соответствующим оператором `delete` (или, если она была выделена с помощью функции `malloc()`, функцией среды выполнения С `free()`).  
  
 Тем не менее, можно легко забыть удалить динамически выделенный объект, особенно в сложном коде, что приводит к ошибке ресурсов под названием *утечка памяти*. По этой причине в современном С++ настоятельно не рекомендуется использовать необработанные указатели. Почти всегда лучше создать необработанный указатель в [интеллектуального указателя](../cpp/smart-pointers-modern-cpp.md), который автоматически освобождает память при вызове его деструктора (когда код выходит из области интеллектуального указателя); с помощью интеллектуальных указателей вы практически исключается целый класс ошибок в программах с ++. В следующем примере предположим, что `MyClass` — это пользовательский тип, который имеет открытый метод `DoSomeWork();`  
  
```cpp  
  
void someFunction() {  
    unique_ptr<MyClass> pMc(new MyClass);  
    pMc->DoSomeWork();  
}  
  // No memory leak. Out-of-scope automatically calls the destructor  
  // for the unique_ptr, freeing the resource.  
  
```  
  
 Дополнительные сведения об интеллектуальных указателях см. в разделе [интеллектуальные указатели](../cpp/smart-pointers-modern-cpp.md).  
  
 Дополнительные сведения о преобразования указателей см. в разделе [преобразования типов и строгую типизацию](../cpp/type-conversions-and-type-safety-modern-cpp.md).  
  
 Дополнительные сведения об указателях см [указатели](../cpp/pointers-cpp.md).  
  
## <a name="windows-data-types"></a>Типы данных Windows  
 В классическом программировании Win32 на языке C и C++ для указания типов параметров и возвращаемых значений в большинстве функций используются специально предназначенные для Windows определения typedef и макросы #define (определенные в `windef.h`). Эти типы данных Windows большей части являются лишь специальными имена (псевдонимы), учитывая встроенные типы данных C/C++. Полный список этих определений типов и определений препроцессора. в разделе [типы данных Windows](http://msdn.microsoft.com/en-us/4553cafc-450e-4493-a4d4-cb6e2f274d46). Некоторые из этих определений typedef, например HRESULT и LCID, удобны и содержат полезные сведения. Другие, такие как INT, не имеют особого смысла и просто являются псевдонимами для базовых типов C++. Прочие типы данных Windows имеют имена, которые сохранились с эпохи программирования на языке C для 16-разрядных процессоров, и не имеют смысла или значения на современном оборудовании или в современных операционных системах. Существуют также специальными типами данных связанных с библиотекой среды выполнения Windows, в списке [среды выполнения Windows базовые типы данных](http://msdn.microsoft.com/en-us/b5735851-ec07-48c1-92b4-ca9f768096f6). В современном языке C++ в целом рекомендуется использовать базовые типы C++, за исключением случаев, когда тип Windows сообщает некоторые дополнительные сведения о том, как следует интерпретировать значение.  
  
## <a name="more-information"></a>Дополнительные сведения  
 Дополнительные сведения о системе типов C++ см. в следующих разделах.  
  
|||  
|-|-|  
|[Типы значений](../cpp/value-types-modern-cpp.md)|Описывает *типы значений* и проблемы, связанные с их использованием.|  
|[Преобразования типов и безопасность типов](../cpp/type-conversions-and-type-safety-modern-cpp.md)|Описание типовых проблем преобразования типов и способов их избежать.|  
  
## <a name="see-also"></a>См. также  
 [Возвращение к C++](../cpp/welcome-back-to-cpp-modern-cpp.md)   
 [Справочник по языку C++](../cpp/cpp-language-reference.md)   
 [Стандартная библиотека C++](../standard-library/cpp-standard-library-reference.md)
