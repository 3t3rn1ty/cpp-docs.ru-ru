---
title: Программа и компоновка (C++) | Документы Microsoft
ms.custom: ''
ms.date: 04/09/2018
ms.technology:
- cpp-language
ms.topic: language-reference
dev_langs:
- C++
ms.assetid: a6493ba0-24e2-4c89-956e-9da1dea660cb
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 4154f0951b46b1c8badc0224845d2881cc8ad573
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
ms.locfileid: "32421371"
---
# <a name="program-and-linkage--c"></a>Программа и компоновка (C++)

В программе на C++ каждый глобальных символов можно определить только один раз, даже если программа состоит из нескольких записей преобразования. Записи преобразования состоит в файле реализации (.cpp, .hpp, .cxx и т. д) и все заголовки, которые он содержит, прямо или косвенно. Программа состоит из одной или нескольких записей преобразования, связанных друг с другом. 

## <a name="linkage-vs-scope"></a>Компоновка и области

Понятие *компоновка* ссылается на видимость глобальные символы (например, переменных, имена типов и функции), в рамках программы в целом в записи преобразования. Понятие *область* относится к символам, которые объявлены внутри блока, таких как пространства имен, класса или тело функции. Такие символы видны только в пределах области действия, в котором они определены; Понятие компоновка не применяется к ним.

## <a name="external-vs-internal-linkage"></a>Внешние и внутренние связи

Non-const глобальные переменные и функции по умолчанию имеют внешнюю компоновку; они видимы из любой записи преобразования в программе. Это поведение можно переопределить путем явного объявления их в виде **статических** что ограничивает их отображения в той же записи преобразования, в котором они объявлены. Это значение **статических** отличается от его значения при применении к локальным переменным. Переменные, объявленные как **const** по умолчанию имеют внутреннюю компоновку.

## <a name="extern-constexpr-linkage"></a>Внешнюю компоновку constexpr

В более ранних версиях Visual Studio компилятор всегда было присвоено переменной внутренней компоновкой constexpr даже в том случае, когда переменная была помечена extern. В Visual Studio 2017 версии 15.5 новый параметр компилятора /Zc:externConstexpr обеспечивает правильное поведение, соответствующее стандартам. В конечном счете это будет поведением по умолчанию.

```cpp
extern constexpr int x = 10; //error LNK2005: "int const x" already defined
```

Если файл заголовка содержит constexpr переменной объявленного extern, она должна быть отмечена как **__declspec(selectany)** для выполнения правильно его повторяющихся объявлений вместе:

```cpp
extern constexpr __declspec(selectany) int x = 10;
```

## <a name="see-also"></a>См. также

 [Основные понятия](../cpp/basic-concepts-cpp.md)