---
title: "поток | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-language
ms.tgt_pltfrm: 
ms.topic: language-reference
f1_keywords: thread_cpp
dev_langs: C++
helpviewer_keywords:
- thread local storage (TLS)
- thread __declspec keyword
- TLS (thread local storage), compiler implementation
- __declspec keyword [C++], thread
ms.assetid: 667f2a77-6d1f-4b41-bee8-05e67324fab8
caps.latest.revision: "7"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: b26487e7f5f11bb32f418b438e9d0396b5854a91
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="thread"></a>thread

**Блок, относящийся только к системам Microsoft**  
**Поток** модификатор расширенного класса хранения используется для объявления локальной переменной потока. Портативный эквивалента в C ++ 11 и более поздних версий, используйте [thread_local](../cpp/storage-classes-cpp.md#thread_local) спецификатор класса хранения для создания переносимого кода. В Windows **thread_local** реализуется с помощью **__declspec(thread)**.

## <a name="syntax"></a>Синтаксис

```
__declspec( thread ) declarator
```

## <a name="remarks"></a>Примечания

Локальное хранилище потока (TLS) — это механизм, с помощью которого в каждом потоке многопоточного процесса выделяется хранилище для хранения данных определенного потока. В стандартных многопоточных программах данные совместно используются всеми потоками заданного процесса, в то время как локальное хранилище потоков является механизмом предоставления данных для конкретного потока. Обсуждение потоков см. в разделе [многопоточность](../parallel/multithreading-support-for-older-code-visual-cpp.md).

Объявления локальных переменных потока должны использовать [расширенный синтаксис атрибутов](../cpp/declspec.md) и `__declspec` ключевого слова with **поток** ключевое слово. В следующем примере кода показано, как объявлять целочисленную локальную переменную потока и инициализировать её некоторым значением:

```cpp
__declspec( thread ) int tls_i = 1;  
```

При использовании локальные переменные потока в библиотеках динамической загрузке, необходимо иметь в виду факторы, которые могут привести к локальной переменной потока для не удается правильно инициализировать:

1) Если переменная инициализируется с помощью вызова функции (включая конструкторы), эта функция будет вызываться только для потока, который вызвал двоичного файла или библиотеки DLL для загрузки в процесс, а также для этих потоков, в которых началось после загрузки двоичного файла или DLL. Функции инициализации не вызываются для любого другого потока, в котором уже выполняется при загрузке библиотеки DLL. Динамическая инициализация происходит вызов функции DllMain для DLL_THREAD_ATTACH, но она никогда не возвращает, сообщение, если библиотека DLL не в процессе, при запуске потока. 

2) Локальные переменные потока, статически инициализируются с помощью константы обычно правильность инициализации во всех потоках. Тем не менее начиная с декабря 2017 г. существует проблема известных соответствия в Microsoft C++ компилятора, при котором переменные constexpr получать динамические вместо статической инициализации.  
  
   Примечание: Обе эти проблемы ожидаются будет исправлено в будущих обновлений компилятора.


Кроме того необходимо соблюдать следующие правила при объявлении локальных объектов потока и переменных.

- Можно применить **поток** атрибут только для класса и объявлениях и определениях данных; **поток** не может использоваться в объявлениях или определениях функций.

- Можно указать **поток** атрибут только для элементов данных со статической длительностью хранения. Сюда входят глобальные объекты данных (оба **статических** и **extern**), локальные статические объекты и статические данные-члены классов. Нельзя объявлять автоматические объекты данных с **поток** атрибута.

- Необходимо использовать **поток** атрибута для объявления и определения локального объекта потока, в объявлении и определении выполняются ли в одном файле или в отдельных файлах.

- Нельзя использовать **поток** атрибут в качестве модификатора типа.

- Поскольку объявление объектов, которые используют **поток** разрешено, эти два примера семантически эквивалентны:

    ```cpp
    // declspec_thread_2.cpp
    // compile with: /LD
    __declspec( thread ) class B {
    public:
       int data;
    } BObject;   // BObject declared thread local.

    class B2 {
    public:
       int data;
    };
    __declspec( thread ) B2 BObject2;   // BObject2 declared thread local.
    ```

- В стандартном языке C разрешена инициализация объекта или переменной с помощью выражения, предусматривающего ссылку на себя, но только для объектов нестатической области памяти. Хотя в C++ обычно разрешена такая динамическая инициализация объекта выражениями с ссылкой на себя, такой тип инициализации не допускается в отношении локальных объектов потока. Пример:

    ```cpp
    // declspec_thread_3.cpp
    // compile with: /LD
    #define Thread __declspec( thread )
    int j = j;   // Okay in C++; C error
    Thread int tls_i = sizeof( tls_i );   // Okay in C and C++
    ```

     Обратите внимание, что **sizeof** выражение, включающее инициализируемый объект не является ссылкой на себя и является допустимым в C и C++.

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[__declspec](../cpp/declspec.md)  
[Ключевые слова](../cpp/keywords-cpp.md)  
[Локальное хранилище потока (TLS)](../parallel/thread-local-storage-tls.md)
