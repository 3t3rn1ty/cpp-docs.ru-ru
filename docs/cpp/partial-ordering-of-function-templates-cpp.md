---
title: "Частичное упорядочение шаблонов функций (C++) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "language-reference"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "частичное упорядочение шаблонов функций"
ms.assetid: 0c17347d-0e80-47ad-b5ac-046462d9dc73
caps.latest.revision: 9
caps.handback.revision: 9
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Частичное упорядочение шаблонов функций (C++)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Может быть доступно несколько шаблонов функций, соответствующих списку аргументов в вызове функции.  В C\+\+ определено частичное упорядочение шаблонов функции, что позволяет указать, какую функцию необходимо вызвать.  Упорядочение выполняется частично, поскольку может быть несколько шаблонов, которые считаются в равной мере специализированными.  
  
 Компилятор выбирает функцию наиболее специализированного шаблона среди всех возможных совпадений.  Например, если шаблон функции принимает тип **T**, и при этом доступен другой шаблон функции, принимающий тип **T\***, то версия с типом **T\*** считается более специализированной. Если аргумент относится к типу указателя, она будет предпочтительнее, чем универсальная версия с типом **T**, даже если обе они будут допустимыми совпадениями.  
  
 Чтобы определить, является ли один кандидатов — шаблонов функций — более специализированным, используйте следующую процедуру:  
  
1.  Рассмотрим два шаблона функции, T1 и T2.  
  
2.  Замените параметры в шаблоне T1 на гипотетический уникальный тип X.  
  
3.  Пользуясь списком параметров из шаблона T1, проверьте, является ли T2 допустимым шаблоном для этого списка параметров.  Любые неявные преобразования пропускайте.  
  
4.  Повторите ту же самую процедуру, поменяв шаблоны T1 и T2 местами.  
  
5.  Если список аргументов из одного шаблона будет допустимым для другого, но не наоборот, то первый шаблон считается менее специализированным, чем второй.  Если на предыдущем этапе оба шаблона позволили сформировать допустимые друг для друга аргументы, то они считаются в равной мере специализированными, и при попытке использовать их возникнет неоднозначный вызов.  
  
6.  При проведении процедуры руководствуйтесь следующими правилами:  
  
    1.  Шаблон для определенного типа является более специализированным, чем шаблон, принимающий аргумент универсального типа.  
  
    2.  Шаблон, принимающий только аргумент **T\***, является более специализированным, чем принимающий только аргумент **T**, так как гипотетический тип **X\*** является допустимым аргументом для аргумента шаблона **T**, однако **X** не является допустимым аргументом для аргумента шаблона **T\***.  
  
    3.  Шаблон, принимающий только аргумент **const T**, является более специализированным, чем принимающий только аргумент **T**, так как **const X** является допустимым аргументом для аргумента шаблона **T**, однако **X** не является допустимым аргументом для аргумента шаблона **const T**.  
  
    4.  Шаблон, принимающий только аргумент **const T\***, является более специализированным, чем принимающий только аргумент **T\***, так как гипотетический тип **const X\*** является допустимым аргументом для аргумента шаблона **T\***, однако **X\*** не является допустимым аргументом для аргумента шаблона **const T\***.  
  
7.  Следующий пример работает в Visual C\+\+ .NET 2003 в соответствии со стандартом.  
  
```  
// partial_ordering_of_function_templates.cpp  
// compile with: /EHsc  
#include <iostream>  
  
extern "C" int printf(const char*,...);  
template <class T> void f(T) {  
   printf_s("Less specialized function called\n");  
}  
  
template <class T> void f(T*) {  
   printf_s("More specialized function called\n");  
}  
  
template <class T> void f(const T*) {  
   printf_s("Even more specialized function for const T*\n");  
}  
  
int main() {  
   int i =0;  
   const int j = 0;  
   int *pi = &i;  
   const int *cpi = &j;  
  
   f(i);   // Calls less specialized function.  
   f(pi);  // Calls more specialized function.  
   f(cpi); // Calls even more specialized function.  
   // Without partial ordering, these calls would be ambiguous.  
}  
```  
  
### Output  
  
```  
Less specialized function called  
More specialized function called  
Even more specialized function for const T*  
```  
  
## См. также  
 [Шаблоны функций](../cpp/function-templates.md)