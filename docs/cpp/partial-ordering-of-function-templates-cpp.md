---
title: "Частичное Упорядочение шаблонов функций (C++) | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-language
ms.tgt_pltfrm: 
ms.topic: language-reference
dev_langs:
- C++
helpviewer_keywords:
- partial ordering of function templates
ms.assetid: 0c17347d-0e80-47ad-b5ac-046462d9dc73
caps.latest.revision: 9
author: mikeblome
ms.author: mblome
manager: ghogen
ms.translationtype: HT
ms.sourcegitcommit: f460497071445cff87308fa9bf6e0d43c6f13a3e
ms.openlocfilehash: 252f80416f581ecc2c126bc44ab22c1b63c50130
ms.contentlocale: ru-ru
ms.lasthandoff: 09/25/2017

---

# <a name="partial-ordering-of-function-templates-c"></a>Частичное упорядочение шаблонов функций (C++)

Может быть доступно несколько шаблонов функций, соответствующих списку аргументов в вызове функции. В C++ определено частичное упорядочение шаблонов функции, что позволяет указать, какую функцию необходимо вызвать. Упорядочение выполняется частично, поскольку может быть несколько шаблонов, которые считаются в равной мере специализированными.

Компилятор выбирает функцию наиболее специализированного шаблона среди всех возможных совпадений. Например, если шаблон функции принимает тип __T__и другой шаблон функции перевода __T\* __ доступен, __T\* __ говорят, что версия более специализированным, поэтому предпочтительнее, чем универсальный __T__ версии всякий раз, когда аргумент имеет тип указателя, даже если оба бы допустимый совпадений.

Чтобы определить, является ли один кандидатов — шаблонов функций — более специализированным, используйте следующую процедуру:

1. Рассмотрим два шаблона функции, T1 и T2.

2. Замените параметры в шаблоне T1 на гипотетический уникальный тип X.

3. Пользуясь списком параметров из шаблона T1, проверьте, является ли T2 допустимым шаблоном для этого списка параметров. Любые неявные преобразования пропускайте.

4. Повторите ту же самую процедуру, поменяв шаблоны T1 и T2 местами.

5. Если список аргументов из одного шаблона будет допустимым для другого, но не наоборот, то первый шаблон считается менее специализированным, чем второй. Если оба шаблона позволили предыдущего шага формы допустимые аргументы друг для друга, то они считаются в равной мере специализированными, и возникнет Неоднозначный вызов результатов при попытке их использования.

6. При проведении процедуры руководствуйтесь следующими правилами:

     1. Шаблон для определенного типа является более специализированным, чем шаблон, принимающий аргумент универсального типа.

     2. Шаблон, принимающий только __T\* __ является более специализированным, чем один занимает только __T__, так как гипотетический тип __X\* __ является допустимым аргументом для __T__ аргумент шаблона, но __X__ не является допустимым аргументом для __T\* __ аргумент шаблона.

     3. __const T__ является более специализированным, чем __T__, так как __const X__ является допустимым аргументом для __T__ аргумент шаблона, но __X__ не является допустимым аргументом для __const T__ аргумент шаблона.

     4. __const T\* __ является более специализированным, чем __T\*__, так как __const X\* __ является допустимым аргументом для __T\* __ аргумент шаблона, но __X\* __ не является допустимым аргументом для __const T\* __ аргумент шаблона.

## <a name="example"></a>Пример

Следующий пример работает в соответствии со стандартом:

```cpp
// partial_ordering_of_function_templates.cpp
// compile with: /EHsc
#include <iostream>

extern "C" int printf(const char*,...);
template <class T> void f(T) {
   printf_s("Less specialized function called\n");
}

template <class T> void f(T*) {
   printf_s("More specialized function called\n");
}

template <class T> void f(const T*) {
   printf_s("Even more specialized function for const T*\n");
}

int main() {
   int i =0;
   const int j = 0;
   int *pi = &i;
   const int *cpi = &j;

   f(i);   // Calls less specialized function.
   f(pi);  // Calls more specialized function.
   f(cpi); // Calls even more specialized function.
   // Without partial ordering, these calls would be ambiguous.
}
```  
  
### <a name="output"></a>Вывод  
  
```  
Less specialized function called  
More specialized function called  
Even more specialized function for const T*  
```  
  
## <a name="see-also"></a>См. также

[Шаблоны функций](../cpp/function-templates.md)

