---
title: "Время обработки исключений: Сводка | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-language
ms.tgt_pltfrm: 
ms.topic: language-reference
dev_langs:
- C++
helpviewer_keywords:
- sequence
- sequence, of handlers
- exception handling, timing
- SETJMPEX.H
- termination handlers, timing
- SETJMP.H
- handlers, order of exception
- structured exception handling, timing
ms.assetid: 5d1da546-73fd-4673-aa1a-7ac0f776c420
caps.latest.revision: 6
author: mikeblome
ms.author: mblome
manager: ghogen
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: HT
ms.sourcegitcommit: 6ffef5f51e57cf36d5984bfc43d023abc8bc5c62
ms.openlocfilehash: 0ba1075095381229667c7164aa7de7f3e4537486
ms.contentlocale: ru-ru
ms.lasthandoff: 09/25/2017

---
# <a name="timing-of-exception-handling-a-summary"></a>Время обработки исключений. Общие сведения
Обработчик завершения выполняется независимо от того, как завершается блок инструкции `__try`. Причины включают выход из блока `__try`, инструкцию `longjmp`, которая передает контроль за пределы блока, а также освобождение стека из-за обработки исключения.  
  
> [!NOTE]
>  Visual C++ поддерживает две формы инструкций `setjmp` и `longjmp`. Быстрая версия обходит обработку завершения, однако является более эффективной. Для использования этой версии включите файл SETJMP.H. Другая версия поддерживает обработку завершения, как описано в предыдущем абзаце. Для использования этой версии включите файл SETJMPEX.H. Увеличение производительности быстрой версии зависит от конфигурации оборудования.  
  
 Операционная система выполняет все обработчики завершения в нужном порядке, прежде чем сможет быть выполнен какой-либо другой код, включая тело обработчика исключений.  
  
 Если причина прерывания — исключение, система должна сначала выполнить фильтровую часть одного или нескольких обработчиков исключений, а потом определять объект завершения. Используется следующий порядок событий:  
  
1.  Выдается исключение.  
  
2.  Система анализирует иерархию активных обработчиков исключений и выполняет фильтр обработчика с наивысшим приоритетом; это обработчик исключений, который был установлен последним и имеет наиболее глубокую структуру с точки зрения блоков и вызовов функций.  
  
3.  Если этот фильтр передает контроль (возвращает 0), процесс продолжается до тех пор, пока не будет найден фильтр, который не передает контроль.  
  
4.  Если этот фильтр возвращает значение -1, выполнение продолжается, где было создано исключение, а завершение не происходит.  
  
5.  Если фильтр возвращает 1, возникают следующие события:  
  
    -   Система освобождает стек, снимает все кадры стека между текущим исполняемым кодом (где было создано исключение) и кадром стека, который содержит получающий контроль обработчик исключений.  
  
    -   По мере освобождения стека выполняется каждый обработчик завершения в стеке.  
  
    -   Выполняется сам обработчик исключений.  
  
    -   Контроль переходит к строке кода после окончания этого обработчика исключений.  
  
## <a name="see-also"></a>См. также  
 [Написание обработчика завершения](../cpp/writing-a-termination-handler.md)   
 [Структурированная обработка исключений (C/C++)](../cpp/structured-exception-handling-c-cpp.md)
