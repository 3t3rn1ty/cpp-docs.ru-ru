---
title: "Постфиксные выражения | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "language-reference"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "выражения [C++], постфикс"
  - "операторы [C++], постфикс"
  - "постфиксные выражения"
ms.assetid: 7ac62a57-06df-422f-b012-a75b37d7cb9b
caps.latest.revision: 8
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 8
---
# Постфиксные выражения
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Постфиксные выражения состоят из основных выражений или выражений, в которых постфиксные операторы следуют за основным выражением.  Постфиксные операторы перечислены в следующей таблице.  
  
### Постфиксные операторы  
  
|Имя оператора|Нотация оператора|  
|-------------------|-----------------------|  
|[Оператор индекса](../Topic/Subscript%20Operator:.md)|**\[ \]**|  
|[Оператор вызова функции](../cpp/function-call-operator-parens.md)|**\( \)**|  
|[Оператор явного преобразования типа](../Topic/Explicit%20Type%20Conversion%20Operator:%20\(\).md)|*имя\-типа* **\( \)**|  
|[Оператор доступа к элементу](../Topic/Member%20Access%20Operators:%20.%20and%20-%3E.md)|**.** или **–\>**|  
|[Постфиксный оператор приращения](../cpp/postfix-increment-and-decrement-operators-increment-and-decrement.md)|`++`|  
|[Постфиксный оператор уменьшения](../cpp/postfix-increment-and-decrement-operators-increment-and-decrement.md)|**––**|  
  
 Следующий синтаксис описывает возможные постфиксные выражения:  
  
```  
  
          primary-expression   
postfix-expression [ expression ]  
postfix-expression ( expression-list)  
simple-type-name ( expression-list)  
postfix-expression . name  
postfix-expression –> name  
postfix-expression ++  
postfix-expression ––  
cast-keyword < typename > (expression ) typeid ( typename )  
```  
  
 *постфиксное\-выражение* выше может быть основным выражением или другим постфиксным выражением.  См. **основные выражения**.  Постфиксные выражения группируются слева направо, делая возможным следующее связывание выражений.  
  
```  
func(1)->GetValue()++  
```  
  
 В предыдущем выражении func — это основное выражение, func\(1\) — постфиксное выражение функции, func\(1\)\-\>GetData — постфиксное выражение, задающее член класса, func \(1\)\-\>GetData\(\) — это другое постфиксное выражение функции, и все выражение представляет собой постфиксное выражение, инкрементно увеличивающее возвращаемое значение GetData.  Значение выражения в целом имеет следующий смысл: "вызовите функцию, передающую 1 в качестве аргумента, и получите указатель на класс в качестве возвращаемого значения.  Затем вызовите GetValue\(\) для этого класса и выполните инкрементное увеличение возвращаемого значения.  
  
 Перечисленные выше выражения — это выражения присваивания, что означает, что результат этих выражений должен представлять собой r\-значение.  
  
 Форма постфиксного выражения  
  
```  
simple-type-name ( expression-list )  
```  
  
 показывает вызов конструктора.  Если simple\-type\-name — это фундаментальный тип, список выражений должен представлять собой отдельное выражение, и это выражение обозначает приведение значения выражения к фундаментальному типу.  Данный тип выражения приведения копирует конструктор.  Поскольку эта форма позволяет создавать фундаментальные типы и классы с использованием одного и того же синтаксиса, эта форма особенно полезна при определении шаблонных классов.  
  
 *Ключевое\-слово\-приведения* — это одно из ключевых слов `dynamic_cast`, `static_cast` или `reinterpret_cast`.  Дополнительные сведения можно найти в разделах **dynamic\_cast**, **static\_cast** и **reinterpet\_cast**.  
  
 Оператор `typeid` считается постфиксным выражением.  См. раздел **Оператор typeid**.  
  
## Формальные и фактические аргументы  
 При вызове программ сведения передаются в вызываемую функцию в фактических аргументах. Вызываемые функции получают доступ к сведениям с помощью соответствующих формальных аргументов.  
  
 При вызове функции выполняются следующие задачи.  
  
-   Вычисляются все фактические аргументы \(предоставляемые вызывающим объектом\).  Эти аргументы вычисляются в произвольном порядке, но все аргументы вычисляются и все побочные эффекты завершаются перед переходом в функцию.  
  
-   Каждый формальный аргумент инициализируется с соответствующим фактическим аргументом в списке выражений.  \(Формальный аргумент — это аргумент, объявленный в заголовке функции и используемый в теле функции.\) Преобразования выполняются таким же образом как при инициализации: стандартные и пользовательские преобразования выполняются при преобразовании фактического аргумента в требуемый тип.  В общем виде выполненная инициализация показана в следующем коде.  
  
    ```  
    void Func( int i ); // Function prototype  
    ...  
    Func( 7 );          // Execute function call  
    ```  
  
     Ниже представлены концептуальные инициализации до вызова.  
  
    ```  
    int Temp_i = 7;  
    Func( Temp_i );  
    ```  
  
     Обратите внимание, что инициализация выполняется таким образом, как если бы использовался синтаксис со знаком равенства, а не синтаксис с круглыми скобками.  Копия `i` создается до передачи значения в функцию.  \(Дополнительные сведения см. в разделах [Инициализаторы](../cpp/initializers.md), [Преобразования](../cpp/user-defined-type-conversions-cpp.md), [Инициализация с помощью специальных функций\-членов](http://msdn.microsoft.com/ru-ru/82223d73-64cb-4923-b678-78f9568ff3ca) и [Явная инициализация](http://msdn.microsoft.com/ru-ru/c89724f8-ddd3-4d77-b86d-77fcd8bd8595).\)  
  
     Поэтому, если прототип функции \(объявление\) вызывает аргумент типа **long** и вызывающая программа предоставляет фактический аргумент типа `int`, фактический аргумент повышается до типа **long** с помощью преобразования стандартного типа \(см. раздел [Стандартные преобразования](../cpp/standard-conversions.md)\).  
  
     Предоставление фактического аргумента при отсутствии стандартного или пользовательского преобразования в тип формального аргумента будет ошибкой.  
  
     В случае фактических аргументов типа класса формальный аргумент инициализируется путем вызова конструктора класса.  \(Дополнительные сведения об этих специальных функциях\-членах класса см. в разделе [Конструкторы](../cpp/constructors-cpp.md).\)  
  
-   Выполняется вызов функции.  
  
 В следующем фрагменте программного кода показан вызов функции.  
  
```  
// expre_Formal_and_Actual_Arguments.cpp  
void func( long param1, double param2 );  
  
int main()  
{  
    long i = 1;  
    double j = 2;  
  
    // Call func with actual arguments i and j.  
    func( i, j );  
}  
  
// Define func with formal parameters param1 and param2.  
void func( long param1, double param2 )  
{  
}  
```  
  
 Если `func` вызывается из функции main, формальный параметр `param1` инициализируется значением `i` \(`i` преобразуется в тип **long** для соответствия требуемому типу с помощью стандартного преобразования\), а формальный параметр `param2` инициализируется значением `j` \(`j` преобразуется в тип **double** с помощью стандартного преобразования\).  
  
## Работа с типами аргументов  
 Формальные аргументы, объявленные как типы const, невозможно изменить в теле функции.  Функции могут изменить любой аргумент, который не принадлежит типу **const**.  Однако изменение является локальным для функции и не влияет на значение фактического аргумента, если фактический аргумент не является ссылкой на объект типа, отличного от **const**.  
  
 Некоторые из этих понятий показаны на примере следующих функций.  
  
```  
// expre_Treatment_of_Argument_Types.cpp  
int func1( const int i, int j, char *c ) {  
   i = 7;   // C3892 i is const.  
   j = i;   // value of j is lost at return  
   *c = 'a' + j;   // changes value of c in calling function  
   return i;  
}  
  
double& func2( double& d, const char *c ) {  
   d = 14.387;   // changes value of d in calling function.  
   *c = 'a';   // C3892 c is a pointer to a const object.  
    return d;  
}  
```  
  
## Многоточия и аргументы по умолчанию  
 Чтобы функции принимали меньше аргументов, чем указано в определении функции, их можно определять, используя многоточие \(`...`\) или аргументы по умолчанию.  
  
 Многоточие означает, что аргументы могут требоваться, но их число и типы не определены в объявлении.  Это обычно плохой стиль программирования на языке C\+\+, поскольку он сводит на нет одно из преимуществ этого языка: безопасность типа.  Для функций, объявленных с многоточием, применяются иные преобразования, нежели для функций, для которых известны типы формальных и фактических аргументов.  
  
-   Если фактический аргумент имеет тип **float**, то перед вызовом функции он повышается до типа **double**.  
  
-   Любой знаковый или беззнаковый тип `char`, **short**, перечислимый тип или битовое поле преобразуется в знаковый или беззнаковый тип `int` с помощью восходящего приведения целого типа.  
  
-   Любой аргумент типа класса передается по значению в виде структуры данных; копия создается путем двоичного копирования, а не путем вызова конструктора копии класса \(если он имеется\).  
  
 Многоточие \(если оно используется\) необходимо объявлять последним в списке аргументов.  Дополнительные сведения о передаче переменного числа аргументов см. в разделе описания [va\_arg, va\_start и va\_list](../c-runtime-library/reference/va-arg-va-copy-va-end-va-start.md) в *Справочнике по библиотеке времени выполнения*.  
  
 Сведения об аргументах по умолчанию при программировании в среде CLR см. в разделе [Списки аргументов переменных \(...\) \(C\+\+\/CLI\)](../windows/variable-argument-lists-dot-dot-dot-cpp-cli.md).  
  
 Аргументы по умолчанию позволяют задать значение, которое должен принять аргумент, если в вызове функции значение не передано.  В следующем фрагменте кода показано, как работают аргументы по умолчанию.  Дополнительные сведения об ограничениях на задание аргументов по умолчанию см. в разделе [Аргументы по умолчанию](../Topic/Default%20Arguments.md).  
  
```  
// expre_Ellipses_and_Default_Arguments.cpp  
// compile with: /EHsc  
#include <iostream>  
  
// Declare the function print that prints a string,  
// then a terminator.  
void print( const char *string,  
            const char *terminator = "\n" );  
  
int main()  
{  
    print( "hello," );  
    print( "world!" );  
  
    print( "good morning", ", " );  
    print( "sunshine." );  
}  
  
using namespace std;  
// Define print.  
void print( const char *string, const char *terminator )  
{  
    if( string != NULL )  
        cout << string;  
  
    if( terminator != NULL )  
        cout << terminator;  
}  
```  
  
 Представленная выше программа объявляет функцию `print`, принимающую два аргумента.  Однако второй аргумент \(`terminator`\) имеет значение по умолчанию `"\n"`.  В разделе **main** первые два вызова функции `print` позволяют второму аргументу по умолчанию предоставить новую строку для завершения печатаемой строки.  В третьем вызове указывается явное значение второго аргумента.  После выполнения этой программы выводится следующий результат:  
  
```  
hello,  
world!  
good morning, sunshine.  
```  
  
## См. также  
 [Типы выражений](../cpp/types-of-expressions.md)