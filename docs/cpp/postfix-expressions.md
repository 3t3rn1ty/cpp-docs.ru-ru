---
title: "Постфиксные выражения | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-language
ms.tgt_pltfrm: 
ms.topic: language-reference
dev_langs:
- C++
helpviewer_keywords:
- operators [C++], postfix
- postfix expressions
- expressions [C++], postfix
ms.assetid: 7ac62a57-06df-422f-b012-a75b37d7cb9b
caps.latest.revision: 8
author: mikeblome
ms.author: mblome
manager: ghogen
ms.translationtype: HT
ms.sourcegitcommit: 6ffef5f51e57cf36d5984bfc43d023abc8bc5c62
ms.openlocfilehash: c72b54a3941731d95ec12bcdae552651b9176d9a
ms.contentlocale: ru-ru
ms.lasthandoff: 09/25/2017

---
# <a name="postfix-expressions"></a>Постфиксные выражения
Постфиксные выражения состоят из основных выражений или выражений, в которых постфиксные операторы следуют за основным выражением. Постфиксные операторы перечислены в следующей таблице.  
  
### <a name="postfix-operators"></a>Постфиксные операторы  
  
|Имя оператора|Нотация оператора|  
|-------------------|-----------------------|  
|[Подстрочный оператор](../cpp/subscript-operator.md)|**[ ]**|  
|[Оператор вызова функции](../cpp/function-call-operator-parens.md)|**( )**|  
|[Оператор явного преобразования типа](../cpp/explicit-type-conversion-operator-parens.md)|*Имя типа* **)**|  
|[Оператор доступа к членам](../cpp/member-access-operators-dot-and.md)|**.** или**->**|  
|[Постфиксный оператор приращения](../cpp/postfix-increment-and-decrement-operators-increment-and-decrement.md)|`++`|  
|[Постфиксный оператор уменьшения](../cpp/postfix-increment-and-decrement-operators-increment-and-decrement.md)|**--**|  
  
 Следующий синтаксис описывает возможные постфиксные выражения:  
  
```  
  
      primary-expression   
postfix-expression[expression]postfix-expression(expression-list)simple-type-name(expression-list)postfix-expression.namepostfix-expression->namepostfix-expression++postfix-expression--cast-keyword < typename > (expression )typeid ( typename )  
```  
  
 *Постфиксное выражение* выше может быть основным выражением или другим постфиксным выражением.  В разделе **первичные выражения**.  Постфиксные выражения группируются слева направо, делая возможным следующее связывание выражений.  
  
```  
func(1)->GetValue()++  
```  
  
 В предыдущем выражении func — это основное выражение, func(1) — постфиксное выражение функции, func(1)->GetData — постфиксное выражение, задающее член класса, func (1)->GetData() — это другое постфиксное выражение функции, и все выражение представляет собой постфиксное выражение, инкрементно увеличивающее возвращаемое значение GetData.  Значение выражения в целом имеет следующий смысл: "вызовите функцию, передающую 1 в качестве аргумента, и получите указатель на класс в качестве возвращаемого значения.  Затем вызовите GetValue() для этого класса и выполните инкрементное увеличение возвращаемого значения.  
  
 Перечисленные выше выражения — это выражения присваивания, что означает, что результат этих выражений должен представлять собой r-значение.  
  
 Форма постфиксного выражения  
  
```  
simple-type-name ( expression-list )  
```  
  
 показывает вызов конструктора.  Если simple-type-name — это фундаментальный тип, список выражений должен представлять собой отдельное выражение, и это выражение обозначает приведение значения выражения к фундаментальному типу.  Данный тип выражения приведения копирует конструктор.  Поскольку эта форма позволяет создавать фундаментальные типы и классы с использованием одного и того же синтаксиса, эта форма особенно полезна при определении шаблонных классов.  
  
 *Слово cast* является одним из `dynamic_cast`, `static_cast` или `reinterpret_cast`.  Дополнительные сведения можно найти в **dynamic_cast**, **static_cast** и **reinterpet_cast**.  
  
 Оператор `typeid` считается постфиксным выражением.  В разделе **оператор typeid**.  
  
## <a name="formal-and-actual-arguments"></a>Формальные и фактические аргументы  
 При вызове программ сведения передаются в вызываемую функцию в фактических аргументах. Вызываемые функции получают доступ к сведениям с помощью соответствующих формальных аргументов.  
  
 При вызове функции выполняются следующие задачи.  
  
-   Вычисляются все фактические аргументы (предоставляемые вызывающим объектом). Эти аргументы вычисляются в произвольном порядке, но все аргументы вычисляются и все побочные эффекты завершаются перед переходом в функцию.  
  
-   Каждый формальный аргумент инициализируется с соответствующим фактическим аргументом в списке выражений. (Формальный аргумент — это аргумент, объявленный в заголовке функции и используемый в теле функции.) Преобразования выполняются таким же образом как при инициализации: стандартные и пользовательские преобразования выполняются при преобразовании фактического аргумента в требуемый тип. В общем виде выполненная инициализация показана в следующем коде.  
  
    ```  
    void Func( int i ); // Function prototype  
    ...  
    Func( 7 );          // Execute function call  
    ```  
  
     Ниже представлены концептуальные инициализации до вызова.  
  
    ```  
    int Temp_i = 7;  
    Func( Temp_i );  
    ```  
  
     Обратите внимание, что инициализация выполняется таким образом, как если бы использовался синтаксис со знаком равенства, а не синтаксис с круглыми скобками. Копия `i` создается до передачи значения в функцию. (Дополнительные сведения см. в разделе [инициализаторы](../cpp/initializers.md) и [преобразования](../cpp/user-defined-type-conversions-cpp.md)).  
  
     Таким образом Если прототип функции (объявление) вызывает аргумент типа **длинные**, и если вызывающая программа предоставляет фактический аргумент типа `int`, фактический аргумент повышается с помощью преобразования стандартного типа для ввода **длинные** (см. [стандартные преобразования](../cpp/standard-conversions.md)).  
  
     Предоставление фактического аргумента при отсутствии стандартного или пользовательского преобразования в тип формального аргумента будет ошибкой.  
  
     В случае фактических аргументов типа класса формальный аргумент инициализируется путем вызова конструктора класса. (См. [конструкторы](../cpp/constructors-cpp.md) Дополнительные сведения об этих специальных классов функций-членов.)  
  
-   Выполняется вызов функции.  
  
 В следующем фрагменте программного кода показан вызов функции.  
  
```  
// expre_Formal_and_Actual_Arguments.cpp  
void func( long param1, double param2 );  
  
int main()  
{  
    long i = 1;  
    double j = 2;  
  
    // Call func with actual arguments i and j.  
    func( i, j );  
}  
  
// Define func with formal parameters param1 and param2.  
void func( long param1, double param2 )  
{  
}  
```  
  
 Когда `func` вызывается из метода main, формальный параметр `param1` инициализируется со значением `i` (`i` преобразуется в тип **длинные** в правильный тип в стандартном преобразование) и формальный параметр `param2` инициализируется со значением `j` (`j` преобразуется в тип **двойные** с помощью стандартного преобразования).  
  
## <a name="treatment-of-argument-types"></a>Работа с типами аргументов  
 Формальные аргументы, объявленные как типы const, невозможно изменить в теле функции. Функции могут изменить любой аргумент, который не относится к типу **const**. Однако изменение является локальным для функции и не влияет на значение фактического аргумента если фактический аргумент не является ссылкой на объект типа, отличного от **const**.  
  
 Некоторые из этих понятий показаны на примере следующих функций.  
  
```  
// expre_Treatment_of_Argument_Types.cpp  
int func1( const int i, int j, char *c ) {  
   i = 7;   // C3892 i is const.  
   j = i;   // value of j is lost at return  
   *c = 'a' + j;   // changes value of c in calling function  
   return i;  
}  
  
double& func2( double& d, const char *c ) {  
   d = 14.387;   // changes value of d in calling function.  
   *c = 'a';   // C3892 c is a pointer to a const object.  
    return d;  
}  
```  
  
## <a name="ellipses-and-default-arguments"></a>Многоточия и аргументы по умолчанию  
 Чтобы функции принимали меньше аргументов, чем указано в определении функции, их можно определять, используя многоточие (`...`) или аргументы по умолчанию.  
  
 Многоточие означает, что аргументы могут требоваться, но их число и типы не определены в объявлении. Это обычно плохой стиль программирования на языке C++, поскольку он сводит на нет одно из преимуществ этого языка: безопасность типа. Для функций, объявленных с многоточием, применяются иные преобразования, нежели для функций, для которых известны типы формальных и фактических аргументов.  
  
-   Если фактический аргумент имеет тип **float**, повышается до типа **двойные** перед вызовом функции.  
  
-   Любой знаковый или беззнаковый `char`, **короткие**, перечисляемый тип или битовое поле преобразуется со знаком или без знака `int` с помощью восходящее приведение целого типа.  
  
-   Любой аргумент типа класса передается по значению в виде структуры данных; копия создается путем двоичного копирования, а не путем вызова конструктора копии класса (если он имеется).  
  
 Многоточие (если оно используется) необходимо объявлять последним в списке аргументов. Дополнительные сведения о передаче переменное число аргументов в описании [va_arg, va_start и va_list](../c-runtime-library/reference/va-arg-va-copy-va-end-va-start.md) в *Справочник по библиотеке времени выполнения*.  
  
 Сведения в аргументах по умолчанию при программировании в среде CLR см. в разделе [списками аргументов переменных (...) (C + +/ CLI) ](../windows/variable-argument-lists-dot-dot-dot-cpp-cli.md).  
  
 Аргументы по умолчанию позволяют задать значение, которое должен принять аргумент, если в вызове функции значение не передано. В следующем фрагменте кода показано, как работают аргументы по умолчанию. Дополнительные сведения об ограничениях на задание аргументов по умолчанию см. в разделе [аргументы по умолчанию](../cpp/default-arguments.md).  
  
```  
// expre_Ellipses_and_Default_Arguments.cpp  
// compile with: /EHsc  
#include <iostream>  
  
// Declare the function print that prints a string,  
// then a terminator.  
void print( const char *string,  
            const char *terminator = "\n" );  
  
int main()  
{  
    print( "hello," );  
    print( "world!" );  
  
    print( "good morning", ", " );  
    print( "sunshine." );  
}  
  
using namespace std;  
// Define print.  
void print( const char *string, const char *terminator )  
{  
    if( string != NULL )  
        cout << string;  
  
    if( terminator != NULL )  
        cout << terminator;  
}  
```  
  
 Представленная выше программа объявляет функцию `print`, принимающую два аргумента. Однако второй аргумент (`terminator`) имеет значение по умолчанию `"\n"`. В **основной**, первые два вызова `print` позволяют второму аргументу по умолчанию предоставить новую строку для завершения печатаемой строки. В третьем вызове указывается явное значение второго аргумента. После выполнения этой программы выводится следующий результат:  
  
```  
hello,  
world!  
good morning, sunshine.  
```  
  
## <a name="see-also"></a>См. также  
 [Типы выражений](../cpp/types-of-expressions.md)
