---
title: Алгоритмы (современный C++) | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-language
ms.topic: conceptual
dev_langs:
- C++
ms.assetid: 6f758d3c-a7c7-4a50-92bb-97b2f6d4ab27
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: fdd5742bb86992ce20f5a52f587c8557d46a97eb
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
---
# <a name="algorithms-modern-c"></a>Алгоритмы (современный C++)
Для современных особенностях программирования на C++, мы рекомендуем использовать алгоритмы в [стандартной библиотеки C++](../standard-library/cpp-standard-library-reference.md). Ниже приведены несколько важных примеров.  
  
-   `for_each`, который является алгоритм обхода по умолчанию. (Также `transform` для семантики не на месте.)  
  
-   `find_if`, который является алгоритм поиска по умолчанию.  
  
-   `sort`, `lower_bound`, другие значения по умолчанию сортировка и поиск алгоритмов.  
  
 При написании сравнивающее устройство используйте strict `<` и использовать *лямбда-выражения с именем* когда вы можете.  
  
```cpp  
auto comp = [](const widget& w1, const widget& w2)  
      { return w1.weight() < w2.weight(); }  
  
sort( v.begin(), v.end(), comp );  
  
auto i = lower_bound( v.begin(), v.end(), comp );  
```  
  
## <a name="loops"></a>Циклы  
 По возможности используйте на основе диапазонов `for` циклы вызовы алгоритма и/или, вместо рукописный циклы.`copy`, `transform`, `count_if`, `remove_if`, и другие подобные, гораздо лучше, чем рукописные циклы из-за их назначение Очевидно, и их было проще писать код без ошибок. Кроме того многие алгоритмы стандартной библиотеки C++ оптимизированы реализацию, сделать их более эффективным.  
  
 Вместо старого C++ следующим образом:  
  
```cpp  
for ( auto i = strings.begin(); i != strings.end(); ++i ) {  
   /* ... */  
}  
  
auto i = v.begin();  
  
for ( ; i != v.end(); ++i ) {  
  if (*i > x && *i < y) break;  
}  
```  
  
 Используйте современный язык C++ следующим образом:  
  
```cpp  
for_each( begin(strings), end(strings), [](string& s) {  
   // ...  
} );  
  
auto i = find_if( begin(v), end(v),  [=](int i) { return i > x && i < y; } );  
```  
  
### <a name="range-based-for-loops"></a>На основе диапазонов циклы for  
 На основе диапазонов `for` цикла является функцией C ++ 11 языка, не является алгоритмом стандартной библиотеки C++. Но уделят упоминание в данном контексте о циклах. На основе диапазонов `for` циклы являются расширением `for` ключевое слово и предоставляют удобный и эффективный способ создания циклов, которые проходят через диапазон значений. Контейнеры стандартной библиотеки C++, строки и массивы, готовых для на основе диапазонов `for` циклы. Чтобы включить этот новый синтаксис итерации для определяемого пользователем типа, добавьте следующие возможности:  
  
-   Объект `begin` метод, который возвращает итератор для начала структуры и `end` метод, который возвращает итератор конца самой структуры.  
  
-   Поддержка в итераторе для этих методов: `operator*`, `operator!=`, и `operator++` (префиксная версия).  
  
 Эти методы могут быть члены или автономного функции.  
  
## <a name="random-numbers"></a>Случайные числа  
 Это не секрет, старый CRT `rand()` функция имеет множество недостатков, которые объяснял описан в сообществе C++. В современном C++ нет необходимости работать с этими недостатки — не приходится создавать собственные равномерно распределенных генератора случайных чисел, так как средства для их создания быстро и легко доступны в стандартной библиотеке C++, как показано в [ \<случайных >](../standard-library/random.md).  
  
## <a name="see-also"></a>См. также  
 [Возвращение к C++](../cpp/welcome-back-to-cpp-modern-cpp.md)   
 [Справочник по языку C++](../cpp/cpp-language-reference.md)   
 [Стандартная библиотека C++](../standard-library/cpp-standard-library-reference.md)