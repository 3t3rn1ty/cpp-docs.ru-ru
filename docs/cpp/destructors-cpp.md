---
title: "Деструкторы (C++) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "language-reference"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "~ - оператор, указание деструкторов"
  - "уничтожение объектов, деструкторы"
  - "деструкторы, сведения о деструкторах"
  - "деструкторы, C++"
  - "объекты [C++], уничтожение"
  - "Visual C++, деструкторы"
ms.assetid: afa859b0-f3bc-4c4d-b250-c68b335b6004
caps.latest.revision: 10
caps.handback.revision: 10
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Деструкторы (C++)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Функции\-деструкторы представляют собой противоположность конструкторам.  Они вызываются при уничтожении \(отмене выделения памяти\) объектов.  Для того чтобы указать функцию как деструктор класса, необходимо указать перед именем класса знак тильды \(`~`\).  Например, деструктор для класса `String` объявляется следующим образом: `~String()`.  
  
 При компиляции с параметром \/clr деструктор имеет специальную роль, которая заключается в высвобождении управляемых и неуправляемых ресурсов.  Дополнительные сведения см. в статье [Деструкторы и методы завершения в Visual C\+\+](../misc/destructors-and-finalizers-in-visual-cpp.md).  
  
 Обычно деструктор используется для "очистки", когда объект больше не нужен.  Рассмотрим следующее объявление класса `String`:  
  
```  
// spec1_destructors.cpp  
#include <string.h>  
  
class String {  
public:  
   String( char *ch );  // Declare constructor  
   ~String();           //  and destructor.  
private:  
   char    *_text;  
   size_t  sizeOfText;  
};  
  
// Define the constructor.  
String::String( char *ch ) {  
   sizeOfText = strlen( ch ) + 1;  
  
   // Dynamically allocate the correct amount of memory.  
   _text = new char[ sizeOfText ];  
  
   // If the allocation succeeds, copy the initialization string.  
   if( _text )  
      strcpy_s( _text, sizeOfText, ch );  
}  
  
// Define the destructor.  
String::~String() {  
   // Deallocate the memory that was previously reserved  
   //  for this string.  
   if (_text)  
      delete[] _text;  
}  
  
int main() {  
   String str("The piper in the glen...");  
}  
```  
  
 В приведенном выше примере в деструкторе `String::~String` используется оператор `delete`, который отменяет выделение пространства, динамически выделенного для хранения текста.  
  
## Объявление деструкторов  
 Деструкторы — это функции с тем же именем, что и класс, но с добавленным в начало знаком тильды \(`~`\).  
  
 Первая форма синтаксиса используется для деструкторов, объявленных или определенных внутри объявления класса; вторая форма используется для деструкторов, определенных вне объявления класса.  
  
 При объявлении деструкторов действуют несколько правил.  Деструкторы:  
  
-   Не могут иметь аргументов.  
  
-   Не могут иметь возвращаемого типа \(включая `void`\).  
  
-   Не могут возвращать значение с помощью оператора `return`.  
  
-   Не могут объявляться как **const**, `volatile` или **static**.  Однако их можно вызывать для уничтожения объектов, объявленных как **const**, `volatile` или **static**.  
  
-   Могут объявляться как **virtual**.  Используя виртуальные деструкторы, можно уничтожать объекты, не зная их тип — правильный деструктор для объекта вызывается с помощью механизма виртуальных функций.  Обратите внимание, что для абстрактных классов деструкторы также могут объявляться как чисто виртуальные функции.  
  
## Использование деструкторов  
 Деструкторы вызываются, когда происходит одно из следующих событий:  
  
-   Объект, предоставленный с использованием оператора **new**, можно явно освободить с использованием оператора **delete**.  Если объекты освобождаются с помощью оператора **delete**, память освобождается для "наиболее производного объекта" или объекта, который является полным, а не вложенным объектом, представляющим базовый класс.  Освобождение "самого производного объекта" гарантированно работает только с виртуальными деструкторами.  Освобождение может завершиться ошибкой в случае множественного наследования, если сведения о типе не соответствуют базовому типу фактического объекта.  
  
-   Локальный \(автоматический\) объект с областью видимости "блок" выходит за пределы области видимости.  
  
-   Время существования временного объекта заканчивается.  
  
-   Программа заканчивается, глобальные или статические объекты продолжают существовать.  
  
-   Деструктор явно вызываться с использованием полного имени функции деструктора.  \(Дополнительные сведения см. в разделе [Явные вызовы деструктора](../misc/explicit-destructor-calls.md).\)  
  
 Случаи, описанные в предыдущем списке, гарантируют, что все объекты можно удалить с помощью пользовательских методов.  
  
 Если базовый класс или элемент данных имеет доступный деструктор, а производный класс не объявляет такой деструктор, он создается компилятором.  Этот созданный компилятором деструктор вызывает деструктор базового класса и деструкторы для членов производного типа.  Деструкторы по умолчанию являются открытыми.  \(Дополнительные сведения о специальных возможностях см. в разделе [Описатели доступа для базовых классов](../misc/access-specifiers-for-base-classes.md).\)  
  
 Деструкторы могут свободно вызывать функции\-члена класса и осуществлять доступ к данным членов класса.  Если виртуальная функция вызывается из деструктора, вызываемая функция — это функция для класса, который в настоящее время удаляется.  \(Дополнительные сведения см. в разделе [Порядок удаления](../misc/order-of-destruction.md).\)  
  
 Существует два ограничения на использование деструкторов.  Первое ограничение заключается в том, что невозможно взять адрес деструктора.  Второе ограничение в том, что производные классы не наследуют деструкторы базового класса.  Вместо этого, как поясняется выше, они всегда переопределяют деструкторы базового класса.  
  
## Порядок уничтожения  
 Когда объект выходит за пределы области или удаляется, последовательность событий при его полном уничтожении выглядит следующим образом:  
  
1.  Вызывается деструктор класса, и выполняется тело функции деструктора.  
  
2.  Деструкторы для объектов нестатических членов вызываются в порядке, обратном порядку их появления в объявлении класса.  Необязательный список инициализации членов, используемый при создании этих членов, не влияет на порядок \(создания или\) уничтожения.  \(Дополнительные сведения об инициализации членов см. в разделе [Инициализация базовых классов и членов](http://msdn.microsoft.com/ru-ru/2f71377e-2b6b-49da-9a26-18e9b40226a1).\)  
  
3.  Деструкторы для невиртуальных базовых классов вызываются в порядке, обратном порядку их объявления.  
  
4.  Деструкторы для виртуальных базовых классов вызываются в порядке, обратном порядку их объявления.  
  
```  
// order_of_destruction.cpp  
#include <stdio.h>  
  
struct A1      { virtual ~A1() { printf("A1 dtor\n"); } };  
struct A2 : A1 { virtual ~A2() { printf("A2 dtor\n"); } };  
struct A3 : A2 { virtual ~A3() { printf("A3 dtor\n"); } };  
  
struct B1      { ~B1() { printf("B1 dtor\n"); } };  
struct B2 : B1 { ~B2() { printf("B2 dtor\n"); } };  
struct B3 : B2 { ~B3() { printf("B3 dtor\n"); } };  
  
int main() {  
   A1 * a = new A3;  
   delete a;  
   printf("\n");  
  
   B1 * b = new B3;  
   delete b;  
   printf("\n");  
  
   B3 * b2 = new B3;  
   delete b2;  
}  
  
Output: A3 dtor  
A2 dtor  
A1 dtor  
  
B1 dtor  
  
B3 dtor  
B2 dtor  
B1 dtor  
  
```  
  
### Виртуальные базовые классы  
 Деструкторы для виртуальных базовых классов вызываются в порядке, обратном их указанию в направленном ациклическом графе \(в глубину, слева направо, обход в обратном порядке\).  На следующем рисунке представлен граф наследования.  
  
 ![Граф наследования, показывающий виртуальные базовые классы](../cpp/media/vc392j1.png "vc392J1")  
Граф наследования, представляющий виртуальные базовые классы  
  
 Ниже перечислены заголовки классов, представленных на рисунке.  
  
```  
class A  
class B  
class C : virtual public A, virtual public B  
class D : virtual public A, virtual public B  
class E : public C, public D, virtual public B  
```  
  
 Чтобы определить порядок удаления виртуальных базовых классов объекта типа `E`, компилятор выполняет сборку списка, применяя следующий алгоритм.  
  
1.  Просмотрите левую часть графа, начиная с самой глубокой точки графа \(в данном случае `E`\).  
  
2.  Просматривайте граф справа налево, пока не будут пройдены все узлы.  Запомните имя текущего узла.  
  
3.  Пересмотрите предыдущий узел \(вниз и вправо\), чтобы определить, является ли рассматриваемый узел виртуальным базовым классом.  
  
4.  Если рассматриваемый узел является виртуальным базовым классом, просмотрите список, чтобы проверить, был ли он введен ранее.  Если он не является виртуальным базовым классом, игнорируйте его.  
  
5.  Если рассматриваемого узла еще нет в списке, добавьте его вниз списка.  
  
6.  Просмотрите граф вверх и вдоль следующего пути вправо.  
  
7.  Перейдите к шагу 2.  
  
8.  Если путь последний путь вверх исчерпан, запомните имя текущего узла.  
  
9. Перейдите к шагу 3.  
  
10. Выполняйте этот процесс, пока нижний узел снова не станет текущим узлом.  
  
 Таким образом, для класса `E` порядок удаления будет следующим.  
  
1.  Невиртуальный базовый класс `E`.  
  
2.  Невиртуальный базовый класс `D`.  
  
3.  Невиртуальный базовый класс `C`.  
  
4.  Виртуальный базовый класс `B`.  
  
5.  Виртуальный базовый класс `A`.  
  
 В ходе этого процесса создается упорядоченный список уникальных записей.  Имя класса никогда не отображается дважды.  После создания список просматривается в обратном порядке, и вызывается деструктор для каждого класса в списке от последнего к первому.  
  
 Порядок построения или удаления очень важен, когда конструкторы и деструкторы в одном классе полагаются на другой компонент, который создается первым или сохраняется дольше, например если деструктор `A` \(на рисунке выше\) полагается на то, что `B` будет по\-прежнему присутствовать после выполнения кода, или наоборот.  
  
 Такие взаимозависимости между классами в графе наследования опасны, поскольку классы, наследуемые впоследствии, могут изменить крайний левый путь, тем самым изменив порядок построения и удаления.  
  
### Невиртуальные базовые классы  
 Деструкторы для невиртуальных базовых классов вызываются в порядке, обратном объявлению имен базовых классов.  Рассмотрим следующее объявление класса.  
  
```  
class MultInherit : public Base1, public Base2  
...  
```  
  
 В предыдущем примере деструктор `Base2` вызывается перед деструктором `Base1`.  
  
## Явные вызовы деструктора  
 Редко возникает необходимость в явном вызове деструктора.  Однако может быть полезно выполнить удаление объектов, размещенных по абсолютным адресам.  Эти объекты часто предоставляются с использованием пользовательского оператора **new**, который принимает аргумент размещения.  Оператор **delete** не может отменить предоставление этой памяти, потому что она не предоставляется из свободного хранилища \(дополнительные сведения см. в разделе [Операторы new и delete](../cpp/new-and-delete-operators.md)\).  Вызов деструктора, однако, может выполнить соответствующую очистку.  Для явного вызова деструктора для объекта \(`s`\) класса `String` воспользуйтесь одним из следующих операторов.  
  
```  
s.String::~String();     // Nonvirtual call  
ps->String::~String();   // Nonvirtual call  
  
s.~String();       // Virtual call  
ps->~String();     // Virtual call  
```  
  
 Нотация для явных вызовов деструкторов, показанная в предыдущем примере, может использоваться независимо от того, определяет ли тип деструктор.  Это позволяет выполнять такие явные вызовы, не зная, определен ли деструктор для типа.  Явный вызов деструктора, если ни один из них не определен, не имеет никакого эффекта.  
  
## См. также  
 [Специальные функции\-члены](../misc/special-member-functions-cpp.md)