---
title: "Числовые, логические литералы и литералы-указатели (C++) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "language-reference"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "константы, литералы"
  - "литералы"
  - "литералы, C++"
ms.assetid: 17c09fc3-3ad7-47e2-8b48-ba8ae994edc8
caps.latest.revision: 16
caps.handback.revision: 16
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Числовые, логические литералы и литералы-указатели (C++)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Литерал — это элемент программы, который непосредственно представляет значение.  В этой статье описываются литералы целого типа, с плавающей запятой, логического типа и типа указателя.  Сведения о строковых и символьных литералах см. в разделе [Строковые и символьные литералы \(C\+\+\)](../cpp/string-and-character-literals-cpp.md).  Вы также можете задавать собственные литералы на основе любой из этих категорий; дополнительные сведения см. в разделе [Литералы, определяемые пользователем \(C\+\+\)](../Topic/User-Defined%20Literals%20%20\(C++\).md)  
  
 .  Литералы можно использовать во многих контекстах, но наиболее часто они используются для инициализации именованных переменных и для передачи аргументов в функции.  
  
```  
const int answer = 42; // integer literal  
double d = sin(108.87);     //floating point literal passed to sin function  
bool b = true;              // boolean literal  
MyClass* mc = nullptr;      // pointer literal  
  
```  
  
 Иногда важно указывать компилятору, как следует обрабатывать литерал или какой конкретный тип ему предоставить.  Это делается путем добавления к литералу префиксов или суффиксов.  Например, префикс 0x сообщает компилятору, что следует интерпретировать число, следующее за этим префиксом, как шестнадцатеричное значение, например 0x35.  Суффикс ULL сообщает компилятору, что тип значения — `unsigned long long`, например 5894345ULL.  Полный список префиксов и суффиксов для каждого типа литерала см. в следующих разделах.  
  
## Синтаксис  
  
## Целочисленные литералы  
 Целочисленные литералы начинаются с цифры и не имеют дробных частей или экспонент.  Целочисленные литералы можно задавать в десятеричной, восьмеричной или шестнадцатеричной форме.  Они могут обозначать знаковые или беззнаковые, а также длине или короткие типы.  
  
 Если нет ни префикса, ни суффикса, компилятор будет предоставлять значению целочисленного литерала тип `int` \(32 бита\), если значение помещается в этот размер; в противном случае он будет предоставлять значению тип `long long` \(64 бита\).  
  
 Чтобы указать десятичный целочисленный литерал, начинайте спецификацию с любой цифры, кроме нуля.  Примеры.  
  
```  
int i = 157;   // Decimal literal  
int j = 0198;       // Not a decimal number; erroneous octal literal  
int k = 0365;       // Leading zero specifies octal literal, not decimal  
int m = 36'000'000  // digit separators make large values more readable  
int   
```  
  
 Чтобы указать восьмеричный целочисленный литерал, начинайте спецификацию с нуля, за которым следует ряд цифр в диапазоне от 0 до 7.  Цифры 8 и 9 при указании восьмеричного литерала будут ошибками.  Примеры.  
  
```  
int i = 0377;   // Octal literal  
int j = 0397;        // Error: 9 is not an octal digit  
```  
  
 Для указания шестнадцатеричного целочисленного литерала спецификация должна начинаться с префикса `0x` или `0X` \(регистр символа «x» не имеет значения\), за которым следует ряд цифр в диапазоне от `0` до `9` и от `a` \(или `A`\) до `f` \(или `F`\).  Шестнадцатеричные цифры от `a` \(или `A`\) до `f` \(или `F`\) представляют собой значения в диапазоне от 10 до 15.  Примеры.  
  
```  
int i = 0x3fff;   // Hexadecimal literal  
int j = 0X3FFF;        // Equal to i  
```  
  
 Для указания беззнакового типа используется суффикс **u** или **U**.  Для указания длинного типа используется суффикс **l** или **L**.  Для указания 64\-разрядного целочисленного типа используется суффикс LL или ll.  Суффикс i64 по\-прежнему поддерживается, но следует избегать его, так как он характерен только для Майкрософт и не является переносимым.  Примеры.  
  
```  
unsigned val_1 = 328u;             // Unsigned value  
long val_2 = 0x7FFFFFL;                 // Long value specified   
                                        //  as hex literal  
unsigned long val_3 = 0776745ul;        // Unsigned long value  
auto val_4 = 108LL;                           // signed long long  
auto val_4 = 0x8000000000000000ULL << 16;     // unsigned long long   
```  
  
 **Разделитель чисел**. Вы можете использовать символ одинарной кавычки \(апостроф\) для разделения значений разряда в больших числах в целях повышения удобочитаемости.  Разделители не влияют на компиляцию.  
  
```  
long long i = 24'847'458'121  
```  
  
## Литералы с плавающей запятой  
 Литералы с плавающей запятой задают значения, которые должны иметь дробную часть.  Эти значения содержат десятичные точки \(**.**\) и могут содержать показатели степени.  
  
 Литералы с плавающей запятой имеют «мантиссу», которая определяет значение числа, «экспоненту», которая определяет порядок числа, и необязательный суффикс, задающий тип константы.  Мантисса задается как последовательность цифр, затем точка, за которой следует необязательная последовательность цифр, представляющая дробную часть числа.  Примеры.  
  
```  
18.46  
38.  
```  
  
 Если указан показатель степени, он задает порядок числа в виде степени 10, как показано в следующем примере:  
  
```  
18.46e0      // 18.46  
18.46e1           // 184.6  
```  
  
 Показатель степени указывается с помощью символа **e** или **E**, которые имеют одинаковое значение, затем следует необязательный знак \(\+ или \-\) и последовательность цифр.  Если указан показатель степени, десятичная точка в конце целых чисел не требуется, например `18E0`.  
  
 По умолчанию литералы с плавающей запятой имеют тип **double**.  С помощью суффиксов **f** или **l** \(или **F** или **L** — регистр суффикса не учитывается\) литерал можно определить как **float** или `long double` соответственно.  
  
 Хотя `long double` и **double** имеют одинаковое представление, это разные типы.  Например, можно задать приведенные ниже перегруженные функции  
  
```  
void func( double );  
```  
  
 и  
  
```  
void func( long double );  
```  
  
## Логические литералы  
 Логические литералы — это `true` и `false`.  
  
## Литерал\-указатель \(C\+\+11\)  
 В C\+\+ появился литерал [nullptr](../Topic/nullptr.md) для задания указателя, инициализируемого нулевым значением.  В переносимом коде `nullptr` следует использовать вместо нуля целочисленного типа или макросов, таких как NULL.  
  
## Двоичные литералы \(C\+\+14\)  
 Двоичный литерал можно задать с помощью префикса `0B` или `0b` и последовательности, состоящей из 1 и 0:  
  
```  
  
auto x = 0B001101 ; // int  
auto y = 0b000001 ; // int  
```  
  
## Избегайте использования литералов как «магических констант»  
 Несмотря на то что это не всегда является хорошим стилем программирования, можно использовать литералы непосредственно в выражениях и операторах:  
  
```  
if (num < 100)  
    return "Success";  
  
```  
  
 В предыдущем примере, возможно, лучше было бы использовать именованную константу, которая более точно передает смысл, например MAXIMUM\_ERROR\_THRESHOLD.  И если возвращаемое значение Success видят конечные пользователи, то, возможно, лучше было бы использовать именованную строковую константу, которая хранится в одном месте в файле, где ее можно локализовать на другие языки.  Использование именованных констант помогает вам и другим пользователям понимать назначение кода.  
  
## См. также  
 [Лексические соглашения](../cpp/lexical-conventions.md)   
 [Целочисленные константы в C\+\+](http://msdn.microsoft.com/ru-ru/1f3b58a4-8346-4533-ba6e-df26d76f8dcf)   
 [Символьные литералы в C\+\+](http://msdn.microsoft.com/ru-ru/a7901c61-524d-47c6-beb6-d9dacc2e72ed)   
 [Константы с плавающей запятой в C\+\+](http://msdn.microsoft.com/ru-ru/f6273f24-a876-4484-a7a2-e82275692ad3)   
 [Строковые литералы в C\+\+](../cpp/string-and-character-literals-cpp.md)   
 [Определяемые пользователем литералы в C\+\+](../Topic/User-Defined%20Literals%20%20\(C++\).md)