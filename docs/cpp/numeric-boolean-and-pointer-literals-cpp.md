---
title: "Числовые, логические литералы и литералы-указатели (C++) | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-language
ms.tgt_pltfrm: 
ms.topic: language-reference
dev_langs: C++
helpviewer_keywords:
- literals, C++
- constants, literals
- literals [C++]
ms.assetid: 17c09fc3-3ad7-47e2-8b48-ba8ae994edc8
caps.latest.revision: "16"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.openlocfilehash: a55a608246403f427107869cbb275fa10b5569b1
ms.sourcegitcommit: ebec1d449f2bd98aa851667c2bfeb7e27ce657b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/24/2017
---
# <a name="numeric-boolean-and-pointer-literals--c"></a>Числовые, логические литералы и литералы-указатели (C++)
Литерал — это элемент программы, который непосредственно представляет значение. В этой статье описываются литералы целого типа, с плавающей запятой, логического типа и типа указателя. Сведения о строковых и символьных литералах см. в разделе [строковые и символьные литералы (C++)](../cpp/string-and-character-literals-cpp.md). Можно также определить собственные литералы на основе любого из этих категорий; Дополнительные сведения см. [определяемые пользователем литералы (C++)](../cpp/user-defined-literals-cpp.md)  
  
 . Литералы можно использовать во многих контекстах, но наиболее часто они используются для инициализации именованных переменных и для передачи аргументов в функции.  
  
```  
const int answer = 42; // integer literal  
double d = sin(108.87);     //floating point literal passed to sin function  
bool b = true;              // boolean literal  
MyClass* mc = nullptr;      // pointer literal  
  
```  
  
 Иногда важно указывать компилятору, как следует обрабатывать литерал или какой конкретный тип ему предоставить. Это делается путем добавления к литералу префиксов или суффиксов. Например, префикс 0x сообщает компилятору, что следует интерпретировать число, следующее за этим префиксом, как шестнадцатеричное значение, например 0x35. Суффикс ULL сообщает компилятору, что тип значения — `unsigned long long`, например 5894345ULL. Полный список префиксов и суффиксов для каждого типа литерала см. в следующих разделах.  
  
## <a name="syntax"></a>Синтаксис  
  
## <a name="integer-literals"></a>Целочисленные литералы  
 Целочисленные литералы начинаются с цифры и не имеют дробных частей или экспонент. Целочисленные литералы можно задавать в десятеричной, восьмеричной или шестнадцатеричной форме. Они могут обозначать знаковые или беззнаковые, а также длине или короткие типы.  
  
 Если нет ни префикса, ни суффикса, компилятор будет предоставлять значению целочисленного литерала тип `int` (32 бита), если значение помещается в этот размер; в противном случае он будет предоставлять значению тип `long long` (64 бита).  
  
 Чтобы указать десятичный целочисленный литерал, начинайте спецификацию с любой цифры, кроме нуля. Например:  
  
```  
int i = 157;   // Decimal literal  
int j = 0198;       // Not a decimal number; erroneous octal literal  
int k = 0365;       // Leading zero specifies octal literal, not decimal  
int m = 36'000'000  // digit separators make large values more readable  
int   
```  
  
 Чтобы указать восьмеричный целочисленный литерал, начинайте спецификацию с нуля, за которым следует ряд цифр в диапазоне от 0 до 7. Цифры 8 и 9 при указании восьмеричного литерала будут ошибками. Например:  
  
```  
int i = 0377;   // Octal literal  
int j = 0397;        // Error: 9 is not an octal digit  
```  
  
 Для указания шестнадцатеричного целочисленного литерала спецификация должна начинаться с префикса `0x` или `0X` (регистр символа «x» не имеет значения), за которым следует ряд цифр в диапазоне от `0` до `9` и от `a` (или `A`) до `f` (или `F`). Шестнадцатеричные цифры от `a` (или `A`) до `f` (или `F`) представляют собой значения в диапазоне от 10 до 15. Пример:  
  
```  
int i = 0x3fff;   // Hexadecimal literal  
int j = 0X3FFF;        // Equal to i  
```  
  
 Чтобы указать тип без знака, используйте **u** или **U** суффикс. Чтобы указать тип long, используйте **l** или **L** суффикс. Для указания 64-разрядного целочисленного типа используется суффикс LL или ll. Суффикс i64 по-прежнему поддерживается, но следует избегать его, так как он характерен только для Майкрософт и не является переносимым. Пример:  
  
```  
unsigned val_1 = 328u;             // Unsigned value  
long val_2 = 0x7FFFFFL;                 // Long value specified   
                                        //  as hex literal  
unsigned long val_3 = 0776745ul;        // Unsigned long value  
auto val_4 = 108LL;                           // signed long long  
auto val_4 = 0x8000000000000000ULL << 16;     // unsigned long long   
```  
  
 **Разделители между цифрами**: можно использовать символ одинарной кавычки (апостроф) для разделения значений разряда в больших числах, чтобы сделать их более удобными для удобочитаемости. Разделители не влияют на компиляцию.  
  
```  
long long i = 24'847'458'121  
```  
  
## <a name="floating-point-literals"></a>Литералы с плавающей запятой  
 Литералы с плавающей запятой задают значения, которые должны иметь дробную часть. Эти значения содержат десятичные точки (**.**) и могут содержать показатели степени.  
  
 Литералы с плавающей запятой имеют «мантиссу», которая определяет значение числа, «экспоненту», которая определяет порядок числа, и необязательный суффикс, задающий тип константы. Мантисса задается как последовательность цифр, затем точка, за которой следует необязательная последовательность цифр, представляющая дробную часть числа. Например:  
  
```  
18.46  
38.  
```  
  
 Если указан показатель степени, он задает порядок числа в виде степени 10, как показано в следующем примере:  
  
```  
18.46e0      // 18.46  
18.46e1           // 184.6  
```  
  
 Показатель степени может быть указан с помощью **e** или **E**, которые имеют одинаковое значение, затем следует необязательный знак (+ или -) и последовательность цифр.  Если указан показатель степени, десятичная точка в конце целых чисел не требуется, например `18E0`.  
  
 Литералы с плавающей запятой по умолчанию тип **двойные**. С помощью суффиксов **f** или **l** (или **F** или **L** — суффикс регистр не учитывается), литерала может быть указан как  **число с плавающей запятой** или `long double`соответственно.  
  
 Несмотря на то что `long double` и **двойные** имеют одинаковое представление, они не относятся к одному типу. Например, можно задать приведенные ниже перегруженные функции  
  
```  
void func( double );  
```  
  
 и  
  
```  
void func( long double );  
```  
  
## <a name="boolean-literals"></a>Логические литералы  
 Логические литералы — это `true` и `false`.  
  
## <a name="pointer-literal-c11"></a>Литерал-указатель (C++11)  
 C++ появился [nullptr](../cpp/nullptr.md) литерала определять указатель инициализированы нулевым значением. В переносимом коде `nullptr` следует использовать вместо нуля целочисленного типа или макросов, таких как NULL.  
  
## <a name="binary-literals-c14"></a>Двоичные литералы (C++14)  
 Двоичный литерал можно задать с помощью префикса `0B` или `0b` и последовательности, состоящей из 1 и 0:  
  
```  
  
auto x = 0B001101 ; // int  
auto y = 0b000001 ; // int  
```  
  
## <a name="avoid-using-literals-as-magic-constants"></a>Избегайте использования литералов как «магических констант»  
 Несмотря на то что это не всегда является хорошим стилем программирования, можно использовать литералы непосредственно в выражениях и операторах:  
  
```  
if (num < 100)  
    return "Success";  
  
```  
  
 В предыдущем примере, возможно, лучше было бы использовать именованную константу, которая более точно передает смысл, например MAXIMUM_ERROR_THRESHOLD. И если возвращаемое значение Success видят конечные пользователи, то, возможно, лучше было бы использовать именованную строковую константу, которая хранится в одном месте в файле, где ее можно локализовать на другие языки. Использование именованных констант помогает вам и другим пользователям понимать назначение кода.  
  
## <a name="see-also"></a>См. также  
 [Лексические соглашения](../cpp/lexical-conventions.md)   
 [Строковые литералы в C++](../cpp/string-and-character-literals-cpp.md)   
 [Определяемые пользователем литералы C++](../cpp/user-defined-literals-cpp.md)