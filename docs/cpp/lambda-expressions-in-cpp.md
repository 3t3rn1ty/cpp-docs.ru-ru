---
title: "Лямбда-выражения в C++ | Документы Microsoft"
ms.custom: 
ms.date: 07/19/2017
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-language
ms.tgt_pltfrm: 
ms.topic: language-reference
dev_langs:
- C++
helpviewer_keywords:
- lambda expressions [C++]
- lambda expressions [C++], overview
- lambda expressions [C++], vs. function objects
ms.assetid: 713c7638-92be-4ade-ab22-fa33417073bf
caps.latest.revision: 
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: 035fe5c222f6de5b3f0d71c0ce9133c1101f2993
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="lambda-expressions-in-c"></a>Лямбда-выражения в C++
В C ++ 11 и более поздних версиях лямбда-выражение — часто называют *лямбда-выражение*— это удобный способ определения анонимного объекта-функции ( *замыкание*) непосредственно в месте, где его вызова или передана в качестве аргумента в функцию. Обычно лямбда-выражения используются для инкапсуляции нескольких строк кода, передаваемых алгоритмам или асинхронным методам. В этой статье приводится определение лямбда-выражений, их сравнение с другими методами программирования, описание их преимуществ и простой пример.  

## <a name="related-topics"></a>См. также
- [Лямбда-выражения или объекты функций](lambda-expression-syntax.md)
- [Работа с лямбда-выражения](examples-of-lambda-expressions.md)
- [constexpr лямбда-выражения](lambda-expressions-constexpr.md)

## <a name="parts-of-a-lambda-expression"></a>Структура лямбда-выражения  
 В стандарте ISO C++ демонстрируется простое лямбда-выражение, передаваемое функции `std::sort()` в качестве третьего аргумента:  
  
```cpp  
#include <algorithm>  
#include <cmath>  
  
void abssort(float* x, unsigned n) {  
    std::sort(x, x + n,  
        // Lambda expression begins  
        [](float a, float b) {  
            return (std::abs(a) < std::abs(b));  
        } // end of lambda expression  
    );  
}  
  
```  
  
 На следующем рисунке показана структура лямбда-выражения:  
  
 ![Структурные элементы лямбда-выражения](../cpp/media/lambdaexpsyntax.png "LambdaExpSyntax")  
  
1.  *предложение фиксации* (также известный как *лямбда-выражение introducer* в спецификации C++.)  
  
2.  *список параметров* необязательно. (Также известный как *декларатор лямбда-выражение*)  
  
3.  *Отключаемая спецификация* необязательно.  
  
4.  *Спецификация исключения* необязательно.  
  
5.  *Trailing-return-type* необязательно.  
  
6.  *тело лямбда-выражения*)  
  
### <a name="capture-clause"></a>Предложение фиксации  
 Лямбда-выражения могут вводиться новые переменные в его теле (в **C ++ 14**) и его можно также доступ, или *захвата*, переменные из окружающей области видимости. Лямбда-выражение начинается с предложения фиксации (*лямбда-выражение introducer* в синтаксисе стандарта), который указывает переменные, которые отслеживаются, и является ли запись по значению или по ссылке. Доступ к переменным с префиксом с амперсандом (`&`) осуществляется по ссылке, а к переменным без префикса — по значению.  
  
 Пустое предложение фиксации (`[ ]`) показывает, что тело лямбда-выражения не осуществляет доступ к переменным во внешней области видимости.  
  
 Можно использовать режим фиксации по умолчанию (*отслеживания по умолчанию* в синтаксисе стандарта), чтобы задать способ фиксации внешних переменных, на которые ссылается лямбда-выражения: `[&]` означает отражаются все переменные, которые ссылаются на ссылка, и `[=]` означает захваченные по значению. Можно сначала использовать режим фиксации по умолчанию, а затем применить для определенных переменных другой режим. Например, если тело лямбда-выражения осуществляет доступ к внешней переменной `total` по ссылке, а к внешней переменной `factor` по значению, следующие предложения фиксации эквивалентны:  
  
```cpp  
[&total, factor]  
[factor, &total]  
[&, factor]  
[factor, &]  
[=, &total]  
[&total, =]  
```  
  
 При использовании отслеживания по умолчанию, регистрируются только переменные, упомянутые в лямбда-выражения.  
  
 Если предложение фиксации включает записи по умолчанию `&`, ни один `identifier` в `capture` для отслеживания предложения не может иметь форму `& identifier`. Аналогично Если предложение фиксации включает записи по умолчанию `=`, ни один `capture` для отслеживания предложения не может иметь форму `= identifier`. Идентификатор или `this` не могут использоваться более одного раза в предложении захвата. В следующем фрагменте кода приводится несколько примеров.  
  
```cpp  
struct S { void f(int i); };  
  
void S::f(int i) {  
    [&, i]{};      // OK  
    [&, &i]{};     // ERROR: i preceded by & when & is the default  
    [=, this]{};   // ERROR: this when = is the default  
    [=, *this]{ }; // OK: captures this by value. See below.
    [i, i]{};      // ERROR: i repeated  
}  
```  
  
 Отслеживания последующим многоточием является расширением пакета, как показано в следующем [с переменным числом аргументов шаблона](../cpp/ellipses-and-variadic-templates.md) пример:  
  
```cpp  
template<class... Args>  
void f(Args... args) {  
    auto x = [args...] { return g(args...); };  
    x();  
}  
```  
  
 Чтобы использовать лямбда-выражения в теле метода класса, необходимо передать указатель `this` предложению фиксации, чтобы обеспечить доступ к методам и данным-членам включающего класса. 
 
**Visual Studio 2017 г 15,3 и более поздних версий** (с [/std: c ++ 17](../build/reference/std-specify-language-standard-version.md)): `this` указатель могут захватываться по значению, указав `*this` в предложении захвата. Записи по значению означает, что весь *закрытия*, который является объектом анонимной функции, encapulates лямбда-выражения, копируется каждого вызова, где вызывается лямбда-выражения. Запись в значение полезно в том случае, если лямбда-выражения будут выполнены в параллельных или асинхронных операций, особенно на определенных аппаратной архитектурой, например NUMA. 

Пример, демонстрирующий использование лямбда-выражений с методами классов см. в разделе «Пример: с помощью лямбда-выражения в методе» в [примеры лямбда-выражения](../cpp/examples-of-lambda-expressions.md).  
  
 При использовании предложения фиксации рекомендуется помнить об этих важных аспектах, особенно при использовании лямбда-выражений с многопоточностью:  
  
-   Фиксацию ссылок можно использовать для изменения переменных снаружи, тогда как фиксацию значений нельзя. (`mutable` позволяет изменять копии, но не оригиналы.)  
  
-   Фиксация ссылок отражает изменение переменных снаружи, тогда как фиксация значений — нет.  
  
-   Фиксация ссылки вводит зависимость от времени существования, тогда как фиксация значения не обладает зависимостями от времени существования. Это особенно важно в случае асинхронного использования лямбда-выражений. Если в асинхронном лямбда-выражении по ссылке фиксируется локальная переменная, вполне вероятно, что к моменту его вызова она станет недоступной, что вызовет исключение нарушения прав доступа во время выполнения.  
  
### <a name="generalized-capture-c-14"></a>Обобщенная фиксация (C++14)  
  
 В C++14 вы можете объявлять и инициализировать новые переменные в предложении фиксации. Для этого не требуется, чтобы эти переменные существовали во внешней области видимости лямбда-функции. Инициализация может быть выражена в качестве любого произвольного выражения. Тип новой переменной определяется типом, который создается выражением. Одно из преимуществ этой возможности заключается в том, что в C++14 таким образом можно фиксировать переменные из окружающей области видимости, доступные только для перемещения (например std::unique_ptr), и использовать их в лямбда-выражении.  
  
```cpp  
pNums = make_unique<vector<int>>(nums);  
//...  
      auto a = [ptr = move(pNums)]()  
        {  
           // use ptr  
        };  
```  
  
### <a name="parameter-list"></a>Список параметров  
 В дополнение к возможности фиксации переменных, лямбда-выражения могут принимать входные параметры. Список параметров (*декларатор лямбда-выражения* в синтаксисе стандарта) является необязательным и по большей части походит на список параметров для функции.  
  
```cpp  
auto y = [] (int first, int second)  
{  
    return first + second;  
};  
  
```  
  
 В **c ++ 14**, если тип параметра является универсальным, можно использовать ключевое слово auto, как спецификатор типа. Это отдает компилятору команду создать оператор вызова функции в качестве шаблона. Каждый экземпляр ключевого слова auto в списке параметров эквивалентен параметру отдельного типа.  
  
```cpp  
auto y = [] (auto first, auto second)  
{  
    return first + second;  
};  
```  
  
 Лямбда-выражение может принимать другое лямбда-выражение в качестве своего аргумента. Дополнительные сведения см. в разделе «Лямбда-выражения высшего порядка» в разделе [примеры лямбда-выражения](../cpp/examples-of-lambda-expressions.md).  
  
 Поскольку список параметров является необязательным, можно опустить пустые скобки, если аргументы не передаются в лямбда-выражение и его декларатора лямбда-выражение не содержит *спецификацией исключений*,  *Trailing-return-type*, или `mutable`.  
  
### <a name="mutable-specification"></a>Отключаемая спецификация  
 Как правило, оператор вызова функции лямбда-выражения является константой по значению, но ключевое слово `mutable` отменяет это. Он не создает изменяемые данные-члены. Отключаемая спецификация позволяет телу лямбда-выражения изменять переменные, захваченные по значению. Некоторые примеры далее в этой статье демонстрируют использование ключевого слова `mutable`.  
  
### <a name="exception-specification"></a>Спецификация исключений  
 Можно использовать спецификацию исключений `noexcept`, чтобы указать, что лямбда-выражение не создает исключений. Как и с обычными функциями, компилятор Visual C++ создает предупреждение [C4297](../error-messages/compiler-warnings/compiler-warning-level-1-c4297.md) Если лямбда-выражение объявляет `noexcept` спецификацией исключений и тело лямбда-выражения вызывает исключение, как показано ниже:  
  
```cpp  
// throw_lambda_expression.cpp  
// compile with: /W4 /EHsc   
int main() // C4297 expected  
{  
   []() noexcept { throw 5; }();  
}  
```  
  
 Дополнительные сведения см. в разделе [спецификации исключений (throw)](../cpp/exception-specifications-throw-cpp.md).  
  
### <a name="return-type"></a>Возвращаемый тип  
 Тип возвращаемого значения лямбда-выражения выводится автоматически. Нет необходимости в использовании [автоматически](../cpp/auto-cpp.md) ключевое слово, если не указать *trailing-return-type*. *Trailing-return-type* напоминает часть возвращаемого типа обычного метода или функции. Однако тип возвращаемого значения следует списку параметров, и необходимо включить ключевое слово `->` элемента trailing-return-type перед типом возвращаемого значения.  
  
 Можно опустить часть возвращаемого типа лямбда-выражения, если тело лямбда-выражения содержит только один оператор return или лямбда-выражение не возвращает значение. Если тело лямбда-выражения содержит один оператор return, компилятор выводит тип возвращаемого значения из типа возвращаемого выражения. В противном случае компилятор выводит следующий тип возвращаемого значения: `void`. Рассмотрим следующие примеры кода, иллюстрирующие этот принцип.  
  
```cpp  
auto x1 = [](int i){ return i; }; // OK: return type is int  
auto x2 = []{ return{ 1, 2 }; };  // ERROR: return type is void, deducing   
                                  // return type from braced-init-list is not valid  
```  
  
 Лямбда-выражение может создавать другое лямбда-выражение в качестве своего возвращаемого значения. Дополнительные сведения см. в разделе «Лямбда-выражения высшего порядка» в [примеры лямбда-выражения](../cpp/examples-of-lambda-expressions.md).  
  
### <a name="lambda-body"></a>Тело лямбда-выражения  
 Тело лямбда-выражения (*составной оператор* в синтаксисе стандарта) из лямбда-выражение, выражение может содержать все, что и тело обычного метода или функции. Тело обычной функции и лямбда-выражения может осуществлять доступ к следующим типам переменных:  
  
-   Фиксированные переменные из внешней области видимости (см. выше).  
  
-   Параметры  
  
-   Локально объявленные переменные  
  
-   Данные-члены класса (при объявлении внутри класса и фиксации `this`)  
  
-   Любая переменная, которая имеет статическую длительность хранения (например, глобальная переменная)  
  
 В следующем примере содержится лямбда-выражение, которое явно фиксирует переменную `n` по значению и неявно фиксирует переменную `m` по ссылке.  
  
```cpp  
// captures_lambda_expression.cpp  
// compile with: /W4 /EHsc   
#include <iostream>  
using namespace std;  
  
int main()  
{  
   int m = 0;  
   int n = 0;  
   [&, n] (int a) mutable { m = ++n + a; }(4);  
   cout << m << endl << n << endl;  
}  
```  
  
```Output  
5  
0  
```  
  
 Поскольку переменная `n` фиксируется по значению, ее значение после вызова лямбда-выражения остается равным `0`. Спецификация `mutable` позволяет изменять `n` внутри лямбда-выражения.  
  
 Несмотря на то что лямбда-выражение может фиксировать только переменные с автоматической длительностью хранения, в теле лямбда-выражения можно использовать переменные, которые имеют статическую длительность хранения. В следующем примере функция `generate` и лямбда-выражение используются для присвоения значения каждому элементу объекта `vector`. Лямбда-выражение изменяет статическую переменную для получения значения следующего элемента.  
  
```cpp  
void fillVector(vector<int>& v)  
{  
    // A local static variable.  
    static int nextValue = 1;  
  
    // The lambda expression that appears in the following call to  
    // the generate function modifies and uses the local static   
    // variable nextValue.  
    generate(v.begin(), v.end(), [] { return nextValue++; });   
    //WARNING: this is not thread-safe and is shown for illustration only  
}  
```  
  
 Дополнительные сведения см. в разделе [создания](../standard-library/algorithm-functions.md#generate).  
  
 В следующем примере кода используется функция из предыдущего примера и добавляется пример лямбда-выражения, которая использует алгоритм стандартной библиотеки C++ `generate_n`. Это лямбда-выражение назначает элемент объекта `vector` сумме предыдущих двух элементов. Ключевое слово `mutable` используется, чтобы тело лямбда-выражения могло изменять соответствующие копии внешних переменных `x` и `y`, захваченные лямбда-выражением по значению. Поскольку лямбда-выражение захватывает исходные переменные `x` и `y` по значению, их значения остаются равными `1` после выполнения лямбда-выражения.  
  
```cpp  
// compile with: /W4 /EHsc  
#include <algorithm>  
#include <iostream>  
#include <vector>  
#include <string>  
  
using namespace std;  
  
template <typename C> void print(const string& s, const C& c) {  
    cout << s;  
  
    for (const auto& e : c) {  
        cout << e << " ";  
    }  
  
    cout << endl;  
}  
  
void fillVector(vector<int>& v)  
{  
    // A local static variable.  
    static int nextValue = 1;  
  
    // The lambda expression that appears in the following call to  
    // the generate function modifies and uses the local static   
    // variable nextValue.  
    generate(v.begin(), v.end(), [] { return nextValue++; });  
    //WARNING: this is not thread-safe and is shown for illustration only  
}  
  
int main()  
{  
    // The number of elements in the vector.  
    const int elementCount = 9;  
  
    // Create a vector object with each element set to 1.  
    vector<int> v(elementCount, 1);  
  
    // These variables hold the previous two elements of the vector.  
    int x = 1;  
    int y = 1;  
  
    // Sets each element in the vector to the sum of the   
    // previous two elements.  
    generate_n(v.begin() + 2,  
        elementCount - 2,  
        [=]() mutable throw() -> int { // lambda is the 3rd parameter  
        // Generate current value.  
        int n = x + y;  
        // Update previous two values.  
        x = y;  
        y = n;  
        return n;  
    });  
    print("vector v after call to generate_n() with lambda: ", v);  
  
    // Print the local variables x and y.  
    // The values of x and y hold their initial values because   
    // they are captured by value.  
    cout << "x: " << x << " y: " << y << endl;  
  
    // Fill the vector with a sequence of numbers  
    fillVector(v);  
    print("vector v after 1st call to fillVector(): ", v);  
    // Fill the vector with the next sequence of numbers  
    fillVector(v);  
    print("vector v after 2nd call to fillVector(): ", v);  
}  
```  
  
```Output  
vector v after call to generate_n() with lambda: 1 1 2 3 5 8 13 21 34  
x: 1 y: 1  
vector v after 1st call to fillVector(): 1 2 3 4 5 6 7 8 9  
vector v after 2nd call to fillVector(): 10 11 12 13 14 15 16 17 18  
```  
  
 Дополнительные сведения см. в разделе [generate_n](../standard-library/algorithm-functions.md#generate_n).  

## <a name="constexpr-lambda-expressions"></a>constexpr лямбда-выражения
**Visual Studio 2017 г 15,3 и более поздних версий** (с [/std: c ++ 17](../build/reference/std-specify-language-standard-version.md)): лямбда-выражение может быть объявлен как `constexpr` или использоваться в константном выражении при инициализации каждого элемента данных, что он захватывает или вводит может в константном выражении.  

```cpp
    int y = 32;
    auto answer = [y]() constexpr 
    {
        int x = 10;
        return y + x; 
    };

    constexpr int Increment(int n) 
    {
        return [n] { return n + 1; }();
    }

``` 
Лямбда-выражение неявно является `constexpr` если его результат не соответствует требованиям `constexpr` функции:
```cpp
    auto answer = [](int n) 
    {
        return 32 + n; 
    };

    constexpr int response = answer(10);
``` 
Если лямбда-выражение, явно или неявно `constexpr`, выводятся преобразования в указатель на функцию `constexpr` функции:

```cpp
    auto Increment = [](int n)
    {
        return n + 1;
    };

    constexpr int(*inc)(int) = Increment;
```
  
## <a name="microsoft-specific"></a>Только для систем Майкрософт  
 Лямбда-выражения не поддерживаются в следующих управляемых сущностях среды CLR: `ref class`, `ref struct`, `value class` и `value struct`.  
  
 При использовании модификатора специфичные для Microsoft, такие как [__declspec](../cpp/declspec.md), его можно вставить в лямбда-выражение сразу же после `parameter-declaration-clause`, например:  
  
```cpp  
auto Sqr = [](int t) __declspec(code_seg("PagedMem")) -> int { return t*t; };  
```  
  
 Чтобы определить, поддерживается ли модификатор лямбда-выражения, см. в статье о нем на [модификаторы, используемые Microsoft](../cpp/microsoft-specific-modifiers.md) раздел документации.  
  
 Дополнение C ++ 11 лямбда-выражений стандарта функциональности Visual Studio поддерживает преобразовывать лямбда-выражения, которые являются универсально преобразуемыми в указатели функций с произвольными соглашениями о вызовах.  
  
## <a name="see-also"></a>См. также  
 [Справочник по языку C++](../cpp/cpp-language-reference.md)   
 [Объекты функций в стандартной библиотеке C++](../standard-library/function-objects-in-the-stl.md)   
 [Вызов функции](../cpp/function-call-cpp.md)   
 [for_each](../standard-library/algorithm-functions.md#for_each)
