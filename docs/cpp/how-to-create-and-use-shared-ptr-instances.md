---
title: "Практическое руководство. Создание и использование экземпляров shared_ptr | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
ms.assetid: 7d6ebb73-fa0d-4b0b-a528-bf05de96518e
caps.latest.revision: 15
caps.handback.revision: 15
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Практическое руководство. Создание и использование экземпляров shared_ptr
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Тип `shared_ptr` интеллектуального указателя в C стандартной библиотеке C\+\+, которая предназначена для сценариев, в которых несколько владелец может управлять временем существования объекта в памяти.  После инициализации `shared_ptr` можно скопировать, передает его значение в аргументах функции и присвоить его другим экземплярам `shared_ptr`.  Все экземпляры указывают на один объект, и используют доступ к одному «блок элемента управления» эти этапы и декременты счетчик ссылок при создании нового `shared_ptr` добавляется, выходит за пределы области, или сброшены.  Когда число ссылок достигает нуля, блок элемента управления сам памяти и удаляет ресурс.  
  
 На следующем рисунке показаны несколько экземпляров `shared_ptr`, указывающих на одно расположение в памяти.  
  
 [![Общий указатель](../cpp/media/shared_ptr.png "shared\_ptr")](assetId:///9785ad08-31d8-411a-86a9-fb9cd9684c27)  
  
## Пример  
 Если возможно, используйте функцию [make\_shared](../Topic/make_shared%20\(%3Cmemory%3E\).md) для создания `shared_ptr` при ресурс памяти создается в первый раз.  `make_shared` исключений безопасным образом.  Он использует тот же вызов для распределения памяти для блока элементов управления и ресурсов, поэтому снижает нагрузку на систему построения.  Если не используется `make_shared`, необходимо использовать явное новое выражение для создания объекта до его необходимо передать в конструктор `shared_ptr`.  В следующем примере показаны различные способы объявления и инициализации `shared_ptr` вместе с новым объектом.  
  
 [!code-cpp[stl_smart_pointers#1](../cpp/codesnippet/CPP/how-to-create-and-use-shared-ptr-instances_1.cpp)]  
  
## Пример  
 В следующем примере показано, как объявить и инициализировать экземпляры `shared_ptr`, принимающие на общий владельца объекта, который уже был выбран другой `shared_ptr`.  Высказывать `sp2` инициализированное `shared_ptr`.  
  
 [!code-cpp[stl_smart_pointers#2](../cpp/codesnippet/CPP/how-to-create-and-use-shared-ptr-instances_2.cpp)]  
  
## Пример  
 `shared_ptr` полезно в контейнерах \(STL\) стандартной библиотеки шаблонов при использовании алгоритмы, скопируйте элементы.  Элементы можно использованих программы\-оболочек в `shared_ptr`, а затем скопируйте его в другие контейнеры, команда должна понимать, что основной памяти допустима, если это необходимо, и не.  В следующем примере показано, как использовать алгоритм `replace_copy_if` в экземплярах `shared_ptr` в векторе.  
  
 [!code-cpp[stl_smart_pointers#4](../cpp/codesnippet/CPP/how-to-create-and-use-shared-ptr-instances_3.cpp)]  
  
## Пример  
 Можно использовать `dynamic_pointer_cast`, `static_pointer_cast` и `const_pointer_cast` приведение `shared_ptr`.  Эти функции похожи на `dynamic_cast`, `static_cast` и операторы `const_cast`.  В следующем примере показано, как выполнить производный тип каждого элемента в векторе `shared_ptr` базовых классов, а затем скопировать элементы и отображение информации о них.  
  
 [!code-cpp[stl_smart_pointers#5](../cpp/codesnippet/CPP/how-to-create-and-use-shared-ptr-instances_4.cpp)]  
  
## Пример  
 Можно передать `shared_ptr` другой функции следующими способами:  
  
-   Передайте `shared_ptr` значение.  Это вызывает конструктор копии, увеличивает счетчик ссылок и делает вызываемым объектом владельца.  Минимальный объем нагрузки в этой операции, которая может быть значительно в зависимости от количества объектов `shared_ptr` при передаче.  Этот параметр следует использовать, когда контракт кода \(явный или неявный\) между вызывающим и вызываемым объектами требует вызываемый объект dbo.  
  
-   Передайте `shared_ptr` ссылкой или константной.  В этом случае число ссылок не инкрементирован и вызываемый объект может получить указатель, если вызывающий объект не выходит за пределы области действия.  Или, вызываемый объект может потребоваться создание `shared_ptr` на основе ссылки, и поэтому переход общий dbo.  Используйте этот параметр, если вызывающий объект не имеет статью вызываемого объекта, или при необходимости передать `shared_ptr` и хотелось бы избежать копирования для повышения производительности.  
  
-   Передайте основной указатель или ссылку к базовому объекту.  Это позволяет использовать объект вызываемый объект, но не позволяет использовать его владельца или продлить время существования.  Если вызываемый объект создает `shared_ptr` из начального указателем, новое `shared_ptr` независимо от исходного и не делает элемент управления является основным ресурсом.  Этот параметр следует использовать, когда контракт между вызывающим и вызываемым объектом, указывает, что вызывающий объект сохраняет владение времени существования `shared_ptr`.  
  
-   При принятии решения о том, как передавать `shared_ptr`, определения, должен ли вызываемый объект владельца основного совместное использование ресурсов.  «Владелец» объект или функция которого может хранить основной ресурс в активном состоянии, пока ему нужно.  Если вызывающий объект должен гарантировать, что вызываемый объект можно расширить жизненный указателя за его \(времени существования функции\), используйте первый вариант.  Если не заботите, увеличивает ли вызываемый объект время существования, а затем передать по ссылке и оставляет вызываемому объекту копирования или нет.  
  
-   Если необходимо предоставить доступ к базовому вспомогательной функции указателя, и известно, что вспомогательная функция просто будет использовать указатель и будет возвращать до вызывающая функция возвращает, то, что функция не должна использовать владельца основного указателя.  Она просто должна получить указатель за время существования `shared_ptr` вызывающего объекта.  В этом случае безопасно передавать `shared_ptr` по ссылке, или передайте необработанный указатель или ссылку к базовому объекту.  Этот способ передачи предоставляет небольшое преимущество в производительности, а также может помочь представить в программировании предназначение.  
  
-   В некоторых случаях, например в `std:vector<shared_ptr<T>>`, можно передать каждое `shared_ptr` к объекту или именованной тела функции лямбда\-выражения.  Если лямбда\-выражение или функция не сохраняет указатель, передайте `shared_ptr` в отношении избегайте вызова конструктора для каждого элемента.  
  
 [!CODE [stl_smart_pointers#6](../CodeSnippet/VS_Snippets_Cpp/stl_smart_pointers#6)]  
  
## Пример  
 В следующем примере показано, как `shared_ptr` в различных операторов сравнения для включения сравнения указателя на память, которая принадлежит экземплярами `shared_ptr`.  
  
 [!code-cpp[stl_smart_pointers#3](../cpp/codesnippet/CPP/how-to-create-and-use-shared-ptr-instances_6.cpp)]  
  
## См. также  
 [Интеллектуальные указатели](../cpp/smart-pointers-modern-cpp.md)