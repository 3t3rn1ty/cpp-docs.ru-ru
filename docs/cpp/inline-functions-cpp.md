---
title: "Встроенные функции (C++) | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-language
ms.tgt_pltfrm: 
ms.topic: language-reference
f1_keywords:
- __forceinline_cpp
- __inline_cpp
- inline_cpp
dev_langs: C++
helpviewer_keywords: inline functions [C++], class members
ms.assetid: 355f120c-2847-4608-ac04-8dda18ffe10c
caps.latest.revision: "11"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.openlocfilehash: 9b4d4ad6a2fbfbb30fe5f0b465c8bb70753cd701
ms.sourcegitcommit: ebec1d449f2bd98aa851667c2bfeb7e27ce657b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/24/2017
---
# <a name="inline-functions-c"></a>Встраиваемые функции (C++)
Функция, определенная в теле объявления класса, является встраиваемой.  
  
## <a name="example"></a>Пример  
 В показанном ниже объявлении класса конструктор `Account` является встроенной функцией. Функции-члены `GetBalance`, `Deposit`, и `Withdraw` не указаны как **встроенного** , но могут быть реализованы как встраиваемые функции.  
  
```  
// Inline_Member_Functions.cpp  
class Account  
{  
public:  
    Account(double initial_balance) { balance = initial_balance; }  
    double GetBalance();  
    double Deposit( double Amount );  
    double Withdraw( double Amount );  
private:  
    double balance;  
};  
  
inline double Account::GetBalance()  
{  
    return balance;  
}  
  
inline double Account::Deposit( double Amount )  
{  
    return ( balance += Amount );  
}  
  
inline double Account::Withdraw( double Amount )  
{  
    return ( balance -= Amount );  
}  
int main()  
{  
}  
```  
  
> [!NOTE]
>  В объявлении класса функции объявлены без **встроенного** ключевое слово. **Встроенного** ключевое слово можно указать в объявлении класса; результат будет такой же.  
  
 Заданная встроенная функция-член должна быть объявлена одинаково в каждом блоке компиляции. Из-за этого ограничения встроенные функции работают так же, как если бы они были созданными экземплярами функций. Кроме того, должно существовать только одно определение встраиваемой функции.  
  
 Функции-члена класса по умолчанию внешняя компоновка, если определение этой функции не содержит **встроенного** спецификатор. Предыдущий пример показывает, что эти функции требуется не объявлять явно с **встроенного** описатель; с помощью **встроенного** в функции определения результате она является встроенной функцией. Однако нельзя повторно объявить функцию как **встроенного** после вызова этой функции.  
  
## <a name="inline-inline-and-forceinline"></a>Встроенные, __inline, и \__forceinline  
 Спецификаторы `inline` и `__inline` предписывает компилятору вставить копию тела функции в каждое место, где в котором эта функция вызывается.  
  
 Такая вставка (она называется подстановкой или встраиванием) выполняется только в том случае, если проведенный компилятором анализ затрат и выгод показывает, что это может дать выигрыш. Подстановка снимает нагрузку на вызов функции, иногда ценой увеличения размера кода.  
  
 Ключевое слово `__forceinline` отключает анализ затрат и выгод; в этом случае преимущество имеет мнение программиста. При использовании ключевого слова `__forceinline` необходимо проявлять осмотрительность. Постоянное использование ключевого слова `__forceinline` может привести к увеличению кода с минимальным приростом производительности, а в некоторых случаях даже с падением производительности (например, поскольку большой исполняемый файл требует более активного использования подкачки).  
  
 Применение подставляемых функций может ускорить выполнение программ, поскольку устраняет нагрузку на вызов функций. Для подставляемых функций выполняются оптимизации кода, которые недоступны для обычных функций.  
  
 Параметры и ключевые слова подстановки компилятор обрабатывает как рекомендации. Подстановка функции не гарантируется. Принудительно включить подстановку конкретной функции невозможно, даже при помощи ключевого слова `__forceinline`. При компиляции с параметром **/CLR**, компилятор не будет подставлять функцию при наличии атрибутов безопасности, применяемых в функцию.  
  
 **Встроенного** ключевое слово доступно только в C++. Ключевые слова `__inline` и `__forceinline` доступны как в C, так и в C++. Для обеспечения совместимости с предыдущими версиями **_inline** является синонимом `__inline`.  
  
 **Встроенного** ключевое слово сообщает компилятору, что подстановка является предпочтительной. Однако компилятор может создать отдельный экземпляр функции и вместо подстановки кода создать стандартную компоновку вызова. Существует две ситуации, в которых это может происходить.  
  
-   Рекурсивные функции.  
  
-   Функции, на которые создаются ссылки посредством указателя в любом месте блока трансляции.  
  
 Этим причинам может помешать встраивание, *как с некоторыми другими*, по своему усмотрению компилятора; вам не следует полагаться на **встроенного** вызовет подстановку функции.  
  
 Как при использовании обычных функций, для встраиваемых функций нет заданного порядка вычисления аргументов. Фактически он может отличаться от порядка, в котором аргументы вычисляются при передаче с использованием обычного протокола вызова функций.  
  
 [/Ob](../build/reference/ob-inline-function-expansion.md) параметр оптимизации компилятора помогает определить, происходит ли фактически подставляемых функций.  
  
 [/ Параметр LTCG](../build/reference/ltcg-link-time-code-generation.md) выполняет межмодульную подстановку вне зависимости от того, была ли она запрошена в исходном коде.  
  
### <a name="example-1"></a>Пример 1  
  
```  
// inline_keyword1.cpp  
// compile with: /c  
inline int max( int a , int b ) {  
   if( a > b )   
      return a;  
   return b;  
}  
```  
  
 Функции-члены класса могут объявляться как подставляемые либо при помощи **встроенного** ключевое слово или поместив определения функции в определении класса.  
  
### <a name="example-2"></a>Пример 2  
  
```  
// inline_keyword2.cpp  
// compile with: /EHsc /c  
#include <iostream>  
using namespace std;  
  
class MyClass {  
public:  
   void print() { cout << i << ' '; }   // Implicitly inline  
private:  
   int i;  
};  
```  
  
### <a name="microsoft-specific"></a>Блок, относящийся только к системам Microsoft  
 `__inline` Ключевое слово является эквивалентом **встроенного**.  
  
 Даже если используется ключевое слово `__forceinline`, компилятор не может выполнять подстановку кода во всех ситуациях. Компилятор не выполняет подстановку, если:  
  
-   Функция или вызывающий ее объект скомпилированы с параметром /Ob0 (параметр по умолчанию для отладочной сборки).  
  
-   В функции и вызывающем объекте используются разные типы (в одном — обработка исключений C++, а в другом — структурированная).  
  
-   Функция имеет переменное число аргументов.  
  
-   В функции используется встроенный код ассемблера (кроме случаев компиляции с параметром /Og, /Ox, /O1 или /O2).  
  
-   Функция является рекурсивной и не сопровождается **#pragma inline_recursion(on)**. С помощью этой директивы выполняется подстановка рекурсивных функций с глубиной по умолчанию, 16 вызовам. Чтобы уменьшить глубину подстановки, используйте [inline_depth](../preprocessor/inline-depth.md) pragma.  
  
-   Функция является виртуальной, и для нее используется виртуальный вызов. Прямые вызовы виртуальных функций могут подставляться.  
  
-   Программа принимает адрес функции, и вызов совершается через указатель на функцию. Прямые вызовы функций, чей адрес был принят, могут подставляться.  
  
-   Функция также помечена [naked](../cpp/naked-cpp.md) [__declspec](../cpp/declspec.md) модификатор.  
  
 Если компилятор не может выполнить подстановку функции, объявленные с `__forceinline`, он создает предупреждение уровня 1, за исключением случаев:
  
-   Функция компилируется с помощью /Od или параметром/Ob0. Не встраивания ожидается в таких случаях.     
  
-   Функция извне, определяется в библиотеке или другой записи преобразования, или целевого объекта виртуального вызова или косвенного вызова целевой. Компилятор не может определить неподставляемый код, который его не удается найти в текущей записи преобразования.  
  
 Рекурсивные функции можно подставляться до глубины, заданной директивой [inline_depth](../preprocessor/inline-depth.md) pragma, не более 16 вызовов. Начиная с этой глубины рекурсивные функции обрабатываются как вызовы на экземпляр функции.  Глубина, до которой эвристический поиск для подстановки функций проверяет рекурсивные функции, не может превышать 16 вызовов. [Inline_recursion](../preprocessor/inline-recursion.md) pragma управляет подстановкой подставляемых функций функции в настоящий момент расширения. В разделе [расширение встроенных функций](../build/reference/ob-inline-function-expansion.md) (/ Ob)-параметр компилятора для связанные сведения.  
  
**Завершение блока, относящегося только к системам Майкрософт**  
 Дополнительные сведения об использовании **встроенного** спецификатор, см.:  
  
-   [Подставляемые функции-члены класса](../cpp/inline-functions-cpp.md)  
  
-   [Определение встроенных функций C++ с помощью dllexport и dllimport](../cpp/defining-inline-cpp-functions-with-dllexport-and-dllimport.md)  
  
## <a name="when-to-use-inline-functions"></a>Когда использовать встраиваемые функции  
 Встроенные функции лучше использовать для небольших функций, например функций доступа к закрытым элементам данных. Основное назначение таких одно- и двухстрочных функций доступа — возвращение сведений о состоянии объектов; короткие функции чувствительны к рабочей нагрузке вызовов функций. Более длинные функции тратят пропорционально меньше времени на выполнение последовательности вызова и возврата. Встраивание дает им меньше преимуществ.  
  
 Объект `Point` класса можно определить следующим образом:  
  
```  
// when_to_use_inline_functions.cpp  
class Point  
{  
public:  
    // Define "accessor" functions as  
    //  reference types.  
    unsigned& x();  
    unsigned& y();  
private:  
    unsigned _x;  
    unsigned _y;  
};  
  
inline unsigned& Point::x()  
{  
    return _x;  
}  
inline unsigned& Point::y()  
{  
    return _y;  
}  
int main()  
{  
}  
```  
  
 При условии, что манипуляция координатами — относительно распространенная операция в клиенте такого класса, задание двух функций метода доступа (`x` и `y` в предыдущем примере) как **встроенного** обычно обеспечивает экономию временные затраты на:  
  
-   вызовы функций (включая передачу параметров и размещение адреса объекта в стеке);  
  
-   сохранение кадра стека вызывающего объекта;  
  
-   настройку нового кадра стека;  
  
-   передачу возвращаемого значения;  
  
-   восстановление старого кадра стека;  
  
-   Назад  
  
## <a name="inline-functions-vs-macros"></a>Встроенные функции и макросы  
 Хотя встраиваемые функции похожи на макросы (поскольку код функции разворачивается в точке вызова во время компиляции), встраиваемые функции анализируются компилятором, тогда как макросы разворачиваются препроцессором. В результате, имеется несколько важных различий.  
  
-   Встраиваемые функции выполняют все протоколы безопасности типов, обязательные для обычных функций.  
  
-   Подставляемые функции определяются с помощью того же синтаксиса как любая другая функция, за исключением того, что они содержат **встроенного** ключевое слово в объявлении функции.  
  
-   Выражения, передаваемые во встраиваемые функции в качестве аргументов, вычисляются один раз. В некоторых случаях выражения, передаваемые в макросы в качестве аргументов, можно вычислить несколько раз.  
  
 В следующем примере показан макрос, преобразующий строчные буквы в прописные.  
  
```  
// inline_functions_macro.c  
#include <stdio.h>  
#include <conio.h>  
  
#define toupper(a) ((a) >= 'a' && ((a) <= 'z') ? ((a)-('a'-'A')):(a))  
  
int main() {  
   char ch;  
   printf_s("Enter a character: ");  
   ch = toupper( getc(stdin) );  
   printf_s( "%c", ch );  
}  
//  Sample Input:  xyz  
// Sample Output:  Z  
  
```  
  
 Цель выражения `toupper(getc(stdin))` — что символ должны быть прочитаны с консольного устройства (`stdin`) и, при необходимости, переведенную в верхний регистр.  
  
 В результате реализации макроса `getc` выполняется один раз для определения того, больше или равен "a" символ, и один раз для определения того, меньше он или равен "z". Если символ находится в этом диапазоне, `getc` выполняется еще раз для преобразования символа в прописную букву. Это означает, что программа ожидает два или три символа, когда в идеальном случае она должна ожидать только один.  
  
 Встраиваемые функции позволяют устранить описанную выше проблему.  
  
```  
// inline_functions_inline.cpp  
#include <stdio.h>  
#include <conio.h>  
  
inline char toupper( char a ) {  
   return ((a >= 'a' && a <= 'z') ? a-('a'-'A') : a );  
}  
  
int main() {  
   printf_s("Enter a character: ");  
   char ch = toupper( getc(stdin) );  
   printf_s( "%c", ch );  
}  
```  
  
```Output  
Sample Input: a  
Sample Output: A  
```  
  
## <a name="see-also"></a>См. также  
 [noinline](../cpp/noinline.md)   
 [auto_inline](../preprocessor/auto-inline.md)