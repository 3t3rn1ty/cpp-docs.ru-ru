---
title: "Структурированная обработка исключений (C/C++) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "language-reference"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "обработка исключений С++, обработчики исключений"
  - "обработка исключений С++, обработчики завершения"
  - "структурированная обработка исключений"
  - "обработчики завершения, обработка исключений в C++"
  - "try-catch - ключевое слово [C++], обработчики исключений"
  - "try-catch - ключевое слово [C++], обработчики завершения"
ms.assetid: dd3b647d-c269-43a8-aab9-ad1458712976
caps.latest.revision: 14
caps.handback.revision: 12
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Структурированная обработка исключений (C/C++)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Хотя Windows и Visual C\+\+ поддерживают структурированную обработку исключений \(SEH\), настоятельно рекомендуется использовать обработку исключений C\+\+ в соответствии со стандартом ISO, поскольку это повышает переносимость и гибкость кода.  Однако в имеющемся коде или в программах определенных видов можно продолжать использовать SEH.  
  
## Блок, относящийся только к системам Microsoft  
  
## Грамматика  
 *оператор\-try\-except*:  
  
 `__try` *составной\-оператор*  
  
 `__except` \( `expression` \) *составной\-оператор*  
  
## Заметки  
 Обработка ошибок SEH позволяет в случае непредвиденного завершения программы корректно освободить все ресурсы, например блоки памяти и файлы.  Кроме того, она позволяет обрабатывать конкретные проблемы, например нехватку памяти, при помощи краткого структурированного кода, который не зависит от операторов `goto` или длительного тестирования кодов возврата.  
  
 Операторы try\-except и try\-finally, которые упоминаются в этом разделе, являются расширениями языка C для систем Microsoft.  Они поддерживают SEH, позволяя приложениям получать контроль над программой после событий, которые в иных ситуациях привели бы к завершению выполнения.  Хотя обработка ошибок SEH работает с исходными файлами C\+\+, она не была создана специально для этого языка.  Если SEH используется в программе на C\+\+, которая компилируется с параметром [\/EH](../build/reference/eh-exception-handling-model.md) \(вместе с некоторыми модификаторами\), то деструкторы для локальных объектов вызываются, однако прочие аспекты выполнения могут отличаться от ожидаемого.  \(См. пример далее в этой статье.\) В большинстве случаев вместо SHE рекомендуется использовать стандартную [обработку исключений C\+\+](../cpp/try-throw-and-catch-statements-cpp.md) согласно стандарту ISO, которая также поддерживается Visual C\+\+.  С помощью обработки исключений C\+\+ можно повысить переносимость кода и обрабатывать исключения любого типа.  
  
 При наличии модулей на C, в которых используется SEH, их можно использовать одновременно с модулями на C\+\+, в которых используется обработка исключений C\+\+.  Дополнительные сведения см. в статье [Различия в обработке исключений](../cpp/exception-handling-differences.md).  
  
 Существует два механизма SEH.  
  
-   [Обработчики исключений](../cpp/writing-an-exception-handler.md), которые могут реагировать на исключение или отбрасывать его.  
  
-   [Обработчики завершения](../cpp/writing-a-termination-handler.md), которые вызываются, когда исключение вызывает завершение в блоке кода.  
  
 Эти два типа обработчиков различаются, однако тесно взаимодействию в процессе, который называется "развертыванием стека". При возникновении исключения операционная система Windows ищет последний установленный обработчик исключений, который в данный момент активен.  Обработчик может выполнить одно из трех действий:  
  
-   не распознать исключение и передать управление другим обработчикам;  
  
-   распознать исключение, но отбросить его;  
  
-   распознать исключение и обработать его.  
  
 Обработчик исключений, распознавший исключение, может находиться за пределами функции, которая выполнялась, когда возникло исключение.  В некоторых случаях он может находиться в функции, хранящейся гораздо выше по стеку.  Выполняемая в настоящее время функция и все прочие функции в кадре стека завершаются.  Во время этого процесса стек "развертывается"; иными словами, из него удаляются локальные переменные и завершенные функции, если они не были определены с ключевым словом `static`.  
  
 По мере развертывания стека операционная система вызывает все обработчики завершения, которые были написаны для каждой функции.  При помощи обработчиков завершения можно освободить ресурсы, которые в противном случае оставались бы открытыми ненормального завершения.  Если был выполнен вход в критическую секцию, обработчик завершения можно использовать для выхода из нее.  Если ожидается завершение программы, можно выполнить другие задачи обслуживания, например закрыть и удалить временные файлы.  
  
 Дополнительные сведения:  
  
-   [Написание обработчика исключений](../cpp/writing-an-exception-handler.md)  
  
-   [Написание обработчика завершения](../cpp/writing-a-termination-handler.md)  
  
-   [Использование структурированной обработки исключений с C\+\+](../Topic/Using%20Structured%20Exception%20Handling%20with%20C++.md)  
  
## Пример  
 Как уже говорилось выше, деструкторы для локальных объектов вызываются, если в программе на C\+\+ используется обработка ошибок SEH, а сама программа скомпилирована с параметром **\/EH** с определенными модификаторами, например **\/EHsc** и **\/EHa**.  Однако если при этом используются исключения C\+\+, то поведение во время выполнения может отличаться от ожидаемого.  Это различие в поведении демонстрируется в следующем примере.  
  
```cpp  
#include <stdio.h>  
#include <Windows.h>  
#include <exception>  
  
class TestClass  
{  
public:  
    ~TestClass()  
    {  
        printf("Destroying TestClass!\r\n");  
    }  
};  
  
__declspec(noinline) void TestCPPEX()  
{  
#ifdef CPPEX  
    printf("Throwing C++ exception\r\n");  
    throw std::exception("");  
#else  
    printf("Triggering SEH exception\r\n");  
    volatile int *pInt = 0x00000000;  
    *pInt = 20;  
#endif  
}  
  
__declspec(noinline) void TestExceptions()  
{  
    TestClass d;  
    TestCPPEX();  
}  
  
int main()  
{  
    __try  
    {  
        TestExceptions();  
    }  
    __except(EXCEPTION_EXECUTE_HANDLER)  
    {  
        printf("Executing SEH __except block\r\n");  
    }  
  
    return 0;  
}  
  
```  
  
 Если при компиляции этого кода установлен параметр **\/EHsc**, однако локальное управление проверкой `CPPEX` не определено, то деструктор `TestClass` не выполняется, и вывод выглядит следующим образом:  
  
  **Triggering SEH exception**  
**Executing SEH \_\_except block** Если при компиляции кода установлен параметр **\/EHsc**, а `CPPEX` определено при помощи ключа `/DCPPEX` \(чтобы создавалось исключение C\+\+\), то деструктор `TestClass` выполняется, и вывод выглядит следующим образом:  
  
  **Throwing C\+\+ exception**  
**Destroying TestClass\!  Executing SEH \_\_except block**  Если при компиляции кода установлен параметр **\/EHa**, то деструктор `TestClass` выполняется вне зависимости от того, было ли исключение создано при помощи `std::throw` или при помощи обработки исключений SEH, которая создавала ошибку \(вне зависимости от того, было ли определено `CPPEX`\).  Вывод выглядит следующим образом.  
  
  **Throwing C\+\+ exception**  
**Destroying TestClass\!  Executing SEH \_\_except block**  Дополнительные сведения см. в статье [Параметр \/EH \(модель обработки исключений\)](../build/reference/eh-exception-handling-model.md).  
  
## Завершение блока, относящегося только к системам Майкрософт  
  
## См. также  
 [Обработка исключений](../cpp/exception-handling-in-visual-cpp.md)   
 [Ключевые слова в C\+\+](../cpp/keywords-cpp.md)   
 [\<exception\>](../standard-library/exception.md)   
 [Обработка ошибок и исключений](../cpp/errors-and-exception-handling-modern-cpp.md)   
 [Структурированная обработка исключений \(Windows\)](http://msdn.microsoft.com/library/windows/desktop/ms680657.aspx)