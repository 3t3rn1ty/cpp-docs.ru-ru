---
title: "Оператор try-finally | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-language
ms.tgt_pltfrm: 
ms.topic: language-reference
f1_keywords:
- __try
- __leave_cpp
- __leave
- __finally_cpp
- __try_cpp
- __finally
dev_langs:
- C++
helpviewer_keywords:
- __try keyword [C++]
- __finally keyword [C++]
- __leave keyword [C++]
- try-catch keyword [C++], try-finally keyword
- try-finally keyword [C++]
- __finally keyword [C++], try-finally statement syntax
- __leave keyword [C++], try-finally statement
- structured exception handling [C++], try-finally
ms.assetid: 826e0347-ddfe-4f6e-a7bc-0398e0edc7c2
caps.latest.revision: 14
author: mikeblome
ms.author: mblome
manager: ghogen
translation.priority.ht:
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- ru-ru
- zh-cn
- zh-tw
translation.priority.mt:
- cs-cz
- pl-pl
- pt-br
- tr-tr
ms.translationtype: HT
ms.sourcegitcommit: 6ffef5f51e57cf36d5984bfc43d023abc8bc5c62
ms.openlocfilehash: 5bfaa7d2a2f75fa479f135a61c15f9fcf3bbf5ca
ms.contentlocale: ru-ru
ms.lasthandoff: 09/25/2017

---
# <a name="try-finally-statement"></a>Оператор try-finally
**Блок, относящийся только к системам Майкрософт**  
  
 Следующий синтаксис описывает оператор `try-finally`:  
  
```  
__try {  
   // guarded code  
}  
__finally {  
   // termination code  
}  
```  
  
## <a name="grammar"></a>Грамматика  
 *try-finally-statement*:  
 `__try`*составной оператор*  
  
 `__finally`*составной оператор*  
  
 Оператор `try-finally` является расширением Microsoft для языков C и С++ и позволяет целевым приложениям гарантировать выполнение кода очистки при прерывании выполнения блока кода. Очистка включает такие задачи, как отмена распределения памяти, закрытие файлов и освобождение их дескрипторов. Оператор `try-finally` особенно полезен для подпрограмм, в которых в нескольких местах выполняется проверка на наличие ошибок, способных вызвать преждевременное возвращение из подпрограммы.  
  
 Сопутствующую информацию и пример кода см. в разделе [повторите-инструкции, за исключением](../cpp/try-except-statement.md). Дополнительные сведения о структурированной обработке исключений в общем см. в разделе [структурированную обработку исключений](../cpp/structured-exception-handling-c-cpp.md). Дополнительные сведения об обработке исключений в управляемых приложениях см. в разделе [обработка исключений в/CLR](../windows/exception-handling-cpp-component-extensions.md).  
  
> [!NOTE]
>  Структурированная обработка исключений поддерживается в Win32 для исходных файлов как на C, так и на C++. Однако она не предназначена специально для C++. Для того чтобы ваш код лучше переносился, лучше использовать механизм обработки исключений языка C++. Кроме того, этот механизм отличается большей гибкостью, поскольку может обрабатывать исключения любого типа. Для программ на языке C++, рекомендуется использовать механизм обработки исключений C++ ([try, catch и throw](../cpp/try-throw-and-catch-statements-cpp.md) инструкций).  
  
 Составной оператор после предложения `__try` представляет собой защищенный раздел. Составной оператор после предложения `__finally` является обработчиком завершения. Такой обработчик определяет набор действий, выполняемых при выходе из защищенного раздела независимо от того, происходит ли выход в результате исключения (ненормальное завершение) или в результате стандартной передачи управления дальше (нормальное завершение).  
  
 Управление достигает оператора `__try` в процессе обычного последовательного выполнения (передачи управления дальше). Если элемент управления входит в `__try`, становится активным соответствующий обработчик. Если поток элементов управления достигает конца блока try, выполнение продолжается следующим образом.  
  
1.  Вызывается обработчик завершения.  
  
2.  По окончании работы обработчика завершения выполнение продолжается после оператора `__finally`. Независимо от того как завершается защищенный раздел (например, оператором `goto` выхода из защищенного тела или оператором `return`), обработчик завершения выполняется перед (`before`) выходом потока элементов управления из защищенного раздела.  
  
     Объект **__finally** инструкции не блокирует поиск подходящий обработчик исключений.  
  
 Если исключение возникает в блоке `__try`, операционная система должна найти обработчик для исключения, либо программа завершится ошибкой. Если обработчик найден, любые и все блоки `__finally` выполняются и выполнение продолжается в обработчике.  
  
 Например, предположим, ряд вызовов функций связывает функцию А с функцией D, как показано на следующем рисунке. Каждая функция имеет один обработчик завершения. Если исключение создается в функции D и обрабатывается в функции А, обработчики завершения вызываются в том порядке, в котором система освобождает стек: D, C и B.  
  
 ![Порядок завершения &#45; выполнение обработчика](../cpp/media/vc38cx1.gif "vc38CX1")  
Порядок выполнения обработчиков завершения  
  
> [!NOTE]
>  Поведение оператора try-finally отличается от некоторых других языков, которые поддерживают использование **наконец**, таких как C#.  Один оператор `__try` может иметь либо `__finally`, либо `__except`, но не оба.  Если оба следует использовать одновременно, оператор try-except должен включать внутренней оператор try-finally.  Правила,задающие время выполнения каждого блока, также различаются.  
  
## <a name="the-leave-keyword"></a>Ключевое слово __leave  
 Ключевое слово `__leave` может использоваться только в защищенном разделе оператора `try-finally`. Оно приводит к тому, что выполнение переходит в конец защищенного раздела. Выполнение продолжается с первого оператора в обработчике завершения.  
  
 Оператор `goto` может также выйти из защищенного раздела, однако в этом случае производительность снизится, поскольку будет вызвано освобождение стека. Оператор `__leave` более эффективен, поскольку не вызывает освобождение стека.  
  
## <a name="abnormal-termination"></a>Аварийное завершение  
 Выход из `try-finally` инструкции с помощью [longjmp](../c-runtime-library/reference/longjmp.md) во время выполнения функция считается ненормальным завершением. Переход к оператору `__try` недопустим, но допустим выход из него. Все операторы `__finally`, которые активны между отправным пунктом (нормальным завершением блока `__try`) и точкой назначения (блоком `__except`, обрабатывающим исключение), должны быть запущены. Это называется "локальной раскруткой".  
  
 Если **повторите** блок завершается преждевременно по любой причине, включая выход из блока, система выполняет связанный **наконец** блок в рамках процесса очистки стека. В таких случаях [AbnormalTermination](http://msdn.microsoft.com/library/windows/desktop/ms679265) функция возвращает значение TRUE, если вызывается из **наконец** блока; в противном случае возвращается значение FALSE.  
  
 Если в процессе выполнения оператора `try-finally` процесс удаляется, обработчик завершения не вызывается.  
  
 **Завершение блока, относящегося только к системам Майкрософт**  
  
## <a name="see-also"></a>См. также  
 [Написание обработчика завершения](../cpp/writing-a-termination-handler.md)   
 [Структурированных исключений, обработки (C/C++)](../cpp/structured-exception-handling-c-cpp.md)   
 [Ключевые слова](../cpp/keywords-cpp.md)   
 [Обработчик завершения синтаксиса](http://msdn.microsoft.com/library/windows/desktop/ms681393)
