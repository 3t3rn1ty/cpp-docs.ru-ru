---
title: Передача аргументов и соглашения об именовании | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-language
ms.topic: language-reference
dev_langs:
- C++
helpviewer_keywords:
- argument passing [C++], conventions
- arguments [C++], widening
- coding conventions, arguments
- arguments [C++], passing
- registers, return values
- thiscall keyword [C++]
- naming conventions [C++], arguments
- arguments [C++], naming
- passing arguments [C++], conventions
- conventions [C++], argument names
ms.assetid: de468979-eab8-4158-90c5-c198932f93b9
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 43aa3430b641f6333c6c35d618f9e9de123b7390
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
---
# <a name="argument-passing-and-naming-conventions"></a>Передача аргументов и соглашения именования
**Блок, относящийся только к системам Microsoft**  
  
 Компиляторы Visual C++ позволяют определять соглашения для передачи аргументов и возвращаемых значений между функциями и вызывающими объектами. Некоторые соглашения доступны не на всех поддерживаемых платформах, и в некоторых соглашениях используются реализации, зависящие от платформы. В большинстве случаев ключевые слова или параметры компилятора, которые задают неподдерживаемое на определенной платформе соглашение, игнорируются, и используется соглашение по умолчанию для данной платформы.  
  
 На платформах x86 все аргументы при передаче расширяются до 32 бит. Возвращаемые значения также расширяются до 32 бит и возвращаются в регистре EAX, за исключением 8-байтовых структур, которые возвращаются в паре регистров EDX:EAX. Более крупные структуры возвращаются в регистре EAX в виде указателей на скрытые возвращаемые структуры. Параметры помещаются в стек справа налево. Структуры, не являющиеся данными POD (обычные старые данные), не возвращаются в регистрах.  
  
 Компилятор создает код пролога и эпилога для сохранения и восстановления регистров ESI, EDI, EBX и EBP, если они используются в функции.  
  
> [!NOTE]
>  Если функция возвращает структуру, объединение или класс по значению, все определения типа должны быть одинаковыми, в противном случае программа завершается сбоем в среде выполнения.  
  
 Сведения об определении собственного кода пролога и эпилога функции см. в разделе [функции с атрибутом naked](../cpp/naked-function-calls.md).  
  
 Для получения сведений о по умолчанию соглашения о вызовах в коде, который x64 целевых платформ, в разделе [Обзор x64 соглашения о вызовах](../build/overview-of-x64-calling-conventions.md). Сведения о вызове соглашение о проблемах в код, предназначенный для платформы ARM см. в разделе [Visual C++ ARM затруднения](../build/common-visual-cpp-arm-migration-issues.md).  
  
 Компилятор Visual C/C++ поддерживает следующие соглашения о вызовах.  
  
|Ключевое слово|Очистка стека|Передача параметров|  
|-------------|-------------------|-----------------------|  
|[__cdecl](../cpp/cdecl.md)|Вызывающая функция|Параметры помещаются в стек в обратном порядке (справа налево)|  
|[__clrcall](../cpp/clrcall.md)|Н/Д|Параметры загружаются в стек выражений CLR по-порядку (слева направо).|  
|[__stdcall](../cpp/stdcall.md)|Вызываемая функция|Параметры помещаются в стек в обратном порядке (справа налево)|  
|[__fastcall](../cpp/fastcall.md)|Вызываемая функция|Хранятся в регистрах, затем помещаются в стек|  
|[__thiscall](../cpp/thiscall.md)|Вызываемая функция|Помещаются в стек; **это** указателем, сохраненным в регистре ECX|  
|[__vectorcall](../cpp/vectorcall.md)|Вызываемая функция|Хранятся в регистрах, затем помещаются в стек в обратном порядке (справа налево)|  
  
 Дополнительные сведения см. в разделе [устаревшие соглашения о вызовах](../cpp/obsolete-calling-conventions.md).  
  
 **Завершение блока, относящегося только к системам Майкрософт**  
  
## <a name="see-also"></a>См. также  
 [Соглашения о вызовах](../cpp/calling-conventions.md)