---
title: "Операторы отношения: &lt;, &gt;, &lt;= и &gt;= | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "language-reference"
f1_keywords: 
  - "<"
  - ">"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "< - оператор"
  - "<= - оператор"
  - "> - оператор"
  - ">= - оператор"
  - "операторы "больше""
  - "операторы "больше или равно""
  - "оператор "меньше""
  - "оператор "меньше или равно""
  - "реляционные операторы, синтаксис"
ms.assetid: d346b53d-f14d-4962-984f-89d39a17ca0f
caps.latest.revision: 8
caps.handback.revision: 8
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Операторы отношения: &lt;, &gt;, &lt;= и &gt;=
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

## Синтаксис  
  
```  
  
        expression < expression  
expression > expression  
expression <= expression  
expression >= expression  
```  
  
## Заметки  
 Бинарные операторы отношения определяют следующие отношения:  
  
-   Меньше \(**\<**\)  
  
-   Больше \(**\>**\)  
  
-   Меньше или равно \(**\<\=**\)  
  
-   Больше или равно \(**\>\=**\)  
  
 Операторы отношения обладают ассоциативностью слева направо.  Оба операнда операторов отношения должны быть арифметического типа или типа указателя.  Они возвращают значения типа `bool`.  Значение **false** \(0\) возвращается, если отношение в выражении ложно; в противном случае возвращается значение **true** \(1\).  
  
## Пример  
  
```  
// expre_Relational_Operators.cpp  
// compile with: /EHsc  
#include <iostream>  
  
using namespace std;  
  
int main() {  
   cout  << "The true expression 3 > 2 yields: "  
         << (3 > 2) << endl  
         << "The false expression 20 < 10 yields: "  
         << (20 < 10) << endl;  
}  
```  
  
 Выражения в предыдущем примере должны быть заключены в скобки, потому что оператор вставки потока \(**\<\<**\) имеет более высокий приоритет, чем операторы отношения.  Поэтому первое выражение без скобок вычислялось бы следующим образом:  
  
```  
(cout << "The true expression 3 > 2 yields: " << 3) < (2 << "\n");  
```  
  
 К операндам арифметических типов применяются обычные арифметические преобразования, описанные в разделе [Арифметические преобразования](../misc/arithmetic-conversions.md).  
  
## Сравнение указателей  
 При сравнении двух указателей на объекты одного типа результат определяется расположением объектов, указываемых в адресном пространстве программы.  Указатели также можно сравнить с константным выражением, результатом которого является значение 0, или с указателем типа void \*.  Если указатель сравнивается с указателем типа void \*, другой указатель неявно преобразуется в тип void \*.  Затем выполняется сравнение.  
  
 Два указателя разных типов можно сравнивать, только если выполняются следующие условия.  
  
-   Один тип является типом класса, производным от другого типа.  
  
-   По крайней мере один указатель явно преобразован \(приведен\) в тип void \*.  \(Другой указатель неявно преобразован в тип void \* для преобразования.\)  
  
 Гарантируется, что два указателя одного типа, указывающие на один и тот же объект, равны.  Если сравнивается два указателя на нестатические члены объекта, применяются следующие правила.  
  
-   Если тип класса не является объединением и если два члена не разделены указателем *спецификатор\-доступа*, например открытым, защищенным или закрытым, указатель на член, объявленный последним, больше указателя на член, объявленный раньше.  \(Дополнительные сведения о *спецификаторе\-доступа* см. в подразделе "Синтаксис" раздела [Описатели доступа](../misc/access-specifiers.md).\)  
  
-   Если два члена разделены указателем *спецификатор\-доступа*, результаты не определены.  
  
-   Если тип класса является объединением, указатели на разные данные\-члены в этом объединении равны.  
  
 Если два указателя указывают на элементы одного массива или на элемент, находящийся за пределами массива, большим является указатель на объект с более высоким нижним индексом.  Сравнение указателей гарантированно является допустимым, только если указатели ссылаются на объекты в одном массиве или на расположение объекта после конца массива.  
  
## См. также  
 [Выражения с бинарными операторами](../cpp/expressions-with-binary-operators.md)   
 [Операторы C\+\+](../misc/cpp-operators.md)   
 [Операторы C\+\+, приоритет и ассоциативность](../cpp/cpp-built-in-operators-precedence-and-associativity.md)   
 [Операторы отношения и равенства C](../c-language/c-relational-and-equality-operators.md)