---
title: volatile (C++) | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-language
ms.topic: language-reference
f1_keywords:
- volatile_cpp
dev_langs:
- C++
helpviewer_keywords:
- interrupt handlers and volatile keyword [C++]
- volatile keyword [C++]
- volatile objects
- objects [C++], volatile
ms.assetid: 81db4a85-ed5a-4a2c-9a53-5d07a771d2de
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 295654586a3fe251526a4764d54f80f3a70c7014
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
ms.locfileid: "32423965"
---
# <a name="volatile-c"></a>volatile (C++)
Квалификатор типа, который используется для объявления о том, что объект может быть изменен в программе аппаратным обеспечением.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
volatile declarator ;  
```  
  
## <a name="remarks"></a>Примечания  
 Можно использовать [/volatile](../build/reference/volatile-volatile-keyword-interpretation.md) переключатель компилятора для изменения, как компилятор интерпретирует ключевое слово.  
  
 Visual Studio интерпретирует ключевое слово `volatile` по-разному, в зависимости от целевой архитектуры. Для ARM, если не **/volatile** указан параметр компилятора, то компилятор действует как если бы **/volatile:iso** были указаны. Для архитектур, кроме ARM, если не **/volatile** указан параметр компилятора, то компилятор действует как если бы **/volatile:ms** указаны; таким образом, для архитектур отличный от строго ARM Рекомендуется указать **/volatile:iso**и использовать явные примитивы синхронизации и встроенные функции компилятора при работе с памятью, совместно используемой потоками.  
  
 Квалификатор `volatile` позволяет предоставлять доступ к областям памяти, которые используются асинхронными процессами, например обработчиками прерываний.  
  
 Когда `volatile` используется для переменной, которая также имеет [__restrict](../cpp/extension-restrict.md) ключевое слово, `volatile` имеет более высокий приоритет.  
  
 Если член `struct` помечен как `volatile`, то ключевое слово `volatile` распространяется на всю структуру. Если структура не имеет длины, которую в текущей архитектуре можно скопировать с помощью одной инструкции, то квалификатор `volatile` может быть полностью утерян для этой структуры.  
  
 Ключевое слово `volatile` может не оказывать воздействия на поле, если выполняется одно из следующих условий.  
  
-   Длина поля с ключевым словом volatile превышает максимальный размер, который в текущей архитектуре может быть скопирован с помощью одной инструкции.  
  
-   Длина самого внешнего окружающего объекта `struct` — или если он является членом объекта `struct`, который может быть также вложенным — превышает максимальный размер, который в текущей архитектуре может быть скопирован с помощью одной инструкции.  
  
 Хотя процессор не меняет порядок некэшированных обращений к памяти, некэшированные переменные должны быть помечены как `volatile`, чтобы гарантировать, что компилятор не изменит порядок обращений к памяти.  
  
 Объекты, которые были объявлены как `volatile`, не используются в некоторых способах оптимизации, поскольку их значения могут измениться в любое время.  При запросе объекта с ключевым словом volatile система всегда считывает его текущее значение, даже если оно запрашивалось в предшествовавшей инструкции.  Кроме того, значение объекта записывается непосредственно при присваивании.  
  
## <a name="iso-compliant"></a>Блок, относящийся к стандарту ISO  
 Если вы знакомы с C# ключевое слово volatile или знакомые с поведением `volatile` в более ранних версиях Visual C++, необходимо учитывать, стандарта C ++ 11 ISO `volatile` ключевое слово отличается и поддерживается в Visual Studio при [/ volatile: iso](../build/reference/volatile-volatile-keyword-interpretation.md) указан параметр компилятора. (Для архитектуры ARM он установлен по умолчанию). Ключевое слово `volatile` в коде, создаваемом согласно стандарту ISO для языка C ++11, должно использоваться только для аппаратного доступа; его использование для взаимодействия между потоками не допускается. Для взаимодействия между потоками, использовать механизмы, такие как [std::atomic\<T >](../standard-library/atomic.md) из [стандартной библиотеки C++](../standard-library/cpp-standard-library-reference.md).  
  
## <a name="end-of-iso-compliant"></a>Конец блока, относящегося к стандарту ISO  
  
## <a name="microsoft-specific"></a>Блок, относящийся только к системам Microsoft  
 Когда **/volatile:ms** используется параметр компилятора — по умолчанию, если целевой архитектуры, кроме ARM, компилятор создает дополнительный код для сохранения порядка между ссылками на временных объектов в дополнение к сохранению порядка ссылок на другие глобальные объекты. В частности:  
  
-   Запись в объект с ключевым словом volatile (т. н. "запись в изменяемый объект") имеет семантику освобождения. Это означает, что ссылка на глобальный или статический объект, которая находится в последовательности инструкций перед записью в объект с ключевым словом volatile, в скомпилированном двоичном файле будет находиться до записи в изменяемый объект.  
  
-   Считывание из объекта с ключевым словом volatile (т. н. "считывание из изменяемого объекта") имеет семантику получения. Это означает, что ссылка на глобальный или статический объект, которая находится в последовательности инструкций после считывания из объекта с ключевым словом volatile, в скомпилированном двоичном файле будет находиться после считывания из изменяемого объекта.  
  
 Благодаря этому объекты с ключевым словом volatile могут использоваться для блокировки и освобождения памяти в многопоточных приложениях.  
  
> [!NOTE]
>  Если он основывается на гарантии, которые дает **/volatile:ms** используется параметр компилятора, код не будет переносимым.  
  
**Завершение блока, относящегося только к системам Майкрософт**  
  
## <a name="see-also"></a>См. также  
 [Ключевые слова](../cpp/keywords-cpp.md)   
 [const](../cpp/const-cpp.md)   
 [Указатели с ключевыми словами const и volatile](../cpp/const-and-volatile-pointers.md)