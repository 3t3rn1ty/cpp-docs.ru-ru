---
title: Схемы (классов ATL) сообщений | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-atl
ms.topic: reference
dev_langs:
- C++
helpviewer_keywords:
- message maps, ATL
- ATL, message handlers
ms.assetid: 9e100400-65c7-4a85-8857-4e6cb6dd7340
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: eaef52363ebdd79a1efb1e2e26bce016500cb722
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
---
# <a name="message-maps-atl"></a>Схемы сообщений (ATL)
Схемы сообщений связывает функцию обработчика событий с определенного сообщения, команды или уведомления. С помощью ATL [макросы схемы сообщений](../atl/reference/message-map-macros-atl.md), можно указать схему сообщений для окна. Процедуры окна в `CWindowImpl`, `CDialogImpl`, и `CContainedWindowT` направлять сообщения окна к схему сообщений.  
  
 [Функции обработчика сообщений](../atl/message-handler-functions.md) принять дополнительный аргумент типа `BOOL&`. Этот аргумент указывает, является ли сообщение было обработано и ему присваивается `TRUE` по умолчанию. Функция-обработчик может затем аргументе `FALSE` для указания, что он не обработал сообщение. В этом случае ATL будет искать функцию обработчика событий, далее в схеме сообщений. Установив этот аргумент `FALSE`, можно выполнить некоторые действия в ответ на сообщение и разрешить обработку по умолчанию или другой функции обработчика завершения обработки сообщения.  
  
## <a name="chained-message-maps"></a>Схемы последовательных сообщений  
 ATL также позволяет отправлять цепочки схемы сообщений, который направляет вывод сообщения, обработке сообщения сопоставление, определенное в другом классе. Например можно реализовать общие обработки сообщений в отдельный класс для предоставления единообразное поведение для всех окон, привязка к этому классу. Можно соединить в цепочку к базовому классу или элементу данных вашего класса.  
  
 ATL также поддерживает динамическое цепочки, что позволяет создать цепочку карты сообщения другого объекта во время выполнения. Для реализации динамической цепочки, должен быть производным от класса [CDynamicChain](../atl/reference/cdynamicchain-class.md). Затем объявите [CHAIN_MSG_MAP_DYNAMIC](reference/message-map-macros-atl.md#chain_msg_map_dynamic) макрос в схему сообщений. `CHAIN_MSG_MAP_DYNAMIC` требуется уникальный номер, который идентифицирует объекта и сопоставление сообщений, к которому вы цепочки. Необходимо определить это уникальное значение посредством вызова `CDynamicChain::SetChainEntry`.  
  
 Можно соединить в цепочку к любому классу, который объявляет схему сообщений, предоставляемый класс является производным от [CMessageMap](../atl/reference/cmessagemap-class.md). `CMessageMap` позволяет объекту предоставлять его схемы сообщений с другими объектами. Обратите внимание, что `CWindowImpl` уже является производным от `CMessageMap`.  
  
## <a name="alternate-message-maps"></a>Схемы сообщений альтернативный  
 И, наконец, ATL поддерживает сопоставления альтернативного сообщения, объявленных с [ALT_MSG_MAP](reference/message-map-macros-atl.md#alt_msg_map) макрос. Каждый альтернативную схему сообщений определяется уникальный номер, который передается `ALT_MSG_MAP`. С помощью альтернативных сопоставляет, может обрабатывать сообщения несколько окон в одной карте. Обратите внимание, что по умолчанию `CWindowImpl` не использует схемы альтернативный сообщений. Чтобы добавить поддержку этих функций, переопределите `WindowProc` метод в вашей `CWindowImpl`-производного класса, а также вызов `ProcessWindowMessage` с карты идентификатор сообщения.  
  
## <a name="see-also"></a>См. также  
 [Реализация окна](../atl/implementing-a-window.md)

