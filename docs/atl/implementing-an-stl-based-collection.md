---
title: "Implementing an STL-Based Collection | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "ICollectionOnSTLImpl interface"
ms.assetid: 6d49f819-1957-4813-b074-3f12c494d8ca
caps.latest.revision: 12
caps.handback.revision: 7
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Implementing an STL-Based Collection
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Библиотеки ATL предоставляет интерфейс `ICollectionOnSTLImpl` позволяет быстро реализовывать стандартной библиотеки шаблонов \(STL\) \- интерфейсов коллекции, основанные на объектах.  Чтобы понять, как работает этот класс будет работать через простой пример \(см. ниже\), используют этот класс для реализации доступную только для чтения коллекцию направили для клиентов автоматизации.  
  
 В образце кода из [Образец ATLCollections](../top/visual-cpp-samples.md).  
  
 Для выполнения этой процедуры необходимо:  
  
-   [Создайте новый простой объект](#vccongenerating_an_object).  
  
-   [Правка файл IDL](#vcconedit_the_idl) для созданного интерфейса.  
  
-   [Создание 5 typedef](#vcconstorage_and_exposure_typedefs), описывающие, как элементы коллекции хранятся и как они будут предоставлены клиентам через модель COM взаимодействует.  
  
-   [Создание 2 typedef для классов политики копирования](#vcconcopy_classes).  
  
-   [создайте typedef для реализаций перечислителя и коллекции](#vcconenumeration_and_collection).  
  
-   [Правка мастер\- созданный код C\+\+ для использования typedef коллекции](#vcconedit_the_generated_code).  
  
-   [Добавьте код для заполнения коллекции](#vcconpopulate_the_collection).  
  
##  <a name="vccongenerating_an_object"></a> Создание новый простой объект  
 Создайте новый проект, предоставляя, что очищено окно " атрибуты в окне параметры приложения.  Использование библиотеки ATL диалоговое окно " добавление класса объекта и добавьте простой мастер для создания простого вызываемый объект `Words`.  Убедитесь, что сдвоенный интерфейс `IWords` сформирован.  Объекты созданного класса будут использоваться для представления коллекции слов \(строк\).  
  
##  <a name="vcconedit_the_idl"></a> Изменение файла IDL  
 Теперь открыть idl\-файл и добавьте значение 3 свойства необходимого, что повернул `IWords` в интерфейс коллекции, доступной только для чтения, как показано ниже:  
  
 [!code-cpp[NVC_ATL_COM#24](../atl/codesnippet/CPP/implementing-an-stl-based-collection_1.idl)]  
  
 Это стандартная форма, разработанного интерфейса коллекции, доступной только для чтения с клиентами автоматизации.  Пронумерованные комментарии в этом определении интерфейса соответствуют комментарии ниже.  
  
1.  Интерфейсы коллекции обычно двойны поскольку клиенты автоматизации, получат доступ к свойству `_NewEnum` через **IDispatch::Invoke**.  Однако клиенты автоматизации могут получить доступ к остальные методы в таблице vtable, поэтому сдвоенные интерфейсы предпочтительны для диспетчерских интерфейсов.  
  
2.  Если сдвоенный интерфейс или диспетчерский интерфейс не будут расширены во время выполнения \(то есть не обеспечите дополнительные методы или свойства в **IDispatch::Invoke**\), необходимо применить атрибут **nonextensible** к определению.  Этот атрибут позволяет клиентам автоматизации для выполнения полной проверки кода во время компиляции.  В этом случае интерфейс не должен быть расширен.  
  
3.  Правильный идентификатор DISPID важно, если необходимо, чтобы клиенты автоматизации использовать это свойство.  \(Обратите внимание, что только один символ подчеркивания в **DISPID\_NEWENUM**\).  
  
4.  Можно ввести любое значение в виде DISPID свойства **item**.  Однако **item** обычно использует **DISPID\_VALUE**, чтобы сделать его свойство коллекции по умолчанию.  Это позволяет клиентам автоматизации для обращения к свойству без именование его явно.  
  
5.  Тип данных, используемый для возвращаемого значения свойства **item** тип элемента, хранящегося в коллекции, сколько клиентов модели COM.  Интерфейс возвращает строки, поэтому необходимо использовать стандартный тип string в модели COM, `BSTR`.  Можно сохранить данные в другом формате автоматически по мере того, как вы увидите скоро истекает.  
  
6.  Значение, используемое для свойства **Счетчик** DISPID полностью произвольно.  Нет стандартных DISPID для данного свойства.  
  
##  <a name="vcconstorage_and_exposure_typedefs"></a> Создание typedef для хранения и извлечения  
 Как только интерфейс коллекции указан, необходимо решить, как данные будут храниться, и то, как эти данные будут предоставлены с помощью перечислителя.  
  
 Ответы на эти вопросы можно указать в форме нескольких typedef, которые можно добавить в верхней части файла заголовка для созданного класса:  
  
 [!code-cpp[NVC_ATL_COM#25](../atl/codesnippet/CPP/implementing-an-stl-based-collection_2.h)]  
  
 В этом случае будут храниться данные как **std::vectorstd::string**.  **std::vector** класс контейнеров STL, который ведет себя как управляемый массив.  **std::string** класс строки стандартной библиотеки C\+\+.  Эти классы упрощают работу с коллекцией строк.  
  
 Поскольку поддержка Visual Basic существена к успешности выполнения этого интерфейса перечислителя, возвращенный свойством `_NewEnum` должен поддерживать интерфейс **IEnumVARIANT**.  Это единственный интерфейс перечислителя, воспринимаемый Visual Basic.  
  
##  <a name="vcconcopy_classes"></a> Создание typedef для классов политики копирования  
 Typedef, созданного до тех пор, предоставляющие все необходимые сведения для создания более дополнительных typedef для классов копии, которые используются перечислителем и коллекцией.  
  
 [!code-cpp[NVC_ATL_COM#26](../atl/codesnippet/CPP/implementing-an-stl-based-collection_3.h)]  
  
 В этом примере можно использовать заданный класс `GenericCopy` VCUE\_Copy.h и VCUE\_CopyString.h из пользовательских в образце [ATLCollections](../top/visual-cpp-samples.md).  Этот класс можно использовать в коде, но можно определить дальнейшие специализации `GenericCopy` для поддержки типов данных, используемых в пользовательских коллекциях.  Дополнительные сведения см. в разделе [Классов политики копирования библиотеки ATL](../Topic/ATL%20Copy%20Policy%20Classes.md).  
  
##  <a name="vcconenumeration_and_collection"></a> Создание typedef для перечисления и коллекции  
 Теперь все параметры шаблона, необходимые для специализировала классы `CComEnumOnSTL` и `ICollectionOnSTLImpl` для этой ситуации были представлены в форме typedef.  Чтобы упростить использование специализаций создайте 2 больше typedef как показано ниже:  
  
 [!code-cpp[NVC_ATL_COM#27](../atl/codesnippet/CPP/implementing-an-stl-based-collection_4.h)]  
  
 Теперь `CollectionType` синоним для специализации `ICollectionOnSTLImpl`, которая реализует интерфейс `IWords` заданный ранее, и предоставляет перечислитель, который **IEnumVARIANT** поддержки.  
  
##  <a name="vcconedit_the_generated_code"></a> Изменение Мастер\- Созданный код  
 Теперь необходимо создать `CWords` от реализации интерфейса, представленной typedef `CollectionType`, а не `IWords`, как показано ниже:  
  
 [!code-cpp[NVC_ATL_COM#28](../atl/codesnippet/CPP/implementing-an-stl-based-collection_5.h)]  
  
##  <a name="vcconpopulate_the_collection"></a> Добавление кода для заполнения коллекции  
 Единственная всего, которая остается заполнения вектор с данными.  В этом простом примере можно добавить несколько слов в коллекции в конструкторе для данного класса:  
  
 [!code-cpp[NVC_ATL_COM#29](../atl/codesnippet/CPP/implementing-an-stl-based-collection_6.h)]  
  
 Теперь можно проверить код с клиентом.  
  
## См. также  
 [Коллекции и перечислители](../atl/atl-collections-and-enumerators.md)   
 [Образец ATLCollections](../top/visual-cpp-samples.md)   
 [ATL Copy Policy Classes](../Topic/ATL%20Copy%20Policy%20Classes.md)