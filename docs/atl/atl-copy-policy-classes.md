---
title: "ATL-классы политики копирования | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
helpviewer_keywords:
- data [C++], ATL
- classes [C++], copy policy
- copy policy classes [C++]
- _Copy class
- _CopyInterface class
ms.assetid: 06704b68-d318-4c5d-a65b-71457fe9d00d
caps.latest.revision: "13"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: 54ac3c9d53c3b6d2b295643001fd15b1e4c6c46d
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="atl-copy-policy-classes"></a>ATL-классы политики копирования
Копирование политики классы являются [служебные классы](../atl/utility-classes.md) используется для инициализации, копировать и удалять данные. Копирование классов политик можно для определения семантику копирования для любого типа данных, а также определять преобразования между различными типами данных.  
  
 Использует копию политики классы ATL в его реализации следующих шаблонов:  
  
-   [CComEnumImpl](../atl/reference/ccomenumimpl-class.md)  
  
-   [IEnumOnSTLImpl](../atl/reference/ienumonstlimpl-class.md)  
  
-   [ICollectionOnSTLImpl](../atl/reference/icollectiononstlimpl-class.md)  
  
 Инкапсулирующий сведения, необходимые для копирования или преобразования данных в класс политики копирования, который может быть передан в качестве аргумента шаблона, разработчики ATL предоставили для extreme возможность повторного использования этих классов. Например если необходимо реализовать коллекции с помощью любого произвольного типа данных, необходимо предоставить достаточно политики соответствующей копии; Вам не придется работать код, который реализует коллекции.  
  
## <a name="definition"></a>Определение  
 По определению класс, предоставляющий следующие статические функции является класс политики копирования:  
  
 `static void init(` `DestinationType` `* p);`  
  
 `static HRESULT copy(` `DestinationType` `* pTo, const`  `SourceType` `* pFrom);`  
  
 `static void destroy(` `DestinationType` `* p);`  
  
 Вы можете заменить типы `DestinationType` и *SourceType* с типами произвольных данных для каждой политики копирования.  
  
> [!NOTE]
>  Несмотря на то, что можно определить классов политики копирования для всех типов, произвольные данные, используйте классы ATL кода следует ограничить типы, которые имеют смысл. Например, когда с помощью политики копирования класс с ATL коллекции или реализации перечислителя `DestinationType` должен быть типом, который можно использовать в качестве параметра в метод COM-интерфейса.  
  
 Используйте **init** инициализировать данные, **копирования** для копирования данных, и **уничтожить** для освобождения данных. Точное значение инициализации, копирования и удаления входят в домен класс политики копирования и зависит от используемых типов данных.  
  
 Существует два требования по использованию и реализация класс политики копирования:  
  
-   Первый параметр **копирования** только должен получить указатель на данные, которые ранее был инициализирован с помощью **init**.  
  
-   **уничтожить** только когда-либо должен получить указатель на данные, которые ранее был инициализирован с помощью **init** или копирования через **копирования**.  
  
## <a name="standard-implementations"></a>Стандартные реализации  
 Библиотека ATL предоставляет два класса копирование политики в виде **_Copy** и **_CopyInterface** классы шаблонов:  
  
-   **_Copy** класс позволяет однородных только копирование (не преобразование между типами данных), так как он только предоставляет Укажите оба параметра один шаблон `DestinationType` и *SourceType*. Универсальная реализация этот шаблон не содержит инициализации или уничтожения кода и использует `memcpy` для копирования данных. Кроме того, библиотека ATL предоставляет специализации **_Copy** для **VARIANT**, `LPOLESTR`, **OLEVERB**, и **CONNECTDATA** типов данных.  
  
-   **_CopyInterface** класс предоставляет реализацию для копирования стандартных правил COM указателей интерфейса. Еще раз этот класс позволяет только однородных копирование, поэтому он использует простое присваивание и вызов `AddRef` для выполнения копирования.  
  
## <a name="custom-implementations"></a>Пользовательские реализации  
 Как правило необходимо определить свои собственные классы политики копирования разнородных копирования (то есть преобразование между типами данных). Некоторые примеры пользовательских классов политики копирования, просмотрите файлы файлах VCUE_Copy.h и VCUE_CopyString.h в [ATLCollections](../visual-cpp-samples.md) образца. Эти файлы содержат два шаблона класса копирования политики `GenericCopy` и `MapCopy`, плюс количество специализации `GenericCopy` для различных типов данных.  
  
### <a name="genericcopy"></a>GenericCopy  
 `GenericCopy`позволяет указать *SourceType* и `DestinationType` как аргументы шаблонов. Вот наиболее распространенная форма `GenericCopy` класс в файле VCUE_Copy.h:  
  
 [!code-cpp[NVC_ATL_COM#30](../atl/codesnippet/cpp/atl-copy-policy-classes_1.h)]  
  
 Файле VCUE_Copy.h также содержит следующие специализации этого класса: `GenericCopy<BSTR>`, `GenericCopy<VARIANT, BSTR>`, `GenericCopy<BSTR, VARIANT>`. VCUE_CopyString.h содержит специализации для копирования из **std::string**s: `GenericCopy<std::string>`, `GenericCopy<VARIANT, std::string>`, и `GenericCopy<BSTR, std::string>`. Можно повысить `GenericCopy` , предоставляя дополнительные собственные специализации.  
  
### <a name="mapcopy"></a>MapCopy  
 `MapCopy`предполагается, копируемых данных хранится в библиотеке C++ Standard в стиле сопоставление, поэтому он позволяет указывать тип карты, в котором хранятся данные, а целевой тип. Реализация класса используется только для определения типов, предоставляемых *MapType* класса для определения типа источника данных и для вызова соответствующего `GenericCopy` класса. Без специализации этого класса не требуются.  
  
 [!code-cpp[NVC_ATL_COM#31](../atl/codesnippet/cpp/atl-copy-policy-classes_2.h)]  
  
## <a name="see-also"></a>См. также  
 [Реализация коллекции на основе библиотеки C++ Standard](../atl/implementing-an-stl-based-collection.md)   
 [Образец ATLCollections](../visual-cpp-samples.md)

