---
title: "Общие сведения о x64 соглашения о вызовах | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-tools
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
ms.assetid: a05db5eb-0844-4d9d-8b92-b1b2434be0ea
caps.latest.revision: 
author: corob-msft
ms.author: corob
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: 8ac42eb934692fb9eaecf345b75e7544e7078f07
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="overview-of-x64-calling-conventions"></a>Общие сведения о соглашениях о вызовах для архитектуры x64
Два важных отличия между x86 и [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)] является возможность адресации 64-разрядной и плоский набор 16 64-битных регистров общего назначения. Предоставляя расширенный набор регистров, [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)] использует [__fastcall](../cpp/fastcall.md) соглашение о вызовах и модель RISC-архитектуры обработки исключений. `__fastcall` Соглашение использует регистры для первых четырех аргументов и кадр стека для передачи дополнительных аргументов.  
  
 Следующий параметр компилятора позволяет оптимизировать приложение для [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)]:  
  
-   [/ favor (оптимизация для особенностей архитектуры)](../build/reference/favor-optimize-for-architecture-specifics.md)  
  
## <a name="calling-convention"></a>Соглашение о вызовах  
 [!INCLUDE[vcprx64](../assembler/inline/includes/vcprx64_md.md)] Двоичный интерфейс приложений (ABI) по умолчанию использует соглашение о вызовах fast вызов четыре регистра. Выделяется место в стеке вызовов в качестве теневого хранилища для вызывающих объектов для сохранения этих регистров. Имеется точное однозначное соответствие между аргументами в вызове функции и регистров, используемых для этих аргументов. Любой аргумент, который не умещается в 8 байт или не является 1, 2, 4 или 8 байт должны передаваться по ссылке. Нет не пытается разместить один аргумент по нескольким регистрам. X87 стек регистра не используется. Он может использоваться вызываемым, но должен быть временным при вызове функций. Число с плавающей запятой, все операции осуществляются с помощью 16 регистров XMM. Целочисленные аргументы передаются в регистрах RCX, RDX, R8 и R9. Число с плавающей запятой, что аргументы передаются в XMM0L, XMM1L, XMM2L и XMM3L. 16-байтовые аргументы передаются по ссылке. Передача параметров подробно описывается в [передача параметров](../build/parameter-passing.md). Регистры RAX, R10, R11, XMM4 и XMM5 считаются временными. Все остальные регистры являются долговременного. Использование регистров подробно рассматривается в [зарегистрировать использование](../build/register-usage.md) и [сохраненные регистры вызываемого и вызывающего объектов](../build/caller-callee-saved-registers.md).  
  
 Вызывающий объект отвечает за выделение пространства для параметров в вызываемый объект и всегда должен выделить достаточно места для хранения четыре параметра регистра, даже если вызываемый объект не принимает такого количества параметров. Это упрощает поддержку функции без прототипа языка C и функции C/C++ с переменным количеством аргументов. Для функций с переменным количеством аргументов или без прототипа, любой чисел с плавающей запятой значения должны повторяться в соответствующем регистре общего назначения. Любые параметры, за первые четыре должны храниться в стеке выше хранилища тени для первые четыре до вызова метода. Сведения о функции с переменным количеством аргументов можно найти в [Varargs](../build/varargs.md). Сведения о функции без прототипа подробно описан в [функции без прототипа](../build/unprototyped-functions.md).  
  
## <a name="alignment"></a>Выравнивание  
 Большинство структур выровнены естественным выравниванием. Главными исключениями являются указатель стека и `malloc` или `alloca` памяти, что выравниваются по 16 байт для сохранения производительности. Выравнивание свыше 16 байт должно выполняться вручную, но поскольку 16 байт общее выравнивание размера для операций XMM, это должно работать для большей части кода. Дополнительные сведения о структуре и выравнивании см [типы и хранилище](../build/types-and-storage.md). Сведения о стеке см. в разделе [использование стека](../build/stack-usage.md).  
  
## <a name="unwindability"></a>Способность очищаться  
 Конечным функциям, функции, которые не изменяют значения неизменяемых регистров. Функция неконечных могут изменяться долговременного RSP, например, путем вызова функции или выделение памяти в дополнительных стеке для локальных переменных. Чтобы восстановить неизменяемые регистры, если исключение обработано, неконечные функции должен быть помечен статических данных, описывающий, каким образом выполнять функции на произвольный инструкции. Эти данные хранятся в виде *pdata*, или данные процедуры, которые в свою очередь ссылается *xdata*, исключений, обработки данных. Xdata со сведениями о очистки, а также может указывать на дополнительных pdata или функцию обработчика исключения. Прологи и эпилоги ограничены высокой, чтобы их можно было правильно описаны в xdata. Указатель стека должен быть выровнен 16 байт в любой области кода, который не является частью эпилога или пролога, за исключением внутри конечным функциям. Конечным функциям можно развернута просто имитируя возврата, pdata и xdata не являются обязательными. Дополнительные сведения о структуре функции Прологи и эпилоги см. в разделе [пролога и эпилога](../build/prolog-and-epilog.md). Дополнительные сведения об обработке исключений и обработки исключений и очистки pdata и xdata см. в разделе [(x64) обработка исключений](../build/exception-handling-x64.md).  
  
## <a name="see-also"></a>См. также  
 [Программные соглашения для X64](../build/x64-software-conventions.md)