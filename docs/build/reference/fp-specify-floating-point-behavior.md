---
title: "/fp (Определение поведения с плавающей запятой) | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "VC.Project.VCCLCompilerTool.floatingPointModel"
  - "VC.Project.VCCLWCECompilerTool.FloatingPointExceptions"
  - "/fp"
  - "VC.Project.VCCLWCECompilerTool.floatingPointModel"
  - "VC.Project.VCCLCompilerTool.FloatingPointExceptions"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "/fp - параметр компилятора [C++]"
  - "-fp - параметр компилятора [C++]"
ms.assetid: 10469d6b-e68b-4268-8075-d073f4f5d57e
caps.latest.revision: 21
author: "corob-msft"
ms.author: "corob"
manager: "ghogen"
caps.handback.revision: 21
---
# /fp (Определение поведения с плавающей запятой)
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

Определяет поведение для чисел с плавающей запятой в файле исходного кода.  
  
## Синтаксис  
  
```  
/fp:[precise | except[-] | fast | strict ]  
```  
  
## Флаги  
 **precise**  
 По умолчанию.  
  
 Улучшает согласованность проверок на равенство и неравенство для значений с плавающей запятой путем отключения оптимизаций, которые могут повлиять на точность вычислений с плавающей запятой. \(Поддержка определенной точности необходима для строгого соответствия стандарту ANSI.\) По умолчанию в коде для архитектуры x86 компилятор использует 80\-разрядный сопроцессор для хранения промежуточных результатов вычислений с плавающей запятой.  Это увеличивает быстродействие программы и уменьшает ее объем.  Однако, так как в вычислениях используются типы данных с плавающей запятой, которые занимают в памяти менее 80 битов, поддержание дополнительных битов точности вычислений \(80 битов минус количество битов в более коротких типах с плавающей запятой\) во время длительных вычислений может приводить к недостоверным результатам.  
  
 С параметром **\/fp:precise** на процессорах x86 компилятор выполняет округление переменных типа `float` до требуемой точности для операций присваивания и приведения типов, а также при передаче параметров в функцию.  Такое округление гарантирует, что количество значащих разрядов данных не будет превышать разрядность их типа.  Программа, скомпилированная с параметром **\/fp:precise**, может работать медленнее и иметь больший размер по сравнению с программой, скомпилированной без параметра **\/fp:precise**.  Параметр **\/fp:precise** отключает встроенные функции; вместо них используются стандартные процедуры библиотеки времени выполнения.  Дополнительные сведения см. в разделе [\/Oi \(создание встроенных функций\)](../Topic/-Oi%20\(Generate%20Intrinsic%20Functions\).md).  
  
 С помощью параметра **\/fp:precise** включается следующее поведение для чисел с плавающей запятой:  
  
-   Сокращение — т. е., использование составной операции, при которой вместо нескольких операций выполняется только одно округление в конце вычислений.  
  
-   Не допускаются оптимизации выражений, которые недопустимы для специальных значений \(NaN, \+бесконечность, \-бесконечность, \+0, \-0\).  Оптимизации x\-x \=\> 0, x\*0 \=\> 0, x\-0 \=\> x, x\+0 \=\> x и 0\-x \=\> \-x недействительны по разным причинам. \(См. стандарты IEEE 754 и C99\).  
  
-   Компилятор правильно обрабатывает сравнения с участием значений NaN.  Например, выражение x \!\= x дает значение **true**, если `x` имеет значение NaN, а упорядоченные сравнения, включающие NaN, вызывают исключение.  
  
-   Вычисление выражений производится в соответствии в методом FLT\_EVAL\_METHOD\=2 стандарта C99 со следующим исключением: при программировании для процессоров x86 в связи с тем, что для сопроцессора FPU задана точность 53 бита, это рассматривается как точность long\-double.  
  
-   Умножение ровно на 1,0 преобразуется в использование другого множителя.  x\*y\*1.0 преобразуется в x\*y.  Аналогично, x\*1.0\*y преобразуется в x\*y.  
  
-   Деление ровно на 1,0 преобразуется в использование делимого.  x\*y\/1.0 преобразуется в x\*y.  Аналогично, x\/1.0\*y преобразуется в x\*y.  
  
 При использовании параметра **\/fp:precise** с включенным параметром [fenv\_access](../../preprocessor/fenv-access.md) отключаются некоторые оптимизации, такие как оценка выражений с плавающей запятой во время компиляции.  Например, если для изменения режима округления используется параметр [\_control87, \_controlfp, \_\_control87\_2](../Topic/_control87,%20_controlfp,%20__control87_2.md) и компилятор выполняет вычисления с плавающей запятой, заданный режим округления вступает в силу только в том случае, если включен параметр `fenv_access`.  
  
 Параметр **\/fp:precise** заменяет параметр компилятора **\/Op**.  
  
 **fast**  
 В большинстве случаев создает наиболее быстрый код, ослабляя правила оптимизации операций с плавающей запятой.  Это позволяет компилятору оптимизировать код с плавающей запятой для повышения быстродействия за счет точности и правильности.  Если указан параметр **\/fp:fast**, компилятор может неправильно выполнять округление в операторах присваивания, при приведении типов или в вызовах функций, а также может не производить округление промежуточных выражений.  Компилятор может изменять порядок операций или выполнять алгебраические преобразования \(например, в соответствии с условиями ассоциативности и дистрибутивности\) без учета влияния на конечную точность результатов.  Компилятор может заменять операции и операнды на значения одинарной точности вместо применения правил повышения типа в C\+\+.  Оптимизации сокращения для значений с плавающей запятой всегда включены \(параметр [fp\_contract](../../preprocessor/fp-contract.md) включен\).  Исключения для значений с плавающей запятой и доступ к сопроцессору FPU отключены \(параметр **\/fp:except\-** подразумевается, а параметр [fenv\_access](../../preprocessor/fenv-access.md) выключен\).  
  
 Параметр **\/fp:fast** невозможно использовать с параметром **\/fp:strict** или **\/fp:precise**.  Используется последний параметр, указанный в командной строке.  Совместное указание параметров **\/fp:fast** и **\/fp:except** вызывает ошибку компилятора.  
  
 Задание параметра [\/Za, \/Ze \(отключить расширения языка\)](../../build/reference/za-ze-disable-language-extensions.md) \(совместимость с ANSI\) совместно с параметром **\/fp:fast** может вызвать непредвиденное поведение.  Например, операции с плавающей запятой одиночной точности могут не округляться до одинарной точности.  
  
 **except\[\-\]**  
 Надежная модель исключений с плавающей точкой.  Исключения вызываются незамедлительно после запуска.  По умолчанию этот параметр выключен.  При добавление знака "минус" к параметру он в явном виде выключается.  
  
 **strict**  
 Самая строгая модель вычислений с плавающей точкой.  Если задан параметр **\/fp:strict**, параметр [fp\_contract](../../preprocessor/fp-contract.md) выключается, а параметр [fenv\_access](../../preprocessor/fenv-access.md) включается.  Параметр **\/fp:except** используется неявно, и его можно отключить, явным образом указав **\/fp:except\-**.  При использовании с параметром **\/fp:except\-** параметр **\/fp:strict** принудительно включает строгую семантику операций с плавающей запятой, но без учета исключительных событий.  
  
## Заметки  
 При компиляции можно задать несколько параметров **\/fp**.  
  
 Для управления поведением вычислений с плавающей запятой раздельно по функциям см. директиву pragma [float\_control](../Topic/float_control.md).  Она переопределяет параметр компилятора **\/fp**.  Рекомендуется сохранять и восстанавливать локальное поведение вычислений с плавающей точкой:  
  
```css  
#pragma float_control(precise, on, push)  
// Code that uses /fp:precise mode  
#pragma float_control(pop)  
```  
  
 Большинство оптимизаций операций с плавающей запятой, связанных с параметрами **\/fp:strict**, **\/fp:except** \(и соответствующими директивами pragma\) и директивой pragma `fp_contract`, зависят от оборудования.  Параметры **\/fp:strict** и **\/fp:except** несовместимы с параметром **\/clr**.  
  
 Параметр **\/fp:precise** удовлетворяет большинству требований, предъявляемых к вычислениям с плавающей запятой в приложениях.  Можно использовать параметры **\/fp:except** и **\/fp:strict**, но возможно некоторое снижение производительности.  Если производительность является самым важным условием, рассмотрите возможность использования параметра **\/fp:fast**.  
  
 Параметры **\/fp:strict**, **\/fp:fast** и **\/fp:precise** представляют собой режимы точности \(правильности\).  Одновременно можно использовать только один из них.  Если указаны оба параметра **\/fp:strict** и **\/fp:precise**, компилятор использует тот, который обрабатывается последним.  Одновременное указание параметров **\/fp:strict** и **\/fp:fast** невозможно.  
  
 Дополнительные сведения см. в разделе [Оптимизация вычислений с плавающей запятой в Microsoft Visual C\+\+](http://msdn.microsoft.com/library/aa289157.aspx).  
  
### Установка данного параметра компилятора в среде разработки Visual Studio  
  
1.  Откройте диалоговое окно **Страницы свойств** проекта.  Дополнительные сведения см. в разделе [Открытие свойств страниц проекта](../../misc/how-to-open-project-property-pages.md).  
  
2.  Разверните узел **Свойства конфигурации**.  
  
3.  Разверните узел **C\/C\+\+**.  
  
4.  Выберете страницу свойств **Создание кода**.  
  
5.  Измените свойство **Модель вычислений с плавающей точкой**.  
  
### Установка данного параметра компилятора программным способом  
  
-   См. раздел <xref:Microsoft.VisualStudio.VCProjectEngine.VCCLCompilerTool.floatingPointModel%2A>.  
  
## См. также  
 [Параметры компилятора](../../build/reference/compiler-options.md)   
 [Настройка параметров компилятора](../Topic/Setting%20Compiler%20Options.md)   
 [Оптимизация вычислений с плавающей запятой в Microsoft Visual C\+\+](http://msdn.microsoft.com/library/aa289157.aspx)