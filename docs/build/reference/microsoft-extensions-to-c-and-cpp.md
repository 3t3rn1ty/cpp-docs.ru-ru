---
title: "Расширения Майкрософт для языков C и C++ | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "! оператор, расширение в C++"
  - "!= - оператор"
  - "& - оператор, расширения в C/C++"
  - "&& - оператор"
  - "&= - оператор"
  - "^ - оператор, расширения в C/C++"
  - "^= - оператор, расширения C++"
  - "| - оператор, расширения"
  - "|| - оператор"
  - "|= - оператор"
  - "~ - оператор, расширения в C/C++"
  - "And - оператор, расширения в C/C++"
  - "and_eq - оператор"
  - "compl - метод"
  - "расширения"
  - "расширения, C - язык"
  - "iso646.h - заголовок"
  - "расширения Microsoft в C/C++"
  - "NOT - оператор"
  - "not_eq - оператор"
  - "Or - оператор, расширения Microsoft в C/C++"
  - "or_eq - оператор"
  - "Visual C, расширения Microsoft"
  - "Visual C++, расширения в C/C++"
  - "Xor - оператор, расширения Microsoft в C/C++"
  - "xor_eq - оператор"
ms.assetid: e811a74a-45ba-4c00-b206-2f2321b8689a
caps.latest.revision: 18
caps.handback.revision: 18
author: "corob-msft"
ms.author: "corob"
manager: "ghogen"
---
# Расширения Майкрософт для языков C и C++
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

Visual C\+\+ расширяет стандарты ANSI C\+\+ и ANSI C следующим образом.  
  
## Ключевые слова  
 Некоторые ключевые слова добавления.  В [Ключевые слова в C\+\+](../../cpp/keywords-cpp.md), ключевые слова с 2 символа подчеркивания повышает расширения Visual C\+\+.  
  
## Определение статических постоянных целочисленных элементов \(static, const или enum\) вне класса  
 В стандартный \(**\/Za**\), необходимо сделать определение вне класса для элементов данных, как показано ниже:  
  
```  
class CMyClass  {  
   static const int max = 5;  
   int m_array[max];  
}  
...  
const int CMyClass::max;   // out of class definition  
```  
  
 По стандарту **\/Ze** определение вне класса необязательно для статических \(static\), целых постоянных \(const int\) и постоянных перечислений \(const enum\) элементов данных.  Только целые и перечисления, статический и const могут иметь инициализаторы в классе; при инициализации выражение должно быть выражение const.  
  
 Чтобы избежать ошибок при определении вне класса содержится в файле заголовка и файл заголовка включен в нескольких файлах источника, используйте [selectany](../../cpp/selectany.md).  Примеры.  
  
```  
__declspec(selectany) const int CMyClass::max = 5;  
```  
  
## Приведение типов  
 Компилятор и C\-компилятор C\+\+ поддерживают следующие типы преобразований не ANSI.  
  
-   Приведение не ANSI для создания L\-значение.  Примеры.  
  
    ```  
    char *p;  
    (( int * ) p )++;  
    ```  
  
    > [!NOTE]
    >  Это расширение доступно только в языке C.  Можно использовать следующую форму ANSI C — стандартная в коде C\+\+ изменения указателя, если это указатель на другой тип.  
  
     Предыдущий пример может быть переписан для обеспечения соответствия стандарту ANSI C.  
  
    ```  
    p = ( char * )(( int * )p + 1 );  
    ```  
  
-   Приведение не ANSI указателя функции к указателю данных.  Примеры.  
  
    ```  
    int ( * pfunc ) ();   
    int *pdata;  
    pdata = ( int * ) pfunc;  
    ```  
  
     Для выполнения такого же приведение и поддерживать совместимость ANSI можно привести указатель функции в `uintptr_t` перед его приведение к указателю данных:  
  
    ```  
    pdata = ( int * ) (uintptr_t) pfunc;  
    ```  
  
## Списки аргументов переменной длины  
 Компилятор и C\-компилятор C\+\+ декларатор поддерживают функции, который определяет переменное число аргументов, перед определением функции, предоставляющий тип вместо:  
  
```  
void myfunc( int x, ... );  
void myfunc( int x, char * c )  
{ }  
```  
  
## Однострочные комментарии  
 C\-компилятор поддерживает одностроковые комментарии, которые вставляются с помощью 2 знаков косой черты \(\/\).  
  
```  
// This is a single-line comment.  
```  
  
## Область  
 C\-компилятор поддерживает следующие нужно связанные функции.  
  
-   Переопределения элементов extern как static:  
  
    ```  
    extern int clip();  
    static int clip()  
    {}  
    ```  
  
-   Использование мягких переопределений typedef в той же области действия:  
  
    ```  
    typedef int INT;  
    typedef int INT;  
    ```  
  
-   У деклараторов функций есть область действия:  
  
    ```  
    void func1()  
    {  
        extern int func2( double );  
    }  
    int main( void )  
    {  
        func2( 4 );    //  /Ze passes 4 as type double  
    }                  //  /Za passes 4 as type int  
    ```  
  
-   Использование переменных в области видимости блока, которые инициализируются с использованием неконстантного выражений.  
  
    ```  
    int clip( int );  
    int bar( int );  
    int main( void )  
    {  
        int array[2] = { clip( 2 ), bar( 4 ) };  
    }  
    int clip( int x )  
    {  
        return x;  
    }  
    int bar( int x )  
    {  
        return x;  
    }  
    ```  
  
## Объявление и определение данных  
 C\-компилятор поддерживает следующие функции объявления и определения данных.  
  
-   Смешанные символы и строковые константы в инициализаторе:  
  
    ```  
    char arr[5] = {'a', 'b', "cde"};  
    ```  
  
-   Битовые поля с базовые типы, отличные от **unsigned int** или **signed int**.  
  
-   Деклараторы, не имеющие тип:  
  
    ```  
    x;  
    int main( void )  
    {  
        x = 1;  
    }  
    ```  
  
-   Массивы без указанного размера в качестве последнего поля структуры или объединения:  
  
    ```  
    struct zero  
    {  
        char *c;  
        int zarray[];  
    };  
    ```  
  
-   Безымянные \(анонимные\) структуры:  
  
    ```  
    struct  
    {  
        int i;  
        char *s;  
    };  
    ```  
  
-   Безымянные \(анонимные\) объединения:  
  
    ```  
    union  
    {  
        int i;  
        float fl;  
    };  
    ```  
  
-   Безымянные члены:  
  
    ```  
    struct s  
    {  
       unsigned int flag : 1;  
       unsigned int : 31;  
    }  
    ```  
  
## Встроенные функции с плавающей запятой  
 Компилятор C\+\+ и поддержка компилятора C\- создание **x86 с \>** является встроенной `atan`, `atan2`, `cos`, `exp`, `log`, `log10`, `sin`, `sqrt` и функций **КОНЕЧНАЯ x86 с**`tan` при **\/Oi** будет определено.  Для компилятора C\-, соответствия ANSI потеряно при следующих встроенных используются, поскольку они не задаются `errno` переменным.  
  
## Передача неконстантного указателя в функцию, которая ожидает ссылку на константный указатель  
 Это расширение языка C\+\+.  Этот код будет компилироваться с **\/Ze**:  
  
```  
typedef   int   T;  
  
const T  acT = 9;      // A constant of type 'T'  
const T* pcT = &acT;   // A pointer to a constant of type 'T'  
  
void func2 ( const T*& rpcT )   // A reference to a pointer to a constant of type 'T'  
{  
   rpcT = pcT;  
}  
  
T*   pT;               // A pointer to a 'T'  
  
void func ()  
{  
   func2 ( pT );      // Should be an error, but isn't detected  
   *pT   = 7;         // Invalidly overwrites the constant 'acT'  
}  
```  
  
## ISO646.H не включено  
 При использовании параметра **\/Ze** необходимо включить файл iso646.h, если требуется использовать текстовые формы следующих операторов:  
  
-   && \(и\)  
  
-   &\= \(and\_eq\)  
  
-   & bitand \(\)  
  
-   &#124; \(bitor\)  
  
-   ~ \(compl\)  
  
-   \! \(not\)  
  
-   \!\= \(not\_eq\)  
  
-   &#124;&#124; \(or\)  
  
-   &#124;\= \(or\_eq\)  
  
-   ^ \(xor\)  
  
-   ^\= \(xor\_eq\)  
  
## Адрес строкового литерала, типа const char \[\], не const char \* \[\(\)\]  
 В следующем примере выводится тип char const \(\*\)\[4\] с использованием параметра **\/Za**, но если используется параметр **\/Ze**, выводится тип char const \[4\].  
  
```  
#include <stdio.h>  
#include <typeinfo>  
  
int main()  
{  
    printf_s("%s\n", typeid(&"abc").name());  
}  
```  
  
## См. также  
 [\/Za, \/Ze \(отключить расширения языка\)](../../build/reference/za-ze-disable-language-extensions.md)   
 [Параметры компилятора](../../build/reference/compiler-options.md)   
 [Настройка параметров компилятора](../Topic/Setting%20Compiler%20Options.md)