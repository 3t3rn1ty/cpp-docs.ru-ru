---
title: ЭКСПОРТЫ | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-tools
ms.topic: reference
f1_keywords:
- EXPORTS
dev_langs:
- C++
helpviewer_keywords:
- EXPORTS .def file statement
ms.assetid: dbcd7579-b855-44c4-bd27-931e157657f7
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 7cc7a9995fdc5be786712752e30015337b9f1607
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
---
# <a name="exports"></a>EXPORTS
Начинает раздел, состоящий из одного или нескольких определений экспорта, в которых указываются имена или порядковые номера экспортируемых функций или данных. Каждое определение должно находиться в отдельной строке.  
  
```  
EXPORTS  
   definition  
```  
  
## <a name="remarks"></a>Примечания  
 Первое определение `definition` может располагаться в одной строке с ключевым словом `EXPORTS` или в следующей строке. В файле DEF могут содержаться один или несколько операторов `EXPORTS`.  
  
 Синтаксис определения экспорта `definition`.  
  
```  
  
entryname[=internalname] [@ordinal [NONAME]] [[PRIVATE] | [DATA]]  
```  
  
 `entryname` — это имя функции или переменной, которую необходимо экспортировать. Оно является обязательным. Если экспортируемое имя отличается от имени в библиотеке DLL, укажите имя экспорта в DLL с помощью параметра `internalname`. Например, если библиотека DLL экспортирует функцию `func1` и вы хотите, чтобы она вызывалась как функция `func2`, укажите следующее.  
  
```  
EXPORTS  
   func2=func1  
```  
  
 Так как компилятор Visual C++ использует декорирование имен для функций C++, необходимо использовать декорированное имя в качестве параметра `entryname` или `internalname` либо определить экспортируемые функции с помощью `extern "C"` в исходном коде. Компилятор также декорирует функции C, использующие [__stdcall](../../cpp/stdcall.md) вызов соглашение с префиксом в виде символа подчеркивания (_) и суффиксом, состоящим из символа (@) за которым следует число байтов (в десятичном формате) в списке аргументов.  
  
 Чтобы найти декорированные имена, созданные компилятором, используйте [DUMPBIN](../../build/reference/dumpbin-reference.md) средства или компоновщик [/MAP](../../build/reference/map-generate-mapfile.md) параметр. Декорированные имена зависят от компилятора. Если вы экспортируете декорированные имена в файле DEF, сборка исполняемых файлов, связанных с библиотекой DLL, должна осуществляться с помощью той же версии компилятора. Таким образом обеспечивается совпадение декорированных имен в вызывающем объекте с экспортированными именами в файле DEF.  
  
 @`ordinal` позволяет указать, что номер, а не имя функции попадет в таблицу экспорта библиотеки DLL. Многие библиотеки DLL Windows экспортируют порядковые номера для поддержки устаревшего кода. В 16-разрядном коде Windows часто использовались порядковые номера, так как это позволяло уменьшить размер DLL. Мы не рекомендуем экспортировать функции по порядковым номерам, если это не требуется клиентам библиотеки DLL для поддержки устаревшего кода. Файл LIB будет содержать сопоставление между порядковым номером и функцией, что позволит использовать имя функции, как обычно в проектах, использующих DLL.  
  
 Дополнительное ключевое слово `NONAME` позволяет экспортировать только порядковый номер и сократить размер таблицы экспорта в конечной библиотеке DLL. Тем не менее если вы хотите использовать [GetProcAddress](http://msdn.microsoft.com/library/windows/desktop/ms683212.aspx) в DLL, необходимо знать порядковый номер, поскольку имя не будет допустимым.  
  
 Дополнительное ключевое слово `PRIVATE` не допускает присутствия параметра `entryname` в библиотеке импорта, созданной LINK. Оно не влияет на экспорт в образ, также созданный с помощью LINK.  
  
 Дополнительное ключевое слово `DATA` указывает на то, что экспорт содержит данные, а не код. Например, переменную с именем `exported_global`, содержащую данные, можно экспортировать так.  
  
```  
EXPORTS  
   exported_global DATA  
```  
  
 Существует четыре способа экспорта определения; здесь они перечислены в порядке предпочтительности:  
  
1.  [__Declspec(dllexport)](../../cpp/dllexport-dllimport.md) ключевое слово в исходном коде  
  
2.  оператор `EXPORTS` в файле DEF;  
  
3.  [И экспорт](../../build/reference/export-exports-a-function.md) спецификации в команде LINK  
  
4.  Объект [комментарий](../../preprocessor/comment-c-cpp.md) директив в исходном коде, формы `#pragma comment(linker, "/export: definition ")`  
  
 Все эти методы можно использовать в одной программе. Когда программа LINK создает программу, содержащую экспорты, она также создает библиотеку импорта (если только при построении не используется файл EXP).  
  
 Ниже приведен пример раздела EXPORTS.  
  
```  
EXPORTS  
   DllCanUnloadNow      @1          PRIVATE  
   DllWindowName = WindowName       DATA  
   DllGetClassObject    @4 NONAME   PRIVATE  
   DllRegisterServer    @7  
   DllUnregisterServer  
```  
  
 Если экспортируется переменная из библиотеки DLL с помощью файла DEF, вам не надо указывать `__declspec(dllexport)` для переменной. Однако в любом файле, использующем библиотеку DLL, вы должны использовать `__declspec(dllimport)` для объявления данных.  
  
## <a name="see-also"></a>См. также  
 [Правила для операторов определения модуля](../../build/reference/rules-for-module-definition-statements.md)