---
title: "Ограничения /clr | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "/clr - параметр компилятора [C++], ограничения"
ms.assetid: 385f6462-2c68-46d6-810e-469553ead447
caps.latest.revision: 27
caps.handback.revision: 27
author: "corob-msft"
ms.author: "corob"
manager: "ghogen"
---
# Ограничения /clr
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

Обратите внимание на следующие ограничения по применению параметра **\/clr**:  
  
-   В обработчиках структурированных исключений налагаются ограничения на использование функции `_alloca` при компиляции с параметром **\/clr**.  Дополнительные сведения см. в разделе [\_alloca](../../c-runtime-library/reference/alloca.md).  
  
-   Использование проверок ошибок во время выполнения при использовании параметра **\/clr** не допускается.  Дополнительные сведения см. в разделе [Проверки ошибок во время выполнения](../Topic/How%20to:%20Use%20Native%20Run-Time%20Checks.md).  
  
-   Когда параметр **\/clr** используется для компиляции программы, использующей только стандартный синтаксис C\+\+, на использование встроенных операторов языка ассемблера налагаются следующие ограничения:  
  
    -   Встроенный код на языке ассемблера, полагающийся на определенные правила организации стека, соглашения о вызове за пределами текущей функции или другую низкоуровневую информацию о компьютере, может привести к сбою, если эта информация применяется для работы с кадром стека управляемой функции.  Функции, содержащие встроенный код на языке ассемблера, генерируются как неуправляемые, как если бы они размещались в отдельном модуле, компилируемом без использования параметра **\/clr**.  
  
    -   Встроенный код на языке ассемблера нельзя использовать в функциях, принимающих параметры, передаваемые с помощью конструкторов копирования.  
  
-   [Функции vprintf](../../c-runtime-library/vprintf-functions.md) нельзя вызывать из программы, скомпилированной с параметром **\/clr**.  
  
-   Модификатор [\_\_declspec](../../cpp/declspec.md) [naked](../Topic/naked%20\(C++\).md) игнорируется при использовании параметра \/clr.  
  
-   Функция\-преобразователь, заданная с помощью функции [\_set\_se\_translator](../../c-runtime-library/reference/set-se-translator.md), будет использоваться только в перехватчиках исключений в неуправляемом коде.  Дополнительные сведения см. в разделе [Обработка исключений](../../windows/exception-handling-cpp-component-extensions.md).  
  
-   При использовании параметра **\/clr** не допускается сравнение указателей на функции.  
  
-   При использовании параметра **\/clr** не допускается использование функций, не имеющих полных прототипов.  
  
-   Следующие параметры компилятора нельзя использовать вместе с параметром **\/clr**:  
  
    -   **\/EHsc** и **\/EHs** \(параметр **\/clr** неявно предполагает параметр **\/EHa** \(см. раздел [Параметр \/EH \(модель обработки исключений\)](../../build/reference/eh-exception-handling-model.md)\);  
  
    -   **\/fp:strict** и **\/fp:except** \(см. раздел [\/fp \(Определение поведения с плавающей запятой\)](../../build/reference/fp-specify-floating-point-behavior.md)\);  
  
    -   [\/Zd](../Topic/-Z7,%20-Zi,%20-ZI%20\(Debug%20Information%20Format\).md)  
  
    -   [\/Gm](../../build/reference/gm-enable-minimal-rebuild.md)  
  
    -   [\/MT](../../build/reference/md-mt-ld-use-run-time-library.md)  
  
    -   [\/RTC](../../build/reference/rtc-run-time-error-checks.md)  
  
    -   **\/ZI**  
  
-   Сочетание определения препроцессора `_STATIC_CPPLIB` \(`/D_STATIC_CPPLIB`\) и параметра компилятора **\/clr** или **\/clr:pure** не поддерживается.  Причина в том, что определение приводит к компоновке приложения со статической многопотоковой стандартной библиотекой C\+\+; такое поведение не поддерживается.  Дополнительные сведения см. в разделе [\/MD, \/MT, \/LD \(использование библиотеки времени выполнения\)](../../build/reference/md-mt-ld-use-run-time-library.md).  
  
-   Параметр [\/J](../../build/reference/j-default-char-type-is-unsigned.md) нельзя использовать вместе с параметром **\/clr:safe** или **\/clr:pure**.  
  
-   Библиотеки ATL и MFC не поддерживаются при компиляции в режиме чистого промежуточного языка \(**\/clr:pure**\).  Параметр **\/clr:pure** можно использовать со стандартной библиотекой C\+\+ и библиотекой времени выполнения C, если одновременно используется параметр **\/MD** или **\/MDd**.  
  
-   При использовании параметра **\/Zi** одновременно с параметром **\/clr** страдает производительность.  Дополнительные сведения см. в разделе [\/Zi](../Topic/-Z7,%20-Zi,%20-ZI%20\(Debug%20Information%20Format\).md).  
  
-   Передача многобайтового знака в процедуру вывода .NET Framework без одновременного указания параметра [\/Zc:wchar\_t](../../build/reference/zc-wchar-t-wchar-t-is-native-type.md) или без приведения знака к типу `__wchar_t` ведет к тому, что вывод будет иметь вид `unsigned short int`.  Примеры.  
  
    ```  
    Console::WriteLine(L' ')              // Will output 32.  
    Console::WriteLine((__wchar_t)L' ')   // Will output a space.  
    ```  
  
-   Параметр [\/GS](../Topic/-GS%20\(Buffer%20Security%20Check\).md) пропускается при компиляции с параметром **\/clr**, если только функция не включена в директиву pragma `#pragma` [unmanaged](../../preprocessor/managed-unmanaged.md) или же не компилируется в машинном коде; в последнем случае компилятор выдает предупреждение C4793, которое по умолчанию отключено.  
  
-   Дополнительные сведения о требованиях, предъявляемых к сигнатурам функций в управляемых приложениях, см. в разделе [\/ENTRY](../../build/reference/entry-entry-point-symbol.md).  
  
-   Приложения, компилируемые с параметрами **\/openmp** и **\/clr**, могут выполняться только в процессе с одним доменом приложения.  Дополнительные сведения см. в разделе [\/openmp \(включение поддержки OpenMP 2.0\)](../../build/reference/openmp-enable-openmp-2-0-support.md).  
  
-   Функции, принимающие переменное число аргументов \(varargs\), будут компилироваться в машинном коде.  Любые управляемые типы данных, используемые в качестве дополнительных аргументов, будут маршалироваться в неуправляемые типы.  Обратите внимание, что типы <xref:System.String?displayProperty=fullName> в действительности являются многобайтовыми строками, но они маршалируются в строки однобайтовых знаков.  Соответственно, если в функции printf используется спецификатор "%S" \(тип wchar\_t\*\), то он будет упакован в строку "%s".  
  
-   Если при компиляции с параметром **\/clr:pure** используется макрос va\_arg, результаты его использования могут быть непредвиденными.  Для получения дополнительной информации см. [va\_arg, va\_copy, va\_end, va\_start](../../c-runtime-library/reference/va-arg-va-copy-va-end-va-start.md).  
  
-   Если приложение передает аргумент типа [va\_list](../../c-runtime-library/reference/va-arg-va-copy-va-end-va-start.md) в функцию, которая в соответствии с объявлением принимает [переменное количество аргументов](../Topic/Variable%20Argument%20Lists.md), и приложение компилируется с **\/clr:pure**, среда CLR вызывает исключение <xref:System.NotSupportedException>.  Если вместо этого используется **\/clr** , затронутые функции компилируются в машинный код и выполняются правильно.  Если используется **\/clr:safe**, выдается ошибка диагностики.  
  
-   Из управляемого кода не следует вызывать любые функции, проходящие по стеку для получения сведений о параметрах \(аргументов функций\); уровень P\/Invoke переводит эти сведения ниже по стеку.  Например, с параметром **\/clr** не следует компилировать прокси и заглушки.  
  
-   Функции по возможности компилируются в управляемом коде, но не все конструкции C\+\+ можно преобразовать в управляемый код.  Возможность преобразования определяется отдельно для каждой функции.  Если часть функции нельзя преобразовать в управляемый код, то вся функция будет скомпилирована в машинном коде.  Компилятор не генерирует управляемый код в следующих случаях.  
  
    -   Генерируемые компилятором преобразователи и вспомогательные функции.  Преобразователи в машинном коде генерируются для всех вызовов функций через указатель на функцию, в том числе и для вызовов виртуальных функций;  
  
    -   Функции, вызывающие команду `setjmp` или `longjmp`;  
  
    -   Функции, использующие определенные встроенные процедуры для прямого взаимодействия с аппаратными ресурсами.  К примеру, использование встроенных процедур `__enable` и `__disable`, `_ReturnAddress` и `_AddressOfReturnAddress` или мультимедийных встроенных процедур приведет к компиляции в машинном коде;  
  
    -   Функции, следующие директиве `#pragma unmanaged`. \(обратите внимание, что также поддерживается обратная директива, `#pragma managed`\);  
  
    -   Функции, содержащие ссылки на выравниваемые типы, то есть типы, объявленные с помощью модификатора `__declspec(align(...))`.  
  
-   Классы [Поддержка компилятора COM](../Topic/Compiler%20COM%20Support.md) нельзя использовать с параметром **\/clr:pure** или **\/clr:safe**.  
  
## См. также  
 [\/clr \(компиляция CLR\)](../../build/reference/clr-common-language-runtime-compilation.md)