---
title: "-clr ограничения | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-tools
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
helpviewer_keywords: /clr compiler option [C++], restrictions
ms.assetid: 385f6462-2c68-46d6-810e-469553ead447
caps.latest.revision: "27"
author: corob-msft
ms.author: corob
manager: ghogen
ms.openlocfilehash: b5113abbf63fdb7ab87363e5344806d6eb34e0dd
ms.sourcegitcommit: ebec1d449f2bd98aa851667c2bfeb7e27ce657b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/24/2017
---
# <a name="clr-restrictions"></a>Ограничения /clr
Обратите внимание на следующие ограничения на использование **/CLR**:  
  
-   В обработчик структурированных исключений, существуют ограничения на использование `_alloca` при компиляции с параметром **/CLR**. Дополнительные сведения см. в разделе [_alloca](../../c-runtime-library/reference/alloca.md).  
  
-   Использование проверки ошибок во время выполнения не допускается с **/CLR**. Дополнительная информация есть в статье [Практическое руководство. Настройка проверок во время выполнения машинного кода](/visualstudio/debugger/how-to-use-native-run-time-checks).  
  
-   Когда **/CLR** — используется для компиляции программы, использующей только стандартный синтаксис C++ с использованием встроенного кода на ассемблере применяются следующие правила:  
  
    -   Встроенный код сборки, предполагает собственный стек макета, соглашения за пределами текущей функции или другую низкоуровневую информацию о компьютере, при вызове невозможно, если эта информация применяется к кадру стека управляемой функции. Функции, содержащие встроенный код сборки создаются как неуправляемые функции, как если бы они были размещены в отдельном модуле, который был скомпилирован без **/CLR**.  
  
    -   Встроенный код ассемблера в функциях, которые передают параметры функции с помощью конструкторов копирования не поддерживается.  
  
-   [Функции vprintf](../../c-runtime-library/vprintf-functions.md) нельзя вызвать из программы, скомпилированной с **/CLR**.  
  
-   [Naked](../../cpp/naked-cpp.md) [__declspec](../../cpp/declspec.md) модификатор учитывается в/CLR.  
  
-   Функция-преобразователь задается [_set_se_translator](../../c-runtime-library/reference/set-se-translator.md) будет только в перехватчиках в неуправляемом коде. В разделе [обработка исключений](../../windows/exception-handling-cpp-component-extensions.md) для получения дополнительной информации.  
  
-   Сравнение указателей на функции не разрешено **/CLR**.  
  
-   Не разрешено использование функций, которые не являются полным прототипом **/CLR**.  
  
-   Не поддерживает следующие параметры компилятора **/CLR**:  
  
    -   **/ EHsc** и **/EHs** (**/CLR** подразумевает **/EHa** (см. [/EH (модель обработки исключений)](../../build/reference/eh-exception-handling-model.md))  
  
    -   **/ fp: strict** и **/fp: except** (см. [/FP (указать поведение с плавающей запятой)](../../build/reference/fp-specify-floating-point-behavior.md))  
  
    -   [/ Zd](../../build/reference/z7-zi-zi-debug-information-format.md)  
  
    -   [/Gm](../../build/reference/gm-enable-minimal-rebuild.md)  
  
    -   [/MT](../../build/reference/md-mt-ld-use-run-time-library.md)  
  
    -   [/RTC](../../build/reference/rtc-run-time-error-checks.md)  
  
    -   **/ ZI**  
  
-   Сочетание `_STATIC_CPPLIB` определение препроцессора (`/D_STATIC_CPPLIB`) и **/CLR** или **/CLR: pure** параметр компилятора не поддерживается. Это так, так как определение приводит приложение для связи с статические многопоточные стандартной библиотеки C++, который не поддерживается. Дополнительные сведения см. в разделе [/MD, / MT, /LD (использование библиотеки времени выполнения)](../../build/reference/md-mt-ld-use-run-time-library.md) раздела.  
  
-   [/J](../../build/reference/j-default-char-type-is-unsigned.md) не поддерживается с **/CLR: safe** или **/CLR: pure**. Параметры компилятора **/CLR: pure** и **/CLR: safe** в Visual Studio 2015 не рекомендуется использовать.  
  
-   Библиотеки ATL и MFC не поддерживаются в чистом режиме компиляции (**/CLR: pure**). Можно использовать **/CLR: pure** со стандартной библиотеки C++ и CRT, если одновременно с **/MD** или **/MDd**.  
  
-   При использовании **/ZI** с **/CLR**, это влияет на производительность. Дополнительные сведения см. в разделе [/ZI](../../build/reference/z7-zi-zi-debug-information-format.md).  
  
-   Передача расширенных символов в .NET Framework вывода процедуру без указания [/Zc: wchar_t](../../build/reference/zc-wchar-t-wchar-t-is-native-type.md) или без приведения знака к `__wchar_t` вызовет выходные данные отображаются в виде `unsigned short int`. Пример:  
  
    ```  
    Console::WriteLine(L' ')              // Will output 32.  
    Console::WriteLine((__wchar_t)L' ')   // Will output a space.  
    ```  
  
-   [/ GS](../../build/reference/gs-buffer-security-check.md) игнорируется при компиляции с параметром **/CLR**, если функция находится в `#pragma` [неуправляемые](../../preprocessor/managed-unmanaged.md) или если функция необходимо скомпилировать в машинный код, в этом случае компилятор Показывать предупреждение C4793, которое отключено по умолчанию.  
  
-   В разделе [/Entry](../../build/reference/entry-entry-point-symbol.md) для требования к сигнатуре функции управляемого приложения.  
  
-   Приложения, скомпилированные с **/OpenMP** и **/CLR** могут выполняться только в процессе один домен приложения.  В разделе [/OpenMP (Включение поддержки OpenMP 2.0)](../../build/reference/openmp-enable-openmp-2-0-support.md) для получения дополнительной информации.  
  
-   Функции, которые принимают переменное число аргументов (varargs) будет создан в машинном коде. Все управляемые типы данных в позиции переменное число аргументов будет маршалировать в собственные типы. Обратите внимание, что <xref:System.String?displayProperty=fullName> типы являются строками с расширенными символами фактически, но они маршалируются в строки однобайтовых символов. Поэтому если спецификатор printf %S (wchar_t *), он будет упакован в строку %s вместо.  
  
-   При использовании va_arg-макрос, можно получить непредвиденные результаты при компиляции с параметром **/CLR: pure**.  Дополнительные сведения см. в разделе [va_arg, va_copy, va_end, va_start](../../c-runtime-library/reference/va-arg-va-copy-va-end-va-start.md).  
  
-   Если приложение передает аргумент типа [va_list](../../c-runtime-library/reference/va-arg-va-copy-va-end-va-start.md) функции объявлено принимает переменное число аргументов, а приложение компилируется с **/CLR: pure**, среда CLR вызывает <xref:System.NotSupportedException>. Если **/CLR** используется вместо этого затронутые функции компилируются в машинный код и выполняться правильно. Если **/CLR: safe** — используется, выдается ошибка диагностики.  
  
-   Не следует вызывать, из управляемого кода, любые функции, обход стека для получения сведений о параметре (аргументы функции); уровень P/Invoke переводит эти сведения для последующего вниз по стеку.  Например, не компилируйте прокси/заглушки с **/CLR**.  
  
-   Функции компилируются в управляемый код, когда это возможно, но не все конструкции C++ можно преобразовать в управляемый код.  Это решение принимается на основе функции, функции. Если любую часть функции не удается преобразовать в управляемый код, всей функции преобразуется в машинный код, вместо этого. Запретить компилятору выполнять вариантов создания управляемого кода.  
  
    -   Созданная компилятором преобразователи и вспомогательные функции. Преобразователи в машинном коде создаются для всех вызовов функций через указатель функции, включая вызовы виртуальной функции.  
  
    -   Функции, вызывающие `setjmp` или `longjmp`.  
  
    -   Функции, использующие определенные встроенные процедуры для взаимодействия непосредственно с аппаратными ресурсами. Например, использование `__enable` и `__disable`, `_ReturnAddress` и `_AddressOfReturnAddress`, или встроенные функции мультимедиа будет все результирующие в машинном коде.  
  
    -   Функции ниже `#pragma unmanaged` директивы. (Обратите внимание, что обратная `#pragma managed`, также поддерживается.)  
  
    -   Функции, которая содержит ссылки на краю типов, то есть типы, объявленные с помощью `__declspec(align(...))`.  
  
-   Нельзя использовать [модели COM в компиляторе](../../cpp/compiler-com-support.md) классы с **/CLR: pure** или **/CLR: safe**.  
  
## <a name="see-also"></a>См. также  
 [/ CLR (компиляция CLR)](../../build/reference/clr-common-language-runtime-compilation.md)