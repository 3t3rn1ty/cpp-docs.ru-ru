---
title: Профильная оптимизация | Документы Microsoft
ms.custom: ''
ms.date: 03/14/2018
ms.technology:
- cpp-tools
ms.topic: reference
dev_langs:
- C++
helpviewer_keywords:
- profile-guided optimizations
- optimization, profile-guided [C++]
ms.assetid: 2225c307-d3ae-42c1-8345-a5a959d132dc
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: c7d6de281097232b1b8abc10a103af9c186e3550
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
ms.locfileid: "32379410"
---
# <a name="profile-guided-optimizations"></a>Профильная оптимизация

Профильная оптимизация позволяет оптимизировать выходной файл, используя данные из тестовых запусков EXE- или DLL-файла. Данные представляют, как программа, вероятно, будет работать в рабочей среде.

Профильные оптимизации доступны только x86 или x64 компиляции в машинный код. Профильная оптимизация недоступны для выходных файлов, выполняемых в среде CLR. Даже если создать сборку со смешанным машинным и управляемым кодом (с помощью **/CLR** параметр компилятора), нельзя использовать профильную оптимизацию только для машинного кода. При попытке построить проект с этими параметрами, заданными в Интегрированной среде разработки, приводит к ошибке сборки.

> [!NOTE]
> Сведения, полученные из теста профилирования, запускают переопределения оптимизаций, которые в противном случае вступят в силу при указании **/Ob**, **/Os**, или **/Ot**. Дополнительные сведения см. в разделе [/Ob (расширение встроенных функций)](../../build/reference/ob-inline-function-expansion.md) и [/OS, /Ot (приоритет размера кода, предпочтения быстрого кода)](../../build/reference/os-ot-favor-small-code-favor-fast-code.md).

## <a name="steps-to-optimize-your-app"></a>Шаги для оптимизации приложения

Чтобы использовать профильной оптимизации, выполните следующие действия для оптимизации приложения.

- Компиляции одного или нескольких файлов исходного кода с [/GL](../../build/reference/gl-whole-program-optimization.md).

   Каждый модуль, построенный с **/GL** может быть проанализирован во время тестовых запусков профильной оптимизации для захвата поведение во время выполнения. Каждый модуль в построении профильной оптимизации не должен быть скомпилирован с **/GL**. Однако только те модули, скомпилированные с **/GL** будут обработаны и доступны для профильной оптимизации.

- Связывание с помощью [/LTCG](../../build/reference/ltcg-link-time-code-generation.md) и [/genprofile или/fastgenprofile](../../build/reference/genprofile-fastgenprofile-generate-profiling-instrumented-build.md).

   Использование обеих **/LTCG** и **/genprofile** или **/fastgenprofile** создает PGD-файла, при выполнении инструментированного приложения. После добавления данных тестового запуска в PGD-файл они могут использоваться как входные данные для следующего этапа компоновки (создание оптимизированного образа). При указании **/genprofile**, вы можете добавить **PGD =**_filename_ аргумент, чтобы указать нестандартным именем или расположением PGD-файла. Сочетание **/LTCG** и **/genprofile** или **/fastgenprofile** заменяет устаревшие параметры компоновщика **/LTCG: PGINSTRUMENT** параметр компоновщика.

- Профилирование приложения.

   Каждый раз профилируемый сеанс EXE или профилируемый DLL-ФАЙЛ выгружается, *appname*! # .pgc файл создается. PGC-файл содержит сведения об определенном тестовом запуске приложения. # — Это номер, начиная с 1, который увеличивается в зависимости от числа других *appname*! # .pgc файлы в каталоге. Можно удалить PGC-файл, если тестовый запуск не представляет сценарий, который вы хотите оптимизировать.

   Во время выполнения теста принудительное закрытие открытых PGC-файла и создание нового PGC-файл с [pgosweep](../../build/reference/pgosweep.md) программы (например, если конец тестового сценария не совпадает с завершением работы приложения).

   Приложение также напрямую можно вызвать функцию профильной Оптимизации [использованием PgoAutoSweep](pgoautosweep.md), чтобы сохранить данные профиля в точке вызова как PGC-файл. Это можно получить более точный контроль кода, включенный в файлы .pgc захваченные данные. Пример использования этой функции см. в разделе [использованием PgoAutoSweep](pgoautosweep.md) документации.

   При создании инструментированной сборки по умолчанию сбор данных выполняется в режиме не потокобезопасна, который позволяет быстрее, но может быть не вполне точной. С помощью **EXACT** аргумент **/genprofile** или **/fastgenprofile**, сбор данных можно указать в режиме потокобезопасна, который является более точной, но медленнее. Этот параметр доступен также при установке устаревших [PogoSafeMode](environment-variables-for-profile-guided-optimizations.md#pogosafemode) переменной среды или устаревшие **/POGOSAFEMODE** компоновщика, при создании инструментированной сборки.

- Связывание с помощью **/LTCG** и **параметром/useprofile**.

   Использовать оба **/LTCG** и [параметром/useprofile](useprofile.md) параметры компоновщика для создания оптимизированного образа. На этом шаге в качестве входных данных принимается PGD-файл. При указании **параметром/useprofile**, вы можете добавить **PGD =**_filename_ аргумент, чтобы указать имя не по умолчанию или расположением PGD-файла. Это имя также можно указать с помощью устаревших **/PGD** компоновщика. Сочетание **/LTCG** и **параметром/useprofile** заменяет устаревшие **/LTCG: PGOPTIMIZE** и **/LTCG: PGUPDATE** параметры компоновщика.

Можно даже создать оптимизированный выходной файл и позже определить, что дополнительное профилирование будет полезно для создания более оптимизированного образа. Если инструментированный образ и соответствующий PGD-файл доступны, можно выполнить дополнительные тестовые запуски и перестройте оптимизированный образ с новым PGD-файлом с тем же **/LTCG** и **параметром/useprofile** параметры компоновщика .

## <a name="optimizations-performed-by-pgo"></a>Оптимизацию, выполняемую с профильной Оптимизации

Ниже приведен список профильных оптимизаций.

- **Встраивание** — например, если существует функция A, которая часто вызывает функцию B, а функция B относительно невелико, то Профильная оптимизация встроит функцию B в функцию A.

- **Отражение виртуального вызова** — Если виртуальный или другой вызов через указатель функции часто предназначен для определенной функции, Профильная оптимизация может вставить условно выполняемый прямой вызов функции часто целевые и прямой вызов может быть встроен.

- **Распределение регистров** — Оптимизация с результатами данных профиля в лучше выделение регистров.

- **Простая блочная оптимизация** -Простая блочная оптимизация позволяет часто выполняемые основные блоки, которые временно выполняются во фрейме должен располагаться в одном наборе страниц (локально). Это минимизирует число используемых страниц, уменьшая тем самым затраты памяти.

- **Оптимизация размера и скорости** -функции, на которые программа тратит много времени могут быть оптимизированы по скорости.

- **Структура функции** — на основании графа вызовов и профилирования поведение вызываемого и вызывающего объектов функции, как правило, относятся к одному пути выполнения, размещаются в том же разделе.

- **Оптимизация условного ветвления** — с помощью зондов значений Профильная оптимизация может определить, если заданное значение в операторе switch используется чаще, чем другие значения.  Затем это значение может быть извлечено из оператора switch.  То же можно сделать с инструкциями if/else, где оптимизатор может упорядочить их так, чтобы блок if или else размещался первым в зависимости от того, какой блок чаще получает значение true.

- **Отделение неиспользуемого кода** -код, который не вызывается во время профилирования, перемещается в специальный раздел, добавляемый в конец набора разделов. Это позволяет вынести раздел с часто используемых страниц.

- **Отделение кода EH** -EH, чрезвычайно выполняемый код, можно поместить в отдельный раздел при профильной оптимизации удается определить, что исключения возникают только при исключительных условиях.

- **Внутренние функции памяти** — расширение внутренних компонентов можно оптимизировать, если можно определить, если часто вызываются. Встроенная функция может также быть оптимизирована на основе размера блока перемещения или копирования.

Если вы используете Visual Studio 2013, можно использовать автоматический [профиль подключаемый модуль профильной оптимизации](../../build/reference/profile-guided-optimization-in-the-performance-and-diagnostics-hub.md) для Visual C++ в концентраторе производительности и диагностики упростить и ускорить процесс оптимизации в среде Visual Studio. Этот подключаемый модуль доступен не в более поздних версиях Visual Studio.

## <a name="next-steps"></a>Следующие шаги

Дополнительные сведения о эти переменные среды, функции и средства, которые можно использовать в профильной оптимизации.

[Переменные среды для профильной оптимизации](../../build/reference/environment-variables-for-profile-guided-optimizations.md)<br/>
Эти переменные могут использоваться для указания поведения сценариев тестирования во время выполнения. Они стали нерекомендуемыми в пользу новых параметров; чтение, это может помочь перейти от переменные среды, чтобы параметры компоновщика.

[PgoAutoSweep](pgoautosweep.md)<br/>
Функции можно добавить в приложение, обеспечивая возможность управления системы отслеживания измененных данных файл .pgc детально.

[pgosweep](../../build/reference/pgosweep.md)<br/>
Программа командной строки, которая записывает все данные профиля в файл PGC закрывает PGC-файл и открывает новый PGC-файл.

[pgomgr](../../build/reference/pgomgr.md)<br/>
Программа командной строки, добавление данных профиля из одного или нескольких файлов PGC в PGD-файл.

[Как: слияние нескольких профилей PGO в единый профиль](../../build/reference/how-to-merge-multiple-pgo-profiles-into-a-single-profile.md) примеры **pgomgr** использования.

## <a name="see-also"></a>См. также

[Средства сборки С/C++](../../build/reference/c-cpp-build-tools.md)
