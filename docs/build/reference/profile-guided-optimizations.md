---
title: "Профильная оптимизация | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-tools
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
helpviewer_keywords:
- profile-guided optimizations
- optimization, profile-guided [C++]
ms.assetid: 2225c307-d3ae-42c1-8345-a5a959d132dc
caps.latest.revision: "26"
author: corob-msft
ms.author: corob
manager: ghogen
ms.openlocfilehash: 467888dc773a8d84e5a1b3fc1fd2c337b06654be
ms.sourcegitcommit: ebec1d449f2bd98aa851667c2bfeb7e27ce657b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/24/2017
---
# <a name="profile-guided-optimizations"></a>Профильная оптимизация
Профильная оптимизация позволяет оптимизировать выходной файл, используя данные из тестовых запусков EXE- или DLL-файла. Данные представляют, как программа, вероятно, будет работать в рабочей среде.  
  
 Профильные оптимизации доступны только при компиляции в машинный код для x86 и [!INCLUDE[vcprx64](../../assembler/inline/includes/vcprx64_md.md)]. Они недоступны для выходных файлов, которые будут запускаться в среде CLR. Даже если создать сборку со смешанным машинным и управляемым кодом (компиляция с **/CLR**), нельзя использовать профильную оптимизацию только для машинного кода. Попытка построить проект с этими параметрами, заданными в среде разработки, приведет к ошибке построения.  
  
> [!NOTE]
>  Сведения, полученные при тестах профилирования, переопределяют оптимизации, которые в противном случае вступят в силу при указании **/Ob**, **/Os**, или **/Ot**. Дополнительные сведения см. в разделе [/Ob (расширение встроенных функций)](../../build/reference/ob-inline-function-expansion.md) и [/OS, /Ot (приоритет размера кода, предпочтения быстрого кода)](../../build/reference/os-ot-favor-small-code-favor-fast-code.md).  
  
 Вы можете упростить и ускорить процесс оптимизации с помощью подключаемого модуля автоматической профильной оптимизации для Visual C++ в концентраторе производительности и диагностики Visual Studio. Или же можно выполнить оптимизацию вручную в Visual Studio или в командной строке. Мы рекомендуем использовать подключаемый модуль, поскольку это более простой метод. Сведения о том, как получить подключаемый модуль и использовать его для оптимизации приложения см. в разделе [профиль подключаемый модуль профильной оптимизации](../../build/reference/profile-guided-optimization-in-the-performance-and-diagnostics-hub.md).  
  
 Подключаемый модуль профильной оптимизации и ручная профильная оптимизация используют следующие действия для оптимизации приложения.  
  
-   Компиляции одного или нескольких файлов исходного кода с [/GL](../../build/reference/gl-whole-program-optimization.md).  
  
     Каждый модуль, построенный с параметром /GL, может быть проанализирован во время тестовых запусков профильной оптимизации для получения информации о поведении во время выполнения. Не каждый модуль в построении профильной оптимизации требуется компилировать с параметром /GL. Однако только модули, скомпилированные с его использованием, будут обработаны и доступны для профильной оптимизации.  
  
-   Связывание с помощью [/LTCG](../../build/reference/ltcg-link-time-code-generation.md) и [/genprofile](../../build/reference/genprofile-fastgenprofile-generate-profiling-instrumented-build.md).  
  
     Используя параметр/LTCG и/genprofile создает пустой PGD-файл. После добавления данных тестового запуска в PGD-файл они могут использоваться как входные данные для следующего этапа компоновки (создание оптимизированного образа). При указании/genprofile, при необходимости можно добавлять: PGD =`filename` для указания нестандартным именем или расположением PGD-файла.  
  
-   Профилирование приложения.  
  
     Каждый раз профилируемый сеанс EXE или профилируемый DLL-ФАЙЛ выгружается, *appname*! # .pgc файл создается. PGC-файл содержит сведения об определенном тестовом запуске приложения. # — Это номер, начиная с 1, который увеличивается в зависимости от числа других *appname*! # .pgc файлы в каталоге. Можно удалить PGC-файл, если тестовый запуск не представляет сценарий, который вы хотите оптимизировать.  
  
     Во время выполнения теста принудительное закрытие открытых PGC-файла и создание нового PGC-файл с [pgosweep](../../build/reference/pgosweep.md) программы (например, если конец тестового сценария не совпадает с завершением работы приложения).  
  
     При профилировании приложения параметр можно использовать `PogoSafeMode`. Этот параметр позволяет указать, следует ли профилировать приложение в безопасном или в быстром режиме. Дополнительные сведения о режимах см. в разделе [PogoSafeMode](../../build/reference/pogosafemode.md).  
  
-   Свяжите, используя параметр/LTCG и параметром/useprofile.  
  
     Используя параметр/LTCG и параметром/useprofile создает оптимизированный образ. На этом шаге в качестве входных данных принимается PGD-файл. При указании параметром/useprofile, при необходимости можно добавлять: PGD =`filename` для указания нестандартным именем или расположением PGD-файла. Дополнительные сведения см. в разделе [/LTCG](../../build/reference/ltcg-link-time-code-generation.md).  
  
 Можно даже создать оптимизированный выходной файл и позже определить, что дополнительное профилирование будет полезно для создания более оптимизированного образа. Если инструментированный образ и соответствующий PGD-файл доступны, можно выполнить дополнительные тестовые запуски и повторно создать оптимизированный образ с новым PGD-файлом.  
  
 Ниже приведен список профильных оптимизаций.  
  
-   **Встраивание** — например, если существует функция A, которая часто вызывает функцию B, а функция B относительно невелико, то Профильная оптимизация встроит функцию B в функцию A.  
  
-   **Отражение виртуального вызова** — Если виртуальный или другой вызов через указатель функции часто предназначен для определенной функции, Профильная оптимизация может вставить условно выполняемый прямой вызов функции часто целевые и прямой вызов может быть встроен.  
  
-   **Распределение регистров** — Оптимизация с результатами данных профиля в лучше выделение регистров.  
  
-   **Простая блочная оптимизация** -Простая блочная оптимизация позволяет часто выполняемые основные блоки, которые временно выполняются во фрейме должен располагаться в одном наборе страниц (локально). Это минимизирует число используемых страниц, уменьшая тем самым затраты памяти.  
  
-   **Оптимизация размера и скорости** -функции, на которые программа тратит много времени могут быть оптимизированы по скорости.  
  
-   **Структура функции** — на основании графа вызовов и профилирования поведение вызываемого и вызывающего объектов функции, как правило, относятся к одному пути выполнения, размещаются в том же разделе.  
  
-   **Оптимизация условного ветвления** — с помощью зондов значений Профильная оптимизация может определить, если заданное значение в операторе switch используется чаще, чем другие значения.  Затем это значение может быть извлечено из оператора switch.  То же можно сделать с инструкциями if/else, где оптимизатор может упорядочить их так, чтобы блок if или else размещался первым в зависимости от того, какой блок чаще получает значение true.  
  
-   **Отделение неиспользуемого кода** -код, который не вызывается во время профилирования, перемещается в специальный раздел, добавляемый в конец набора разделов. Это позволяет вынести раздел с часто используемых страниц.  
  
-   **Отделение кода EH** -EH, чрезвычайно выполняемый код, можно поместить в отдельный раздел при профильной оптимизации удается определить, что исключения возникают только при исключительных условиях.  
  
-   **Внутренние функции памяти** — расширение внутренних компонентов можно оптимизировать, если можно определить, если часто вызываются. Встроенная функция может также быть оптимизирована на основе размера блока перемещения или копирования.  
  
 Дополнительные сведения о ручной оптимизации в Интегрированной среде разработки или в командной строке см. в разделе [профиль подключаемый модуль профильной оптимизации](../../build/reference/profile-guided-optimization-in-the-performance-and-diagnostics-hub.md).  
  
## <a name="in-this-section"></a>Содержание  
 [Подключаемый модуль профильной оптимизации](../../build/reference/profile-guided-optimization-in-the-performance-and-diagnostics-hub.md)  
  
 [Средства для профильной оптимизации вручную](../../build/reference/tools-for-manual-profile-guided-optimization.md)  
  
 [Практическое руководство. Слияние нескольких профилей PGO в единый профиль](../../build/reference/how-to-merge-multiple-pgo-profiles-into-a-single-profile.md)  
  
## <a name="see-also"></a>См. также  
 [Средства сборки С/C++](../../build/reference/c-cpp-build-tools.md)