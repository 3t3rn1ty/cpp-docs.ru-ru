---
title: "Профильная оптимизация | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "оптимизация, профильная [C++]"
  - "профильная оптимизация"
ms.assetid: 2225c307-d3ae-42c1-8345-a5a959d132dc
caps.latest.revision: 26
caps.handback.revision: 24
author: "corob-msft"
ms.author: "corob"
manager: "ghogen"
---
# Профильная оптимизация
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

Профильная оптимизация позволяет оптимизировать выходной файл, используя данные из тестовых запусков EXE\- или DLL\-файла.  Данные представляют, как программа, вероятно, будет работать в рабочей среде.  
  
 Профильные оптимизации доступны только при компиляции в машинный код для x86 и [!INCLUDE[vcprx64](../Token/vcprx64_md.md)].  Они недоступны для выходных файлов, которые будут запускаться в среде CLR.  Даже если создать сборку со смешанным машинным и управляемым кодом \(компиляция с параметром **\/clr**\), невозможно использовать профильную оптимизацию только для машинного кода.  Попытка построить проект с этими параметрами, заданными в среде разработки, приведет к ошибке построения.  
  
> [!NOTE]
>  Сведения, полученные при тестах профилирования, переопределяют оптимизации, которые вступят в силу в противном случае, если указать **\/Ob**, **\/Os** или **\/Ot**.  Подробнее: [Параметр \/Ob \(расширение встроенных функций\)](../../build/reference/ob-inline-function-expansion.md) и [\/Os, \/Ot \(приоритет размера кода или скорости кода\)](../../build/reference/os-ot-favor-small-code-favor-fast-code.md).  
  
 Вы можете упростить и ускорить процесс оптимизации с помощью подключаемого модуля автоматической профильной оптимизации для Visual C\+\+ в концентраторе производительности и диагностики Visual Studio. Или же можно выполнить оптимизацию вручную в Visual Studio или в командной строке.  Мы рекомендуем использовать подключаемый модуль, поскольку это более простой метод.  Сведения о том, как получить подключаемый модуль и использовать его для оптимизации приложения, см. в разделе [Подключаемый модуль профильной оптимизации](../../build/reference/profile-guided-optimization-in-the-performance-and-diagnostics-hub.md).  
  
 Подключаемый модуль профильной оптимизации и ручная профильная оптимизация используют следующие действия для оптимизации приложения.  
  
-   Компиляции одного или нескольких файлов исходного кода с параметром [\/GL](../../build/reference/gl-whole-program-optimization.md).  
  
     Каждый модуль, построенный с параметром \/GL, может быть проанализирован во время тестовых запусков профильной оптимизации для получения информации о поведении во время выполнения.  Не каждый модуль в построении профильной оптимизации требуется компилировать с параметром \/GL.  Однако только модули, скомпилированные с его использованием, будут обработаны и доступны для профильной оптимизации.  
  
-   Компоновка с параметром [\/LTCG:PGINSTRUMENT](../../build/reference/ltcg-link-time-code-generation.md).  
  
     \/LTCG:PGINSTRUMENT создает пустой PGD\-файл.  После добавления данных тестового запуска в PGD\-файл они могут использоваться как входные данные для следующего этапа компоновки \(создание оптимизированного образа\).  При указании параметра \/LTCG:PGINSTRUMENT можно также задать параметр [\/PGD](../../build/reference/pgd-specify-database-for-profile-guided-optimizations.md) с нестандартным именем или расположением PGD\-файла.  
  
-   Профилирование приложения.  
  
     Каждый раз, когда профилируемый сеанс EXE или профилируемый DLL\-файл выгружается, создается PGC\-файл *имя\_приложения*\!\#.pgc.  PGC\-файл содержит сведения об определенном тестовом запуске приложения.  \# — это номер, начиная с 1, который увеличивается в зависимости от числа других файлов *имя\_приложения*\!\#.pgc в каталоге.  Можно удалить PGC\-файл, если тестовый запуск не представляет сценарий, который вы хотите оптимизировать.  
  
     Во время тестового запуска можно принудительно закрыть открытый в текущий момент PGC\-файл и создать новый PGC\-файл с помощью служебной программы [pgosweep](../../build/reference/pgosweep.md) \(например, если конец тестового сценария не совпадает с завершением работы приложения\).  
  
     При профилировании приложения параметр можно использовать `PogoSafeMode`.  Этот параметр позволяет указать, следует ли профилировать приложение в безопасном или в быстром режиме.  Дополнительные сведения об этих элементах см. в разделе [PogoSafeMode](../../build/reference/pogosafemode.md).  
  
-   Компоновка с параметром \/LTCG:PGOPTIMIZE.  
  
     Параметр \/LTCG:PGOPTIMIZE создает оптимизированный образ.  На этом шаге в качестве входных данных принимается PGD\-файл.  Подробнее об этом см. в разделе [\/LTCG:PGOPTIMIZE](../../build/reference/ltcg-link-time-code-generation.md).  
  
 Можно даже создать оптимизированный выходной файл и позже определить, что дополнительное профилирование будет полезно для создания более оптимизированного образа.  Если инструментированный образ и соответствующий PGD\-файл доступны, можно выполнить дополнительные тестовые запуски и повторно создать оптимизированный образ с новым PGD\-файлом.  
  
 Ниже приведен список профильных оптимизаций.  
  
-   **Встраивание** — например, если существует функция A, которая часто вызывает функцию B, а функция B относительно небольшая, то профильная оптимизация встроит функцию B в функцию A.  
  
-   **Отражение виртуального вызова** — если виртуальный или другой вызов через указатель функции часто предназначен для определенной функции, профильная оптимизация может вставить условно выполняемый прямой вызов функции.  
  
-   **Распределение регистров** — оптимизация с данными профиля улучшает распределение регистров.  
  
-   **Простая блочная оптимизация** позволяет разместить часто выполняемые основные блоки, которые временно выполняются во фрейме, в одном наборе страниц \(локально\).  Это минимизирует число используемых страниц, уменьшая тем самым затраты памяти.  
  
-   **Оптимизация размера и скорости**  — функции, на которые программа тратит много времени, могут быть оптимизированы по скорости.  
  
-   **Структура функции**  — на основе графа вызовов и поведения профилируемого вызываемого и вызывающего объектов функции, которые, как правило, относятся к одному пути выполнения, размещаются в одном разделе.  
  
-   **Оптимизация условного ветвления** — с помощью зондов значений профильная оптимизация может определить, используется ли заданное значение в операторе switch чаще, чем другие значения.  Затем это значение может быть извлечено из оператора switch.  То же можно сделать с инструкциями if\/else, где оптимизатор может упорядочить их так, чтобы блок if или else размещался первым в зависимости от того, какой блок чаще получает значение true.  
  
-   **Отделение неиспользуемого кода**  — код, который не вызывается во время профилирования, перемещается в специальный раздел, добавляемый в конец набора разделов.  Это позволяет вынести раздел с часто используемых страниц.  
  
-   **Отделение кода EH** — код EH, который выполняется очень часто, во многих случаях можно поместить в отдельный раздел, если профильной оптимизации удается определить, что исключения возникают только при исключительных условиях.  
  
-   **Внутренние функции памяти** — расширение внутренних компонентов можно оптимизировать, если определить, какие из них часто вызываются.  Встроенная функция может также быть оптимизирована на основе размера блока перемещения или копирования.  
  
 Подробнее о ручной оптимизации в интегрированной среде разработки или в командной строке см. в разделе [Пошаговое руководство. Использование профильной оптимизации](http://msdn.microsoft.com/ru-ru/6e36421b-ec8c-4626-9c29-fa5ffb6f27f8).  
  
## Содержание  
 [Подключаемый модуль профильной оптимизации](../../build/reference/profile-guided-optimization-in-the-performance-and-diagnostics-hub.md)  
  
 [Средства профильной оптимизации](../../build/reference/tools-for-manual-profile-guided-optimization.md)  
  
 [Практическое руководство. Слияние нескольких профилей PGO в единый профиль](../Topic/How%20to:%20Merge%20Multiple%20PGO%20Profiles%20into%20a%20Single%20Profile.md)  
  
## См. также  
 [Средства построения С\/C\+\+](../Topic/C-C++%20Build%20Tools.md)