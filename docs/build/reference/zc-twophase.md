---
title: "/Zc:twoPhase-(отключить поиск двухфазной имени) | Документы Microsoft"
ms.custom: 
ms.date: 03/06/2018
ms.technology:
- cpp-tools
ms.topic: article
f1_keywords:
- twoPhase
- /Zc:twoPhase
- VC.Project.VCCLCompilerTool.EnforceTypeConversionRules
dev_langs:
- C++
helpviewer_keywords:
- twoPhase
- disable two-phase name lookup
- /Zc:twoPhase
author: corob-msft
ms.author: corob
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: 4582a5532d9fd410224ee4174ca3973bfe539656
ms.sourcegitcommit: eeb2b5ad8d3d22514a7b9bd7d756511b69ae0ccf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/15/2018
---
# <a name="zctwophase--disable-two-phase-name-lookup"></a>/Zc:twoPhase-(отключить поиск двухфазной имени)

Когда **/Zc:twoPhase-** параметр указан, компилятор выполняет синтаксический анализ и создает экземпляр класса шаблонов и функции в несоответствующих аналогично версии Visual Studio до версии 15,3 2017 г. Visual Studio. 

## <a name="syntax"></a>Синтаксис

> **/Zc:twoPhase-**

## <a name="remarks"></a>Примечания

В Visual Studio 2017 г. версия 15,3 и более поздних версиях по умолчанию компилятор использует поиск двухфазной имени для разрешения имен шаблона. Если **/Zc:twoPhase-** указан, компилятор переходит в его предыдущего несоответствующих класса шаблона и функция имя разрешения и подстановки поведение шаблона.

**/Zc:twoPhase-** возможность включения несоответствующих поведение по умолчанию не задано. [/ Разрешительным-](permissive-standards-conformance.md) параметр неявно задает соответствующих поведение компилятора двухфазной уточняющего запроса, но его можно переопределить с помощью **/Zc:twoPhase-**.

Файлы заголовков Windows SDK версия 10.0.15063.0 (обновление создатели или Redstone 2) и более ранних версий не работают в режиме совместимости. Необходимо использовать **/Zc:twoPhase-** для компиляции кода для этих версий пакета SDK, при использовании версии Visual Studio 2017 г 15,3 и более поздних версиях. Версии пакета SDK Windows, начиная с версии 10.0.15254.0 (Redstone 3 или обновление создатели Осень) правильно работают в режиме совместимости и не требуют **/Zc:twoPhase-** параметр.

Используйте **/Zc:twoPhase-** Если код требует выполнения старое поведение для правильной компиляции. Настоятельно рекомендуется обновить код, чтобы соответствовать стандарту.

### <a name="compiler-behavior-under-zctwophase-"></a>Поведение компилятора /Zc:twoPhase-

В версиях до Visual Studio 2017 г. версия 15,3, компилятор и когда **/Zc:twoPhase-** указан, компилятор использует это поведение:

- Анализирует только объявление шаблона класса head и список базовых классов. Текст шаблона записывается в виде потока лексем. Нет тело функции, инициализаторы, аргументы по умолчанию или noexcept аргументы анализируются. Шаблон класса псевдо экземпляр пробного типа для проверки правильности объявления шаблона класса. Рассмотрим следующий шаблон класса.

   ```cpp
   template <typename T> class Derived : public Base<T> { ... }
   ```

   Объявление шаблона `template <typename T`>, заголовке класса `class Derived`и в списке базовых классов `public Base<T>` синтаксического анализа, но текста шаблона записывается в виде потока лексем.

- При синтаксическом анализе шаблона функции, компилятор выполняет синтаксический анализ только сигнатуру функции. Тело функции никогда не выполняется синтаксический анализ. Вместо этого он записывается в виде потока лексем.

В результате Если шаблон никогда не инициализируется текста шаблона содержит синтаксические ошибки, ошибки никогда не обнаружить.

Другим эффектом такого поведения — в разрешении перегрузки. Таким образом потока лексем развернут на сайте при создании экземпляра символы, которые не были видны в объявлении шаблона может быть видимым в момент создания экземпляра и участвует в разрешении перегрузки. Это может привести к шаблонам, изменяющие поведение на основе кода, который не был видимым при определении шаблона, в отличие от стандартной.

Например, рассмотрим следующий код.

```cpp
#include <cstdio>

void func(void*) { std::puts("The call resolves to void*") ;}

template<typename T> void g(T x)
{
    func(0);
}

void func(int) { std::puts("The call resolves to int"); }

int main() 
{
    g(3.14);
}
```

При компиляции в **/Zc:twoPhase-**, эта программа выводит «вызов разрешается int». В режиме совместимости под **/ разрешительным-**, эта программа выводит «вызов разрешается void *», так как второй перегрузки `func` не отображается, когда компилятор обнаруживает шаблон.

*Зависимые имена*, имена, которые зависят от параметра шаблона, имеют режим уточняющего запроса, который также отличается в **/Zc:twoPhase-**. В режиме совместимости зависимых имен не связаны точке определения шаблона. Вместо этого такие имена ищутся при создании экземпляра шаблона. Для вызовов функции с именем зависимые функции имя привязан к набору функций, видимых в точке вызова в определении шаблона, как описано выше. В точке определения шаблона и где шаблона создается точки добавляются дополнительные перегрузки в поиске с зависимостью от аргументов. Две фазы двухфазной подстановки являются поиск не зависит от имен во время определения шаблона и поиска для зависимых имен во время создания экземпляра шаблона. В разделе **/Zc:twoPhase-**, компилятор не выполняет поиск с зависимостью от аргументов отдельно от обычного или неполным Уточняющий запрос (то есть, он не выполняет двухфазной уточняющего запроса), поэтому результаты разрешения перегрузки могут отличаться.

Вот другой пример:

```cpp
// zctwophase1.cpp
// Compile by using
// cl /EHsc /W4 /permissive- zctwophase1.cpp
// cl /EHsc /W4 /permissive- /Zc:twoPhase- zctwophase1.cpp

#include <cstdio>

void func(long) { std::puts("func(long)"); }

template <typename T> void tfunc(T t) {
    func(t);
}

void func(int) { std::puts("func(int)"); }

namespace NS {
    struct S {};
    void func(S) { std::puts("NS::func(NS::S)"); }
}

int main() {
    tfunc(1729);
    NS::S s;
    tfunc(s);
}
```

При компиляции без **/Zc:twoPhase-**, это печать

```Output
func(long)
NS::func(NS::S)
```

При компиляции с параметром **/Zc:twoPhase-**, это печать

```Output
func(int)
NS::func(NS::S)
```

В режиме совместимости в разделе **/ разрешительным-**, вызов `tfunc(1729)` разрешается в `void func(long)` перегрузку, не `void func(int)` как перегрузить **/Zc:twoPhase-**, так как неполное `func(int)` объявляется после определения шаблона и не удалось найти путем поиска зависимостью от аргументов. Но `void func(S)` участвовать в поиске с зависимостью от аргументов, поэтому добавлять перегрузка этого метода для вызова `tfunc(s)` несмотря на то, что он объявлен после функции шаблона.

### <a name="update-your-code-for-two-phase-conformance"></a>Обновите код на соответствие двухфазной

Старые версии компилятора не требуют ключевые слова `template` и `typename` everywhere стандарт C++ требует их. Эти ключевые слова в некоторые положения требуются для устранения неоднозначности как компиляторы должен выделять зависимое имя в первой фазе уточняющего запроса. Пример:

`T::Foo<a || b>(c);`

Согласование компилятор анализирует `Foo` как переменную в области `T`, то есть этот код является логического- или выражения с `T::foo < a` как левый операнд и `b > (c)` как правый операнд. Если вы хотели использовать `Foo` как шаблон функции необходимо указать, что это шаблон, добавив `template` ключевое слово:

`T::template Foo<a || b>(c);`

В версиях до Visual Studio 2017 г. версия 15,3 и когда **/Zc:twoPhase-** указан, компилятор разрешает этот код без `template` ключевое слово и интерпретирует его как вызов шаблона функции с аргументом `a || b`, так как он анализирует шаблоны в ограниченном режиме. На первом этапе приведенный выше код не во всех синтаксический анализ. На втором этапе является достаточным контекстом, чтобы определить, что `T::Foo` является шаблоном, а не переменной, поэтому компилятор не предписывает использование ключевого слова.

Это поведение также можно увидеть, удалив ключевое слово `typename` перед именами в тело функции шаблона, инициализаторы, аргументы по умолчанию и noexcept аргументы. Пример:

```cpp
template<typename T>
typename T::TYPE func(typename T::TYPE*)
{
    /* typename */ T::TYPE i;
}
```

Если вы не используете ключевое слово `typename` в теле функции этот код компилируется при использовании **/Zc:twoPhase-**, но не при использовании **/ разрешительным-**. `typename` Для указания того, что требуется ключевое слово `TYPE` является зависимым. Так как текст не будет обработано в **/Zc:twoPhase-**, does't компилятора требуется ключевое слово. В **/ разрешительным-** режим совместимости, без кода `typename` ключевое слово приводит к возникновению ошибки. Перенос кода в Visual Studio 2017 г. версия 15,3 и выше, вставить `typename` ключевое слово, где он отсутствует.

Аналогичным образом рассмотрим этот пример кода:

```cpp
template<typename T>
typename T::template X<T>::TYPE func(typename T::TYPE)
{
    typename T::/* template */ X<T>::TYPE i;
}
```

В разделе **/Zc:twoPhase-** и в более старых компиляторах компилятор только требует `template` ключевое слово в строке 2. По умолчанию, а в режиме совместимости, компилятор теперь также требует `template` ключевое слово в строке 4, чтобы указать, что `T::X<T>` является шаблоном. Найдите код, который не удалось обнаружить это ключевое слово и передайте в него кода соответствует стандарту.

Дополнительные сведения о вопросах соответствия см. в разделе [улучшения соответствия C++ в Visual Studio](../../cpp-conformance-improvements-2017.md) и [нестандартное поведение](../../cpp/nonstandard-behavior.md).

### <a name="to-set-this-compiler-option-in-the-visual-studio-development-environment"></a>Установка данного параметра компилятора в среде разработки Visual Studio

1. Откройте диалоговое окно **Страницы свойств** проекта. Дополнительные сведения см. в разделе [работа со свойствами проекта](../../ide/working-with-project-properties.md).

1. Выберите **свойства конфигурации** > **C/C++** > **командной строки** страницу свойств.

1. Изменить **Дополнительные параметры** включив **/Zc:twoPhase-** и выберите **ОК**.

## <a name="see-also"></a>См. также

[/Zc (соответствие)](../../build/reference/zc-conformance.md)<br/>
