---
title: Рекомендации по оптимизации | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-tools
ms.topic: reference
dev_langs:
- C++
helpviewer_keywords:
- Visual C++, optimization
- optimization, best practices
ms.assetid: f3433148-7255-4ca6-8a4f-7c31aac88508
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 4e869a12635117f37f32fad3dcfdd38ed45d401e
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
---
# <a name="optimization-best-practices"></a>Рекомендации по оптимизации
В этом документе описаны рекомендации по оптимизации в Visual C++. Рассматриваются следующие темы:  
  
-   Параметры компилятора и компоновщика  
  
    -   Профильная оптимизация  
  
    -   Какой уровень оптимизации следует использовать?  
  
    -   Число с плавающей точки коммутаторов  
  
-   Оптимизация спецификаций объявлений  
  
-   Прагмы оптимизации  
  
-   __restrict и \__assume  
  
-   Поддержка встроенных функций  
  
-   Исключения  
  
## <a name="compiler-and-linker-options"></a>Параметры компилятора и компоновщика  
  
### <a name="profile-guided-optimization"></a>Профильная оптимизация  
 Visual C++ поддерживает профильной оптимизации (PGO). Эта оптимизация использует данные профиля во время прошлых запусков инструментированной версии приложения для передачи более поздней версии оптимизации приложения. С помощью профильной Оптимизации может занять много времени, поэтому он не может быть то, что каждый разработчик использует, но рекомендуется использовать профильной Оптимизации для построения окончательной версии продукта. Дополнительные сведения см. в разделе [профильные оптимизации](../../build/reference/profile-guided-optimizations.md).  
  
 Кроме того, оптимизация всей программы (также известная как создание кода во время компоновки) и **/O1** и **/O2** была улучшена. Как правило приложение, скомпилированное с помощью одного из этих параметров будет быстрее, чем же приложение, скомпилированное с более ранней версии компилятора.  
  
 Дополнительные сведения см. в разделе [/GL (оптимизация всей программы)](../../build/reference/gl-whole-program-optimization.md) и [/O1, / O2 (минимизировать размер, максимизировать скорость)](../../build/reference/o1-o2-minimize-size-maximize-speed.md).  
  
### <a name="which-level-of-optimization-should-i-use"></a>Какой уровень оптимизации следует использовать?  
 Если это возможно заключительные построения выпуска должны компилироваться с использованием профильной оптимизации. Если это не возможным построение с использованием профильной Оптимизации, из-за недостаточности инфраструктуры для запуска инструментированных построений или отсутствия доступа к скриптам, рекомендуется выполнить построение оптимизация всей программы.  
  
 **/Gy** коммутатор также очень полезно. Он создает отдельный COMDAT для каждой функции, предоставляя компоновщику большую гибкость, когда дело доходит до удаления элементов COMDAT и COMDAT свертывания. Единственный недостаток **/Gy** возможность задать незначительное влияние на время построения. Таким образом обычно рекомендуется использовать его. Дополнительные сведения см. в разделе [/Gy (включение компоновки на уровне функций)](../../build/reference/gy-enable-function-level-linking.md).  
  
 Для компоновки в 64-разрядной среде рекомендуется использовать **/OPT: REF, ICF** компоновщика и в 32-разрядных сред **/OPT: ref** рекомендуется. Дополнительные сведения см. в разделе [/OPT (оптимизации)](../../build/reference/opt-optimizations.md).  
  
 Также настоятельно рекомендуется создавать отладочные символы, даже с оптимизированных построений выпуска. Он не влияет на созданный код, и он упрощает отладку приложения, если должны быть.  
  
### <a name="floating-point-switches"></a>Число с плавающей точки коммутаторов  
 **/Op** параметр компилятора был удален, и были добавлены следующие четыре параметры компилятора, посвященные оптимизации плавающей запятой:  
  
|||  
|-|-|  
|**/ fp: точный**|Это параметр по умолчанию и в большинстве случаев следует использовать.|  
|**/fp:fast**|Рекомендуется использовать, если производительность имеет первостепенное значение, например в играх. Это приведет максимальную производительность.|  
|**/ fp: strict**|Если рекомендуемых точный исключений с плавающей запятой и IEEE требуемого поведения. Это приведет к в самую низкую производительность.|  
|**/ fp: except [-]**|Можно использовать в сочетании с **/fp: strict** или **/fp: точный**, но не **/fp:fast**.|  
  
 Дополнительные сведения см. в разделе [/fp (определение поведения с плавающей запятой)](../../build/reference/fp-specify-floating-point-behavior.md).  
  
## <a name="optimization-declspecs"></a>Оптимизация спецификаций объявлений  
 В этом разделе мы рассмотрим две спецификации объявлений, которые могут использоваться в программах для повышения производительности: `__declspec(restrict)` и `__declspec(noalias)`.  
  
 `restrict` Declspec может применяться только к объявлениям функций, возвращающих указатель, например `__declspec(restrict) void *malloc(size_t size);`  
  
 `restrict` Спецификация используется применительно к функциям, возвращающим указатели. Это ключевое слово используется для реализации библиотеки времени выполнения C `malloc` поскольку она никогда не возвращает значение указателя, уже используется в текущей программе (если только не выполняется недопустимое действие, например использование памяти после ее освобождения).  
  
 `restrict` Declspec предоставляет компилятору больше сведений для выполнения оптимизации компилятора. Один из самых сложных задач для компилятора, чтобы определить, какие указатели псевдоним других указателей, они используют помогают компилятор.  
  
 Это стоит обратить внимание что это Обещание компилятора, не то, что компилятор должен убедиться в. Если программа использует это `restrict` declspec неверно, программа может наблюдаться неправильная работа.  
  
 Дополнительные сведения см. в разделе [ограничить](../../cpp/restrict.md).  
  
 `noalias` Declspec также применяется только к функциям и указывает, что функция является функция. Функция имеет один, которая ссылается на только локальные переменные, аргументы и косвенные обращения первого уровня аргументов. Это спецификация полагается на компилятор и если она ссылается на глобальные переменные или косвенные обращения второго уровня аргументы указателя, то компилятор может создать код, прерывает приложение.  
  
 Дополнительные сведения см. в разделе [noalias](../../cpp/noalias.md).  
  
## <a name="optimization-pragmas"></a>Прагмы оптимизации  
 Существует несколько прагм, способствующих оптимизации кода. Первый способ, мы обсудим `#pragma optimize`:  
  
```  
#pragma optimize("{opt-list}", on | off)  
```  
  
 Эта директива #pragma позволяет задать определенный уровень оптимизации на основе функции, функции. Это идеально подходит для редких случаях, где приложение аварийно завершает работу при компиляции с оптимизацией данной функции. Это можно использовать, чтобы отключить оптимизацию для одной функции:  
  
```  
#pragma optimize("", off)  
int myFunc() {...}  
#pragma optimize("", on)  
```  
  
 Дополнительные сведения см. в разделе [оптимизировать](../../preprocessor/optimize.md).  
  
 Встраивание является одним из наиболее важных оптимизации, которые компилятор выполняет и здесь мы говорим о несколько директив pragma, чтобы изменить это поведение.  
  
 `#pragma inline_recursion` можно указать, требуется ли приложению встраивать рекурсивный вызов. По умолчанию — off. Для неполной рекурсии небольших функций, можно включить этот режим. Дополнительные сведения см. в разделе [inline_recursion](../../preprocessor/inline-recursion.md).  
  
 Другой полезной прагмой для ограничения глубины встраивания является `#pragma inline_depth`. Обычно это полезно в ситуациях, где вы пытаетесь ограничить размер программы или функции. Дополнительные сведения см. в разделе [inline_depth](../../preprocessor/inline-depth.md).  
  
## <a name="restrict-and-assume"></a>__restrict и \__assume  
 Существует несколько ключевых слов в Visual C++, который может повысить производительность: [__restrict](../../cpp/extension-restrict.md) и [__assume](../../intrinsics/assume.md).  
  
 Во-первых, следует отметить, что `__restrict` и `__declspec(restrict)` являются двумя разными параметрами. Хотя они в некоторой степени взаимосвязаны, их семантика отличается. `__restrict` является квалификатором типа, таких как `const` или `volatile`, но предназначены только для типов указателей.  
  
 Указатель, который изменяется с `__restrict` называется *__restrict указатель*. Указатель __restrict — указатель, который может осуществляться только через \__ограничить указателя. Другими словами, другой указатель не может использоваться для доступа к данным, на который указывает \__ограничить указателя.  
  
 `__restrict` может быть мощным средством для оптимизатора Visual C++, но использовать ее с осторожностью. При неправильном использовании оптимизатор может выполнить оптимизацию, которая вызовет сбой в приложении.  
  
 `__restrict` Заменяет ключевое слово **/Oa** переход от предыдущих версий.  
  
 С `__assume`, разработчик сообщает компилятору, что делать предположений относительно значения некоторой переменной.  
  
 Например `__assume(a < 5);` означает, что в этой строке кода переменная `a` меньше 5. Снова полагается для компилятора. Если `a` является фактически 6 в программе, то поведение программы после оптимизации компилятором может отличаться от ожидаемого. `__assume` Рекомендуется использовать перед операторами switch и условными выражениями.  
  
 Существуют некоторые ограничения для `__assume`. Во-первых, такие как `__restrict`, он является всего лишь предложением, поэтому компилятор не освободить, смогут его пропустить. Кроме того `__assume` в настоящее время работает только неравенству переменных относительно констант. Он распространяется на символьные неравенства, например, assume(a < b).  
  
## <a name="intrinsic-support"></a>Поддержка встроенных функций  
 Встроенные функции, функция вызывает которых компилятор имеет внутренние сведения о вызове, а вместо вызова функции в библиотеке, он выдает код для этой функции. Заголовок intrin.h файл, расположенный в < Installation_Directory > \VC\include\intrin.h содержит все доступные встроенные функции для каждого из трех поддерживаемых платформ (x 86, x64 и ARM).  
  
 Встроенные функции позволяют программисту go код без использования сборки. Ниже перечислены некоторые преимущества использования встроенных функций:  
  
1.  Код будет более. Некоторые встроенные функции доступны для нескольких архитектур ЦП.  
  
2.  Код является более удобным для чтения, поскольку код по-прежнему написан на C/C++.  
  
3.  Код получает преимущества оптимизации компилятора. Как компилятора улучшается, повышает создание кода для встроенных функций.  
  
 Дополнительные сведения см. в разделе [встроенные объекты компилятора](../../intrinsics/compiler-intrinsics.md).  
  
## <a name="exceptions"></a>Исключения  
 Производительности попаданий, связанные с использованием исключения. Существует несколько ограничений использования блоков try, которые не позволяют компилятору выполнять определенные оптимизации. На x86 платформами, к которым имеется снижение производительности из повторите блоки, из-за дополнительной информации о состоянии, должен быть создан во время выполнения кода. На 64-разрядных платформах, попробуйте блоки не снижают производительность настолько, однако после исключения процесс поиска обработчика и очистить стек могут потреблять много ресурсов.  
  
 Таким образом рекомендуется во избежание внесения в код, без необходимости его блоки try/catch. Если необходимо использовать исключения, по возможности используйте синхронные исключения. Дополнительные сведения см. в разделе [Structured Exception Handling (C/C++)](../../cpp/structured-exception-handling-c-cpp.md).  
  
 Исключения следует вызывать только в исключительных случаях. Использование исключений для общего потока управления скорее всего будет сделать снижению производительности.  
  
## <a name="see-also"></a>См. также  
 [Оптимизация кода](../../build/reference/optimizing-your-code.md)