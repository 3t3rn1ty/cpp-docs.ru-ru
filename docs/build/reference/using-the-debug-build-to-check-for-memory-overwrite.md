---
title: Использование отладочного построения для проверки затирания памяти | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-tools
ms.topic: reference
dev_langs:
- C++
helpviewer_keywords:
- memory, overwrites
ms.assetid: 1345eb4d-24ba-4595-b1cc-2da66986311e
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 96afeb6be9aac754c952824716322c55d4819d6e
ms.sourcegitcommit: 92f2fff4ce77387b57a4546de1bd4bd464fb51b6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/17/2018
ms.locfileid: "45706359"
---
# <a name="using-the-debug-build-to-check-for-memory-overwrite"></a>Использование отладочного построения для проверки затирания памяти

Использование отладочного построения для проверки затирания памяти, сначала следует перестроить проект для отладки. Перейдите в самом начале приложения `InitInstance` функции и добавьте следующую строку:

```
afxMemDF |= checkAlwaysMemDF;
```

Механизм распределения отладочной памяти устанавливает контрольные байты всех операций выделения памяти. Тем не менее, Охранные байты не принесет пользы, пока не проверите ли они были изменены (что указывает перезаписи памяти). В противном случае это просто предоставляет буфер, возможно по сути, позволяет обойтись без перезаписи памяти.

Включив `checkAlwaysMemDF`, будут принудительно MFC для выполнения вызова к `AfxCheckMemory` функции каждый раз вызов **новый** или **удалить** выполняется. Если перезаписи памяти обнаружена, она создаст сообщение ТРАССИРОВКИ, похожее на следующее:

```
Damage Occurred! Block=0x5533
```

Если вы видите одно из следующих сообщений, необходимо пошагово выполнять код для определения, где произошло повреждение. Чтобы изолировать, более точно перезаписи памяти возникновения, можно сделать явные вызовы `AfxCheckMemory` самостоятельно. Пример:

```
ASSERT(AfxCheckMemory());
    DoABunchOfStuff();
    ASSERT(AfxCheckMemory());
```

Если первая операция ASSERT выполняется успешно, а вторая завершился неудачно, это означает, что между вызовами функции должно быть проведено перезаписи памяти.

В зависимости от особенностей конкретного приложения, может оказаться, что `afxMemDF` программа работает слишком медленно для теста. `afxMemDF` Переменная `AfxCheckMemory` вызываться для каждого вызова, чтобы создать и удалить. В этом случае следует Точечная собственные вызовы для `AfxCheckMemory`(), как показано выше и попробуйте изолировать память перезаписать таким образом.

## <a name="see-also"></a>См. также

[Устранение проблем сборки выпуска](../../build/reference/fixing-release-build-problems.md)