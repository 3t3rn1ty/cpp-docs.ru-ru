---
title: "-clr (компиляция CLR) | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "/CLR"
  - "VC.Project.VCNMakeTool.CompileAsManaged"
  - "VC.Project.VCCLCompilerTool.CompileAsManaged"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "cl.exe — компилятор, параметр среды CLR"
  - "-clr - параметр компилятора [C++]"
  - "clr - параметр компилятора [C++]"
  - "/clr - параметр компилятора [C++]"
  - "Управляемые расширения для C++, компиляция"
  - "среда CLR, /clr — параметр компилятора"
ms.assetid: fec5a8c0-40ec-484c-a213-8dec918c1d6c
caps.latest.revision: 72
author: "corob-msft"
ms.author: "corob"
manager: "ghogen"
caps.handback.revision: 72
---
# /clr (компиляция CLR)
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

Позволяет приложениям и компонентам использовать возможности из среды CLR.  
  
## Синтаксис  
  
```  
/clr[:options]  
```  
  
## Аргументы  
 `options`  
 Один или несколько из следующих параметров, разделенных запятыми.  
  
 **\/clr**  
 Создает метаданные для приложения. Создает метаданные для приложения, которые могут использовать другие CLR\-приложения, а также позволяет приложению применять типы и данные в метаданных других CLR\-компонентов.  
  
 Дополнительные сведения см. в разделе .  
  
 [Смешанные \(собственные и управляемые\) сборки](../Topic/Mixed%20\(Native%20and%20Managed\)%20Assemblies.md) и  
  
 [Практическое руководство. Переход на \/clr](../../dotnet/how-to-migrate-to-clr.md).  
  
 **\/clr:pure**  
 Создает выходной файл в формате MSIL без исполняемого неуправляемого кода. Тем не менее может содержать типы неуправляемого кода, скомпилированные в MSIL.  
  
 Дополнительные сведения см. в разделе [Чистый и проверяемый код](../../dotnet/pure-and-verifiable-code-cpp-cli.md).  
  
 \/clr:pure не рекомендуется к использованию. Будущие версии компилятора могут не поддерживать этот параметр. Мы рекомендуем перенести код, который должен быть чистым кодом MSIL, на C\#.  
  
 **\/clr:safe**  
 Создает проверяемый выходной файл MSIL \(без исполняемого машинного кода\).**\/clr:safe** включает диагностические проверки \([средство PEVerify \(Peverify.exe\)](../Topic/Peverify.exe%20\(PEVerify%20Tool\).md)\).  
  
 Дополнительные сведения см. в разделе [NIB. Написание проверяемого строго типизированного кода](http://msdn.microsoft.com/ru-ru/d18f10ef-3b48-4f47-8726-96714021547b).  
  
 \/clr:safe не рекомендуется к использованию. Будущие версии компилятора могут не поддерживать этот параметр. Мы рекомендуем перенести код, который должен быть чистым, проверяемым кодом MSIL, на C\#.  
  
 **\/clr:noAssembly**  
 Указывает, что манифест сборки не должен быть включен в выходной файл. По умолчанию параметр **noAssembly** отключен.  
  
 Параметр **NoAssembly** не рекомендуется. Взамен рекомендуется использовать [\/LN \(создание модуля MSIL\)](../../build/reference/ln-create-msil-module.md).  
  
 Управляемая программа, которая не содержит метаданных сборки в манифесте, называется *модулем*. Параметр **noAssembly** можно использовать только для создания модуля. Если компиляция выполняется с параметром [\/c](../../build/reference/c-compile-without-linking.md) и **\/clr:noAssembly**, укажите параметр [\/NOASSEMBLY](../../build/reference/noassembly-create-a-msil-module.md) на фазе компоновщика, чтобы создать модуль.  
  
 До выпуска Visual C\+\+ 2005 параметр **\/clr:noAssembly** требовал указания **\/LD**. Теперь параметр **\/LD** подразумевается при указании **\/clr:noAssembly**.  
  
 **\/clr:initialAppDomain**  
 Позволяет приложению [!INCLUDE[vcprvc](../../build/includes/vcprvc_md.md)] работать в среде CLR версии 1. При использовании параметра **initialAppDomain** могут возникнуть некоторые проблемы, которые рассматриваются в статье [ОШИБКА. Исключение AppDomainUnloaded при использовании управляемых расширений для компонентов Visual C\+\+](http://go.microsoft.com/fwlink/?LinkID=169465) на сайте технической поддержки Майкрософт.  
  
 Приложения, скомпилированные с использованием **initialAppDomain**, не должны использоваться приложением, которое применяет ASP.NET, так как этот компонент не поддерживается в версии 1 среды CLR.  
  
 **\/clr:nostdlib**  
 Указывает компилятору игнорировать каталог \\clr по умолчанию. Компилятор выдает ошибки при включении нескольких версий библиотеки DLL, например System.dll. При использовании этого параметра вы можете указать конкретную платформу для компиляции.  
  
## Заметки  
 Управляемый код — это код, который среда CLR может проверять и контролировать. Управляемый код может обращаться к управляемым объектам. Для получения дополнительной информации см. [Ограничения \/clr](../../build/reference/clr-restrictions.md).  
  
 Сведения о разработке приложений, которые определяют и используют управляемые типы, см. в разделе [Расширения компонентов для платформ среды выполнения](../../windows/component-extensions-for-runtime-platforms.md).  
  
 Приложение, скомпилированное с использованием **\/clr**, может содержать или не содержать управляемые данные.  
  
 Сведения о включении отладки управляемых приложений см. в разделе [\/ASSEMBLYDEBUG \(добавление атрибута DebuggableAttribute\)](../Topic/-ASSEMBLYDEBUG%20\(Add%20DebuggableAttribute\).md).  
  
 В куче сбора мусора будут созданы экземпляры только типов среды CLR. Для получения дополнительной информации см. [Классы и структуры](../../windows/classes-and-structs-cpp-component-extensions.md). Для компиляции функции в машинный код используйте директиву `unmanaged` pragma. Дополнительные сведения см. в разделе [managed, unmanaged](../../preprocessor/managed-unmanaged.md).  
  
 По умолчанию параметр **\/clr** отключен. Если **\/clr** включен, также действует и параметр **\/MD**. Дополнительные сведения см. в разделе [\/MD, \/MT, \/LD \(использование библиотеки времени выполнения\)](../../build/reference/md-mt-ld-use-run-time-library.md). Параметр **\/MD** гарантирует, что из файлов стандартных заголовков \(H\-файлов\) выбираются динамически связанные, многопотоковые версии процедур среды выполнения. Многопоточность необходима для управляемого программирования, так как сборщик мусора CLR запускает методы завершения во вспомогательном потоке.  
  
 Если компиляция выполняется с помощью **\/c**, можно указать тип среды CLR \(IJW, safe или pure\) выходного файла, задав параметр [\/CLRIMAGETYPE](../Topic/-CLRIMAGETYPE%20\(Specify%20Type%20of%20CLR%20Image\).md).  
  
 **\/clr** подразумевает указание **\/EHa**, и никакие другие параметры **\/EH** не поддерживаются для **\/clr**. Дополнительные сведения см. в разделе [Параметр \/EH \(модель обработки исключений\)](../../build/reference/eh-exception-handling-model.md).  
  
 Сведения о том, как определить тип образа среды файла CLR, см. в разделе [\/CLRHEADER](../../build/reference/clrheader.md).  
  
 Все модули, передаваемые компоновщику при определенном вызове, должны компилироваться с одним и тем же параметром компилятора, указывающим библиотеку времени выполнения \(**\/MD** или **\/LD**\).  
  
 Используйте параметр компоновщика [\/ASSEMBLYRESOURCE](../../build/reference/assemblyresource-embed-a-managed-resource.md) для внедрения ресурса в сборку. Параметры компоновщика [\/DELAYSIGN](../../build/reference/delaysign-partially-sign-an-assembly.md), [\/KEYCONTAINER](../../build/reference/keycontainer-specify-a-key-container-to-sign-an-assembly.md) и [\/KEYFILE](../../build/reference/keyfile-specify-key-or-key-pair-to-sign-an-assembly.md) также позволяют настраивать способ создания сборки.  
  
 При использовании **\/clr** символ `_MANAGED` определяется как 1. Для получения дополнительной информации см. [Предустановленный макрос](../../preprocessor/predefined-macros.md).  
  
 Глобальные переменные в файлах собственных объектов инициализируются первыми \(во время выполнения DllMain, если исполняемый файл — библиотека DLL\), а затем инициализируются глобальные переменные управляемого раздела \(перед выполнением любого управляемого кода\).`#pragma`[init\_seg](../../preprocessor/init-seg.md) влияет только на порядок инициализации в управляемых и неуправляемых категориях.  
  
 Компиляция с помощью **\/clr:safe** аналогична компиляции с использованием [\/platform: anycpu](../Topic/-platform%20\(C%23%20Compiler%20Options\).md) на таких языках, как C\#.  
  
## Безопасные и чистые образы  
 Чистый образ использует CLR\-версию библиотеки времени выполнения C \(CRT\). Однако среда CRT не поддается проверке, поэтому ее невозможно использовать при компиляции с помощью **\/clr:safe**. Дополнительные сведения см. в разделе [Особенности библиотеки CRT](../../c-runtime-library/crt-library-features.md).  
  
 К примерам машинного кода, который невозможно использовать в чистом образе, относятся встроенная сборка, [setjmp](../../c-runtime-library/reference/setjmp.md) и [longjmp](../../c-runtime-library/reference/longjmp.md).  
  
 Каждая точка входа чистого и безопасного образа является управляемой. При компиляции с помощью **\/clr** точка входа является неуправляемой. Для получения дополнительной информации см. [\_\_clrcall](../../cpp/clrcall.md).  
  
 При компиляции с помощью **\/clr:safe** по умолчанию переменные относятся к [домену приложения](../Topic/appdomain.md), а не к уровню процесса. Хотя по умолчанию применяется **домен приложения**, для **\/clr:pure** можно использовать переменные [процесса](../../cpp/process.md).  
  
 При запуске 32\-разрядного EXE\-файла, скомпилированного с помощью **\/clr** или **\/clr:pure** в 64\-разрядной операционной системе, приложение будет выполняться в режиме WOW64, который позволяет запускать 32\-разрядное приложение в 32\-разрядной среде CLR в 64\-разрядной операционной системе. По умолчанию EXE\-файл, скомпилированный с помощью **\/clr:safe**, будет выполняться в 64\-разрядной среде CLR на компьютере под управлением 64\-разрядной операционной системы. \(В 32\-разрядной операционной системе тот же EXE\-файл будет запускаться в 32\-разрядной среде CLR.\) Однако безопасное приложение может загрузить 32\-разрядный компонент. В этом случае безопасный образ, выполняющийся в 64\-разрядной операционной системе, завершится ошибкой при загрузке 32\-разрядного приложения \(BadFormatException\). Чтобы безопасный образ продолжал работать при загрузке 32\-разрядного образа в 64\-разрядной операционной системе, необходимо использовать параметр [\/CLRIMAGETYPE](../Topic/-CLRIMAGETYPE%20\(Specify%20Type%20of%20CLR%20Image\).md) для изменения метаданных \(.corflags\) и отметить образ для запуска в режиме WOW64. Ниже представлен пример команды. \(Укажите ваш символ записи.\)  
  
 **cl \/clr:safe t.cpp \/link \/clrimagetype:pure \/entry:?main@@$$HYMHXZ \/subsystem:console**  
  
 Сведения о получении декорированного имени см. в разделе [Внутренние имена](../Topic/Decorated%20Names.md). Дополнительные сведения о программировании 64\-разрядных приложений см. в разделе [Настройка программ для 64\-разрядных систем](../../build/configuring-programs-for-64-bit-visual-cpp.md). Сведения об использовании "чистого" кода CLR см. в статьях [Практическое руководство. Миграция в \/clr:pure](../../dotnet/how-to-migrate-to-clr-pure-cpp-cli.md) и [Чистый и проверяемый код](../../dotnet/pure-and-verifiable-code-cpp-cli.md).  
  
## Метаданные и неименованные классы  
 Неименованные классы отображаются в метаданных следующим образом: `$UnnamedClass$`*crc\-текущего\-файла*`$`*индекс*`$`, где *индекс* — это номер неименованного класса в компиляции. Например, следующий код создает неименованный класс в метаданных.  
  
```  
// clr_unnamed_class.cpp  
// compile by using: /clr /LD  
class {} x;  
```  
  
 Для просмотра метаданных используйте ildasm.exe.  
  
## Управляемые расширения для C\+\+  
 Visual C\+\+ больше не поддерживает параметр **\/clr:oldsyntax**. Этот параметр перестал поддерживаться в Visual Studio 2005. Поддерживаемый синтаксис для написания управляемого кода на C\+\+ — C\+\+\/CLI. Для получения дополнительной информации см. [Расширения компонентов для платформ среды выполнения](../../windows/component-extensions-for-runtime-platforms.md).  
  
 Если у вас есть код, использующий управляемые расширения для C\+\+, мы рекомендуем портировать его с использованием синтаксиса C\+\+\/CLI. Сведения о том, как перенести код, см. в разделе [Основы миграции C\+\+\/CLI](../../dotnet/cpp-cli-migration-primer.md).  
  
#### Установка параметра компилятора в Visual Studio  
  
1.  В области **Обозреватель решений** щелкните правой кнопкой мыши имя проекта и выберите пункт **Свойства**, чтобы открыть диалоговое окно **Страницы свойств**.  
  
2.  Выберите папку **Свойства конфигурации**.  
  
3.  На странице свойств **Общие** измените свойство **Поддержка общеязыковой среды выполнения \(CLR\)**.  
  
    > [!NOTE]
    >  Если параметр **\/clr** включен в диалоговом окне **Страницы свойств**, будут также изменены свойства параметров компилятора, несовместимые с **\/clr**. Например, если задан параметр **\/RTC** и затем включен **\/clr**, параметр **\/RTC** будет отключен.  
    >   
    >  Кроме того, при отладке приложения **\/clr** следует установить для свойства **Тип отладчика** значение **Смешанный** или **Только управляемый код**. Для получения дополнительной информации см. [Параметры проекта для конфигурации отладки C\+\+](../Topic/Project%20Settings%20for%20a%20C++%20Debug%20Configuration.md).  
  
     Сведения о том, как создать модуль, см. в разделе [\/NOASSEMBLY \(создать модуль MSIL\)](../../build/reference/noassembly-create-a-msil-module.md).  
  
#### Установка данного параметра компилятора программным способом  
  
-   См. раздел <xref:Microsoft.VisualStudio.VCProjectEngine.VCCLCompilerTool.CompileAsManaged%2A>.  
  
## См. также  
 [Параметры компилятора](../../build/reference/compiler-options.md)   
 [Настройка параметров компилятора](../Topic/Setting%20Compiler%20Options.md)