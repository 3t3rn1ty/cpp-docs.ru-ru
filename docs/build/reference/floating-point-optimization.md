---
title: Microsoft Visual C++ с плавающей запятой оптимизации | Документы Microsoft
ms.custom: ''
ms.date: 03/09/2018
ms.technology:
- cpp-tools
ms.topic: conceptual
dev_langs:
- C++
author: corob-msft
ms.author: corob
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: 35c9263fa6252469124eefb0dfd575ef5bd2ac34
ms.sourcegitcommit: 5e932a0e110e80bc241e5f69e3a1a7504bfab1f3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/21/2018
---
# <a name="microsoft-visual-c-floating-point-optimization"></a>С плавающей запятой оптимизации Microsoft Visual C++

Получите дескриптор по оптимизации код с плавающей запятой с помощью метода компилятор Microsoft C++ семантику с плавающей точкой управления. Создайте быстро программы, гарантируя, что только безопасные оптимизация выполняется на код с плавающей запятой.

## <a name="optimization-of-floating-point-code-in-c"></a>Оптимизация кода с плавающей запятой в C++

Оптимизирующий компилятор C++ не только преобразует исходный код в машинный код, он размещает машины инструкциям таким образом, чтобы повысить эффективность работы системы или уменьшения размера. К сожалению многие распространенные методы оптимизации безопасны не обязательно при применении к вычислений с плавающей запятой. Хорошим примером этого может видеть следующие алгоритму суммирование, взяты из Песоцкий Дэвид, «Что каждые компьютера специалист по анализу следует знать о арифметики с плавающей запятой», *вычисление опросы*, 1991 марта, стр. 203:

```cpp
float KahanSum( const float A[], int n )
{
   float sum=0, C=0, Y, T;
   for (int i=0; i<n; i++)
   {
      Y = A[i] - C;
      T = sum + Y;
      C = T - sum - Y;
      sum = T;
   }
   return sum;
}
```

Эта функция добавляет n **float** значения в массиве вектор `A`. В теле цикла алгоритм вычисляет значение «исправление», который применяется к следующему шагу суммирования. Этот метод позволяет существенно уменьшить совокупное ошибки округления по сравнению с простой суммирование, сохраняя сложности O(n) времени.

Компилятор C++ упрощенного предположить, что арифметических операций с плавающей запятой следует тем же алгебраические правилам, как арифметические вещественное число. Таким компилятором затем ошибочно выглядит

> C = T - sum - Y == > (сумма + Y) - sum - Y == > 0;

То есть значение машинного C всегда является нулевой константы. Если эта константа затем распространяются в последующих выражений, тело цикла уменьшается до простой суммирования. Точнее,

> Y = [i] - C == > Y = [i]<br/>T = сумма + Y == > T = сумма + [i]<br/>Сумма = T == > сумма = сумма + [i]

Таким образом, компилятору упрощенного, логические преобразование `KahanSum` функция могла бы:

```cpp
float KahanSum( const float A[], int n )
{
   float sum=0; // C, Y & T are now unused
   for (int i=0; i<n; i++)
      sum = sum + A[i];
   return sum;
}
```

Несмотря на то, что алгоритм преобразованный происходит быстрее, *это не совсем точно отражает намерения программиста*. Полностью удалены исправление тщательно созданных ошибок, и мы остается с алгоритмом простой и непосредственный суммирование с его соответствующей ошибки.

Конечно сложных компилятор C++ будет знать, то алгебраические правила в реальном арифметические неприменимы обычно арифметических операций с плавающей запятой. Тем не менее даже сложные компилятор C++ может по-прежнему неправильно интерпретировать намерения программиста.

Рассмотрим общие оптимизация для хранения всех значений в регистрах максимально (вызываемой «регистре» значение). В `KahanSum` примере эта оптимизация может пытаться размещать переменные `C`, `Y` и `T` так, как они используются только в теле цикла. Если точность регистра 52bits (double) вместо 23bits (один), эта оптимизация эффективно тип способствует `C`, `Y` и `T` ввода **двойные**. Если переменная сумма не аналогично незарегистрированные, она останется кодировкой одинарной точности. Это преобразует семантику `KahanSum` следующее

```cpp
float KahanSum( const float A[], int n )
{
   float sum=0;
   double C=0, Y, T; // now held in-register
   for (int i=0; i<n; i++)
   {
      Y = A[i] - C;
      T = sum + Y;
      C = T - sum - Y;
      sum = (float) T;
   }
   return sum;
}
```

Несмотря на то что `Y`, `T` и `C` теперь вычисляются на более высокую точность, новая кодировка может привести к менее точный результат, в зависимости от значения в `A[]`. Таким образом даже безобидная на первый взгляд опасное оптимизация может иметь негативные последствия.

Эти виды оптимизации не ограничен «непростой задачей» код с плавающей запятой. Даже простые алгоритмы с плавающей запятой может завершиться ошибкой при оптимизации неправильно. Рассмотрим простой и суммирования direct алгоритма.

```cpp
float Sum( const float A[], int n )
{
   float sum=0;
   for (int i=0; i<n; i++)
      sum = sum + A[i];
   return sum;
}
```

Поскольку некоторые устройства с плавающей запятой не может одновременно выполнять несколько операций, компилятор может потребоваться привлечь оптимизации скалярная редукция. Эта оптимизация эффективно преобразует простая функция Sum выше на следующие:

```cpp
float Sum( const float A[], int n )
{
   int n4 = n-n%4; // or n4=n4&(~3)
   int i;
   float sum=0, sum1=0, sum2=0, sum3=0;
   for (i=0; i<n4; i+=4)
   {
      sum = sum + A[i];
      sum1 = sum1 + A[i+1];
      sum2 = sum2 + A[i+2];
      sum3 = sum3 + A[i+3];
   }
   sum = sum + sum1 + sum2 + sum3;
   for (; i<n; i++)
      sum = sum + A[i];
   return sum;
}
```

Функция теперь содержит четыре отдельные суммированием, которые могут обрабатываться параллельно на каждом шаге. Хотя оптимизированной функции теперь намного быстрее, может быть сильно отличаться от результатов не оптимизированной оптимизированного результаты. В внесение этого изменения, компилятор предполагает ассоциативный сложения чисел с плавающей запятой; то есть что эти два выражения являются эквивалентными: `(a + b) + c == a + (b + c)`. Однако ассоциативность не всегда выполняются для чисел с плавающей запятой. Вместо вычисления сумму как:

```cpp
sum = A[0]+A[1]+A[2]+...+A[n-1];
```

Преобразованный функции теперь вычисляет результат в виде

```cpp
sum = (A[0]+A[4]+A[8]+...)
    + (A[1]+A[5]+A[9]+...)
    + (A[2]+A[6]+A[10]+...)
    + (A[3]+A[7]+A[11]+...);
```

Для некоторых значений `A[]`, этот другой порядок операций добавления может привести к непредвиденным результатам. Для дальнейшей дело усложняется тем, некоторые программисты, можно прогнозировать такая оптимизация и исправлять их соответствующим образом. В этом случае программы можно создать массив `A` в другом порядке, чтобы оптимизированного сумма создает ожидаемый результат. Кроме того во многих случаях точность оптимизированного результат может быть «достаточно близко». Это особенно важно в тех случаях, когда оптимизация обеспечивает преимущества привлекательные скорости. Игры, например, требуется как значительно ускорить можно, но не часто требуют высокой точность вычислений с плавающей запятой. Производители компилятора таким образом необходимо предоставить механизм для программистов для управления часто разрозненных цели скорость и точность.

Некоторые компиляторы разрешить компромисса между скоростью и точностью, предоставляя отдельный параметр для каждого типа оптимизации. Это позволяет разработчикам выключение оптимизации кода, которые вызывают изменения в точности с плавающей запятой для их конкретного приложения. Хотя это решение может предложить высокую степень контроля над компилятор, он предоставляет несколько дополнительных проблем:

- Неясно, часто которого переключается для включения или отключения.
- Отключение любого одного оптимизации может отрицательно повлиять на производительность код не с плавающей запятой.
- Каждый дополнительный переключатель влечет за собой множество новых комбинаций; число сочетаний быстро становится громоздким.

Таким образом предоставляя отдельными коммутаторами для каждого оптимизации может показаться привлекательным, использовать такие компиляторы может быть сложно и ненадежным.

Большинство компиляторов C++ обеспечивают *согласованности* модель с плавающей запятой (через **/Op** или **/fltconsistency** переключения) которого позволяет разработчику создавать совместимые программы с строгую семантику с плавающей запятой. При переводе, эта модель запрещает компилятору использовать большинство видов оптимизации вычислений с плавающей запятой, позволяет этих оптимизаций для кода не число с плавающей запятой. Модель согласованности, однако имеет темной стороне. Для возврата предсказуемые результаты для разных архитектур FPU, почти все реализации **/Op** round промежуточных выражений для пользователя указанной точности; например, рассмотрим следующее выражение:

```cpp
float a, b, c, d, e;
// . . .
a = b * c + d * e;
```

Для создания согласованной и воспроизводимой результатов в разделе **/Op**, это выражение вычисляется, как если бы было реализовано следующим образом:

```cpp
float x = b  *c;
float y = d * e;
a = x + y;
```

Окончательный результат теперь страдает от ошибки округления одинарной точности *на каждом этапе вычисления выражения*. Несмотря на то, что эту интерпретацию не будет прерывать выполнение строго какие-либо правила семантику C++, это почти никогда не лучший способ вычисления выражений с плавающей запятой. Это обычно удобнее для вычисления промежуточных результатов в максимально точность как непрактично. Например, было бы лучше вычислить значение выражения `a = b * c + d * e` в более высокую точность, как в

```cpp
double x = b * c;
double y = d * e;
double z = x + y;
a = (float)z;
```

или, лучше всего

```cpp
long double x = b * c;
long double y = d * e
long double z = x + y;
a = (float)z;
```

При вычислении промежуточных результатов в более высокую точность, конечный результат является значительно более точной. Следует отметить используя модель согласованности, вероятность ошибки увеличивается точно в том случае, когда пользователь пытается сократить путем отключения оптимизаций, небезопасный ошибки. Таким образом модель согласованности серьезно может снизить эффективность одновременно обеспечивая Повышенная точность не гарантируется. Серьезные числовой программистам это выглядит как компромисс очень хорошо и является основной причиной, что модели обычно также принимается.

Начиная с версии 8.0 (Visual C++® 2005), Microsoft C++ компилятор предоставляет много лучшим вариантом. Программисты выберите один из трех режимов, общие с плавающей запятой: fp: precise, fp: FAST и fp: strict.

- В разделе fp: precise, только безопасные оптимизация выполняется код с плавающей запятой и, в отличие от **/Op**, промежуточных вычислений постоянно выполняются на наибольший практические точности.
- режим fp: fast снижает правила с плавающей запятой, что обеспечивает более интенсивная оптимизации за счет точности.
- fp: строгий режим предоставляет общие правильность fp: точный при включении семантику исключения fp и предотвращение недопустимых преобразования при наличии изменения среды Выполнения (например изменения регистра точность, округление направление и т. д).

Семантика исключений с плавающей запятой можно управлять независимо с помощью параметра командной строки или директивы pragma компилятора; по умолчанию отключены семантику исключения с плавающей запятой в разделе fp: точный и включена в fp: strict. Компилятор также обеспечивает управление чувствительности FPU среды и некоторые с плавающей запятой определенные оптимизации, такие как сокращения. Эта модель последовательных дает разработчикам значительные возможности контроля над компиляции кода с плавающей запятой без дополнительной работы слишком много параметров компилятора или перспективного нежелательных побочных эффектов.

## <a name="the-fpprecise-mode-for-floating-point-semantics"></a>Fp: режиме для семантику с плавающей точкой

По умолчанию семантику с плавающей точкой используется режим fp: точным. Если выбран этот режим, компилятор строго соответствуют набор правил безопасности при оптимизации операций с плавающей запятой. Эти правила позволяют компилятору создавать эффективный машинный код при сохранении точность вычислений с плавающей запятой. Для упрощения производства fast программы — fp: точная модель отключает семантику исключения с плавающей запятой (несмотря на то, что они могут быть явно включен). Корпорация Майкрософт выбрала fp: точный в качестве режима по умолчанию с плавающей запятой, так как она создает быстрые и точные программы.

Явно запросить fp: режиме с помощью компилятора командной строки, используйте [/fp: точный](fp-specify-floating-point-behavior.md) переключения:

> CL/fp: точный source.cpp

Это указывает компилятору на необходимость использования fp: точно определить семантику при создании кода для файла source.cpp. Fp: точная модель также может вызываться для функции, функции с помощью [float_control-прагма компилятора](#the-float-control-pragma).

В разделе fp: точном режиме компилятор никогда не выполняет все оптимизации, которые повлиять на точность вычислений с плавающей запятой. Компилятор будет всегда выполнять округление правильно в назначения, приведения типов и вызовов функций и промежуточные округления будет постоянно выполняться в той же точностью как регистрирует FPU. По умолчанию включены безопасные оптимизации, такие как сокращения. По умолчанию отключены семантику исключения и чувствительности к среде Выполнения.

|fp: точно определить семантику|Объяснение|
|-|-|
|Семантики округления|Явные округлением в назначения, приведения типов и вызовы функций. Промежуточных выражений будет вычисляться в точности регистра.|
|Алгебраические преобразования|Строгое соответствие алгебры-ассоциативными, отличных от распределенная с плавающей запятой, если преобразование гарантированно всегда дают одинаковые результаты.|
|Сокращения|Разрешен по умолчанию. Дополнительные сведения см в разделе [fp_contract-прагма](#the-fp-contract-pragma).|
|Порядок вычислений с плавающей запятой|Компилятор может изменить порядок вычисления выражений с плавающей запятой, при условии, что окончательные результаты, не изменяются.|
|Доступ среды Выполнения|По умолчанию отключено. Дополнительные сведения см в разделе [fenv_access pragma](#the-fenv-access-pragma). Точность по умолчанию и режим округления подразумевается.|
|Семантика исключений с плавающей запятой|По умолчанию отключено. Дополнительные сведения см. в разделе [/fp: except](fp-specify-floating-point-behavior.md).|

### <a name="rounding-semantics-for-floating-point-expressions-under-fpprecise"></a>Округление семантику для выражения с плавающей запятой в разделе fp: точный

Fp: точная модель всегда выполняет промежуточных вычислений с наивысшим практические точность, явно округления только в определенных точках при вычислении выражений. Округление до степени точности, определяемый пользователем всегда выполняется в четырех местах: (a) когда выполнено назначение, (б) при выполнении приведения, (c) значение с плавающей запятой передается как аргумент функции и (d) при возвращаемые значения с плавающей запятой функция. Поскольку промежуточных вычислений всегда выполняется на точность регистра, точность промежуточных результатов не зависят от платформы (хотя точность всегда быть менее точным, как пользователь, указанный точности).

Рассмотрим выражение присваивания в следующем коде. Выражения с правой стороны назначения оператор «=» будет вычислено во время регистрации точности и явно округлением в тип в левой части назначения.

```cpp
float a, b, c, d;
double x;
...
x = a*b + c*d;
```

вычисляется как

```cpp
float a, b, c, d;
double x;
...
register tmp1 = a*b;
register tmp2 = c*d;
register tmp3 = tmp1+tmp2;
x = (double) tmp3;
```

Чтобы явно округление промежуточный результат, вызвать typecast. Например, если предыдущий код изменяется путем добавления явного приведения, промежуточного выражения (c * d) будет округляться до типа typecast.

```cpp
float a, b, c, d;
double x;
// . . .
x = a*b + (float)(c*d);
```

вычисляется как

```cpp
float a, b, c, d;
double x;
// . . .
register tmp1 = a*b;
float tmp2 = c*d;
register tmp3 = tmp1+tmp2;
x = (double) tmp3;
```

Вследствие этого метода округления является некоторые первый взгляд эквивалентные преобразования не фактически идентичные семантику. Для экземпляра следующее преобразование разделяет критерий одной операцией на два выражения присваивания.

```cpp
float a, b, c, d;
// . . .
a = b*(c+d);
```

не соответствует

```cpp
float a, b, c, d;
// . . .
a = c+d;
a = b*a;
```

Аналогичным образом:

```cpp
a = b*(c+d);
```

не соответствует

```cpp
a = b*(a=c+d);
```

Эти кодировки не имеют эквивалентные семантику, поскольку второй кодировок представить операции присваивания дополнительных, а дополнительное округление точки таким образом.

Если функция возвращает значение с плавающей запятой, значение будет округляться до тип функции. Когда значение с плавающей запятой передается как параметр функции, значение округляется до типа параметра. Пример:

```cpp
float sumsqr(float a, float b)
{
   return a*a + b*b;
}
```

вычисляется как

```cpp
float sumsqr(float a, float b)
{
    register tmp3 = a*a;
    register tmp4 = b*b;
    register tmp5 = tmp3+tmp4;
    return (float) tmp5;
}
```

Аналогичным образом:

```cpp
float w, x, y, z;
double c;
...
c = symsqr(w*x+y, z);
```

вычисляется как

```cpp
float x, y, z;
double c;
...
register tmp1 = w*x;
register tmp2 = tmp1+y;
float tmp3 = tmp2;
c = symsqr( tmp3, z);
```

### <a name="architecture-specific-rounding-under-fpprecise"></a>Округление конкретной архитектуры под fp: точный

|Процессор|Точность для промежуточных выражений округления|
|-|-|
|x86|Промежуточного выражения вычисляются в точность 53 бита по умолчанию с расширенный диапазон, предоставляемые 16-разрядную экспоненту. Когда эти значения 53:16, «распределяются» память (что может произойти во время вызова функции), будут сведены расширенный диапазон экспоненты до 11-бит. То есть сброшенные значения приводятся формат стандартной двойной точности с 11-разрядную экспоненту.<br/>Пользователь может переключить повышения точности 64-разрядных промежуточного округления, изменив word с плавающей точкой управления с помощью `_controlfp` и обеспечения доступа к среде Выполнения (в разделе [fenv_access-прагма](#the-fenv-access-pragma)). Тем не менее когда значения регистров повышения точности сброшенных на память, промежуточные результаты по-прежнему будет округлено до двойной точности.<br/>Данный конкретный семантической подлежит изменению.|
|amd64|Семантика FP на amd64, немного отличаются от других платформ. Для повышения производительности на широкой точность хотя бы один операнд, а не на широкой точность, доступную вычисляются промежуточных операций.  Чтобы принудительно выполнить вычисления для вычисления с помощью широкого точность, чем операндов, пользователи должны представить оператору приведения на хотя бы один операнд в части выражения.<br/>Данный конкретный семантической подлежит изменению.|

### <a name="algebraic-transformations-under-fpprecise"></a>Алгебраические преобразования под fp: точный

Когда fp: режиме включен, компилятор никогда не будет выполнять алгебраические преобразования *пока окончательный результат идентичен доказуемо*. Многие знакомые алгебраические правила вещественное число арифметические всегда выполняться не для арифметических операций с плавающей запятой. Например, следующие выражения являются эквивалентными Reals, но не обязательно для значений с плавающей запятой.

|Form|Описание|
|-|-|
|`(a+b)+c = a+(b+c)`|Ассоциативные правила для добавления|
|`(a*b)*c = a*(b*c)`|Ассоциативные правила для умножения|
|`a*(b+c) = a*b + b*c`|Распределение умножения над сложением|
|`(a+b)(a-b) = a*a-b*b`|Алгебраические факторизацию|
|`a/b = a*(1/b)`|Деление на обратную величину|
|`a*1.0 = a`|Мультипликативный идентификатор|

Как показано в примере Знакомство с функцией `KahanSum`, компилятор может искушению выполнять различные алгебраические преобразования для создания программ работает значительно быстрее. Несмотря на то, что зависимость от таких алгебраические преобразования оптимизации почти всегда являются неправильными, существуют случаи, для которых они являются абсолютно безопасных. Например, иногда рекомендуется заменить деление на *константой* значение с умножение умножения обратное константы:

```cpp
const double four = 4.0;
double a, b;
...

a = b/four;
```

Могут быть преобразованы в

```cpp
const double four = 4.0;
const double tmp0 = 1/4.0;
double a, b;
...
a = b*tmp0;
```

Это безопасно преобразования, потому что оптимизатор может определить во время компиляции, x / 4.0 == x*(1/4.0) для всех чисел с плавающей запятой значения x, включая бесконечностей и NaN. Заменив операции деления умножения, компилятор можно сохранить несколько циклов, особенно на FPUs, которые не реализуют непосредственно деления, но требуют компилятору создавать сочетание приближения обратное и умножить добавить инструкции. Компилятор может выполнить такую оптимизацию под fp: точным только в том случае, если операция умножения замены приводит к появлению точное же результат как деления. Компилятор может также выполнять тривиальные преобразования под fp: precise, предоставляемые результаты идентичны. Сюда входит следующее.

|Form|Описание
|-|-|
|`(a+b) == (b+a)`|Коммутативной правило для сложения|
|`(a*b) == (b*a)`|Коммутативной правило для умножения|
|`1.0*x*y == x*1.0*y == x*y*1.0 == x*y`|Умножение 1.0|
|`x/1.0*y == x*y/1.0 == x*y`|Деление 1.0|
|`2.0*x == x+x`|Умножение 2.0|

### <a name="contractions-under-fpprecise"></a>Сокращения в fp: точный

Ключевой особенностью архитектуры многие современные единиц с плавающей запятой является возможность умножения следуют дополнения в ходе одной операции без промежуточных ошибок округления. Например, Intel для архитектуры Itanium предоставляет инструкции для каждой из этих троичный операций объединения (*b + c), (* b c) и (c-a * b), в одной инструкции с плавающей запятой (fma fms и fnma соответственно). Этих инструкций с одинарной быстрее, чем выполнение отдельных умножение и добавьте инструкции и, более точны, так как нет промежуточных округление не продукта. Эта оптимизация можно значительно ускорить функции, содержащие несколько чередуются multiply и добавить операции. Например рассмотрим следующий алгоритм, который вычисляет скалярное произведение двух векторов в многомерном.

```cpp
float dotProduct( float x[], float y[], int n )
{
   float p=0.0;
   for (int i=0; i<n; i++)
      p += x[i]*y[i];
   return p;
}
```

Это вычисление можно выполнить ряд "умножить" добавьте инструкции в формате p = p + x [i] * y [i].

Оптимизация сокращением может управляться независимо друг от друга с помощью `fp_contract` компилятора pragma. По умолчанию fp: точная модель позволяет для сокращения, так как они повышают скорость и точность. В разделе fp: precise, компилятор никогда не будет контракта выражение с явной округления.
Примеры

```cpp
float a, b, c, d, e, t;
...
d = a*b + c;         // may be contracted
d += a*b;            // may be contracted
d = a*b + e*d;       // may be contracted into a mult followed by a mult-add
etc...

d = (float)a*b + c;  // won't be contracted because of explicit rounding

t = a*b;             // (this assignment rounds a*b to float)
d = t + c;           // won't be contracted because of rounding of a*b
```

### <a name="order-of-floating-point-expression-evaluation-under-fpprecise"></a>Порядок вычисления выражений с плавающей запятой в разделе fp: точный

Оптимизации, которые сохранять порядок вычисления выражений с плавающей запятой всегда являются безопасными и поэтому допускаемой fp: режиме. Рассмотрим следующую функцию, которая вычисляет скалярное произведение двух векторов многомерном в одинарной точности. Первый блок кода ниже исходную функцию как могут быть закодированы, программист, следуют той же функции после частичной оптимизации каналов.

```cpp
//original function
float dotProduct( float x[], float y[], int n )
{
   float p=0;
   for (int i=0; i<n; i++)
      p += x[i]*y[i];
   return p;
}

//after a partial loop-unrolling
float dotProduct( float x[], float y[], int n )
{
   int n4= n/4*4; // or n4=n&(~3);
   float p=0;
   int i;

   for (i=0; i<n4; i+=4)
   {
      p+=x[i]*y[i];
      p+=x[i+1]*y[i+1];
      p+=x[i+2]*y[i+2];
      p+=x[i+3]*y[i+3];
   }

   // last n%4 elements
   for (; i<n; i++)
      p+=x[i]*y[i];

   return p;
}
```

Основным преимуществом этой оптимизации является, что меньше условного ветвления цикла по 75%. Кроме того увеличив количество операций в теле цикла, компилятор может доступно больше возможностей для дальнейшей оптимизации. Для экземпляра, может иметь возможность выполнять некоторые FPUs умножить добавить в p += x [i] * y [i] при получении значения x [i + 1] одновременно и y [i + 1] для использования на следующем шаге. Этот тип оптимизации полностью безопасна для вычислений с плавающей запятой, так как он сохраняет порядок операций.

Часто бывает выгодно компилятору переупорядочить всей операции для создания более быстрый код. Рассмотрим следующий код.

```cpp
double a, b, c, d;
double x, y, z;
...
x = a*a*a + b*b*b + c*c*c;
...
y = a*a + b*b + c*c;
...
z = a + b + c;
```

Семантические правила C++ указывают, что программа должен создать результаты, как если бы он сначала вычисляется x, а затем y и наконец z. Предположим, что у компилятора имеются только четыре доступных регистров с плавающей запятой. Если компилятор вынужден вычислений x, y и z в порядке, можно создавать код с помощью следующую семантику:

```cpp
double a, b, c, d;
double x, y, z;
register r0, r1, r2, r3;
...
// Compute x
r0 = a;         // r1 = a*a*a
r1 = r0*r0;
r1 = r1*r0;
r0 = b;         // r2 = b*b*b
r2 = r0*r0;
r2 = r2*r0;
r0 = c;         // r3 = c*c*c
r3 = r0*r0;
r3 = r3*r0;
r0 = r1 + r2;
r0 = r0 + r3;
x = r0;         // x = r1+r2+r3
// . . .
// Compute y
r0 = a;         // r1 = a*a
r1 = r0*r0;
r0 = b;         // r2 = b*b
r2 = r0*r0;
r0 = c;         // r3 = c*c
r3 = r0*r0;
r0 = r1 + r2;
r0 = r0 + r3;
y = r0;         // y = r1+r2+r3
// . . .
// Compute z
r1 = a;
r2 = b;
r3 = c;
r0 = r1 + r2;
r0 = r0 + r3;
z = r0;         // z = r1+r2+r3
```

Есть несколько четко избыточные операции эта кодировка. Если компилятор строго соответствует семантические правила C++, такое упорядочение необходима, так как программа может получить доступ к среде FPU между открывающим каждого назначения. Однако параметры по умолчанию для fp: точный позволяют компилятору оптимизировать так, будто программа не доступа к среде, что позволяет изменить порядок этих выражений. Затем можно удалить избыточных данных путем вычисления трех значений в обратном порядке, как показано ниже:

```cpp
double a, b, c, d;
double x, y, z;
register r0, r1, r2, r3;
...
// Compute z
r1 = a;
r2 = b;
r3 = c;
r0 = r1+r2;
r0 = r0+r3;
z = r0;
...
// Compute y
r1 = r1*r1;
r2 = r2*r2;
r3 = r3*r3;
r0 = r1+r2;
r0 = r0+r3;
y = r0;
...
// Compute x
r0 = a;
r1 = r1*r0;
r0 = b;
r2 = r2*r0;
r0 = c;
r3 = r3*r0;
r0 = r1+r2;
r0 = r0+r3;
x = r0;
```

Эта кодировка четко превосходит уменьшить количество инструкций,-fp на почти 40%. Значения x, y и z совпадают идентичен предыдущему, но вычисляемый меньшую нагрузку.

В разделе fp: precise, компилятор может также *чередования* общих вложенных выражений, таким образом, чтобы создать более быстрый код. Например код, чтобы вычислить корни уравнения квадратичная может записать следующим образом:

```cpp
double a, b, c, root0, root1;
...
root0 = (-b + sqrt(b*b-4*a*c))/(2*a);
root1 = (-b - sqrt(b*b-4*a*c))/(2*a);
```

Несмотря на то, что эти выражения различаются только одну операцию, программист может написали его таким образом, чтобы гарантировать вычисления каждого корневое значение наибольший практические точности. В разделе fp: precise, компилятор может свободно чередования вычисления root0 и root1 для удаления общих вложенных выражений без потери точности. Для экземпляра следующих был удален из нескольких лишние шаги при этом точное одинаковый результат.

```cpp
double a, b, c, root0, root1;
...
register tmp0 = -b;
register tmp1 = sqrt(b*b-4*a*c);
register tmp2 = 2*a;
root0 = (tmp0+tmp1)/tmp2;
root1 = (tmp0-tmp1)/tmp2;
```

Другие виды оптимизации могут попытаться переместить оценку определенных независимых выражений. Рассмотрим следующий алгоритм, который содержит условной ветви в тело цикла.

```cpp
vector<double> a(n);
double d, s;
// . . .
for (int i=0; i<n; i++)
{
   if (abs(d)>1.0)
      s = s+a[i]/d;
   else
      s = s+a[i]*d;
}
```

Компилятор может обнаружить, что значение выражения (abs(d) > 1) является инвариантным в теле цикла. Это позволяет компилятору «вернуть» if оператор вне тело цикла преобразования приведенный выше код в следующее:

```cpp
vector<double> a(n);
double d, s;
// . . .
if (abs(d)>1.0)
   for (int i=0; i<n; i++)
      s = s+a[i]/d;
else
   for (int i=0; i<n; i++)
      s = s+a[i]*d;
```

После преобразования больше не условной ветви в любом из тел циклов, что значительно повышает общую производительность цикла. Этот тип оптимизации полностью безопасна потому что вычисление выражения (abs(d) > 1.0) не зависит от других выражений.

При наличии доступа к среде Выполнения или исключений с плавающей запятой эти типы оптимизации являются contraindicated так, как они изменяют семантической поток. Такая оптимизация доступны только в списке fp: режиме из-за отключения доступа к среде Выполнения и семантику исключения с плавающей запятой по умолчанию. Функции, которые обращаются к среде Выполнения можно явно отключить такая оптимизация с помощью `fenv_access` компилятора pragma. Аналогичным образом, следует использовать функции с помощью исключений с плавающей запятой `float_control(except ... )` компилятора pragma (или использовать **/fp: except** переключатель командной строки).

Таким образом, fp: режиме позволяет компилятору на необходимость изменить порядок вычисления выражений с плавающей запятой, при условии, что окончательные результаты, не изменяются и что результаты не зависят от среды Выполнения или исключений с плавающей запятой.

### <a name="fpu-environment-access-under-fpprecise"></a>Права доступа среды Выполнения в рамках fp: точный

Когда fp: режиме включен, компилятор предполагает, что программа не доступа или изменения среды Выполнения. Как уже говорилось ранее, это предположение обеспечивает компилятору возможность изменения порядка или перемещения операций с плавающей запятой для повышения эффективности в группе fp: точным.

Некоторые программы могут изменяться с плавающей запятой округления оси с помощью `_controlfp` функции. Для экземпляра некоторые программы вычислений в верхней и нижней границей ошибки на арифметические операции, выполняя выполняется вычисление дважды, сначала при округление в сторону отрицательной бесконечности, затем с округлением в сторону положительной бесконечности. Поскольку FPU предоставляет удобный способ округления, программист может потребоваться изменение режима округления путем изменения среды Выполнения. Следующий код вычисляет, связанный с конкретной ошибки с плавающей запятой умножения путем изменения среды Выполнения.

```cpp
double a, b, cLower, cUpper;
// . . .
_controlfp( _RC_DOWN, _MCW_RC );    // round to -&infin;
cLower = a*b;
_controlfp( _RC_UP, _MCW_RC );    // round to +&infin;
cUpper = a*b;
_controlfp( _RC_NEAR, _MCW_RC );    // restore rounding mode
```

В разделе fp: precise, компилятор всегда предполагает, что среда Выполнения по умолчанию, поэтому оптимизатор будет игнорировать вызовы `_controlfp` и снижения выше назначения, которые cUpper = cLower = * b; это четко были бы получены неверные результаты. Чтобы предотвратить такую оптимизацию, включить доступ среды Выполнения с помощью `fenv_access` компилятора pragma.

Другие программы могут пытаться обнаружить некоторые ошибки с плавающей запятой, проверив слова FPU состояния. Например следующий код проверяет условия деления на ноль и неточный

```cpp
double a, b, c, r;
float x;
// . . .
_clearfp();
r = (a*b + sqrt(b*b-4*a*c))/(2*a);
if (_statusfp() & _SW_ZERODIVIDE)
   handle divide by zero as a special case
_clearfp();
x = r;
if (_statusfp() & _SW_INEXACT)
   handle inexact error as a special case
etc...
```

В разделе fp: precise, оптимизации, которые изменить порядок вычисления выражений может измениться точек, в которых возникают некоторые ошибки. Доступ к слово состояния программы должны включать FPU среды доступ с помощью `fenv_access` компилятора pragma.

Дополнительные сведения см в разделе [fenv_access pragma](#the-fenv-access-pragma).

### <a name="floating-point-exception-semantics-under-fpprecise"></a>Семантика исключений с плавающей запятой в разделе fp: точный

По умолчанию отключены семантику исключения с плавающей запятой в разделе fp: точным. Большинство программистов C++ предпочесть обрабатывать исключительных условиях с плавающей запятой без использования системы или исключения C++. Кроме того как уже говорилось ранее, отключение семантику исключения с плавающей запятой позволяет компилятора большую гибкость при оптимизации операций с плавающей запятой. Используйте либо **/fp: за исключением** переключения или `float_control` pragma, чтобы включить семантику исключений с плавающей точкой при использовании fp: точная модель.

Дополнительные сведения см в разделе [Включение семантику с плавающей запятой исключения](#enabling-floating-point-exception-semantics).

## <a name="the-fpfast-mode-for-floating-point-semantics"></a>Режим fp: fast семантику с плавающей точкой

Если включен режим fp: FAST, компилятор снижает правила, fp: точный использует при оптимизации операций с плавающей запятой. Этот режим используется позволяет компилятору дополнительно оптимизировать код с плавающей запятой для повышения быстродействия за счет точности с плавающей запятой и правильности. Программы, которые не следует полагаться на очень точный результат вычислений с плавающей запятой могут возникнуть значительные быстродействия, включив режим fp: FAST.

Режим с плавающей запятой fp: fast включается с помощью [/fp:fast](fp-specify-floating-point-behavior.md) переключатель командной строки компилятора следующим образом:

> CL /fp:fast source.cpp

В этом примере предписывает компилятору использовать семантику fp: fast при создании кода для файла source.cpp. Модель fp: fast также может вызываться для функции, функции с помощью `float_control` компилятора pragma.

Дополнительные сведения см в разделе [float_control-прагма](#the-float-control-pragma).

В режиме fp: fast компилятор может выполнить оптимизацию, изменяющих точность вычислений с плавающей запятой. Компилятор не может правильно округления в назначения, приведении типов или вызовы функций и промежуточные округления не всегда будет выполняться. Определенные оптимизации с плавающей запятой, например сокращения всегда включен. Семантика исключений с плавающей запятой и чувствительности к среде FPU отключен и недоступен.

|семантика fp: fast|Объяснение
|-|-|
|Семантики округления|Явные округлением в назначения, приведения типов и вызовы функций могут игнорироваться.<br/>Промежуточных выражений может быть округлено в меньше, чем регистрация точности в соответствии с требованиями к производительности.|
|Алгебраические преобразования|Компилятор может преобразовать выражения алгебры ассоциативными, распределенная вещественное число; в соответствии с Эти преобразования не обязательно быть точным или правильно.|
|Сокращения|Всегда включена; не может быть отключен путем директивы pragma `fp_contract`|
|Порядок вычислений с плавающей запятой|Компилятор может изменить порядок вычисления выражений с плавающей запятой, даже в том случае, если такие изменения могут изменяться окончательных результатов.|
|Доступ среды Выполнения|Отключено. Недоступно|
|Семантика исключений с плавающей запятой|Отключено. Недоступно|

### <a name="rounding-semantics-for-floating-point-expressions-under-fpfast"></a>Семантика для выражения с плавающей запятой в разделе fp: fast округления

В отличие от fp: точная модель, модель fp: fast выполняет промежуточных вычислений в самое подходящее точности. Округление в назначения, приведения типов и вызовы функций может не произойти. Например, первая функция ниже представлены три переменные одинарной точности (`C`, `Y` и `T`). Компилятор может также потребоваться размещать эти переменные, фактически повышение типа `C`, `Y` и `T` двойной точности.

Исходную функцию:

```cpp
float KahanSum( const float A[], int n )
{
   float sum=0, C=0, Y, T;
   for (int i=0; i<n; i++)
   {
      Y = A[i] - C;
      T = sum + Y;
      C = T - sum - Y;
      sum = T;
   }
   return sum;
}
```

Незарегистрированные переменные:

```cpp
float KahanSum( const float A[], int n )
{
   float sum=0;
   double C=0, Y, T; // now held in-register
   for (int i=0; i<n; i++)
   {
      Y = A[i] - C;
      T = sum + Y;
      C = T - sum - Y;
      sum = (float) T;
   }
   return sum;
}
```

В этом примере fp: fast subverted цель исходной функции. Конечный результат, содержащееся в переменной оптимизированными для `sum`, может быть довольно perturbed из правильный результат.

В разделе fp: fast компилятор обычно попытается поддерживать по крайней мере точности, указанной в исходном коде. Однако в некоторых случаях компилятор сможет выполнить промежуточных выражений в *снизить точность* от указанных в исходном коде. Например первый блок кода ниже вызывает версии функции квадратный корень двойной точности. В разделе fp: FAST, в некоторых случаях, например когда результата и операндов функции явно приводится к одиночной точности, компилятор может выбрать для замены вызова с двойной точностью `sqrt` вызовом одинарной точности `sqrtf`функции. Поскольку приведения убедитесь, что значение, поступающих на `sqrt` и выходом значения округляются до одинарной точности, меняется только вместо округления. Если значение, поступающих на sqrt было значение двойной точности и компилятор выполнить это преобразование как половина битов точности может быть не так.

Первоначальная функция

```cpp
double sqrt(double);
// . . .
double a, b, c;
float f1, f2;
// . . .
float length = (float)sqrt((float)(a*a + b*b + c*c));
float sum = (float) ((double)f1 + (double)f2);
```

Оптимизированные функции

```cpp
float sqrtf(float)...
// . . .
double a, b, c;
float f1, f2;
// . . .
double tmp0 = a*a + b*b + c*c;
float tmp1 = tmp0;    // round of parameter value
float length = sqrtf(tmp1); // rounded sqrt result
float sum = f1 + f2;
```

Несмотря на то что менее точными, эта оптимизация может быть особенно полезным при разработке для процессоров, которые предоставляют одинарной точности версии встроенных функций, такие как `sqrt`. Точно так же при компилятор будет использовать такую оптимизацию — зависят от платформы и контекста.

Кроме того является не гарантируется согласованность для точность промежуточных вычислений, в которых может выполняться на любом уровне точности, доступных для компилятора. Несмотря на то, что компилятор попытается сохранить по крайней мере уровень точности, как указано в коде, fp: fast позволяет оптимизатору производных типов промежуточных вычислений для создания более быстрый или меньшим машинный код. Например компилятор может дополнительно оптимизировать код выше округления некоторые промежуточные операции умножения до одинарной точности.

```cpp
float sqrtf(float)...
// . . .
double a, b, c;
float f1, f2;
// . . .
float tmp0 = a*a;     // round intermediate a*a to single-precision
float tmp1 = b*b;     // round intermediate b*b to single-precision
double tmp2 = c*c;    // do NOT round intermediate c*c to single-precision
float tmp3 = tmp0 + tmp1 + tmp2;
float length = sqrtf(tmp3);
float sum = f1 + f2;
```

Этот способ округления дополнительных может быть вызвано использование на меньшие точности с плавающей запятой единицы, например SSE2, для выполнения некоторых из промежуточных вычислений. Точность округления fp: FAST, следовательно, зависят от платформы; код, который компилируется для одного процессора может не обязательно работают для другого процессора. Он остается для пользователей, чтобы определить, если скорость преимущества или проблем с точностью.

Если оптимизация fp: fast особенно проблематичным для определенной функции, режим с плавающей запятой можно локально переключить fp: точный с помощью `float_control` компилятора pragma.


### <a name="algebraic-transformations-under-fpfast"></a>Алгебраические преобразования под fp: fast

Режим fp: fast позволяет компилятору выполнять различные выражения точки небезопасный алгебраические преобразования с плавающей запятой. Например следующие оптимизации небезопасный может использоваться в разделе fp: FAST.

||||
|-|-|-|
|Исходный код|Шаг #1|Шаг #2
|`double a, b, c;`<br/>`double x, y, z;`<br/><br/>`y = (a + b);`<br/>`z = y – a – b;`<br/><br/>`c = x – z;`<br/><br/>`c = x * z;`<br/><br/>`c = x - z;`<br/><br/>`c = x + z;`<br/><br/>`c = z-x;`|`double a, b, c;`<br/>`double x, y, z;`<br/><br/>`y = (a + b);`<br/>`z = 0;`<br/><br/>`c = x – 0;`<br/><br/>`c = x * 0;`<br/><br/>`c = x - 0;`<br/><br/>`c = x + 0;`<br/><br/>`c = 0 - x;`|`double a, b, c;`<br/>`double x, y, z;`<br/><br/>`y = (a + b);`<br/>`z = 0;`<br/><br/>`c = x;`<br/><br/>`c = 0;`<br/><br/>`c = x;`<br/><br/>`c = x;`<br/><br/>`c = -x;`|

На шаге 1, компилятор обнаруживает, `z = y – a – b` всегда будет равно нулю. Несмотря на то что технически недопустимый наблюдения, разрешается в fp: FAST. Затем компилятор распространяет постоянное значение ноль для каждого последующего использования переменной z. На шаге 2, дальнейшей компилятор оптимизирует, просматривая `x - 0 == x`, `x * 0 == 0`и т. д. Опять же даже если эти строго недопустимы, они разрешены fp: FAST. Оптимизированный код теперь выполняется гораздо быстрее, но также может значительно менее точным или даже неверен.

Любой из следующих правил (небезопасный) алгебраические может использоваться оптимизатором, если включен режим fp: FAST:

|||
|-|-|
|Form|Описание|
|`(a + b) + c = a + (b + c)`|Ассоциативные правила для добавления|
|`(a * b) * c = a * (b * c)`|Ассоциативные правила для умножения|
|`a * (b + c) = a * b + b * c`|Распределение умножения над сложением|
|`(a + b)(a - b) = a * a - b * b`|Алгебраические факторизацию|
|`a / b = a * (1 / b)`|Деление на обратную величину|
|`a * 1.0 = a, a / 1.0 = a`|Мультипликативный идентификатор|
|`a ± 0.0 = a, 0.0 - a = -a`|Аддитивный идентификатор|
|`a / a = 1.0, a - a = 0.0`|Отмена|

Если оптимизация fp: fast особенно проблематичным для определенной функции, режим с плавающей запятой можно локально переключить fp: точный с помощью `float_control` компилятора pragma.

### <a name="order-of-floating-point-expression-evaluation-under-fpfast"></a>Порядок вычисления выражений с плавающей запятой в разделе fp: fast

В отличие от fp: precise, fp: fast позволяет компилятору изменять порядок операций с плавающей запятой, таким образом, чтобы создать более быстрый код. Таким образом некоторые оптимизации под fp: fast не может сохранять предполагаемого порядок выражений. Например рассмотрим следующую функцию, которая вычисляет скалярное произведение двух векторов в многомерном.

```cpp
float dotProduct( float x[], float y[],
                  int n )
{
   float p=0;
   for (int i=0; i<n; i++)
      p += x[i]*y[i];
   return p;
}
```

Во время fp: FAST, оптимизатор может выполнять скалярные уменьшение `dotProduct` работать эффективно модернизировать функцию следующим образом:

```cpp
float dotProduct( float x[], float y[],int n )
{
    int n4= n/4*4; // or n4=n&(~3);
    float p=0, p2=0, p3=0, p4=0;
    int i;

    for (i=0; i<n4; i+=4)
    {
        p+=x[i]*y[i];
        p2+=x[i+1]*y[i+1];
        p3+=x[i+2]*y[i+2];
        p4+=x[i+3]*y[i+3];
    }
    p+=p2+p3+p4;

    // last n%4 elements
    for (; i<n; i++)
    p+=x[i]*y[i];

    return p;
}
```

В оптимизированной версии функции четыре отдельных продуктов суммированием берутся одновременно и затем добавляются друг с другом. Эта оптимизация может ускорить вычисление `dotProduct` так сильно, как с коэффициентом четыре в зависимости от целевого процессора, но результат может быть так неточной относительно вывести ее из строя. Если такая оптимизация особенно проблематичным для одной функции или записи преобразования, режим с плавающей запятой можно локально переключить fp: точный с помощью `float_control` компилятора pragma.

## <a name="the-fpstrict-mode-for-floating-point-semantics"></a>Fp: strict режим для семантику с плавающей точкой

Когда fp: строгий режим включен, компилятор соответствует те же правила, fp: точный использует при оптимизации операций с плавающей запятой. Этот режим также обеспечивает семантику исключения с плавающей запятой и чувствительности к среде Выполнения и отключает определенные оптимизации, такие как сокращения. Это строгий режим работы.

Fp: strict режим с плавающей запятой включается с помощью [/fp: strict](fp-specify-floating-point-behavior.md) переключатель командной строки компилятора следующим образом:

> CL/fp: strict source.cpp

В этом примере указывает компилятору на необходимость использования fp: при создании кода для файла source.cpp строгую семантику. Fp: strict модели также может вызываться для функции, функции с помощью `float_control` компилятора pragma.

Дополнительные сведения см в разделе [float_control-прагма](#the-float-control-pragma).

В разделе fp: строгий режим компилятор никогда не выполняет все оптимизации, которые повлиять на точность вычислений с плавающей запятой. Компилятор будет всегда выполнять округление правильно в назначения, приведения типов и вызовов функций и промежуточные округления будет постоянно выполняться в той же точностью как регистрирует FPU. Семантика исключений с плавающей запятой и чувствительности к среде FPU включены по умолчанию. Некоторые виды оптимизации, такие как сокращения отключены, так как компилятор не гарантирует правильность во всех случаях.

|fp: strict семантику|Объяснение|
|-|-|
|Семантики округления|Явные округлением в назначения, приведения типов и вызовы функций<br/>Промежуточных выражений будет вычисляться в точности регистра.<br/>То же, что fp: точный|
|Алгебраические преобразования|Строгое соответствие алгебры-ассоциативными, отличных от распределенная с плавающей запятой, если преобразование гарантированно всегда дают одинаковые результаты.<br/>То же, что fp: точный|
|Сокращения|Всегда отключен|
|Порядок вычислений с плавающей запятой|Компилятор не изменит порядок вычисления выражений с плавающей запятой|
|Доступ среды Выполнения|Всегда включен.|
|Семантика исключений с плавающей запятой|По умолчанию включено.|

### <a name="floating-point-exception-semantics-under-fpstrict"></a>Семантика исключений с плавающей запятой в разделе fp: strict

По умолчанию семантику исключения с плавающей запятой, включаются fp: strict модели. Чтобы отключить эту семантику, используйте **/fp: за исключением-** переключения или предоставляет `float_control(except, off)` pragma.

Дополнительные сведения см. в разделе разделы [Включение семантику с плавающей запятой исключения](#enabling-floating-point-exception-semantics) и [float_control Pragma](#the-float-control-pragma).

## <a name="the-fenvaccess-pragma"></a>Fenv_access-прагма

Использование:

```cpp
#pragma fenv_access( [ on  | off ] )
```

[Fenv_access](../../preprocessor/fenv-access.md) pragma позволяет компилятору указание сделать определенные оптимизации, которые могут оказать воздействие FPU проверки флагов и изменения режима FPU. Когда состояние `fenv_access` отключена, компилятор может предположить режимы по умолчанию FPU вступают в силу и флагами FPU не проверяются. По умолчанию среда доступ отключен для fp: режиме, хотя он может быть явно включен с помощью этой директивы pragma. В разделе fp: strict, `fenv_access` всегда включена и не может быть отключена. В разделе fp: fast `fenv_access` всегда отключен и не может быть включен.

Как описано в fp: точный раздела некоторые программисты могут изменяться с плавающей запятой округления направления с помощью `_controlfp` функции. Для вычисления ошибки верхняя и нижняя границы на арифметические операции, некоторые программы проводить, например, выполняется вычисление дважды: сначала при округление в сторону отрицательной бесконечности, а затем при округление в сторону положительной бесконечности. Поскольку FPU предоставляет удобный способ округления, программист может потребоваться изменение режима округления путем изменения среды Выполнения. Следующий код вычисляет, связанный с конкретной ошибки с плавающей запятой умножения путем изменения среды Выполнения.

```cpp
double a, b, cLower, cUpper;
// . . .
_controlfp( _RC_DOWN, _MCW_RC );    // round to -infinity
cLower = a*b;
_controlfp( _RC_UP, _MCW_RC );       // round to +infinity
cUpper = a*b;
_controlfp( _RC_NEAR, _MCW_RC );    // restore rounding mode
```

При отключении `fenv_access` pragma позволяет компилятору считать, среда Выполнения по умолчанию; таким образом оптимизатор игнорировать вызовы `_controlfp` и выше назначения, чтобы уменьшить `cUpper = cLower = a*b`. Если включено, однако `fenv_access` предотвращает подобные оптимизации.

Программы также проверить состояние слова FPU для выявления некоторых ошибок с плавающей запятой. Например следующий код проверяет условия деления на ноль и неточный

```cpp
double a, b, c, r;
float x;
// . . .
_clearfp();
r = (a*b + sqrt(b*b-4*a*c))/(2*a);
if (_statusfp() & _SW_ZERODIVIDE)
   handle divide by zero as a special case
_clearfp();
x = (a*b + sqrt(b*b-4*a*c))/(2*a);
if (_statusfp() & _SW_INEXACT)
   handle inexact error as a special case
etc...
```

Когда `fenv_access` будет отключен, компилятор может изменить порядок выполнения выражения с плавающей запятой, таким образом, возможно, свержение проверки состояния FPU. Включение `fenv_access` предотвращает подобные оптимизации.

## <a name="the-fpcontract-pragma"></a>Fp_contract-прагма

Использование:

```cpp
#pragma fp_contract( [ on | off ] )
```

Как описано в fp: точный разделе сокращением является функцией фундаментальные архитектуры для многих современных единиц с плавающей запятой. Сокращения предоставляют возможность умножения следуют дополнения в ходе одной операции без промежуточных ошибок округления. Этих инструкций с одинарной быстрее, чем выполнение отдельных умножение и добавьте инструкции и, более точны, так как нет промежуточных округление не продукта. Договору операции можно вычисляет значение `(a*b+c)` как в том случае, если обе операции были вычисления бесконечный точностью и затем округляется до ближайшего числа с плавающей запятой. Эта оптимизация можно значительно ускорить функции, содержащие несколько чередуются multiply и добавить операции. Например рассмотрим следующий алгоритм, который вычисляет скалярное произведение двух векторов в многомерном.

```cpp
float dotProduct( float x[], float y[], int n )
{
   float p=0.0;
   for (int i=0; i<n; i++)
      p += x[i]*y[i];
   return p;
}
```

Это вычисление можно выполнить ряд "умножить" добавьте инструкции формы `p = p + x[i]*y[i]`.

[Fp_contract](../../preprocessor/fp-contract.md) pragma указывает, может быть сокращена выражения с плавающей запятой. По умолчанию fp: режиме позволяет для сокращения, так как они повышают скорость и точность. Для режима fp: fast сокращения всегда включен. Тем не менее, так как сокращения могут оказать воздействие явного обнаружения условий ошибки `fp_contract` pragma всегда отключен в разделе fp: строгий режим. Примеры выражений, которые можно сворачивать при `fp_contract` pragma включен:

```cpp
float a, b, c, d, e, t;
...
d = a*b + c;         // may be contracted
d += a*b;            // may be contracted
d = a*b + e*d;       // may be contracted into a mult followed by a mult-add etc...

d = (float)a*b + c;  // won't be contracted because of explicit rounding

t = a*b;             // (this assignment rounds a*b to float)
d = t + c;           // won't be contracted because of rounding of a*b
```

## <a name="the-floatcontrol-pragma"></a>Float_control-прагма

**/Fp: точный**, **/fp:fast**, **/fp: strict** и **/fp: за исключением** управляет семантику с плавающей точкой на файл, файл основы. [Float_control](../../preprocessor/float-control.md) директива #pragma обеспечивает такой элемент управления на основе функции, функции.

Использование:

```cpp
#pragma float_control(push)
#pragma float_control(pop)
#pragma float_control( precise, on | off [, push] )
#pragma float_control( except, on | off [, push] )
```

Директивы pragma `float_control(push)` и `float_control(pop)` соответственно отправка и отображение текущего состояния режим с плавающей запятой и вариант исключения в стек. Обратите внимание, что состояние `fenv_access` и `fp_contract` pragma не подвержены `pragma float_control(push/pop)`.

Вызов директивы pragma `float_control(precise, on)` включит и `float_control(precise, off)` отключит семантику точном режиме. Аналогично, директива pragma `float_control(except, on)` включит и `float_control(except, off)` отключит семантику исключения. Семантику исключения можно включить только в том случае, если точно определить семантику также включены. Когда необязательный `push` присутствует аргумент состояния `float_control` параметры помещаются в стек перед изменением семантику.

### <a name="setting-the-floating-point-semantic-mode-on-a-function-by-function-basis"></a>Режим с плавающей запятой семантики на основе функции, функция

Параметры командной строки на самом деле являются сокращением для задания параметров директивы pragma четыре разных с плавающей запятой. Чтобы явно указать режим конкретного с плавающей запятой семантики на основе функции, функции, выберите каждый из четырех директив pragma с плавающей запятой параметр как описано в следующей таблице:

||||||
|-|-|-|-|-|
||float_control(precise)|float_control(Except)|fp_contract|fenv_access|
|/ fp: strict|вкл.|вкл.|Отключение|вкл.|
|/ fp: strict/fp: except-|вкл.|Отключение|Отключение|вкл.|
|/ fp: точный|вкл.|Отключение|вкл.|Отключение|
|/ fp: precise/fp: except|вкл.|вкл.|вкл.|Отключение|
|/fp:fast|Отключение|Отключение|вкл.|Отключение|

Например, следующие явным образом включает fp: fast семантику.

```cpp
#pragma float_control( except, off )   // disable exception semantics
#pragma float_control( precise, off )  // disable precise semantics
#pragma fp_contract(on)                // enable contractions
#pragma fenv_access(off)               // disable fpu environment sensitivity
```

> [!Note]
> Прежде чем отключать «семантику» семантику исключения должны быть отключены.

## <a name="enabling-floating-point-exception-semantics"></a>Включение семантику исключения с плавающей запятой

Определенные исключительные состояния с плавающей запятой, например деление на ноль, может привести к FPU сигнала аппаратное исключение. По умолчанию отключены исключений с плавающей запятой. Исключения с плавающей запятой, включены посредством изменения контрольного слова FPU с `_controlfp` функции. Например следующий код позволяет исключение деления на ноль с плавающей запятой:

```cpp
_clearfp(); // always call _clearfp before
            // enabling/unmasking a FPU exception
_controlfp( _EM_ZERODIVIDE, _MCW_EM );
```

Если включено исключение деления на ноль, все операции деления с равным знаменателя нулю вызовет исключение FPU сигнала.

Чтобы восстановить контрольного слова FPU режим по умолчанию, вызовите `_controlfp(_CW_DEFAULT, ~0)`.

Включение семантику исключения с плавающей запятой с **/fp: except** флаг не является таким же, как включение исключений с плавающей запятой. Если включены семантику исключения с плавающей запятой, компилятор необходимо учитывать вероятность того, что все операции с плавающей запятой может вызывать исключение. Поскольку FPU называется блок процессора, инструкции, выполняемые на FPU могут выполняться параллельно с инструкциями на других устройствах.

При включении исключения с плавающей запятой FPU прервать выполнение инструкции по вызову исключения и указывают исключительным условием, задав слова FPU состояния. По достижении ЦП Далее операция с плавающей запятой он сначала проверяет все ожидающие исключения FPU. Нет ожидающих исключений, обработчик перехватывает путем вызова обработчика исключений, предоставляемые операционной системой. Это означает, что при операции с плавающей точкой сталкивается с исключительным условием, соответствующее исключение не будет определяться до выполнения следующей операции с плавающей запятой. Например следующий код перехватывает исключение деления на ноль:

```cpp
double a, b, c;
// . . .
// ...unmasking of FPU exceptions omitted...
__try
{
   b/c; // assume c==0.0
   printf("This line shouldn't be reached when c==0.0\n");
   c = 2.0*b;
}
__except( EXCEPTION_EXECUTE_HANDLER )
{
   printf("SEH Exception Detected\n");
}
// . . .
```

При выполнении деления на ноль условия в выражения = b и c, FPU не ловушки/raise исключения до следующей операции с плавающей запятой в выражении 2.0 * b. Это приводит к отображению указанных выходных данных:

```Output
This line shouldn't be reached when c==0.0
SEH Exception Detected
```

Следует, printf, соответствующее первой строки выходных данных не был достигнут; он достигнут, так как не было выдано с плавающей запятой исключение, вызванное выражение b/c до выполнения 2.0 * b. Для вызова исключения, сразу после выполнения b/c, компилятор должен вводить инструкции «Ожидание»:

```cpp
// . . .
   __try
   {
      b/c; // assume this expression will cause a "divide-by-zero" exception
      __asm fwait;
      printf("This line shouldn't be reached when c==0.0\n");
      c = 2.0*b;
   }
// . . .
```

Эта инструкция «ожидания» вызывает процессор для синхронизации с состоянием FPU и обработки исключений, ожидающие. Компилятор будет только создавать эти «ожидания» инструкции, если включены семантику с плавающей точкой. Если эту семантику отключены, поскольку по умолчанию программы могут возникнуть ошибки происходила, аналогичного приведенному выше, при использовании исключений с плавающей запятой.

Если включены семантику с плавающей точкой, компилятор не появятся только инструкции «ожидание», также помешает компилятору оптимизировать код с плавающей запятой при наличии возможных исключений некорректно. В нем никаких преобразований, изменяющих точек, в которых вызываются исключения. Из-за этих факторов Включение семантику с плавающей точкой значительно снизить эффективность созданный машинный код, тем самым ухудшения производительности приложения.

Семантика исключений с плавающей запятой включены по умолчанию в списке fp: strict режиме. Чтобы включить эту семантику в fp: точном режиме Добавить **/fp: except** переключиться на компилятор командной строки. Семантика исключений с плавающей запятой может также включать и отключать для функции, функции с помощью `float_control` pragma.

### <a name="floating-point-exceptions-as-c-exceptions"></a>С плавающей запятой исключения как исключения C++

С все аппаратные исключения исключений с плавающей запятой по своей природе не вызывают исключения C++, а вместо этого триггера структурированное исключение. Для сопоставления с плавающей запятой структурированные исключения исключения C++, пользователи могут вызвать пользовательский преобразователь исключение SEH. Во-первых представляют исключений C++, соответствующий каждой исключений с плавающей запятой.

```cpp
class float_exception : public std::exception {};

class fe_denormal_operand : public float_exception {};
class fe_divide_by_zero : public float_exception {};
class fe_inexact_result : public float_exception {};
class fe_invalid_operation : public float_exception {};
class fe_overflow : public float_exception {};
class fe_stack_check : public float_exception {};
class fe_underflow : public float_exception {};
```

Затем можно вызвать функцию преобразования, который определит с плавающей запятой исключение SEH и соответствующие исключения C++. Чтобы использовать эту функцию, задайте преобразователя обработчик структурированных исключений для текущего потока процесса с [_set_se_translator](../../c-runtime-library/reference/set-se-translator.md) функции из библиотеки времени выполнения.

```cpp
void se_fe_trans_func( unsigned int u, EXCEPTION_POINTERS* pExp )
{
    switch (u)
    {
    case STATUS_FLOAT_DENORMAL_OPERAND:   throw fe_denormal_operand();
    case STATUS_FLOAT_DIVIDE_BY_ZERO:     throw fe_divide_by_zero();
   etc...
    };
}
// . . .
_set_se_translator(se_fe_trans_func);
```

После инициализации это сопоставление исключений с плавающей запятой будет вести себя, как будто они являются исключениями C++. Пример:

```cpp
try
{
   // floating-point code that might throw divide-by-zero
   // or other floating-point exception
}
catch(fe_divide_by_zero)
{
    cout << "fe_divide_by_zero exception detected" << endl;
}
catch(float_exception)
{
    cout << "float_exception exception detected" << endl;
}
```

## <a name="references"></a>Ссылки

[Специалист по анализу каждый компьютер следует знать о арифметических операций с плавающей запятой](http://pages.cs.wisc.edu/~david/courses/cs552/S12/handouts/goldberg-floating-point.pdf) , Дэвид Песоцкий.

## <a name="see-also"></a>См. также

[Оптимизация кода](optimizing-your-code.md)<br/>
