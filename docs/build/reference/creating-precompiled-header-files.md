---
title: Создание файлов предкомпилированных заголовков | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-tools
ms.topic: reference
f1_keywords:
- pch
dev_langs:
- C++
helpviewer_keywords:
- precompiled header files, creating
- PCH files, creating
- cl.exe compiler, precompiling code
- .pch files, creating
ms.assetid: e2cdb404-a517-4189-9771-c869c660cb1b
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 31d9708f203c3d79d4cf369583c75d348278d06a
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
---
# <a name="creating-precompiled-header-files"></a>Создание файлов предкомпилированных заголовков
  
Компиляторы Microsoft C и C++ содержат параметры для предварительной компиляции любого кода C или C++, включая встроенный код. Данная возможность позволяет скомпилировать стабильное тело кода, сохранять скомпилированное состояние кода в файле, а при последующих компиляциях объединять предварительно скомпилированный код с кодом, который еще находится в стадии разработки. Каждая последующая компиляция выполняется быстрее, так как стабильный код не нужно компилировать повторно.  
  
В этом разделе рассматриваются следующие темы предкомпилированного заголовка:  
  
-   [Случаи использования предварительной компиляции исходного кода](#when-to-precompile-source-code)  
  
-   [Два варианта предварительной компиляции кода](#two-choices-for-precompiling-code)  
  
-   [Правила согласованности предкомпилированных заголовков](#precompiled-header-consistency-rules)  
  
-   [Правила целостности для пофайлового использования предкомпилированных заголовков](#consistency-rules-for-per-file-use-of-precompiled-headers)  
  
-   [Правила целостности для параметров компилятора /Yc и /Yu](#consistency-rules-for-yc-and-yu)  
  
-   [Использование предкомпилированных заголовков в проекте](#using-precompiled-headers-in-a-project)  
  
-   [PCH-файлы в процессе сборки](#pch-files-in-the-build-process)  
  
-   [Образец файла makefile для PCH](#sample-makefile-for-pch)  
  
-   [Пример кода для PCH](#example-code-for-pch)  
  
Справочные сведения о параметрах компилятора, связанных с предкомпилированными заголовками см. в разделе [/Y (предварительно скомпилированные заголовки)](../../build/reference/y-precompiled-headers.md).  
  
<a name="when-to-precompile-source-code"></a>  
  
## <a name="when-to-precompile-source-code"></a>Случаи использования предварительной компиляции исходного кода  
  
Предварительно скомпилированный код полезен во время цикла разработки, чтобы сократить время компиляции, особенно в том случае, если:  
  
-   Всегда использовать большой объем кода, которые редко изменяются.  
  
-   Программа состоит из нескольких модулей, каждый из которых использует стандартный набор файлов включения и одинаковые параметры компилятора. В этом случае все файлы включения, могут быть перекомпилированы скомпилировать в один заголовок.  
  
Первая компиляция — того, который создает файл предкомпилированного заголовка (PCH) — занимает больше времени, чем последующие компиляции. Последующие компиляции происходят быстрее, включив предварительно скомпилированный код.  
  
Можно выполнить предварительную компиляцию программы C и C++. В программирования на C++ это часто можно размещать интерфейсы классов в файлах заголовков. Эти файлы заголовка можно включить позже в программах, использующих класс. С помощью предварительной компиляции этих заголовков, можно сократить время, необходимое для компиляции программы.  
  
> [!NOTE]
>  Несмотря на то, что можно использовать только один файл предкомпилированного заголовка (PCH) одного исходного файла, можно использовать несколько PCH-файлы в проекте.  
  
<a name="two-choices-for-precompiling-code"></a>  
  
# <a name="two-choices-for-precompiling-code"></a>Два варианта предварительной компиляции кода  
  
С помощью Visual C++ можно предварительной компиляции любого кода C или C++; Вы не ограничиваются компиляцией только файлов заголовков.  
  
Предварительная компиляция требует тщательного планирования, но он обеспечивает компиляций значительно быстрее, если предварительной компиляции исходного кода компиляции.  
  
Предварительная компиляция кода, когда известно, что исходные файлы используются общие наборы файлов заголовков, но не включайте их в том же порядке или если вы хотите включить в предварительную компиляцию исходного кода.  
  
Параметры, предкомпилированных заголовков, [/Yc (создать файл предкомпилированного заголовка)](../../build/reference/yc-create-precompiled-header-file.md) и [/Yu (использование предкомпилированных заголовков)](../../build/reference/yu-use-precompiled-header-file.md). Используйте **/Yc** для создания предкомпилированного заголовка. При использовании с необязательным [hdrstop](../../preprocessor/hdrstop.md) pragma, **/Yc** позволяет выполнить предварительную компиляцию оба файла заголовка и исходным кодом. Выберите **/Yu** использовать существующий предкомпилированный заголовок в существующей компиляции. Можно также использовать **/FP** с **/Yc** и **/Yu** параметры с целью обеспечения альтернативное имя для предкомпилированного заголовка.  
  
Параметр компилятора справочных разделах по **/Yu** и **/Yc** описывают, как получить доступ к этой функции в среде разработки.  
  
<a name="precompiled-header-consistency-rules"></a>  
  
## <a name="precompiled-header-consistency-rules"></a>Правила согласованности предкомпилированных заголовков  
  
Поскольку PCH-файлы содержат сведения о компьютерной среде, а также сведения о адресов памяти о программе, следует использовать только PCH-файл на компьютере, где он был создан.  
  
<a name="consistency-rules-for-per-file-use-of-precompiled-headers"></a>  
  
## <a name="consistency-rules-for-per-file-use-of-precompiled-headers"></a>Правила целостности для пофайлового использования предкомпилированных заголовков

[/Yu](../../build/reference/yu-use-precompiled-header-file.md) параметры компилятора позволяют указать, какие PCH-файл для использования.  
  
При использовании PCH-файл, компилятор предполагает, что той же среде компиляции —, используются одинаковые параметры компилятора, директивы pragma и т. д, которая использовалась при создании файла предкомпилированного Заголовка, по умолчанию. Если компилятор обнаруживает несовместимость, он выдает предупреждение и выявляет эту несовместимость. Такие предупреждения не обязательно указывать на проблему с PCH-файл; они просто предупреждение о возможных конфликтах. В следующих разделах описываются требования к согласованности для PCH-файлы.  
  
### <a name="compiler-option-consistency"></a>Правила целостности для параметров компилятора  
  
Следующие параметры компилятора могут вызвать предупреждения о нарушении целостности при использовании PCH-файл:  
  
-   Макросы, созданные с использованием параметра препроцессора (/ D) параметра должны быть одинаковыми компиляции, создавшей PCH-файл и в текущей компиляции. Состояние определенных констант не проверяется, но результаты могут быть непредсказуемы их изменение.  
  
-   PCH-файлы не работают с параметрами /E и /EP.  
  
-   PCH-файлы должны создаваться с помощью либо создать Обзор информацию (/ FR) параметр или исключить локальные переменные (/ Fr) параметра, прежде чем эти параметры можно использовать для последующих компиляциях с использованием PCH-файл.  
  
### <a name="c-70-compatible-z7"></a>Совместимость с C 7.0 (/ Z7)  
  
Если этот параметр действует при создании файла предкомпилированного Заголовка, последующих компиляциях с использованием PCH-файл можно использовать отладочную информацию.  
  
Если совместимость с C 7.0 (/ Z7) параметр не действует при создании файла предкомпилированного Заголовка, последующих компиляциях с использованием PCH-файл и/Z7 приводят к возникновению предупреждения. Отладочная информация помещается в текущий OBJ-файл, и локальные символы, определенные в PCH-файл не доступны в отладчик.  
  
### <a name="include-path-consistency"></a>Согласованность путей включения  
  
PCH-файл не содержит сведений о пути включения, которая была действующей при его создании. При использовании PCH-файл, компилятор будет всегда использует путем включения, заданным в текущей компиляции.  
  
### <a name="source-file-consistency"></a>Согласованность исходных файлов  
  
При указании параметра использовать файл предкомпилированного заголовка (/Yu) компилятор игнорирует все директивы препроцессора (включая прагма-директивы), отображаются в исходном коде, подлежащем предварительной компиляции. Компиляция, описываемая подобными директивами препроцессора должен быть таким же, как компиляции с использованием параметра создания предкомпилированного заголовка (/Yc).  
  
### <a name="pragma-consistency"></a>Директива pragma согласованности    
  
Прагмы, обрабатываемые во время создания файла PCH обычно влияет на файл, с которым впоследствии используемый PCH-файл. `comment` И `message` директивы pragma не влияют на остальной части компиляции.  
  
Эти директивы pragma влияют на только код внутри PCH-файл; они не влияют на код, который впоследствии используется PCH-файл:  
  
||||  
|-|-|-|  
|`comment`|`page`|`subtitle`|  
|`linesize`|`pagesize`|`title`|  
|`message`|`skip`||  
  
Эти директивы pragma сохраняются как часть предкомпилированного заголовка и влияют на оставшуюся часть компиляции с параметром предкомпилированного заголовка:  
  
||||  
|-|-|-|  
|`alloc_text`|`include_alias`|`pack`|  
|`auto_inline`|`init_seg`|`pointers_to_members`|  
|`check_stack`|`inline_depth`|`setlocale`|  
|`code_seg`|`inline_recursion`|`vtordisp`|  
|`data_seg`|`intrinsic`|`warning`|  
|`function`|`optimize`||  
  
<a name="consistency-rules-for-yc-and-yu"></a>  
  
## <a name="consistency-rules-for-yc-and-yu"></a>Правила целостности для параметров компилятора /Yc и /Yu  
  
При использовании предкомпилированного заголовка, созданного с помощью параметров компилятора /Yc и /Yu компилятор сравнивает текущей среды компиляции на тот, который был создан PCH-файл. Не забудьте указать среду, совместимую с предыдущим (используя одинаковые параметры компилятора, директивы pragma и т. д.) для текущей компиляции. Если компилятор обнаруживает несовместимость, он выдает предупреждение и выявляет эту несовместимость. Такие предупреждения не обязательно указывают на проблему с PCH-файл; они просто предупреждение о возможных конфликтах. В следующих разделах рассматриваются правила целостности для предкомпилированных заголовков.  
  
### <a name="compiler-option-consistency"></a>Правила целостности для параметров компилятора  
  
В этой таблице перечислены параметры компилятора, которые могут вызвать предупреждение о нарушении целостности, при использовании предкомпилированного заголовка.  
  
|Параметр|name|Правило|  
|------------|----------|----------|  
|/D|Определяет константы и макросы|Должны совпадать между компиляции, в которой создан предкомпилированный заголовок и текущей компиляции. Состояние определенных констант не проверяется, однако непредсказуемые результаты может произойти, если файлы зависят от значений измененных констант.|  
|/E или /EP|Копирует выходные данные препроцессора в стандартный вывод|Предкомпилированные заголовки не работают с параметром/e или /EP.|  
|/FR или/fr|Создание информации обозревателя исходного кода Майкрософт|Параметры /Fr и /FR можно использовать с параметром /Yu они использовались в силе во время создания предкомпилированного заголовка. Последующих компиляциях с использованием предкомпилированного заголовка значительному сведения обозревателя исходного кода. Информация для браузера помещается в единый SBR-файл и ссылаются другие файлы в так же, как Информация CodeView. Нельзя переопределить размещение данных обозревателя исходного кода.|  
|-/GD GA, /GE, /Gw или /GW|Параметры протокола Windows|Должны совпадать между компиляции, в которой создан предкомпилированный заголовок и текущей компиляции. Если эти параметры различаются, будет выдано предупреждение.|  
|/ZI|Создает полную отладочную информацию|Если этот параметр включен, при создании предкомпилированного заголовка, последующих компиляциях, в которых используется этот заголовок можно использовать эту отладочную информацию. Если параметр /Zi не действует при создании предкомпилированного заголовка, последующих компиляциях, в которых используется этот заголовок и параметр/ZI приводят к возникновению предупреждения. Отладочная информация помещается в текущий объектный файл, и локальные символы, определенные в заголовке недоступны для отладчика.|  
  
> [!NOTE]
>  Предкомпилированный заголовок предназначена для использования только в исходные файлы C и C++.  
  
<a name="using-precompiled-headers-in-a-project"></a>  
  
## <a name="using-precompiled-headers-in-a-project"></a>Использование предкомпилированных заголовков в проекте  
  
Предыдущих разделах представлены общие сведения о предкомпилированных заголовках: /Yc и /Yu параметр/FP и [hdrstop](../../preprocessor/hdrstop.md) pragma. В этом разделе описывается способ использования вручную параметров предкомпилированных заголовков в проекте; заканчивается примером файла makefile и кода, который им управляет.  
  
Другим способом, с помощью вручную параметров предкомпилированных заголовков в проекте изучите один из файлов makefile, расположенных в каталоге MFC\SRC, которая создается во время установки Visual C++ по умолчанию. Эти файлы makefile подхода аналогичный представленному в этом разделе, но лучше использовать макросы Microsoft программа обслуживания программ (NMAKE) и обеспечивают больший контроль процесса построения.  
  
<a name="pch-files-in-the-build-process"></a>  
  
## <a name="pch-files-in-the-build-process"></a>PCH-файлы в процессе построения  
  
База кода проекта программного обеспечения обычно содержится в нескольких C или C++ исходные файлы, файлы объектов, библиотеки и заголовочные файлы. Как правило файл makefile сочетание этих элементов в исполняемый файл. На следующем рисунке показана структура файла makefile, использующий файл предкомпилированных заголовков. Имена макроса NMAKE и имена файлов в эту диаграмму согласованы с идентификаторами в примере кода в [образец файла Makefile для PCH](#sample-makefile-for-pch) и [пример кода для PCH](#example-code-for-pch).  
  
На рисунке используется три графических устройств, чтобы показать поток процесса построения. Именованные прямоугольники представляют каждый файл или макрос. три макроса представляют один или несколько файлов. Темные области представляют действие каждой компиляции или компоновки. Стрелки показывают, какие файлы и макросы объединяются во время компиляции или процесс компоновки.  
  
![Файл makefile, использующий файл предкомпилированных заголовков](../../build/reference/media/vc30ow1.gif "структура файла Makefile, использует файл предкомпилированного заголовка")  
##### <a name="structure-of-a-makefile-that-uses-a-precompiled-header-file"></a>Структура файла Makefile, использующий файл предкомпилированных заголовков  
  
Начиная с верхней части диаграммы, STABLEHDRS и BOUNDRY являются макрос (NMAKE), в которых перечисляются файлы, вероятно, не нуждаются в повторной компиляции. Эти файлы компилируются в командной строке  
  
`CL /c /W3 /Yc$(BOUNDRY) applib.cpp myapp.cpp`  
  
только в том случае, если файл предкомпилированного заголовка (STABLE.pch) не существует, или при внесении изменений в файлы, перечисленные в двух макросов. В любом случае предкомпилированного файла заголовка будет содержать код только из файлов, перечисленных в макросе STABLEHDRS. Укажите последний файл, который необходимо предварительно скомпилировать в макросе BOUNDRY.  
  
Файлы, перечислены в эти макросы могут быть файлы заголовков или исходные файлы C или C++. (Один PCH-файл не может использоваться с модулями C и C++.) Обратите внимание, что можно использовать **hdrstop** макрос, чтобы остановить предварительную компиляцию в определенной точке в файле BOUNDRY. В разделе [hdrstop](../../preprocessor/hdrstop.md) для получения дополнительной информации.  
  
Далее на, рисунке файл APPLIB.obj представляет код поддержки, используемый в конечном приложении. Она создается из APPLIB.cpp, файлов, перечисленных в макросе UNSTABLEHDRS и предварительно скомпилированного кода из файла предкомпилированного заголовка.  
  
MYAPP.obj представляет конечное приложение. Она создается из MYAPP.cpp, файлов, перечисленных в макросе UNSTABLEHDRS и предварительно скомпилированного кода из файла предкомпилированного заголовка.  
  
Наконец исполняемый файл (MYAPP. Exe-ФАЙЛ) создается путем связывания файлов, перечисленных в макросе OBJS (рисунке файл APPLIB.obj и MYAPP.obj).  
  
<a name="sample-makefile-for-pch"></a>  
  
## <a name="sample-makefile-for-pch"></a>Образец файла makefile для PCH  
  
Следующий файл makefile используются макросы и! ЕСЛИ! ELSE! Структура команды управления потоком ENDIF для упрощения адаптации к проекту.  
  
```NMAKE  
# Makefile : Illustrates the effective use of precompiled  
#            headers in a project  
# Usage:     NMAKE option  
# option:    DEBUG=[0|1]  
#            (DEBUG not defined is equivalent to DEBUG=0)  
#  
OBJS = myapp.obj applib.obj  
# List all stable header files in the STABLEHDRS macro.  
STABLEHDRS = stable.h another.h  
# List the final header file to be precompiled here:  
BOUNDRY = stable.h  
# List header files under development here:  
UNSTABLEHDRS = unstable.h  
# List all compiler options common to both debug and final  
# versions of your code here:  
CLFLAGS = /c /W3  
# List all linker options common to both debug and final  
# versions of your code here:  
LINKFLAGS = /NOD /ONERROR:NOEXE  
!IF "$(DEBUG)" == "1"  
CLFLAGS   = /D_DEBUG $(CLFLAGS) /Od /Zi /f  
LINKFLAGS = $(LINKFLAGS) /COD  
LIBS      = slibce  
!ELSE  
CLFLAGS   = $(CLFLAGS) /Oselg /Gs  
LINKFLAGS = $(LINKFLAGS)  
LIBS      = slibce  
!ENDIF  
myapp.exe: $(OBJS)  
    link $(LINKFLAGS) @<<  
$(OBJS), myapp, NUL, $(LIBS), NUL;  
<<  
# Compile myapp  
myapp.obj  : myapp.cpp $(UNSTABLEHDRS)  stable.pch  
    $(CPP) $(CLFLAGS) /Yu$(BOUNDRY)    myapp.cpp  
# Compile applib  
applib.obj : applib.cpp $(UNSTABLEHDRS) stable.pch  
    $(CPP) $(CLFLAGS) /Yu$(BOUNDRY)    applib.cpp  
# Compile headers  
stable.pch : $(STABLEHDRS)  
    $(CPP) $(CLFLAGS) /Yc$(BOUNDRY)    applib.cpp myapp.cpp  
```  
  
Помимо STABLEHDRS и BOUNDRY, UNSTABLEHDRS макросы, показанную на рисунке «Структура из файла Makefile, использует файл предкомпилированного заголовка» в [PCH-файлы в процессе построения](#pch-files-in-the-build-process), это makefile предоставляет макрос CLFLAGS и LINKFLAGS макрос. Чтобы перечислить параметры компилятора и компоновщика, применяются ли построение отладочной или окончательной версии исполняемый файл приложения необходимо использовать эти макросы. Имеется также макрос БИБЛИОТЕК где перечислены библиотеки, необходимые проекта необходим.  
  
Файл makefile также использует! ЕСЛИ! ELSE! ENDIF для определения, является ли определить символ DEBUG в командной строке (NMAKE):  
  
```NMAKE  
NMAKE DEBUG=[1|0]  
```  
  
Эта функция позволяет использовать тот же файл makefile во время разработки и в окончательной версии программы, используйте DEBUG = 0 в окончательной версии. Следующие командные строки эквивалентны:  
  
```NMAKE  
NMAKE   
NMAKE DEBUG=0  
```  
  
Дополнительные сведения о файлах makefile см. в разделе [справочнике NMAKE](../../build/nmake-reference.md). См. также [параметры компилятора](../../build/reference/compiler-options.md) и [параметры компоновщика](../../build/reference/linker-options.md).  
  
<a name="example-code-for-pch"></a>  
  
## <a name="example-code-for-pch"></a>Пример кода для PCH  
  
Использование следующих исходных файлов в makefile, описанном в [PCH-файлы в процессе построения](#pch-files-in-the-build-process) и [образец файла Makefile для PCH](#sample-makefile-for-pch). Обратите внимание, что комментарии содержатся важные сведения.  
  
```cpp  
// ANOTHER.H : Contains the interface to code that is not  
//             likely to change.  
//  
#ifndef __ANOTHER_H  
#define __ANOTHER_H  
#include<iostream>  
void savemoretime( void );  
#endif // __ANOTHER_H  
```  
  
```cpp  
// STABLE.H : Contains the interface to code that is not likely  
//            to change. List code that is likely to change   
//            in the makefile's STABLEHDRS macro.  
//  
#ifndef __STABLE_H  
#define __STABLE_H  
#include<iostream>  
void savetime( void );  
#endif // __STABLE_H  
```  
  
```cpp  
// UNSTABLE.H : Contains the interface to code that is  
//              likely to change. As the code in a header  
//              file becomes stable, remove the header file  
//              from the makefile's UNSTABLEHDR macro and list  
//              it in the STABLEHDRS macro.  
//  
#ifndef __UNSTABLE_H  
#define __UNSTABLE_H  
#include<iostream.h>  
void notstable( void );  
#endif // __UNSTABLE_H  
```  
  
```cpp
// APPLIB.CPP : This file contains the code that implements  
//              the interface code declared in the header  
//              files STABLE.H, ANOTHER.H, and UNSTABLE.H.  
//  
#include"another.h"  
#include"stable.h"  
#include"unstable.h"  
// The following code represents code that is deemed stable and  
// not likely to change. The associated interface code is  
// precompiled. In this example, the header files STABLE.H and  
// ANOTHER.H are precompiled.  
void savetime( void )  
    { cout << "Why recompile stable code?\n"; }  
void savemoretime( void )  
    { cout << "Why, indeed?\n\n"; }  
// The following code represents code that is still under  
// development. The associated header file is not precompiled.  
void notstable( void )  
    { cout << "Unstable code requires"  
            << " frequent recompilation.\n"; 
    }  
```  
  
```cpp
// MYAPP.CPP : Sample application  
//             All precompiled code other than the file listed  
//             in the makefile's BOUNDRY macro (stable.h in  
//             this example) must be included before the file  
//             listed in the BOUNDRY macro. Unstable code must  
//             be included after the precompiled code.  
//  
#include"another.h"  
#include"stable.h"  
#include"unstable.h"  
int main( void )  
{  
    savetime();  
    savemoretime();  
    notstable();  
}  
```  
    
## <a name="see-also"></a>См. также  
[Справочные сведения о построении C/C++](../../build/reference/c-cpp-building-reference.md)   
[Параметры компилятора](../../build/reference/compiler-options.md)