---
title: "Связывание исполняемого файла с библиотекой DLL | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-tools
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
helpviewer_keywords:
- run time [C++], linking
- dynamic load linking [C++]
- linking [C++], DLLs
- DLLs [C++], linking
- implicit linking [C++]
- explicit linking [C++]
- executable files [C++], linking to DLLs
- loading DLLs [C++]
ms.assetid: 7592e276-dd6e-4a74-90c8-e1ee35598ea3
caps.latest.revision: 
author: corob-msft
ms.author: corob
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: 6bdc8d4b372a589beb51d2f8a9bc05b1aa241c48
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="link-an-executable-to-a-dll"></a>Связывание исполняемого файла с библиотекой DLL  
  
Исполняемый файл связывает (или загружает) библиотеку DLL одним из двух способов:  
  
-   *Неявное связывание*, где операционная система загружает библиотеку DLL после загрузки исполняемого файла. Клиентский исполняемый файл вызывает экспортированные функции библиотеки DLL, как если функции были статически связанные и содержащихся в исполняемый файл. Неявное связывание иногда называют *статической загрузкой* или *динамическое связывание во время загрузки*.  
  
-   *Явное связывание*, где операционная система загружает библиотеку DLL по запросу во время выполнения. Исполняемый файл, использующий библиотеку DLL, явное связывание должен делать вызовы функции для явной загрузки и выгрузки библиотеки DLL и доступа к функции, экспортируемые библиотеки DLL. В отличие от вызовов функций в статически скомпонованной библиотекой исполняемый файл клиента должен вызывать экспортированных функций DLL через указатель функции. Явное связывание иногда называют *динамической нагрузки* или *динамическое связывание во время выполнения*.  
  
Исполняемый файл можно использовать независимо от выбранного метода для связи с той же библиотеки DLL. Кроме того эти методы не являются взаимоисключающими; один исполняемый файл неявно связывается с библиотекой DLL, и другой подключиться к нему явным образом.  
  
<a name="determining-which-linking-method-to-use"></a>  
  
## <a name="determine-which-linking-method-to-use"></a>Определение подходящего метода связывания  
  
Неявное связывание или явное связывание является архитектурные решения, необходимые для вашего приложения. Есть свои преимущества и недостатки каждого метода.  
  
### <a name="implicit-linking"></a>Неявное связывание  
  
Неявное связывание происходит, когда код приложения вызывает экспортированную функцию DLL. Если исходный код для вызова исполняемого файла или компилируется, вызов функции DLL создает внешнюю ссылку на функцию в объектный код. Чтобы разрешить эту внешнюю ссылку, приложение должно быть связано с библиотекой импорта (LIB-файл), предоставленной создателем библиотеки DLL.  
  
Библиотека импорта содержит только код для загрузки библиотеки DLL и реализации вызовов функций в библиотеке DLL. При нахождении внешней функции в библиотеке импорта сообщает компоновщику, является ли код для этой функции в DLL. Для разрешения внешних ссылок на библиотеки DLL, компоновщик просто добавляет информацию в исполняемый файл, который сообщает системе, где найти код DLL при запуске процесса.  
  
При запуске системы программу, содержащую динамически связанные ссылки, он использует данные в исполняемый файл программы для поиска необходимых библиотек DLL. Если его не удается найти библиотеку DLL, система завершает процесс и отображает диалоговое окно сообщает об ошибке. В противном случае система сопоставляет модули библиотеки DLL в адресное пространство процесса.  
  
Если любой из библиотеки DLL имеет функцию точки входа для кода, инициализация и прекращение работы, например `DllMain`, операционная система вызывает функцию. Один из параметров, переданных в функцию точки входа указывает, что код, который указывает библиотеку DLL, присоединение к процессу. Если функция точки входа не возвращает значение TRUE, система завершает процесс и сообщает об ошибке.  
  
Наконец система изменяет исполняемый код процесса, чтобы предоставить начальные адреса для функций DLL.  
  
Как и остальные программы кода библиотеки DLL сопоставляются в адресное пространство процесса при его запуске и загружается в память только при необходимости. В результате `PRELOAD` и `LOADONCALL` атрибуты кода, используемые DEF-файлами для контроля загрузки в предыдущих версиях Windows, больше не требуются.  
  
### <a name="explicit-linking"></a>Явное связывание  
  
Большинство приложений используют неявное связывание, поскольку он является простым методом для использования. Однако бывают случаи, когда требуется явное связывание. Ниже приведены наиболее распространенные причины для использования явное связывание.  
  
-   Приложение не знает имя библиотеки DLL, загружаемой до времени выполнения. Например приложение может получить имя библиотеки DLL и экспортированные функции из файла конфигурации во время запуска.  
  
-   Процесс, использующий неявное связывание завершается операционной системой, если библиотека DLL не найдена во время запуска процесса. Процесс, использующий явное связывание, не завершается в данной ситуации и может попытаться восстановить из-за ошибки. Например процесс может уведомить пользователя об ошибке и пользователь должен указать другой путь к библиотеке DLL.  
  
-   Процесс, использующий неявное связывание также завершается, если любой из библиотек DLL, она связана с имеют `DllMain` функцию, которая завершается ошибкой. Процесс, использующий явное связывание не завершается в данной ситуации.  
  
-   Приложение, которое неявным образом связано со многими библиотеками DLL может быть медленным ему запуститься, поскольку Windows загружает все библиотеки DLL при загрузке приложения. Для повышения производительности при запуске приложения можно связать неявно только эти библиотеки DLL, необходимые сразу после загрузки и подождите, пока необходимые других библиотек DLL для явной ссылки на них.  
  
-   Явное связывание избавляет от необходимости связать приложение с помощью библиотеки импорта. Если изменения в библиотеке DLL приводят к изменению порядковых номеров экспорта, приложения, использующие явное связывание не приходится выполнять повторное связывание вызывающие `GetProcAddress` с использованием имени функции и порядковое значение, тогда как приложения, использующие неявное связывание должны выполнить повторное связывание новую библиотеку импорта.  
  
Ниже приведены моменты явное связывание следует учитывать.  
  
-   Если библиотека DLL имеет `DllMain` функцию точки входа, операционная система вызывает функцию в контексте потока, вызвавшего `LoadLibrary`. Функция точки входа не вызывается, если библиотека DLL уже присоединена к процессу, из-за предыдущего вызова `LoadLibrary` , имел нет соответствующего вызова `FreeLibrary` функции. Явное связывание может вызвать проблемы, если библиотека DLL использует `DllMain` функции для выполнения инициализации для каждого потока процесса, поскольку потоки, которые уже существуют при `LoadLibrary` (или `AfxLoadLibrary`) называется не инициализированы.  
  
-   Если библиотека DLL объявляет статические данные в виде `__declspec(thread)`, он может привести к сбою защиты при использовании явного связывания. После загрузки библиотеки DLL с помощью вызова `LoadLibrary`, происходит сбой защиты всякий раз, когда код ссылается на эти данные. (Статические данные включают глобальные и локальные статические элементы). Таким образом при создании библиотеки DLL, следует избегать использования локальной памяти потока или уведомить пользователей Библиотеки о потенциальных проблем, динамической загрузки библиотеки DLL. Дополнительные сведения см. в разделе [с помощью локального хранилища потока в библиотеке динамической компоновки (Windows SDK)](http://msdn.microsoft.com/library/windows/desktop/ms686997).  
  
<a name="linking-implicitly"></a>  
  
## <a name="how-to-link-implicitly-to-a-dll"></a>Неявное связывание с библиотекой DLL  
  
С помощью неявного связывания библиотеки DLL, в случае клиентских приложений необходимо получить эти файлы из библиотеки DLL поставщика:  
  
-   Один или несколько заголовков файлов (h-файлы), содержащие объявления экспортированных данных, функции и классы C++ в библиотеке DLL. Классы, функции и данные, экспортированные библиотекой DLL должны все быть помечены `__declspec(dllimport)` в файле заголовка. Дополнительные сведения см. в разделе [dllexport, dllimport](../cpp/dllexport-dllimport.md).  
  
-   Библиотека импорта для связывания в исполняемый файл. При построении библиотеки DLL, компоновщик создает библиотеку импорта. Дополнительные сведения см. в разделе [. LIB-файлы](../build/reference/dot-lib-files-as-linker-input.md).  
  
-   Фактический файл библиотеки DLL.  
  
Чтобы использовать библиотеку DLL, неявное связывание, исполняемый файл должен включать файлы заголовков, объявите данных, функций или классов C++, экспортируемые библиотеки DLL, в каждый исходный файл, содержащий вызовы экспортированные данные, функции и классы. С точки зрения кодирования экспортируемые функции вызываются так же, как любых других вызовов функции.  
  
Чтобы построить вызывающий исполняемый файл, необходимо связать с библиотекой импорта. Если использовать внешний сборочный файл проекта или системы сборки, укажите имя файла библиотеки импорта, где список других объектных файлах (.obj) или библиотеки, которые можно связать.  
  
Операционной системы должен иметь возможность найти DLL-файла при загрузке вызывающий исполняемый файл. Это означает, что приложение необходимо развернуть или проверить существование DLL-библиотеки, при установке приложения.   
  
<a name="linking-explicitly"></a>  
  
## <a name="how-to-link-explicitly-to-a-dll"></a>Как явной ссылки на библиотеку DLL  
  
Чтобы использовать библиотеку DLL, явное связывание, приложения необходимо, чтобы вызов функции для явной загрузки библиотеки DLL во время выполнения. Явной ссылкой на библиотеку DLL, приложение должно удовлетворять следующим требованиям:  
  
-   Вызовите [LoadLibrary](loadlibrary-and-afxloadlibrary.md), `LoadLibraryEx`, или аналогичной функции для загрузки библиотеки DLL и получения дескриптора модуля.  
  
-   Вызовите [GetProcAddress](getprocaddress.md) получить указатель на функцию к каждому экспортированной функции, которые вызывает приложение. Поскольку приложения вызывают функции DLL через указатель, компилятор не создает внешних ссылок, поэтому нет необходимости для связывания с библиотекой импорта. Тем не менее, необходимо иметь `typedef` или `using` инструкция, которая определяет сигнатуры вызова из экспортированных функций, которые можно вызвать.   
  
-   Вызовите [FreeLibrary](freelibrary-and-afxfreelibrary.md) при действий с библиотекой DLL.  
  
Например, в этом примере функции вызывает `LoadLibrary` для загрузки библиотеки DLL с именем «MyDLL» вызывает `GetProcAddress` для получения указателя на функцию с именем «DLLFunc1» вызывает функцию и сохраняет результат, а затем `FreeLibrary` выгрузить библиотеку DLL. 
  
```C  
#include "windows.h"

typedef HRESULT (CALLBACK* LPFNDLLFUNC1)(DWORD,UINT*);  

HRESULT LoadAndCallSomeFunction(DWORD dwParam1, UINT * puParam2)  
{
    HINSTANCE hDLL;               // Handle to DLL  
    LPFNDLLFUNC1 lpfnDllFunc1;    // Function pointer  
    HRESULT hrReturnVal;  
      
    hDLL = LoadLibrary("MyDLL");  
    if (NULL != hDLL)  
    {  
        lpfnDllFunc1 = (LPFNDLLFUNC1)GetProcAddress(hDLL, "DLLFunc1");  
        if (NULL != lpfnDllFunc1)  
        {  
            // call the function  
            hrReturnVal = lpfnDllFunc1(dwParam1, puParam2);  
        }  
        else  
        {  
            // report the error  
            hrReturnVal = ERROR_DELAY_LOAD_FAILED;  
        }
        FreeLibrary(hDLL);
    }
    else
    {
        hrReturnVal = ERROR_DELAY_LOAD_FAILED;
    }  
    return hrReturnVal;
}
```  
  
В отличие от этого, в большинстве случаев следует вызывать `LoadLibrary` и `FreeLibrary` только один раз в приложении для данной библиотеки DLL, особенно в том случае, если вы собираетесь вызовите нескольких функций в библиотеке DLL или DLL функции несколько раз.  
  
## <a name="what-do-you-want-to-know-more-about"></a>Дополнительные сведения  
  
-   [Работа с библиотеками импорта и файлами экспорта](../build/reference/working-with-import-libraries-and-export-files.md)  
  
-   [Путь поиска, используемый Windows для размещения библиотеки DLL](../build/search-path-used-by-windows-to-locate-a-dll.md)  
  
## <a name="see-also"></a>См. также  
 [DLL в Visual C++](../build/dlls-in-visual-cpp.md)