---
title: Библиотеки DLL расширения | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-tools
ms.topic: conceptual
f1_keywords:
- afxdll
dev_langs:
- C++
helpviewer_keywords:
- memory [C++], DLLs
- MFC extension DLLs [C++]
- AFXDLL library
- shared resources [C++]
- MFC DLLs [C++], MFC extension DLLs
- DLLs [C++], extension
- shared DLL versions [C++]
- resource sharing [C++]
- extension DLLs [C++]
- extension DLLs [C++], about MFC extension DLLs
ms.assetid: f69ac3d4-e474-4b1c-87a1-6738843a135c
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 6f60540735be44adf4305dcda77373faf8a83514
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
ms.locfileid: "32377135"
---
# <a name="mfc-extension-dlls"></a>Библиотека DLL-расширения MFC
Расширения MFC DLL является библиотекой DLL, обычно реализуют классы многократного использования, производные от существующих классов библиотеки Microsoft Foundation Class.  
  
 Расширения MFC DLL имеет следующие функции и требования:  
  
-   Исполняемый файл клиента должен быть приложением MFC, скомпилированным с `_AFXDLL` определен.  
  
-   Расширения MFC DLL также может использоваться обычной MFC DLL, динамически компонуемые с MFC.  
  
-   Библиотека DLL-расширения MFC должна компилироваться с `_AFXEXT` определен. Это заставляет `_AFXDLL` также и обеспечивает объявлений из файлов заголовков MFC. Это также гарантирует, что `AFX_EXT_CLASS` определяется как `__declspec(dllexport)` при построении библиотеки DLL, которая необходима при использовании этого макроса для объявления классов в библиотеке DLL расширения MFC.  
  
-   Библиотека DLL-расширения MFC не следует создавать экземпляр класса, производного от `CWinApp`, но полагаются на клиентское приложение (или DLL) для предоставления этого объекта.  
  
-   Библиотека DLL-расширения MFC Однако даст `DllMain` функцией и выполнить любую необходимую инициализацию.  
  
 Библиотеки DLL расширения создаются с помощью версии библиотеки MFC (также известный как общая версия MFC). Только исполняемые файлы MFC (приложения или обычные библиотеки DLL MFC), которые создаются с общедоступной версии MFC можно использовать расширения MFC DLL. Клиентское приложение и библиотеки DLL расширения MFC необходимо использовать одну и ту же версию MFCx0.dll. С расширением MFC библиотеки DLL можно создать новые пользовательские классы из MFC и затем применять эту расширенную версию для MFC для приложений, которые вызывают библиотеку DLL.  
  
 Библиотеки DLL расширения также может использоваться для передачи объекты, производные от приложения и библиотеки DLL. Функции-члены, связанные с переданный объект существует в модуле, в котором был создан объект. Поскольку эти функции соответствующим образом экспортируются при использовании общедоступной версии библиотеки DLL MFC, можно свободно передавать MFC или MFC-производный объект указатели между приложением и библиотеки DLL, он загружает расширения MFC.  
  
 Библиотеки DLL расширения MFC использует общедоступной версии MFC так же, как приложение использует общедоступную версию библиотеки DLL MFC, с следующее:  
  
-   Он не имеет `CWinApp`-производного объекта. Он должен работать с `CWinApp`-производный объект клиентского приложения. Это означает, что клиентское приложение, является владельцем, основной конвейер сообщений, пустых циклов и т. д.  
  
-   Он вызывает `AfxInitExtensionModule` в его `DllMain` функции. Следует проверить возвращаемое значение функции. Если возвращенный нулевое значение `AfxInitExtensionModule`, возвращают 0 из вашего `DllMain` функции.  
  
-   Он создает **CDynLinkLibrary** объекта во время инициализации, если расширения MFC DLL будет экспортировать `CRuntimeClass` объектов или ресурсы в приложение.  
  
 До версии MFC 4.0 такой тип DLL был вызван AFXDLL. AFXDLL ссылается `_AFXDLL` символ препроцессора, который определяется при построении библиотеки DLL.  
  
 Импортируемые библиотеки для общедоступной версии MFC присваиваются в соответствии с соглашением, описанным в [соглашения об именовании библиотек DLL MFC](../mfc/mfc-library-versions.md#mfc-static-library-naming-conventions). Visual C++ предоставляет предварительно построенные версии библиотеки DLL MFC, а также номер из не - MFC DLL-библиотеки, можно использовать и распространять с приложением. Все они описаны в файле Redist.txt, которая устанавливается в папке Program Files\Microsoft Visual Studio.  
  
 При экспорте с использованием DEF-файла, поместите следующий код в начале и в конце файла заголовка:  
  
```cpp  
#undef AFX_DATA  
#define AFX_DATA AFX_EXT_DATA  
// <body of your header file>  
#undef AFX_DATA  
#define AFX_DATA  
```  
  
 Эти четыре строки убедитесь в правильности компиляции кода для библиотеки DLL расширения MFC. Если исключить эти четыре строки может привести к библиотеки DLL для компиляции или неправильно компоновке.  
  
 Если нужно передать MFC или MFC-производный объект указатель или из библиотеки DLL MFC, библиотеки DLL следует расширения MFC DLL. Функции-члены, связанные с переданный объект существует в модуле, в котором был создан объект. Поскольку эти функции соответствующим образом экспортируются при использовании общедоступной версии библиотеки DLL MFC, можно свободно передавать MFC или MFC-производный объект указатели между приложением и библиотеки DLL, он загружает расширения MFC.  
  
 Из-за проблемы искажения и экспорта имен C++ список экспорта из расширения MFC DLL могут быть иными между отладочной версии и розничной версии той же библиотеки DLL и библиотеки DLL для различных платформ. Версии MFCx0.dll около 2 000 экспортированных точек входа; отладочные версии MFCx0D.dll — имеет около 3 000 экспортированных точек входа.  
  
## <a name="memory-management"></a>Управление памятью  
 MFCx0.dll и все расширения MFC загрузки библиотеки DLL в адресное пространство клиентского приложения используют же распределитель памяти, загрузка ресурсов и другие глобальные состояния MFC, как если бы они находились в одном приложении. Это важно, так как библиотеки MFC DLL и обычные библиотеки DLL MFC ведут себя совершенно противоположно и каждой библиотеки DLL выделения памяти за пределами пула памяти.  
  
 Если библиотеки DLL расширения MFC выделяет память, что память можно происходит свободное распределение с любой другой объект, выделенный приложения. Кроме того Если происходит сбой приложения, которое динамически привязано к MFC, защиты операционной системы обеспечивает целостность любого другого приложения MFC DLL.  
  
 Аналогично другие глобальные состояния MFC, такие как текущий исполняемый файл для загрузки ресурсов, также являются общими для клиентского приложения и все библиотеки DLL расширения MFC а также самой MFCx0.dll.  
  
## <a name="sharing-resources-and-classes"></a>Ресурсы и классы для управления доступом  
 Экспорт ресурсов осуществляется по списку ресурсов. Каждое приложение содержит однонаправленный список **CDynLinkLibrary** объектов. При поиске ресурса, большая часть стандартных реализаций MFC, которые загружают ресурсы быть первой в текущем модуле ресурсов (`AfxGetResourceHandle`) и если ресурс не найден проходят по списку из **CDynLinkLibrary** объектов Попытка загрузить запрошенный ресурс.  
  
 Проход по списку имеет недостатки он немного медленнее и требует управления уровнями идентификатора ресурса. Он имеет то преимущество, что клиентское приложение, которое ссылается на несколько библиотек DLL расширения MFC можно использовать любой предоставленный библиотекой DLL ресурс без указания дескриптора экземпляра библиотеки DLL. `AfxFindResourceHandle` интерфейс API используется для прохода в список ресурсов для поиска заданного совпадения. Он принимает имя и тип ресурса и возвращает дескриптор ресурса, где он сначала найден (или NULL).  
  
 Если вы не хотите проходят по списку и только загрузить ресурсы из определенного места, использовать функции `AfxGetResourceHandle` и `AfxSetResourceHandle` для сохранения старого дескриптора и задания нового. Не забудьте восстановить старый дескриптор ресурсов, прежде чем вернуться к клиентскому приложению. Пример использования этого подхода для явной загрузки меню см. в разделе Testdll2 .cpp в образце MFC [DLLHUSK](https://github.com/Microsoft/VCSamples/tree/master/VC2010Samples/MFC/advanced/dllhusk).  
  
 Аналогично динамического создания объектов MFC, заданных MFC именем. Механизм десериализации объекта MFC должен иметь все `CRuntimeClass` объекты регистрации, чтобы сделать возможным восстановление путем динамического создания объектов C++ требуемого типа, в зависимости от того, что было сохранено ранее.  
  
 В случае с примером MFC [DLLHUSK](https://github.com/Microsoft/VCSamples/tree/master/VC2010Samples/MFC/advanced/dllhusk), список будет выглядеть примерно так:  
  
```  
head ->   DLLHUSK.EXE   - or -   DLLHUSK.EXE  
               |                      |  
          TESTDLL2.DLL           TESTDLL2.DLL  
               |                      |  
          TESTDLL1.DLL           TESTDLL1.DLL  
               |                      |  
           MFCOxxD.DLL                |  
               |                      |  
           MFCDxxD.DLL                |  
               |                      |  
            MFCxxD.DLL            MFCxx.DLL  
```  
  
 где *xx* — номер версии; например, 42 представляет версию 4.2.  
  
 MFCxx.dll обычно последнего в списке ресурсов и список классов. MFCxx.dll включает все стандартные ресурсы MFC, в том числе командные строки для всех стандартных идентификаторов команд. Позволяет поместить его в конец списка, библиотеки DLL и самим клиентским приложениям не имеет собственную копию стандартные ресурсы MFC, а вместо этого для общих ресурсов в MFCxx.dll.  
  
 Объединение ресурсов и имена классов всех библиотек DLL в пространство имен клиентское приложение имеет недостаток, что необходимо соблюдать осторожность идентификаторов и имен, вам нужно выбрать.  
  
 [DLLHUSK](https://github.com/Microsoft/VCSamples/tree/master/VC2010Samples/MFC/advanced/dllhusk) образец управляет пространством имен общих ресурсов с помощью нескольких файлов заголовков.  
  
 Если библиотеки DLL расширения MFC должен поддерживать дополнительные данные для каждого приложения, можно наследовать новый класс из **CDynLinkLibrary** и создайте его в `DllMain`. При запуске, библиотеки DLL можно проверить список текущего приложения **CDynLinkLibrary** объектов для поиска объекта для конкретной библиотеки DLL расширения MFC.  
  
### <a name="what-do-you-want-to-do"></a>Выберите действие  
  
-   [Инициализация библиотеки DLL расширения MFC](../build/run-time-library-behavior.md#initializing-extension-dlls)  
  
### <a name="what-do-you-want-to-know-more-about"></a>Дополнительные сведения  
  
-   [Советы по использованию общих файлов ресурсов](../mfc/tn035-using-multiple-resource-files-and-header-files-with-visual-cpp.md)  
  
-   [Версия библиотеки DLL MFC](../mfc/tn033-dll-version-of-mfc.md)  
  
-   [Обычные библиотеки DLL MFC, статически компонуемые с MFC](../build/regular-dlls-statically-linked-to-mfc.md)  
  
-   [Обычные библиотеки DLL MFC, динамически компонуемые с MFC](../build/regular-dlls-dynamically-linked-to-mfc.md)  
  
-   [Использование библиотек DLL расширений MFC для баз данных, OLE и сокетов в обычных DLL-библиотеках MFC](../build/using-database-ole-and-sockets-extension-dlls-in-regular-dlls.md)  
  
## <a name="see-also"></a>См. также  
 [DLL в Visual C++](../build/dlls-in-visual-cpp.md)