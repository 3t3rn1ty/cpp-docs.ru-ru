---
title: "Состояние модулей регулярной динамической библиотеки DLL, связанной с MFC | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "DLL-библиотеки [C++], состояния модулей"
  - "библиотеки DLL MFC [C++], обычные библиотеки DLL"
  - "состояния модулей [C++]"
  - "состояния модулей [C++], обычные библиотеки DLL, динамически компонуемые с"
  - "обычные библиотеки DLL [C++], динамически компонуемые с MFC"
ms.assetid: b4493e79-d25e-4b7f-a565-60de5b32c723
caps.latest.revision: 7
caps.handback.revision: 7
author: "corob-msft"
ms.author: "corob"
manager: "ghogen"
---
# Состояние модулей регулярной динамической библиотеки DLL, связанной с MFC
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Возможность динамически связывать обычную библиотеку DLL с библиотекой DLL MFC позволяет реализовать некоторые очень сложные конфигурации.  Например, обычная библиотека DLL и исполняемый файл, использующий ее, могут динамически связаться с DLL\-библиотекой MFC и любыми DLL\-библиотеками расширения.  
  
 Подобная конфигурация создает проблему по отношению к глобальным данным MFC, таким как указатель на текущий объект `CWinApp` и сопоставления дескрипторов.  
  
 До версии 4.0 библиотеки MFC глобальные данные хранились в самой библиотеке DLL MFC и были общими для всех модулей процесса.  Так как любой процесс, использующий библиотеку DLL Win32, получает собственную копию данных DLL, подобная схема предоставляет простой способ отслеживания данных каждого процесса.  Кроме того, так как модель AFXDLL предполагает, что в процессе существует только один объект `CWinApp` и только один набор сопоставлений дескрипторов, эти элементы можно отследить в самой библиотеке DLL MFC.  
  
 Но с появлением возможности динамического связывания обычной DLL с библиотекой DLL MFC стало возможным существование нескольких объектов `CWinApp` в процессе, а также нескольких наборов сопоставлений дескрипторов.  Как MFC отслеживает, какие объекты ей использовать?  
  
 Решение заключается в предоставлении каждому модулю \(приложению или обычной DLL\) своей копии сведений о глобальном состоянии.  Следовательно, после вызова **AfxGetApp** в обычной библиотеке DLL возвращается указатель на объект `CWinApp` в библиотеке DLL, а не в исполняемом файле.  Эта помодульная копия глобальных данных MFC называется состоянием модуля, она описывается в разделе [Техническая заметка MFC 58](../mfc/tn058-mfc-module-state-implementation.md).  
  
 Общая процедура окна MFC автоматически переключается на верное состояние модуля, поэтому не следует волноваться об этом для любых обработчиков сообщений, реализованных в обычной DLL.  Но если исполняемый файл вызывает обычную библиотеку DLL, необходимо явно задать текущее состояние модуля для одной из DLL.  Для этого следует использовать макрос **AFX\_MANAGE\_STATE** в каждой функции, экспортируемой из DLL.  Для этого следует добавить следующий код в начало функций, экспортируемых из библиотеки DLL:  
  
```  
AFX_MANAGE_STATE(AfxGetStaticModuleState( ))  
```  
  
## Дополнительные сведения  
  
-   [Управление данными состояния модулей MFC](../mfc/managing-the-state-data-of-mfc-modules.md)  
  
-   [Обычные библиотеки DLL, динамически компонуемые с MFC](../Topic/Regular%20DLLs%20Dynamically%20Linked%20to%20MFC.md)  
  
-   [Библиотеки DLL расширения](../build/extension-dlls-overview.md)  
  
## См. также  
 [DLL в Visual C\+\+](../build/dlls-in-visual-cpp.md)