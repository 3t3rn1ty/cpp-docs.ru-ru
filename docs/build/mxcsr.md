---
title: MxCsr | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-tools
ms.topic: conceptual
dev_langs:
- C++
ms.assetid: 4f3c229d-0862-4733-acc7-9ed7a0b870ce
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 0d18a4247d36e6894230d74322d52cd5854e42fb
ms.sourcegitcommit: 92f2fff4ce77387b57a4546de1bd4bd464fb51b6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/17/2018
ms.locfileid: "45726509"
---
# <a name="mxcsr"></a>Регистр MxCsr

Состояние регистра включает MxCsr. Соглашение о вызове разделяет регистр volatile фрагмент и защищенную. Изменяемая часть состоит из 6 флагов состояния, MXCSR [0:5], а остальная часть регистре MXCSR [6:15], считается энергонезависимой.

Защищенной части задано следующие стандартные значения в начале выполнения программы:

```
MXCSR[6]         : Denormals are zeros - 0
MXCSR[7:12]      : Exception masks all 1's (all exceptions masked)
MXCSR[13:14]   : Rounding  control - 0 (round to nearest)
MXCSR[15]      : Flush to zero for masked underflow - 0 (off)
```

Вызываемый объект, который изменяет любое из защищенных полей в MXCSR необходимо восстановить их перед возвращением вызывающему. Более того вызывающий объект, который был изменен любой из этих полей, должен восстановить их стандартные значения перед вызовом вызываемым объектом, если только соглашением вызываемый требует измененные значения.

Существует два исключения из правил с учетом неизменяемости управляющих флагов.

- В функциях, где документированных заданная функция предназначена для изменения защищенные MxCsr флаги.

- Когда это вероятно так, что нарушения этих правил приводит к созданию программы, поведение так же, как программы, где эти правила не нарушены, например, посредством анализа всей программы.

Невозможно сделать никаких предположений о состоянии volatile части MXCSR на границе функции оговорено особо в документации функции.

## <a name="see-also"></a>См. также

[Соглашение о вызовах](../build/calling-convention.md)