---
title: "Visual C++ ARM затруднения | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-tools
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
ms.assetid: 0f4c434e-0679-4331-ba0a-cc15dd435a46
caps.latest.revision: 
author: corob-msft
ms.author: corob
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: bcc34d472fb6db02eb902001ad5aac77dea5baf0
ms.sourcegitcommit: 30ab99c775d99371ed22d1a46598e542012ed8c6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/03/2018
---
# <a name="common-visual-c-arm-migration-issues"></a>Общие вопросы использования Visual C++ ARM

При использовании Microsoft Visual C++ (параметры MSVC), тот же исходный код C++ может давать разные результаты на архитектуре ARM, не так, как на x86 или x64 архитектур.

## <a name="sources-of-migration-issues"></a>Источники миграции

Многие проблемы, которые могут возникнуть при переносе кода из архитектур x86 или x64 архитектуры ARM, связаны с конструкции исходного кода, которые могут вызвать поведение не определено, определяемого реализацией или не указан.

*Поведение определено* поведение, которое не определяет стандарт C++ и вызвана операция, которая имеет не разумного результат: например, преобразование значение с плавающей запятой в целое число без знака или сдвиг значения, число позиций является отрицательным или превышает количество битов в соответствующего типа повышенного уровня.

*Поведение, определяемое реализацией* поведение, которое в стандарте C++ компилятора поставщика определить и задокументировать. Программа полагаться на поведение, определяемое реализацией, даже если это так может не быть переносимой. Поведение, определяемое реализацией примеры размеры встроенных типов данных и их требований к выравниванию. Обращается к в список аргументов переменной является примером операции, зависит от конкретной реализации.

*Не задано поведение* поведение, которое стандарта C++ оставляет намеренно является недетерминированным. Несмотря на то, что поведение считается недетерминированным, реализация компилятора определяются определенного вызовов непредсказуемому поведению. Однако нет необходимости для поставщика компилятора предварительно определить результат или гарантирует согласованное поведение между вызовами сопоставимых и не требуется для документации. Пример поведение — порядок, в котором вычисляются вложенных выражений, включающих аргументов в вызове функции.

Другие проблемы при миграции может свидетельствовать о наличии различия характеристик оборудования ARM и x86 или x64 архитектур, которые по-разному стандарту c++. К примеру, дает модели строгого памяти архитектуры x86- и x64 `volatile`-имен переменных, некоторые дополнительные свойства, которые были использованы для упрощения определенных видов взаимодействия между потоками в прошлом. Но модель слабые память архитектуры ARM не поддерживает такое использование или стандарт C++ требует его.

> [!IMPORTANT]
>  Несмотря на то что `volatile` прибыли, недостаточно для реализации некоторых свойств, которые могут использоваться для реализации взаимодействия между потоками ограниченные формы на x86- и x64, эти дополнительные свойства между потоками обмена данными в целом. Стандарт языка C++ рекомендует такие подключения реализовываться вместо этого примитивы синхронизации, соответствующие.

Из-за различных платформ может по-разному express эти виды поведения, перенос программного обеспечения между платформами и может быть сложным и ошибки подвержено ошибкам, если он зависит от поведение определенной платформы. Несмотря на то, что многие из этих типов поведения можно наблюдать и могут отображаться стабильной, полагаться на них по крайней мере не является переносимым и в случаях поведение определено или не задан, также будет ошибкой. Даже поведения, указанные в этом документе, не следует полагаться на и может измениться в будущих компиляторах или при реализации ЦП.

## <a name="example-migration-issues"></a>Пример проблемы миграции

В оставшейся части этого документа описываются как различное поведение этих элементов языка C++ может дать разные результаты в разных платформах.

### <a name="conversion-of-floating-point-to-unsigned-integer"></a>Преобразование чисел с плавающей запятой в целое число без знака

В архитектуре ARM преобразование в 32-разрядное целое значение с плавающей запятой насыщение до ближайшего значения, которое может представлять целое число, если значение с плавающей запятой находится за пределами диапазона, который может представлять целое число. Архитектуру x86- и x64 преобразование обтекание Если целое число без знака или имеет значение от -2147483648, если целое число имеет подпись. Ни один из этих архитектур непосредственно поддерживают преобразование значений с плавающей запятой в типы меньших целых чисел; Вместо этого преобразования, выполняемые до 32 бит и результаты усекаются до меньшего размера.

Для архитектуры ARM сочетание насыщенности и усечение означает, что преобразование типов без знака правильно насыщение меньшего беззнаковых типов насыщение 32-разрядное целое число, но выдает усеченное результат для значения, большего, чем при меньшего размера тип может представлять но слишком мал для насыщения 32-разрядное целое число. Преобразования также правильно насыщение для 32-разрядных целых чисел со знаком, но приводит к положительно пропускная способность значения -1 и 0 для значения отрицательно пропускная способность усечение насыщенный, с подписью целых чисел. Преобразование в меньшего целого числа со знаком результат усеченное непредсказуем.

По этим архитектурам x86- и x64 сочетание циклических поведение для преобразования целого числа без знака и явные оценки для преобразования целого числа со знаком в случае переполнения, а также усечение, сделать результаты для большинства смен непредсказуемыми, если они являются слишком большой.

Эти платформы также различаются способом обработки преобразования в целочисленные типы NaN (не число). Преобразует значение NaN на ARM, в 0x00000000; на x86- и x64 он преобразует 0x80000000.

Преобразования с плавающей запятой можно полагаться только на, если известно, что значение находится в пределах диапазона, он преобразуется в тип integer.

### <a name="shift-operator---behavior"></a>Оператор сдвига (\< \< >>) поведение

В архитектуре ARM значение можно сдвиг влево или вправо до 255 бит до начала шаблон повторения. Архитектур x86- и x64 шаблон повторяется в каждой кратно 32, если источником шаблона является 64-разрядную переменную; в этом случае что шаблон повторяется в каждом кратен 64 на x 64 и 256 на x86, где работает программная реализация каждые несколько. Например для 32-разрядную переменную со значением 1 сдвиг влево на 32 позиций, на устройствах ARM результат равен 0, на x86 результат равен 1 и на x64 результат также равен 1. Тем не менее, если источник значения 64-разрядную переменную, затем результат на всех трех платформах 4294967296 и значение не «обернуться по кругу» пока она переходит на x64 или 256 позиций на ARM и x86 64 позиций.

Так как результат операции сдвига, размер которой превышает количество битов в исходный тип не определен, компилятор не требуется иметь согласованное поведение во всех ситуациях. Например если оба операнда смены известны во время компиляции, компилятор может оптимизировать программу, используя внутренний подпрограммы для предварительно вычисляет результат сдвига и затем подстановка результат вместо операции сдвига. Если величина сдвига слишком велик или отрицательное значение, результат внутренней процедуры может отличаться от результата того же выражения shift при выполнении ЦП.

### <a name="variable-arguments-varargs-behavior"></a>Поведение с переменными аргументами (varargs)

На архитектуре ARM параметры из списка переменные аргументы, передаваемые в стеке проходят выравнивания. Например 64-разрядный параметр выровнен по границе 64-разрядной. На x86- и x64 аргументы, передаваемые в стеке не распространяется пакет и выравнивание тесно. Это может привести к функции с переменным числом аргументов, как `printf` для чтения адреса памяти, которые были предназначены в качестве заполнителя на ARM Если ожидаемый макета в список аргументов переменной не соответствует полностью, несмотря на то, что она может работать для подмножества некоторые значения на x86 или x64 архитектур. Рассмотрим следующий пример.

```C
// notice that a 64-bit integer is passed to the function, but '%d' is used to read it.
// on x86 and x64 this may work for small values because %d will “parse” the low-32 bits of the argument.
// on ARM the calling convention will align the 64-bit value and the code will print a random value
printf("%d\n", 1LL);
```

В этом случае может быть исправлена, убедившись, что используется правильный формат спецификации, который считается выравнивание аргумента. Этот код является верным:

```C
// CORRECT: use %I64d for 64-bit integers
printf("%I64d\n", 1LL);
```

### <a name="argument-evaluation-order"></a>Порядок вычисления аргумента

Поскольку ARM, x 86 и x64 процессоров, поэтому отличаются, может быть представлен различные требования к реализации компилятора, а также различные возможности для оптимизации. По этой причине вместе с таких факторов, как параметры соглашения о вызовах и оптимизации, компилятор может вычислить аргументов функции в другом порядке в разных архитектур или изменения других факторов. Это может вызвать поведение приложения, которое зависит от конкретного порядка оценки неожиданное изменение.

Такая ошибка может возникнуть, когда аргументы для функции имеют побочные эффекты, которые влияют на другие аргументы функции в одном вызове. Обычно этого вида зависимостей можно легко избежать, но он иногда могут быть закрыты с зависимостями, довольно трудно или путем перегрузки операторов. Рассмотрим следующий пример кода.

```cpp
handle memory_handle;

memory_handle->acquire(*p);
```

Это выглядит хорошо определены, но если `->` и `*` являются перегруженные операторы, то этот код преобразуется в то, что выглядит следующим образом:

```cpp
Handle::acquire(operator->(memory_handle), operator*(p));
```

И если имеется зависимость между `operator->(memory_handle)` и `operator*(p)`, код может зависеть от конкретного порядка оценки, несмотря на то, что исходный код выглядит нет никакой возможные зависимости.

### <a name="volatile-keyword-default-behavior"></a>поведение по умолчанию volatile-ключевое слово

Параметры MSVC компилятор поддерживает две разные интерпретации `volatile` квалификатор хранилища, можно указать с помощью параметров компилятора. [/Volatile:ms](../build/reference/volatile-volatile-keyword-interpretation.md) коммутатор выбирает расширенные volatile семантику, которая гарантирует строгое упорядочение, так же как в случае традиционных x86- и x64 из-за модели строгого памяти на архитектуры Майкрософт. [/Volatile:iso](../build/reference/volatile-volatile-keyword-interpretation.md) коммутатор выбирает strict Стандартная volatile семантику C++, которая не гарантирует строгого порядка.

В архитектуре ARM, значение по умолчанию — **/volatile:iso** Поскольку процессоры ARM имеют слабо упорядоченные модели памяти и программного обеспечения ARM не имеет прежних надлежащей расширенные семантику **/volatile:ms**  и обычно не имеет интерфейс с программным обеспечением, выполняющий. Однако это по-прежнему иногда удобны в использовании или даже необходимые для компиляции программы ARM использует эту расширенную семантику. Например может быть слишком много ресурсов для порта программа использует семантику ISO C++ или драйвер может возникнуть необходимость соблюдать традиционные семантику для правильной работы. В этих случаях можно использовать **/volatile:ms** коммутатор; тем не менее, для повторного создания традиционных volatile семантику для целевых объектов ARM, компилятор должен вставлять барьеры в памяти вокруг каждого считывание или запись `volatile` переменной для принудительного применения строгого порядка сортировки, который может иметь негативное влияние на производительность.

X86- и x64 архитектуру, значение по умолчанию — **/volatile:ms** тем, что большая часть программного обеспечения, который уже был создан для эти архитектуры, используя параметры MSVC их использует. При компиляции программы x86- и x64, можно указать **/volatile:iso** перейдите во избежание ненужных зависимость от традиционных volatile семантику, а также для обеспечения переносимости.

## <a name="see-also"></a>См. также

[Настройка Visual C++ для процессоров ARM](../build/configuring-programs-for-arm-processors-visual-cpp.md)  
