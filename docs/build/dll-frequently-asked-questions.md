---
title: Вопросы и ответы по библиотекам DLL MFC | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-tools
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- troubleshooting [C++], DLLs
- DLLs [C++], frequently asked questions
- FAQs [C++], DLLs
ms.assetid: 09dd068e-fc33-414e-82f7-289c70680256
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 6f5740989562aea799f3a49adfa464e2c460acb3
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
ms.locfileid: "32372514"
---
# <a name="dll-frequently-asked-questions"></a>Вопросы и ответы по библиотекам DLL  
  
Ниже представлены некоторые часто задаваемые вопросы (FAQ) о библиотеках DLL.  
    
-   [Создание можно в библиотеке DLL MFC нескольких потоков?](#mfc_multithreaded_1)  

-   [Можно многопоточного приложения доступ к библиотеке DLL MFC в различных потоках?](#mfc_multithreaded_2)  
  
-   [Существуют ли какие классы MFC и функции не может использоваться в библиотеке DLL MFC?](#mfc_prohibited_classes)  
  
-   [Способы оптимизации следует использовать для повышения производительности клиентского приложения при загрузке](#mfc_optimization)  
  
-   [В обычной библиотеке DLL MFC имеется утечка памяти, но превосходно выглядит мой код. Как найти утечки памяти](#memory_leak)  

## <a name="mfc_multithreaded_1"></a> Создание можно в библиотеке DLL MFC нескольких потоков?  
  
За исключением того, в процессе инициализации библиотеки DLL MFC допускается создание нескольких потоков до тех пор, пока он использует локальное хранилище (TLS) функции, такие как поток Win32 **TlsAlloc** для выделения локальной памяти потока. Тем не менее если библиотека DLL MFC использует **__declspec(thread)** для выделения локальной памяти потока, клиентское приложение должно быть неявно связано с библиотекой DLL. Если клиентское приложение явно связано с библиотекой DLL, вызов **LoadLibrary** не будет успешно загрузить библиотеку DLL. Дополнительные сведения о создании нескольких потоков внутри библиотеки DLL MFC см. в статье базы знаний «PRB: вызов LoadLibrary() для загрузки библиотеки DLL, имеет статическая память TLS» (Q118816). Дополнительные сведения о локальные переменные потока в библиотеках DLL см. в разделе [поток](../cpp/thread.md).
  
 Библиотека DLL MFC, которая создает новый поток MFC при запуске не отвечает при загрузке приложения. Сюда входят всякий раз, когда поток создается путем вызова `AfxBeginThread` или `CWinThread::CreateThread` внутри:  
  
-   `InitInstance` Из `CWinApp`-производный объект в обычной DLL MFC.  
  
-   Указанный `DllMain` или **RawDllMain** функции в библиотеке регулярных DLL MFC.  
  
-   Указанный `DllMain` или **RawDllMain** функции в DLL расширений MFC.  
  
 Дополнительные сведения о создании потоков во время инициализации см. в статье базы знаний «PRB: не удается создать MFC потоков во время DLL запуска» (Q142243).  
  
## <a name="mfc_multithreaded_2"></a> Можно многопоточного приложения доступ к библиотеке DLL MFC в различных потоках?
Многопоточные приложения могут обращаться к обычные библиотеки DLL MFC, динамически связываются с MFC и библиотеки DLL расширения MFC из разных потоков. И, начиная с Visual C++ версии 4.2, приложение может получить доступ к обычные библиотеки DLL MFC, статическая компоновка с MFC из различных потоков, созданных в приложении.  
  
 До версии 4.2 только один внешний поток мог подключиться к обычной MFC DLL, статически компонуемые с MFC. Дополнительные сведения об ограничениях доступа к обычные библиотеки DLL MFC, статическая компоновка с MFC из нескольких потоков (до Visual C++ версии 4.2) см. в статье базы знаний «несколько потоков и MFC предшествовавших» (Q122676).  
  
 Обратите внимание, что термин USRDLL больше не используются в документации по Visual C++. Обычной MFC DLL, статически компонуемые с MFC имеет те же характеристики, как бывшая USRDLL.  


## <a name="mfc_prohibited_classes"></a> Существуют ли какие классы MFC и функции не может использоваться в библиотеке DLL MFC?
Использование библиотек DLL расширения `CWinApp`-производный класс от клиентского приложения. Они не могут иметь свои собственные `CWinApp`-производного класса.  
  
обычные библиотеки DLL MFC должен иметь `CWinApp`-производного класса, а также один объект этого класса приложений, как в приложении MFC. В отличие от `CWinApp` приложения, `CWinApp` объект библиотеки DLL не имеет цикла обработки сообщений.  
  
 Обратите внимание, что поскольку `CWinApp::Run` механизм не применяется для библиотек DLL, приложение имеет основной конвейер сообщений. Если библиотека DLL открывает безрежимные диалоговые окна или имеет собственный фрейма главного окна, приложения цикла обработки сообщений должен вызывать процедуру, экспортированные библиотекой DLL, которая в свою очередь вызывает `CWinApp::PreTranslateMessage` функции-члена объекта приложения библиотеки DLL.  

## <a name="mfc_optimization"></a> Способы оптимизации следует использовать для повышения клиентское приложение&#39;производительности при загрузке?
Если DLL-Библиотека является обычной MFC DLL, статически компонуемые с MFC, изменив ее обычной MFC DLL, динамически компонуемые с MFC уменьшает размер файла.  
  
 Если DLL имеет большое количество функций, используйте DEF-файла для экспорта функции (вместо использования **__declspec(dllexport)**) и использовать данный файл [атрибута NONAME](../build/exporting-functions-from-a-dll-by-ordinal-rather-than-by-name.md) на каждом экспортируемую функцию. Атрибут NONAME приводит только порядковый номер и имя функции не должны храниться в таблице экспорта библиотеки DLL, которая уменьшает размер файла.  
  
 Библиотеки DLL, которые неявным образом связаны с приложением, загружаются при загрузке приложения. Для повышения производительности при загрузке, попробуйте разделить такую библиотеку DLL в разные библиотеки DLL. Поместите все функции, которые требуются вызывающему приложению сразу после загрузки в одну библиотеку DLL и вызывающее приложение неявно ссылаются на эту Библиотеку. Поместите другие функции, которые вызывающему приложению не требуется сразу в другую библиотеку DLL и иметь приложение явно связать с этой библиотекой DLL. Дополнительные сведения см. в разделе [Определение подходящего метода связывания для использования](../build/linking-an-executable-to-a-dll.md#determining-which-linking-method-to-use).  

## <a name="memory_leak"></a> Существует&#39;превосходно выглядит s утечки памяти в обычной библиотеке DLL MFC, но в коде. Как найти утечки памяти  
  
Одной из возможных причин утечки памяти является то, что MFC создает временные объекты, используемые внутри функций обработчика сообщений. В приложениях MFC этих временных объектов автоматически очищаются в `CWinApp::OnIdle()` функция, вызываемая между обработки сообщений. Однако в MFC-библиотеки динамической компоновки (DLL) `OnIdle()` функция не вызывается автоматически. В результате временные объекты не удаляются автоматически. Чтобы очистить временные объекты, необходимо явным образом вызвать DLL `OnIdle(1)` периодически.  
  
## <a name="see-also"></a>См. также  
 [DLL в Visual C++](../build/dlls-in-visual-cpp.md)