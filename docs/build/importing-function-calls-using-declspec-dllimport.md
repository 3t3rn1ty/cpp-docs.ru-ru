---
title: "Импорт вызовов функций с помощью __declspec(dllimport) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "__declspec"
  - "dllimport"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "__declspec(dllimport) - ключевое слово [C++]"
  - "атрибут DllImport [C++], импорты вызова функций"
  - "вызовы функций [C++], импорт"
  - "импортирование вызовов функций [C++]"
ms.assetid: 6b53c616-0c6d-419a-8e2a-d2fff20510b3
caps.latest.revision: 8
caps.handback.revision: 8
author: "corob-msft"
ms.author: "corob"
manager: "ghogen"
---
# Импорт вызовов функций с помощью __declspec(dllimport)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Следующий пример кода демонстрирует способ использования **\_declspec\(dllimport\)** для импорта вызовов функций из библиотеки DLL в приложение.  Предположим, что `func1` это функция, которая хранится в библиотеке DLL отдельно от EXE\-файла, содержащего функцию **main**.  
  
 Без **\_\_declspec\(dllimport\)** с данным кодом:  
  
```  
int main(void)   
{  
   func1();  
}  
```  
  
 компилятор формирует код, имеющий следующий вид:  
  
```  
call func1  
```  
  
 а компоновщик, в свою очередь, преобразует вызов подобным образом:  
  
```  
call 0x4000000         ; The address of 'func1'.  
```  
  
 Если `func1` хранится в другой библиотеке DLL, компоновщик не может ее распознать, поскольку отсутствует информация об адресе `func1`.  В 16\-битных средах компоновщик добавляет адрес этого кода в список в EXE\-файле, который во время выполнения будет заполнен загрузчиком верными адресами.  В 32\-битных и 64\-битных средах компоновщик производит преобразователь, адрес которого неизвестен.  В 32\-битной среде преобразователь выглядит следующим образом:  
  
```  
0x40000000:    jmp DWORD PTR __imp_func1  
```  
  
 В данном примере `imp_func1` это адрес для ячейки `func1` в таблице импортируемых адресов EXE\-файла.  Таким образом все адреса распознаются компоновщиком.  Для правильной работы загрузчику необходимо только обновить таблицу импортируемых адресов EXE\-файла во время загрузки.  
  
 Поэтому рекомендуется использовать **\_\_declspec\(dllimport\)**, поскольку в этом случае компоновщику не приходится создавать преобразователь без надобности.  Преобразователи расширяют код \(в системах RISC могут быть дополнительные инструкции\) и могут ухудшить эффективность кэша.  Если компилятор получает данные о том, что функция размещается в библиотеке DLL, он может создать непрямой вызов.  
  
 Таким образом, теперь следующий код:  
  
```  
__declspec(dllimport) void func1(void);  
int main(void)   
{  
   func1();  
}  
```  
  
 создает следующую инструкцию:  
  
```  
call DWORD PTR __imp_func1  
```  
  
 В этом случае отсутствует преобразователь и инструкция `jmp`, что укорачивает код и делает его быстрее.  
  
 С другой стороны для вызовов функций внутри DLL нет необходимости использовать непрямой вызов.  Адрес функции уже известен.  Так как чтобы загрузить и хранить адрес функции перед непрямым вызовом требуется время и место, прямой вызов всегда бывает быстрее и компактнее.  Рекомендуется использовать **\_\_declspec\(dllimport\)** при вызове функций библиотеки DLL, размещенных не в самой библиотеке.  Однако не используйте **\_\_declspec\(dllimport\)** для функций, размещенных в библиотеке DLL, при построении данной библиотеки.  
  
## См. также  
 [Импорт в приложение](../build/importing-into-an-application.md)