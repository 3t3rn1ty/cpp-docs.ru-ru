---
title: "Импортирование вызовов функций, с помощью __declspec(dllimport) | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-tools
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords:
- __declspec
- dllimport
dev_langs: C++
helpviewer_keywords:
- importing function calls [C++]
- dllimport attribute [C++], function call imports
- __declspec(dllimport) keyword [C++]
- function calls [C++], importing
ms.assetid: 6b53c616-0c6d-419a-8e2a-d2fff20510b3
caps.latest.revision: "8"
author: corob-msft
ms.author: corob
manager: ghogen
ms.openlocfilehash: d1501506d4575c5f7fe1ff1dc7823cbd1545b974
ms.sourcegitcommit: ebec1d449f2bd98aa851667c2bfeb7e27ce657b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/24/2017
---
# <a name="importing-function-calls-using-declspecdllimport"></a>Импорт вызовов функций с помощью __declspec(dllimport)
В следующем примере кода показано, как использовать **_declspec(dllimport)** для импорта вызовов функций из библиотеки DLL в приложение. Предполагается, что `func1` является функция, которая хранится в библиотеке DLL отдельно от файла .exe, который содержит **основной** функции.  
  
 Без **__declspec(dllimport)**, учитывая этот код:  
  
```  
int main(void)   
{  
   func1();  
}  
```  
  
 компилятор создает код, который выглядит следующим образом:  
  
```  
call func1  
```  
  
 и компоновщик преобразует вызов подобным образом:  
  
```  
call 0x4000000         ; The address of 'func1'.  
```  
  
 Если `func1` существует в другой библиотеке DLL, компоновщик не может ее распознать, поскольку нет возможности узнать об адресе `func1` —. В 16-разрядных сред компоновщик добавляет адрес этого кода в список в файл .exe, загрузчик бы исправления во время выполнения с правильным адресом. В 32-разрядных и 64-разрядных сред компоновщик создает преобразователь, из которых знать адрес. В 32-разрядной среде преобразователь выглядит следующим образом.  
  
```  
0x40000000:    jmp DWORD PTR __imp_func1  
```  
  
 Здесь `imp_func1` указан адрес `func1` ячейку в таблице адресов импорта файла .exe. Таким образом, все адреса известны в компоновщик. Загрузчик должен обновить адресную таблицу импорта файл .exe во время загрузки для правильной работы.  
  
 Таким образом, использование **__declspec(dllimport)** лучше, так как компоновщик не приходится создавать преобразователь не требуется. Преобразователи расширяют код (в системах RISC, он может быть несколько инструкций) и может снизить эффективность кэша. Если компилятор сообщить, что функция находится в библиотеке DLL, оно может создавать непрямой вызов для вас.  
  
 Поэтому теперь следующим кодом:  
  
```  
__declspec(dllimport) void func1(void);  
int main(void)   
{  
   func1();  
}  
```  
  
 создает следующую инструкцию:  
  
```  
call DWORD PTR __imp_func1  
```  
  
 Нет преобразователь и нет `jmp` инструкции, поэтому код имеет меньше и быстрее.  
  
 С другой стороны для вызовов функций в библиотеке DLL, вы не хотите использовать непрямой вызов. Вы уже знаете адрес функции. Так как для загружать и хранить адрес функции перед непрямым вызовом требуется время и место, прямой вызов всегда выполняется быстрее и меньшего размера. Вы хотите использовать **__declspec(dllimport)** при вызове функций библиотеки DLL самой библиотеки DLL. Не используйте **__declspec(dllimport)** на функции в библиотеке DLL, при построении данной Библиотеки.  
  
## <a name="see-also"></a>См. также  
 [Импорт в приложение](../build/importing-into-an-application.md)