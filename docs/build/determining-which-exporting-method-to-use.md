---
title: Определение подходящего метода экспорта для использования | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-tools
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- __declspec(dllexport) keyword [C++]
- exporting DLLs [C++], method comparison
- def files [C++], exporting from DLLs
- .def files [C++], exporting from DLLs
ms.assetid: 66d773ed-935c-45c2-ad03-1a060874b34d
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 03c88cee3504d8efef8f9ca19073ed06b66f6aeb
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
ms.locfileid: "32368763"
---
# <a name="determining-which-exporting-method-to-use"></a>Определение подходящего метода экспорта
Вы можете экспортировать функции одним из двух способов — DEF-файла или `__declspec(dllexport)` ключевое слово. Чтобы решить, каким образом является наиболее подходящим для библиотеки DLL, задайте себе следующие вопросы:  
  
-   Планируется экспортировать дополнительные функции позже?  
  
-   Является библиотеки DLL, используемый только приложения, которые можно перестраивать или использования приложениями, которые невозможно перестроить — например, приложений, созданных сторонними производителями?  
  
## <a name="pros-and-cons-of-using-def-files"></a>Преимущества и недостатки использования DEF-файлы  
 Экспорт функций в DEF-файл позволяет управлять порядковых номеров экспорта. При добавлении экспортированную функцию в DLL-Библиотеку, его можно назначить больше порядковый номер, чем значение экспортированную функцию. При этом приложения, использующие неявное связывание не приходится выполнять повторное связывание с библиотекой импорта, который содержит новую функцию. Это очень удобно, если вы разрабатываете библиотеку DLL для использования разными приложениями поскольку добавлять новые функциональные возможности, а также гарантировать, что он сохраняется для правильной работы с приложениями, которые уже используют его. Например библиотеки DLL MFC, построенных с помощью DEF-файлы.  
  
 Другим преимуществом использования DEF-файла является, которые можно использовать `NONAME` атрибут, чтобы экспортировать функцию. Этот запрос помещает порядковый номер только в таблице экспорта библиотеки DLL. Для библиотек DLL, содержащих большое количество функций, с помощью `NONAME` атрибута можно уменьшить размер DLL-файла. Сведения о способах создания инструкции определения модуля см. в разделе [правила для операторов определения модуля](../build/reference/rules-for-module-definition-statements.md). Сведения об экспорте порядковый номер в разделе [Экспорт функций из библиотеки DLL по порядковому номеру, а не по имени](../build/exporting-functions-from-a-dll-by-ordinal-rather-than-by-name.md).  
  
 Недостатком использования DEF-файла, что при экспорте функции в файле C++, либо нужно вставлять декорированные имена в DEF-файл или определить экспортируемые функции с помощью extern «C», чтобы избежать Декорирование имен, которые выполнены компилятором Visual C++.  
  
 Если поместить декорированные имена в DEF-файле, их можно получить с помощью [DUMPBIN](../build/reference/dumpbin-reference.md) инструмент либо с помощью компоновщика [/MAP](../build/reference/map-generate-mapfile.md) параметр. Декорированные имена, созданные компилятором зависят от компилятора; Таким образом, если поместить декорированные имена, созданные компилятором в DEF-файл приложения, которые связан с библиотекой DLL должны также быть построены с использованием той же версии компилятора, чтобы декорированные имена в вызывающем приложении соответствовали экспортированная имена i n в DEF-файле библиотеки DLL.  
  
## <a name="pros-and-cons-of-using-declspecdllexport"></a>Преимущества и недостатки использования __declspec(dllexport)  
 С помощью `__declspec(dllexport)` удобно, так как не нужно беспокоиться о поддержке DEF-файла и о получении декорированных имен экспортируемых функций. Тем не менее полезность таким образом экспорта ограничивается количество связанных приложений, которые требуется перестроить. При повторном построении библиотеки DLL с помощью новых экспортированных, необходимо перестроить приложения, поскольку декорированные имена для экспортируемых функций C++ могут измениться при использовании другой версии компилятора для перестроения.  
  
### <a name="what-do-you-want-to-do"></a>Выберите действие  
  
-   [Экспорт из библиотеки DLL с помощью. DEF-файлы](../build/exporting-from-a-dll-using-def-files.md)  
  
-   [Экспорт из библиотеки DLL с помощью __declspec(dllexport)](../build/exporting-from-a-dll-using-declspec-dllexport.md)  
  
-   [Экспорт и импорт с использованием AFX_EXT_CLASS](../build/exporting-and-importing-using-afx-ext-class.md)  
  
-   [Экспорт функций C++ для использования в реализации языка C](../build/exporting-cpp-functions-for-use-in-c-language-executables.md)  
  
-   [Экспорт функций на языке C для использования в исполняемых файлах C или C++-язык](../build/exporting-c-functions-for-use-in-c-or-cpp-language-executables.md)  
  
-   [Импорт в приложение с помощью __declspec(dllimport)](../build/importing-into-an-application-using-declspec-dllimport.md)  
  
-   [Инициализация библиотеки DLL](../build/run-time-library-behavior.md#initializing-a-dll)  
  
### <a name="what-do-you-want-to-know-more-about"></a>Дополнительные сведения  
  
-   [Импорт и экспорт встроенных функций](../build/importing-and-exporting-inline-functions.md)  
  
-   [Взаимный импорт](../build/mutual-imports.md)  
  
-   [Внутренние имена](../build/reference/decorated-names.md)  
  
## <a name="see-also"></a>См. также  
 [Экспорт из библиотеки DLL](../build/exporting-from-a-dll.md)