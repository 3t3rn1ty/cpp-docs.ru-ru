---
title: "Динамически компонуемые с MFC библиотеки DLL MFC регулярного | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-tools
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
helpviewer_keywords:
- regular MFC DLLs [C++], dynamically linked to MFC
- AFX_MANAGE_STATE macro
- DLLs [C++], regular
- shared DLL versions [C++]
- dynamically linked DLLs [C++]
ms.assetid: b4f7ab92-8723-42a5-890e-214f4e29dcd0
caps.latest.revision: "9"
author: corob-msft
ms.author: corob
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: 930d56f7bc296225e6fefcf92e49087a2aed99cb
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="regular-mfc-dlls-dynamically-linked-to-mfc"></a>Регулярные MFC библиотеки DLL, динамически компонуемые с MFC
Обычный, MFC DLL, динамически компонуемые с MFC является библиотекой DLL, внутренне использует MFC, а экспортированные функции в DLL может быть вызван MFC или не MFC исполняемых файлов. Как из названия, этот вид библиотек DLL построен с использованием версию библиотеки MFC (также известный как общая версия MFC). Функции обычно экспортируются из библиотеки DLL MFC, с помощью стандартного интерфейса C обычного.  
  
 Необходимо добавить `AFX_MANAGE_STATE` макрос в начале экспортируемых функций в обычных библиотеках DLL MFC, который динамически связываются с MFC, чтобы установить для текущего состояния модуля одну из библиотек DLL. Это можно сделать, добавив следующую строку кода в начало функции, экспортированные из библиотеки DLL:  
  
```  
AFX_MANAGE_STATE(AfxGetStaticModuleState( ))  
```  
  
 Обычной MFC DLL, динамически компонуемые с MFC имеет следующие особенности:  
  
-   Это новый тип библиотеки DLL, впервые по Visual C++ 4.0.  
  
-   Исполняемый файл клиента может быть написан на любом языке, поддерживающем использование библиотек DLL (C, C++, Pascal, Visual Basic и т. д.); оно не обязательно должно приложение MFC.  
  
-   В отличие от статически скомпонованной регулярных DLL MFC такой тип DLL динамически связана с библиотекой DLL MFC (также известный как общей библиотеки DLL MFC).  
  
-   Связать с этим типом DLL библиотеки импорта MFC использует тот же для библиотек DLL расширения MFC или приложений, использующих библиотеку DLL MFC: .lib MFCxx (D).  
  
 Обычной MFC DLL, динамически компонуемые с MFC предъявляются следующие требования:  
  
-   Эти библиотеки DLL компилируются с **_AFXDLL** определен, так же, как исполняемого файла, который динамически скомпонован с MFC DLL. Но **_USRDLL** также определяется, как обычной MFC DLL, статически компонуемые с MFC.  
  
-   Этот тип из библиотеки DLL, необходимо создать экземпляр `CWinApp`-производного класса.  
  
-   Этот тип DLL-Библиотека использует `DllMain` предоставляемая MFC. Поместите весь код инициализации зависящей от DLL в `InitInstance` код функции и завершение элемента в `ExitInstance` как обычного приложения MFC.  
  
 Так как такой тип DLL использует версию библиотеки MFC, необходимо явно задать текущее состояние модуля одну библиотеку DLL. Чтобы сделать это, используйте [AFX_MANAGE_STATE](../mfc/reference/extension-dll-macros.md#afx_manage_state) макрос в начале каждой функции, экспортированные из библиотеки DLL.  
  
 обычные библиотеки DLL MFC должен иметь `CWinApp`-производного класса, а также один объект этого класса приложений, как в приложении MFC. Тем не менее `CWinApp` объект библиотеки DLL не имеет цикла обработки сообщений, как и в `CWinApp` приложения.  
  
 Обратите внимание, что `CWinApp::Run` механизм не применяется к библиотеке DLL, поскольку приложение, которому принадлежит основной конвейер сообщений. Если библиотека DLL вызывает немодальное диалоговое окно или собственный фрейма главного окна, приложения цикла обработки сообщений необходимо вызвать процедуру экспорта библиотеки DLL, которая вызывает `CWinApp::PreTranslateMessage`.  
  
 Поместите все инициализации библиотеки DLL в `CWinApp::InitInstance` функции-члена как обычного приложения MFC. `CWinApp::ExitInstance` Функцию-член вашей `CWinApp` производном классе вызывается из предоставляемой MFC `DllMain` функции перед выгрузкой библиотеки DLL.  
  
 Общие библиотеки DLL MFCx0.dll и Msvcr*0.dll (или аналогичные файлы), необходимо распространить вместе с приложением.  
  
 Библиотека DLL, динамически компонуемые с MFC не может одновременно статически с MFC. Приложения связываются с обычные библиотеки DLL MFC динамически компонуемые с MFC он так же, как и любой другой DLL.  
  
 Символы, обычно экспортируются из обычного библиотеки DLL MFC, с помощью стандартного интерфейса C. Объявление функции, экспортируемой из обычной DLL MFC выглядит примерно следующим образом:  
  
```  
extern "C" __declspec(dllexport) MyExportedFunction( );  
```  
  
 Всех операций выделения памяти в обычной MFC DLL должна использоваться только внутри этой DLL. библиотеки DLL не следует передавать или получать из вызывающего исполняемого модуля следующие:  
  
-   Указатели на объекты MFC  
  
-   Указатели памяти, выделенной библиотекой MFC.  
  
 Если необходимо выполнять какие-либо из перечисленных выше, или нужно передать объекты, производные от вызывающего исполняемый файл и библиотека DLL, необходимо построить DLL расширений MFC.  
  
 Можно безопасно передавать указатели памяти, выделенной в библиотеках времени выполнения C между приложением и библиотеку DLL только в том случае, если создать копию данных. Нельзя удалять или изменять размеры этих указателей или использовать их без создания копии памяти.  
  
 При построении обычной DLL MFC, динамически привязано к MFC, необходимо использовать макрос [AFX_MANAGE_STATE](../mfc/reference/extension-dll-macros.md#afx_manage_state) для переключения состояния модуля MFC правильно. Это можно сделать, добавив следующую строку кода в начало функции, экспортированные из библиотеки DLL:  
  
```  
AFX_MANAGE_STATE(AfxGetStaticModuleState( ))  
```  
  
 **AFX_MANAGE_STATE** не следует использовать макрос, в обычных библиотеках DLL MFC, статическая компоновка с MFC или библиотека DLL-расширения MFC. Дополнительные сведения см. в разделе [управление данными о состоянии модулей MFC](../mfc/managing-the-state-data-of-mfc-modules.md).  
  
 Пример того, как записи, создания и использования регулярных DLL MFC, см. в образце [DLLScreenCap](https://github.com/Microsoft/VCSamples/tree/master/VC2010Samples/MFC/advanced/DllScreenCap). Дополнительные сведения об обычных библиотек DLL MFC, динамически связываются с MFC см. в разделе «Преобразование DLLScreenCap для динамически связи с DLL MFC» абстрактные для образца.  
  
## <a name="what-do-you-want-to-do"></a>Выберите действие  
  
-   [Инициализация обычных библиотек DLL MFC](../build/run-time-library-behavior.md#initializing-regular-dlls)  
  
## <a name="what-do-you-want-to-know-more-about"></a>Дополнительные сведения  
  
-   [Состояния модулей обычной MFC DLL, динамически компонуемые с MFC](../build/module-states-of-a-regular-dll-dynamically-linked-to-mfc.md)  
  
-   [Управление данными состояния модулей MFC](../mfc/managing-the-state-data-of-mfc-modules.md)  
  
-   [Использование библиотек DLL расширений MFC для баз данных, OLE и сокетов в обычных DLL-библиотеках MFC](../build/using-database-ole-and-sockets-extension-dlls-in-regular-dlls.md)  
  
-   [Использование MFC как часть библиотеки DLL](../mfc/tn011-using-mfc-as-part-of-a-dll.md)  
  
## <a name="see-also"></a>См. также  
 [Типы библиотек DLL](../build/kinds-of-dlls.md)