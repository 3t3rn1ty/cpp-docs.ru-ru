---
title: "Строки (C++/CX) | Microsoft Docs"
ms.custom: ""
ms.date: "01/22/2017"
ms.prod: "windows-client-threshold"
ms.technology: ""
ms.reviewer: ""
ms.suite: ""
ms.tgt_pltfrm: ""
ms.topic: "article"
ms.assetid: 5b34e1df-7c2b-4269-aba8-b767d36c49d9
caps.latest.revision: 22
author: "ghogen"
ms.author: "ghogen"
manager: "ghogen"
caps.handback.revision: 22
---
# Строки (C++/CX)
Текст в [!INCLUDE[wrt](../cppcx/includes/wrt-md.md)] представляется в [!INCLUDE[cppwrt_short](../cppcx/includes/cppwrt-short-md.md)] с помощью класса [Класс Platform::String](../cppcx/platform-string-class.md). Используйте `Platform::String Class` при передаче строк между методами в классах [!INCLUDE[wrt](../cppcx/includes/wrt-md.md)] и при взаимодействии с другими компонентами [!INCLUDE[wrt](../cppcx/includes/wrt-md.md)] через границы интерфейса ABI.`Platform::String Class` предоставляет методы для некоторых типичных операций над строками, но он является полнофункциональным классом строки. При разработке модуля в C\+\+ используйте стандартные строковые типы C\+\+ \(такие как [wstring](../Topic/wstring.md)\) для сложной обработки строк и преобразуйте конечный результат в тип [Platform::String^](../cppcx/platform-string-class.md), прежде чем передать его открытому интерфейсу или получить его из такого интерфейса. Операция преобразования между типом `wstring` или `wchar_t*` и типом `Platform::String` проста и эффективна.  
  
 **Быстрая передача**  
  
 В некоторых случаях компилятор может удостовериться, что есть возможность безопасно создать экземпляр класса `Platform::String` или передать объект `String` функции, не копируя основные данные строки. Эти операции называются *быстрой передачей*, и их выполнение прозрачно.  
  
## Создание строк  
 Значение объекта `String` — неизменяемая \(доступная только для чтения\) последовательность символов `char16` \(16\-разрядных символов Юникода\). Поскольку объект `String` является неизменяемым, присвоение нового строкового литерала переменной `String` фактически заменяет исходный объект `String` новым объектом `String`. При операции объединения исходный объект `String` разрушается, и создается новый объект.  
  
 **Литералы**  
  
 *Символ\-литерал* — это символ, заключенный в одиночные кавычки, а *строка\-литерал* — это последовательность символов, заключенная в двойные кавычки. Если для инициализации переменной String^ используется литерал, компилятор предполагает, что литерал состоит из символов `char16`. Таким образом, нет необходимости указывать перед литералом модификатор строки "L" или заключать литерал в макрос **\_T\(\)** или **TEXT\(\)**. Дополнительные сведения о поддержке Юникода в C\+\+ см. в разделах [Общие сведения о программировании Юникода](../text/unicode-programming-summary.md).  
  
 В следующем примере показаны различные способы создания объектов `String`.  
  
 [!code-cpp[cx_strings#01](../snippets/cpp/VS_Snippets_Misc/cx_strings/cpp/class1.cpp#01)]  
  
## Операции обработки строк  
 Класс `String` предоставляет методы и операторы для объединения и сравнения строк и других простейших операций со строками. Для более сложных манипуляций со строками используйте функцию\-член `String::Data()` для получения значения объекта `String^` в виде объекта `const wchar_t*`. Затем с помощью этого значения инициализируйте класс `std::wstring`, имеющий более богатый набор функций по обработке строк.  
  
 [!code-cpp[cx_strings#03](../snippets/cpp/VS_Snippets_Misc/cx_strings/cpp/class1.cpp#03)]  
  
## Преобразование строк  
 Объект `Platform::String` может содержать только символы `char16` или символ `NULL`. Если приложение должно работать с 8\-разрядными символами, используйте [Метод String::Data](../cppcx/string-data-method.md) для извлечения текста в качестве объекта `const wchar_t*`. Затем можно воспользоваться соответствующими функциям Windows или стандартной библиотеки для выполнения операций с данными и преобразовать их обратно в объект `wchar_t*` или [wstring](../Topic/wstring.md), из которого можно создать новый объект `Platform::String`.  
  
 В приведенном ниже фрагменте кода демонстрируется, как преобразовать переменную `String^` в переменную `wstring` и обратно. Дополнительные сведения об операциях со строками, используемых в этом примере, см. в разделе [basic\_string::replace](../Topic/basic_string::replace.md).  
  
 [!code-cpp[cx_strings#04](../snippets/cpp/VS_Snippets_Misc/cx_strings/cpp/class1.cpp#04)]  
  
## Длина строки и значения NULL внутри строк  
 [Метод String::Length](../cppcx/string-length-method.md) возвращает количество символов в строке, а не количество байтов. Символ NULL, означающий конец строки, не учитывается, если вы не указали обратное при создании строки с помощью семантики стека.  
  
 Объект `Platform::String` может содержать значения NULL внутри строки, но только если они получены в результате операции объединения. Значения NULL внутри строки не поддерживаются в строковых литералах, поэтому из нельзя использовать для инициализации объектов `Platform::String` таким способом. Значения NULL в объектах `Platform::String` игнорируются при отображении строки, например когда она присваивается свойству `TextBlock::Text`. Когда строковое значение возвращается свойством `Data`, значения NULL внутри строки удаляются.  
  
## StringReference  
 В некоторых случаях код \(a\) получает std::wstring или строку wchar\_t или строковый литерал L”” и просто передает их другому методу, принимающему String^ в качестве входного параметра. Если исходный строковый буфер остается допустимым и не изменяется до возвращения результата функцией, строку `wchar_t*` или строковый литерал можно преобразовать в [Platform::StringReference](../cppcx/platform-stringreference-class.md), а затем передать вместо `Platform::String^`. Это допустимо, поскольку в `StringReference` имеется определенное пользователем преобразование в тип `Platform::String^`. Благодаря `StringReference` можно избежать создания дополнительной копии строковых данных. В циклах, включающих передачу большого количества строк или передачу очень длинных строк, с помощью `StringReference` можно теоретически добиться значительного выигрыша в производительности. Но поскольку `StringReference` фактически занимает исходный строковый буфер, необходимо соблюдать осторожность, чтобы не повредить память. Не следует передавать `StringReference` в асинхронный метод, если нет гарантии, что исходная строка будет находиться в области видимости, когда выполнение метода закончится. При инициализации String^ из StringReference происходит принудительное выделение памяти и копирование содержимого строки, если имеется второй оператор присваивания. В этом случае выигрыш в производительности `StringReference` теряется.  
  
 Обратите внимание, что `StringReference` является типом класса стандартного языка C\+\+, а не ссылочным классом; его нельзя использовать в определяемых пользователем открытых интерфейсах ссылочных классов.  
  
 В следующем примере показано, как использовать StringReference.  
  
```  
void GetDecodedStrings(std::vector<std::wstring> strings)  
{  
    using namespace Windows::Security::Cryptography;  
    using namespace Windows::Storage::Streams;  
  
    for (auto&& s : strings)  
    {  
        // Method signature is IBuffer^ CryptographicBuffer::DecodeFromBase64String (Platform::String^)  
        // Call using StringReference:  
        IBuffer^ buffer = CryptographicBuffer::DecodeFromBase64String(StringReference(s.c_str()));  
  
        //...do something with buffer  
    }  
}  
```  
  
## См. также  
 [Built\-in Types](http://msdn.microsoft.com/ru-ru/acc196fd-09da-4882-b554-6c94685ec75f)