---
title: "Чистый и проверяемый код (C++/CLI) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - ".NET Framework [C++], чистый и проверенный код"
  - "/clr - параметр компилятора [C++], смешанные сборки"
  - "/clr - параметр компилятора [C++], чистые сборки"
  - "/clr - параметр компилятора [C++], проверяемые сборки"
  - "сборки [C++], смешанный код"
  - "сборки [C++], чистый код"
  - "сборки [C++], проверяемый код"
  - "смешанные сборки [C++]"
  - "смешанные сборки [C++], о смешанных сборках"
  - "чистые MSIL [C++]"
  - "чистые MSIL [C++], сведения о чистом коде"
  - "проверяемые сборки [C++]"
  - "проверяемые сборки [C++], сведения о проверяемых сборках"
  - "проверяемый строго типизированный код [C++]"
ms.assetid: 9050e110-fa11-4356-b56c-665187ff871c
caps.latest.revision: 31
caps.handback.revision: 31
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Чистый и проверяемый код (C++/CLI)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Для программирования .NET Visual C\+\+ поддерживает создание трех типов компонентов и приложений: смешанного, чистого и проверяемого.  Все три типа можно определить с помощью параметра компилятора [\/clr \(компиляция CLR\)](../build/reference/clr-common-language-runtime-compilation.md).  
  
## Заметки  
 Дополнительные сведения о проверяемых сборках см. в следующих разделах:  
  
-   [Сравнение смешанных, чистых и проверяемых компонентов](../dotnet/mixed-pure-and-verifiable-feature-comparison-cpp-cli.md)  
  
-   [Практическое руководство. Миграция в \/clr:pure](../dotnet/how-to-migrate-to-clr-pure-cpp-cli.md)  
  
-   [Практическое руководство. Создание проверяемых проектов на языке C\+\+](../dotnet/how-to-create-verifiable-cpp-projects-cpp-cli.md)  
  
-   [Практическое руководство. Миграция в \/clr:safe](../dotnet/how-to-migrate-to-clr-safe-cpp-cli.md)  
  
-   [Использование проверяемых сборок вместе с SQL Server](../Topic/Using%20Verifiable%20Assemblies%20with%20SQL%20Server%20\(C++-CLI\).md)  
  
-   [Рекомендации по безопасности](../top/security-best-practices-for-cpp.md)  
  
-   [Преобразование проектов из смешанного режима в чистый промежуточный язык](../dotnet/converting-projects-from-mixed-mode-to-pure-intermediate-language.md)  
  
## Смешанный режим \(\/clr\)  
 Смешанные сборки \(скомпилированные с помощью параметра **\/clr**\) содержат как неуправляемые, так и управляемые части, что позволяет им использовать функции .NET и при этом содержать неуправляемый код.  Это дает возможность приложениям и компонентам обновляться для использования функций .NET без необходимости полного переписывания всего проекта.  Использование Visual C\+\+ для смешивания управляемого и неуправляемого кодов таким образом называется "взаимодействием C\+\+".  Дополнительные сведения см. в разделах [Смешанные \(собственные и управляемые\) сборки](../Topic/Mixed%20\(Native%20and%20Managed\)%20Assemblies.md) и [Взаимодействие исходного кода и платформы.NET](../Topic/Native%20and%20.NET%20Interoperability.md).  
  
## Чистый режим \(\/clr:pure\)  
 Чистые сборки \(скомпилированные с помощью параметра **\/clr:pure**\) могут содержать как неуправляемые, так и управляемые типы данных, но только управляемые функции.  Подобно смешанном сборкам, чистые сборки обеспечивают взаимодействие со неуправляемыми библиотеками DLL посредством вызова P\/Invoke \(см. [Использование явного вызова Pinvoke в C\+\+ \(атрибут DllImport\)](../dotnet/using-explicit-pinvoke-in-cpp-dllimport-attribute.md)\), но функции взаимодействия C\+\+ недоступны.  Более того, чистые сборки не могут экспортировать функции, которые вызываются из функций машинного кода, поскольку пиксели входа в чистых сборках используют соглашение о вызове [\_\_clrcall](../cpp/clrcall.md).  
  
### Преимущества \/clr:pure  
  
-   Более высокая производительность: поскольку чистые сборки содержат только MSIL, в них нет встроенных функций и, следовательно, отсутствует потребность в управляемых\/неуправляемых переходах. \(Вызовы функций посредством P\/Invoke являются исключением из этого правила.\)  
  
-   Информированность о домене приложения: управляемые функции и типы данных CLR существуют внутри `Application Domains`, что влияет на их видимость и доступность.  Чистые сборки осведомлены о домене \(для каждого типа предусмотрена функция \_\_declspec\([appdomain](../Topic/appdomain.md)\)\), поэтому доступ к типам и функциям из других компонентов .NET проще и безопаснее.  В результате этого чистые сборки проще взаимодействуют с другими компонентами .NET, чем смешанные сборки.  
  
-   Внедисковая загрузка: чистые сборки могут загружаться в память или даже передаваться потоком.  Это особенно важно при использовании сборок .NET как хранимых процедур.  Этот аспект отличается от смешанных сборок, которые из\-за зависимости от механизмов загрузки Windows, чтобы выполняться, должны существовать на диске.  
  
-   Отражение: невозможно отражать смешанные исполняемые файлы, но имеется полная поддержка отражения чистых сборок.  Для получения дополнительной информации см. [Отражение](../dotnet/reflection-cpp-cli.md).  
  
-   Управляемость ведущего приложения: поскольку чистые сборки содержат только MSIL, их поведение более предсказуемое и более гибкое, чем у смешанных сборок, когда они используются в приложениях, содержащих CLR и изменяющих поведение по умолчанию.  
  
### Ограничения \/clr:pure  
 В этом разделе рассматриваются возможности, не поддерживаемые в настоящее время **\/clr:pure**.  
  
-   Чистые сборки не могут быть вызваны неуправляемыми функциями.  Поэтому чистые сборки не могут реализовывать интерфейсы COM или предоставлять собственные обратные вызовы.  Чистые сборки не могут экспортировать функции посредством \_\_declspec\(dllexport\) или DEF\-файлов.  Также, функции, объявленные с соглашением \_\_clrcall, не могут быть импортированы посредством \_\_declspec\(dllimport\).  Функции в модуле машинного кода могут быть вызваны из чистой сборки, но чистые сборки не могут предоставлять функции, вызываемые неуправляемыми функциями, поэтому функции предоставления в чистых сборках должны быть обеспеченны посредством управляемых функций в смешанной сборке.  Дополнительные сведения см. в разделе [Практическое руководство. Миграция в \/clr:pure](../dotnet/how-to-migrate-to-clr-pure-cpp-cli.md).  
  
-   Библиотеки ATL и MFC не поддерживаются при компиляции в режиме чистого промежуточного языка в Visual C\+\+.  
  
-   Чисто .netmodules не принимаются в качестве входных данных для C компоновщик Visual C\+\+.  Однако, чистые OBJ\-файлы принимаются компоновщиком и содержат надмножество сведений, содержащихся в файлах NETMODULE.  Дополнительные сведения см. в разделе [.NETMODULE\-файлы в качестве входных файлов компоновщика](../Topic/.netmodule%20Files%20as%20Linker%20Input.md).  
  
-   COM\-поддержка компилятора \(\#import\) не поддерживается, поскольку это может ввести в чистую сборку неуправляемые инструкции.  
  
-   Параметры с плавающей запятой для выравнивания и обработки исключений для чистых сборок не являются регулируемыми.  В результате этого невозможно использовать \_\_declspec\(align\).  В результате создаются некоторые файлы заголовка, такие как fpieee.h, которые несовместимы с \/clr:pure.  
  
-   Функция GetLastError из пакета PSDK может вести себя непредсказуемым образом при компилировании с помощью **\/clr:pure**.  
  
## Проверяемый \(\/clr:safe\)  
 При использовании параметра компилятора **\/clr:safe** создаются проверяемые сборки, подобные тем, которые пишутся на языках Visual Basic и C\#. Эти сборки отвечают требованиям, которые позволяют среде CLR обеспечивать выполнение кода с соблюдением текущих параметров безопасности.  Например, если параметры безопасности запрещают какому\-либо компоненту запись на диск, среда CLR перед выполнением какого\-либо кода может определить, отвечает ли проверяемый компонент критериям безопасности.  Поддержка CRT для проверяемых сборок отсутствует. \(Поддержка CRT доступна для чистых сборок посредством версии Pure MSIL библиотеки среды выполнения C.\)  
  
 Проверяемые сборки, в отличие от чистых и смешанных, предоставляют следующие преимущества.  
  
-   Повышенный уровень защиты.  
  
-   В некоторых ситуациях это необходимо \(например, в случае использования компонентов SQL\).  
  
-   Последующие версии Windows все чаще будут требовать, чтобы определенные компоненты и приложения были проверяемыми.  
  
 Одним из недостатков является то, что функции взаимодействия C\+\+ недоступны.  Проверяемые сборки не могут содержать неуправляемые функции или собственные типы данных, даже если на них нет ссылок в управляемом коде.  
  
 Несмотря на применение слова "safe", компилирующееся приложение с **\/clr:safe** не означает, что в нем нет ошибок; это означает лишь то, что среда CLR может проверить параметры безопасности во время выполнения.  
  
 Независимо от типа сборки, вызовы, выполненные из управляемых сборок к неуправляемым библиотекам DLL посредством P\/Invoke, будут компилироваться, но могут завершиться неудачей во время выполнения, если возникнет конфликт параметров безопасности.  
  
> [!NOTE]
>  Существует один скрипт кодирования, который будет пропущен компилятором, но приведет к непроверяемой сборке: вызов виртуальной функции через экземпляр объекта с использованием оператора разрешения области действия.  Например, `MyObj -> A::VirtualFunction();`.  
  
## См. также  
 [программирование .NET с использованием C\+\+\/CLI](../dotnet/dotnet-programming-with-cpp-cli-visual-cpp.md)