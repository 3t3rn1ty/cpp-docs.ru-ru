---
title: "Тип перечисления CLR | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
helpviewer_keywords:
- scope, of CLR enum
- enum struct keyword [C++]
- enum class keyword [C++]
ms.assetid: 4541d952-97bb-4e35-a7f8-d14f5f6a6606
caps.latest.revision: "11"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
- dotnet
ms.openlocfilehash: ad82c1d867c511121cd024f2affd5df98b4642bc
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="clr-enum-type"></a>Тип перечисления Enum в среде CLR
Объявление и поведение типов перечисления Enum изменилось с управляемых расширений для C++ к Visual C++.  
  
 В управляемых расширениях объявление типа enum предшествует `__value` ключевое слово. Том, чтобы различать собственное перечисление и перечисление CLR, который является производным от `System::ValueType`, при аналогичные функции. Пример:  
  
```  
__value enum e1 { fail, pass };  
public __value enum e2 : unsigned short  {   
   not_ok = 1024,   
   maybe, ok = 2048   
};  
```  
  
 В новом синтаксисе проблема отличия собственного и перечисления среды CLR, выделяя природе класса а не его происхождении от типа значения. Таким образом `__value` объявлении ключевое слово заменено составное ключевое слово `enum class`. Это обеспечивает симметрии ключевое слово парный объявлений ссылкой, значением и классов интерфейсов:  
  
```  
enum class ec;  
value class vc;  
ref class rc;  
interface class ic;  
```  
  
 Перевод пара перечисления `e1` и `e2` в новый синтаксис выглядит следующим образом:  
  
```  
enum class e1 { fail, pass };  
public enum class e2 : unsigned short {   
   not_ok = 1024,  
   maybe, ok = 2048   
};  
```  
  
 Помимо этого незначительного изменения поведение типа перечисления CLR был изменен в следующих случаях:  
  
-   Опережающее объявление перечисления CLR больше не поддерживается. Отсутствует сопоставление. Он просто помечается как ошибка времени компиляции.  
  
```  
__value enum status; // Managed Extensions: ok  
enum class status;   // new syntax: error  
```  
  
-   Разрешение перегрузки между встроенными арифметическими типами и `Object` иерархии классов изменилось в новой версии языка. Как побочный эффект перечислителях CLR больше не неявно преобразуются в арифметические типы.  
  
-   В новом синтаксисе перечисление CLR имеет собственную область видимости, которое не было в управляемых расширениях. Ранее перечислители были видимы в пределах области, содержащей перечисления. Теперь перечислители инкапсулируются в области перечисления.  
  
## <a name="clr-enums-are-a-kind-of-object"></a>Объект типа объектов являются перечисления CLR  
 Рассмотрим следующий фрагмент кода:  
  
```  
__value enum status { fail, pass };  
  
void f( Object* ){ Console::WriteLine("f(Object)\n"); }  
void f( int ){ Console::WriteLine("f(int)\n"); }  
  
int main()  
{  
   status rslt = fail;  
  
   f( rslt ); // which f is invoked?  
}  
```  
  
 Для собственного C++ программиста, естественным ответом на вопрос, какой экземпляр перегруженного `f()` вызывается является `f(int)`. Перечисление является символьной целой константой и используется в стандартных целых повышениях, которые в данном случае имеют более высокий приоритет.  А на самом деле в управляемых расширениях это экземпляр, к которому разрешается вызов. Это вызвано число сюрпризов - не при их использовании в машинном коде C++ кадра of виду -, а также при необходимости во взаимодействии с существующей инфраструктурой BCL (библиотеки базовых классов), где `Enum` является неявно производный класс от класса `Object`. В конструкции языка Visual C++, экземпляр `f()` вызывается из `f(Object^)`.  
  
 Способом, выбранному в Visual C++ для реализации этого является не поддерживается неявное преобразование между типом перечисления CLR и арифметическими типами. Это означает, что для любого назначения объекта типа перечисления CLR к арифметическому типу потребуется явное приведение. Таким образом например, если  
  
```  
void f( int );  
```  
  
 как-перегруженный метод, в управляемых расширениях вызов  
  
```  
f( rslt ); // ok: Managed Extensions; error: new syntax  
```  
  
 ОК, и значением, содержащимся в `rslt` неявно преобразуется в целочисленное значение. В Visual C++ этот вызов происходит сбой компиляции. Для правильного перевода необходимо вставить оператор преобразования:  
  
```  
f( safe_cast<int>( rslt )); // ok: new syntax  
```  
  
## <a name="the-scope-of-the-clr-enum-type"></a>Область действия типа перечисления CLR  
 Одно из изменений между в языках C и C++ было Добавление в C++ область в структуре. В языке C структура является статическим выражением без поддержки интерфейса или связанной области данных. Это было радикальным изменением во время и вызывало проблемы для многих новых пользователей C++, поступающих от языка. Аналогично связь между машинного кода и перечисления среды CLR.  
  
 В управляемых расширениях была предпринята попытка определить слабо подставляемого имена перечислителей для перечисления CLR, чтобы смоделировать отсутствие области собственного перечисления. Это попытка оказалась неудачной. Проблема заключается в том, что перечислители сливаются глобального пространства имен, в результате чего сложно управлять конфликтов имен. В новом синтаксисе присутствует других языков среды CLR в поддерживаемых областях внутри перечисления CLR.  
  
 Это означает, что любое неопределенное использование перечислителя перечисления CLR не будет распознан нового синтаксиса. Давайте взглянем на реальном примере.  
  
```  
// Managed Extensions supporting weak injection  
__gc class XDCMake {  
public:  
   __value enum _recognizerEnum {   
      UNDEFINED,  
      OPTION_USAGE,   
      XDC0001_ERR_PATH_DOES_NOT_EXIST = 1,  
      XDC0002_ERR_CANNOT_WRITE_TO = 2,  
      XDC0003_ERR_INCLUDE_TAGS_NOT_SUPPORTED = 3,  
      XDC0004_WRN_XML_LOAD_FAILURE = 4,  
      XDC0006_WRN_NONEXISTENT_FILES = 6,  
   };  
  
   ListDictionary* optionList;  
   ListDictionary* itagList;  
  
   XDCMake() {  
      optionList = new ListDictionary;  
  
      // here are the problems...  
      optionList->Add(S"?", __box(OPTION_USAGE)); // (1)  
      optionList->Add(S"help", __box(OPTION_USAGE)); // (2)  
  
      itagList = new ListDictionary;  
      itagList->Add(S"returns",   
         __box(XDC0004_WRN_XML_LOAD_FAILURE)); // (3)  
   }  
};  
```  
  
 Каждый из трех вариантов неопределенного использует имен перечислителя (`(1)`, `(2)`, и `(3)`) должен быть определен при трансляции в новом синтаксисе для компиляции исходного кода. Вот правильное преобразование исходного кода.  
  
```  
ref class XDCMake {  
public:  
   enum class _recognizerEnum {  
      UNDEFINED, OPTION_USAGE,   
      XDC0001_ERR_PATH_DOES_NOT_EXIST = 1,  
      XDC0002_ERR_CANNOT_WRITE_TO = 2,  
      XDC0003_ERR_INCLUDE_TAGS_NOT_SUPPORTED = 3,  
      XDC0004_WRN_XML_LOAD_FAILURE = 4,  
      XDC0006_WRN_NONEXISTENT_FILES = 6  
   };  
  
   ListDictionary^ optionList;  
   ListDictionary^ itagList;  
  
   XDCMake() {  
      optionList = gcnew ListDictionary;  
      optionList->Add("?",_recognizerEnum::OPTION_USAGE); // (1)  
      optionList->Add("help",_recognizerEnum::OPTION_USAGE); //(2)  
      itagList = gcnew ListDictionary;  
      itagList->Add( "returns",   
         _recognizerEnum::XDC0004_WRN_XML_LOAD_FAILURE); //(3)  
   }  
};  
```  
  
 При этом изменяется стратегия разработки между собственным и перечисления среды CLR. Перечисление CLR поддерживает связанную область действия в Visual C++ он не требуется эффективный инкапсуляция объявления перечисления внутри класса. Эту идиому развитие во время разработки cfront 2.0 в компании Bell Laboratories также для решения проблемы засорения глобальное имя.  
  
 В исходном выпуске бета-версии в новой библиотеке iostream, Джерри Schwarz в лаборатории Bell, Джерри была инкапсулирует все связанные перечисления, определенных для библиотеки и общие перечислители, такие как `read`, `write`, `append`и так далее , представляет собой практически невозможным для пользователей для компиляции существующего кода. Одно из решений могло бы стать искажение имен, такие как `io_read`, `io_write`и т. д. Другим решением было бы стать изменение языка путем добавления области действия к перечислению, но это не неосуществимым одновременно. Средний решение было инкапсуляция перечисления внутри класса или иерархии классов, где имя тега и перечислителями для перечисления заполнения области видимости класса.) То есть, мотивация для помещения перечислений внутри классов, по крайней мере первоначально была не философской, но ответ практические проблема засорения глобального пространства имен.  
  
 С помощью перечисления Visual C++ больше не имеет прежних преимуществ инкапсуляция перечисления внутри класса. На самом деле, если взглянуть на `System` пространства имен, вы увидите что перечисления, классы и интерфейсы находятся в одной области объявления.  
  
## <a name="see-also"></a>См. также  
 [Типы значений и их поведение (C + +/ CLI)](../dotnet/value-types-and-their-behaviors-cpp-cli.md)   
 [Класс перечисления](../windows/enum-class-cpp-component-extensions.md)