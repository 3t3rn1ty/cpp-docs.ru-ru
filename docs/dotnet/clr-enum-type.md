---
title: Тип Enum среды CLR | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-cli
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- scope, of CLR enum
- enum struct keyword [C++]
- enum class keyword [C++]
ms.assetid: 4541d952-97bb-4e35-a7f8-d14f5f6a6606
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- dotnet
ms.openlocfilehash: a39c451bcff7b5b3b1d7dd9f0d3925616b9d6aab
ms.sourcegitcommit: 799f9b976623a375203ad8b2ad5147bd6a2212f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/19/2018
ms.locfileid: "46436231"
---
# <a name="clr-enum-type"></a>Тип перечисления Enum в среде CLR

Объявление и поведение перечислений отличается от управляемых расширений для C++ в Visual C++.

Предшествует объявлении перечисления управляемых расширений `__value` ключевое слово. Идея заключается в том, чтобы отличить собственным перечислением от перечисления CLR, который является производным от `System::ValueType`, при аналогичные функции. Пример:

```
__value enum e1 { fail, pass };
public __value enum e2 : unsigned short  {
   not_ok = 1024,
   maybe, ok = 2048
};
```

В новом синтаксисе проблема отличия собственного и перечислениях, выделяя характер класса а не корнями тип значения. Таким образом `__value` ключевое слово отбрасывается, заменены составное ключевое слово `enum class`. Это обеспечивает симметрию парных ключевого слова для объявления ссылки, значение и классов интерфейсов:

```
enum class ec;
value class vc;
ref class rc;
interface class ic;
```

Перевод пара перечисления `e1` и `e2` в новом синтаксисе выглядит следующим образом:

```
enum class e1 { fail, pass };
public enum class e2 : unsigned short {
   not_ok = 1024,
   maybe, ok = 2048
};
```

Помимо этого незначительного изменения поведение типа перечисления CLR был изменен в следующих случаях:

- Опережающее объявление перечисления CLR больше не поддерживается. Отсутствует сопоставление. Он просто помечается как ошибка времени компиляции.

```
__value enum status; // Managed Extensions: ok
enum class status;   // new syntax: error
```

- Разрешение перегрузки между встроенные арифметические типы и `Object` иерархии классов изменилось в новой версии языка! Как побочный эффект перечислителях CLR больше не неявно преобразуются в арифметические типы.

- В новом синтаксисе перечисление CLR имеет собственную область, это не так в управляемых расширений. В предыдущих версиях перечислители были видимы в пределах области, содержащей перечисления. Теперь перечислители инкапсулированы в области действия перечисления.

## <a name="clr-enums-are-a-kind-of-object"></a>Объект типа являются перечисления CLR

Рассмотрим следующий фрагмент кода:

```
__value enum status { fail, pass };

void f( Object* ){ Console::WriteLine("f(Object)\n"); }
void f( int ){ Console::WriteLine("f(int)\n"); }

int main()
{
   status rslt = fail;

   f( rslt ); // which f is invoked?
}
```

Для собственного C++ программиста, естественным ответом на вопрос, какой экземпляр из перегруженных `f()` вызывается, — это `f(int)`. Перечисление является символьной целой константой и используется в стандартных восходящие приведения целых типов которых в данном случае имеют приоритет.  И на самом деле в управляемых расширений это был экземпляр, к которому разрешается вызов. Это вызвано ряд непредвиденных ситуаций — не в том случае, когда мы использовали их в машинном коде C++ кадра of виду -, а также при необходимости их для взаимодействия с существующей инфраструктурой BCL (библиотеки базовых классов), где `Enum` является класс косвенно производным от `Object`. В конструкции языка Visual C++, экземпляр `f()` вызывается из `f(Object^)`.

Способом, выбранных в Visual C++ для реализации этого является не поддерживается неявное преобразование между типом перечисления CLR и арифметические типы. Это означает, что все назначения объекта типа перечисления CLR арифметический тип требуется явное приведение. Таким образом например, если

```
void f( int );
```

как не перегружать метод, в управляемых расширениях вызов

```
f( rslt ); // ok: Managed Extensions; error: new syntax
```

ОК, и значение, содержащееся в `rslt` будет неявно преобразовано в целое число. В Visual C++ этот вызов завершается ошибкой для компиляции. Для правильного перевода, необходимо вставить оператор преобразования:

```
f( safe_cast<int>( rslt )); // ok: new syntax
```

## <a name="the-scope-of-the-clr-enum-type"></a>Область типа Enum среды CLR

Одно из изменений между языками C и C++ был Добавление в C++ область в структуре. В языке C структура является просто это агрегат данных без поддержки интерфейса или связанную область действия. Это было весьма радикальные изменения во время и спорными проблема для многих новых пользователей C++, поступающие от языка. Связь между машинный код и перечисления CLR является аналогом.

В управляемых расширениях была предпринята попытка определить слабо внедренного имена перечислителей для перечисления CLR, чтобы смоделировать отсутствие области собственного перечисления. Это попытка оказалась неудачной. Проблема в том, что перечислители сливаются глобальное пространство имен, в результате чего сложно управлять конфликтов имен. В новом синтаксисе присутствует других языков среды CLR в поддержке областях внутри перечисления CLR.

Это означает, что любое неопределенное использование перечислителя для перечисления CLR не будет распознаваться новый синтаксис. Рассмотрим Реальный пример.

```
// Managed Extensions supporting weak injection
__gc class XDCMake {
public:
   __value enum _recognizerEnum {
      UNDEFINED,
      OPTION_USAGE,
      XDC0001_ERR_PATH_DOES_NOT_EXIST = 1,
      XDC0002_ERR_CANNOT_WRITE_TO = 2,
      XDC0003_ERR_INCLUDE_TAGS_NOT_SUPPORTED = 3,
      XDC0004_WRN_XML_LOAD_FAILURE = 4,
      XDC0006_WRN_NONEXISTENT_FILES = 6,
   };

   ListDictionary* optionList;
   ListDictionary* itagList;

   XDCMake() {
      optionList = new ListDictionary;

      // here are the problems...
      optionList->Add(S"?", __box(OPTION_USAGE)); // (1)
      optionList->Add(S"help", __box(OPTION_USAGE)); // (2)

      itagList = new ListDictionary;
      itagList->Add(S"returns",
         __box(XDC0004_WRN_XML_LOAD_FAILURE)); // (3)
   }
};
```

Каждый из трех вариантов неопределенного использует имен перечислителя (`(1)`, `(2)`, и `(3)`) должен быть определен при трансляции в новый синтаксис, чтобы исходный код для компиляции. Вот правильный перевод исходного кода:

```
ref class XDCMake {
public:
   enum class _recognizerEnum {
      UNDEFINED, OPTION_USAGE,
      XDC0001_ERR_PATH_DOES_NOT_EXIST = 1,
      XDC0002_ERR_CANNOT_WRITE_TO = 2,
      XDC0003_ERR_INCLUDE_TAGS_NOT_SUPPORTED = 3,
      XDC0004_WRN_XML_LOAD_FAILURE = 4,
      XDC0006_WRN_NONEXISTENT_FILES = 6
   };

   ListDictionary^ optionList;
   ListDictionary^ itagList;

   XDCMake() {
      optionList = gcnew ListDictionary;
      optionList->Add("?",_recognizerEnum::OPTION_USAGE); // (1)
      optionList->Add("help",_recognizerEnum::OPTION_USAGE); //(2)
      itagList = gcnew ListDictionary;
      itagList->Add( "returns",
         _recognizerEnum::XDC0004_WRN_XML_LOAD_FAILURE); //(3)
   }
};
```

При этом изменяется стратегия разработки между собственным и перечисления CLR. Перечисление CLR поддерживает связанную область действия в Visual C++ это ни необходимости, ни эффективно инкапсуляция объявления перечисления внутри класса. Эту идиому развитие во время разработки cfront 2.0 в компании Bell Laboratories также для решения проблемы засорения глобальное имя.

В исходном выпуске бета-версии новой библиотеки iostream, Джерри Schwarz в компании Bell Laboratories, Джерри был инкапсулирует все связанные перечисления, определенный для библиотеки и общие перечислители, такие как `read`, `write`, `append`, и так далее , делало практически невозможным для пользователей, для компиляции существующего кода. Решением было бы искажение имен, такие как `io_read`, `io_write`и т. д. Другим решением было бы изменить язык, добавив область для перечисления, но это не было возможно во время. Компромиссным решением было инкапсулировать перечисления внутри класса или иерархии классов, где имя тега и перечислители перечисления заполнения области видимости класса.) То есть причина помещения перечислений внутри классов, по крайней мере изначально не философской, но практические ответ проблема засорения глобального пространства имен.

С помощью перечисления Visual C++ больше не существует любой заманчивым достоинством инкапсуляция перечисления в пределах класса. На самом деле, если взглянуть на `System` пространства имен, вы увидите что перечисления, классы и интерфейсы находятся в одной области объявления.

## <a name="see-also"></a>См. также

[Типы значений и их режимы работы (C++/CLI)](../dotnet/value-types-and-their-behaviors-cpp-cli.md)<br/>
[Класс перечисления](../windows/enum-class-cpp-component-extensions.md)