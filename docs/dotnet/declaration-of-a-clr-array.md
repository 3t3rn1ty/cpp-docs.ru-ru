---
title: "Объявление массива CLR | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "array - ключевое слово [C++]"
ms.assetid: 36a8883c-2663-43f0-a90c-28f27035e036
caps.latest.revision: 9
caps.handback.revision: 9
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Объявление массива CLR
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

В [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)] синтаксис объявления, создания экземпляра и инициализации управляемого массива отличается от управляемых расширений для C\+\+.  
  
 В управляемых расширениях объект массива CLR объявляется с использованием объявления стандартного массива. В этом случае между именем объекта массива и разделенными запятыми измерениями указывается ключевое слово `__gc`, как показано в следующих примерах:  
  
```  
void PrintValues( Object* myArr __gc[]);  
void PrintValues( int myArr __gc[,,]);  
```  
  
 В новом синтаксисе используется упрощенный шаблонный порядок объявления, аналогичный объявлению `vector` в библиотеке STL.  Первый параметр определяет тип элементов массива.  Второй параметр определяет число измерений массива и указывается только для многомерных массивов \(по умолчанию используется значение 1\).  Объект массива представляет собой дескриптор отслеживания и должен сопровождаться знаком крышки.  Если элементы массива имеют ссылочный тип, также необходимо использовать знак крышки.  Например, с использованием нового синтаксиса приведенные выше массивы объявляются следующим образом:  
  
```  
void PrintValues( array<Object^>^ myArr );  
void PrintValues( array<int,3>^ myArr );  
```  
  
 Поскольку ссылочный тип представляет собой дескриптор отслеживания, а не объект, можно определить массив CLR в качестве возвращаемого значения функции. Обратите внимание, что собственный массив нельзя определить в качестве возвращаемого значения функции. В управляемых расширениях для этих целей используется интуитивно неясный синтаксис.  Примеры.  
  
```  
Int32 f() [];  
int GetArray() __gc[];  
```  
  
 В [!INCLUDE[cpp_current_long](../dotnet/includes/cpp_current_long_md.md)] используется более простое объявление.  Например:  
  
```  
array<Int32>^ f();  
array<int>^ GetArray();  
```  
  
 В обеих версиях языка поддерживается сокращенная форма инициализации локального управляемого массива.  Примеры.  
  
```  
int GetArray() __gc[] {  
   int a1 __gc[] = { 1, 2, 3, 4, 5 };  
   Object* myObjArray __gc[] = {   
      __box(26), __box(27), __box(28), __box(29), __box(30)  
   };  
   return a1;  
}  
```  
  
 В новом синтаксисе приведенный выше код значительно упрощается. Обратите внимание, что в связи с применением неявной упаковки\-преобразования в новом синтаксисе не используется оператор `__box` \(дополнительные сведения см. в разделе [Типы значений и их режимы работы \(C\+\+\/CLI\)](../dotnet/value-types-and-their-behaviors-cpp-cli.md)\):  
  
```  
array<int>^ GetArray() {  
   array<int>^ a1 = {1,2,3,4,5};  
   array<Object^>^ myObjArray = {26,27,28,29,30};  
   return a1;  
}  
```  
  
 Поскольку массив является ссылочным типом CLR, объявление каждого объекта массива представляет собой дескриптор отслеживания.  В связи с этим память для объектов массивов следует выделят в куче CLR. \(В сокращенной записи процедура выделения памяти в куче скрывается.\) Ниже приведена явная форма инициализации объекта массива в управляемых расширениях:  
  
```  
Object* myArray[] = new Object*[2];  
String* myMat[,] = new String*[4,4];  
```  
  
 В новом синтаксисе выражение `new` заменяется выражением `gcnew`.  Размеры измерений передаются в качестве параметров выражения `gcnew`, как показано ниже:  
  
```  
array<Object^>^ myArray = gcnew array<Object^>(2);  
array<String^,2>^ myMat = gcnew array<String^,2>(4,4);  
```  
  
 В новом синтаксисе список явной инициализации может следовать за выражением `gcnew` \(в управляемых расширениях подобный синтаксис не поддерживается\).  Примеры.  
  
```  
// explicit initialization list following gcnew   
// was not supported in Managed Extensions  
array<Object^>^ myArray =   
   gcnew array<Object^>(4){ 1, 1, 2, 3 };  
```  
  
## См. также  
 [Управляемые типы \(C\+\+\/CL\)](../dotnet/managed-types-cpp-cl.md)   
 [Массивы](../windows/arrays-cpp-component-extensions.md)