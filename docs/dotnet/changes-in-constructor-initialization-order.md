---
title: Изменения в последовательности инициализации конструктора | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-cli
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- constructors, C++
ms.assetid: 8892c38d-6bf7-4cf7-ac8f-15e052135a79
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- dotnet
ms.openlocfilehash: 32dad73e3d2026726e3042b0c619eeff11a5f57c
ms.sourcegitcommit: 76b7653ae443a2b8eb1186b789f8503609d6453e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
ms.locfileid: "33110358"
---
# <a name="changes-in-constructor-initialization-order"></a>Изменения в последовательности инициализации конструктора
Последовательность инициализации конструкторов класса был изменен с управляемых расширений для C++ к Visual C++.  
  
## <a name="comparison-of-constructor-initialization-order"></a>Сравнение последовательности инициализации конструктора  
 В управляемых расширениях для C++ инициализация конструкторов выполнялась в следующем порядке:  
  
1.  Вызывается конструктор базового класса, при их наличии.  
  
2.  Оценка списка инициализации класса.  
  
3.  Выполняется тело кода конструктора класса.  
  
 Этот порядок выполнения следует тем же соглашениям программирования машинного кода C++. Новый язык Visual C++ существует рекомендуемый порядок выполнения следующих классов CLR:  
  
1.  Оценка списка инициализации класса.  
  
2.  Вызывается конструктор базового класса, при их наличии.  
  
3.  Выполняется тело кода конструктора класса.  
  
 Обратите внимание, что это изменение относится только к классам среды CLR. собственных классов в Visual C++ по-прежнему соглашениям предыдущего. В обоих случаях эти правила действуют каскадно снизу вверх по всей иерархии цепи данного класса.  
  
 Рассмотрим следующий пример кода, с помощью управляемых расширений для C++:  
  
```  
__gc class A  
{  
public:  
   A() : _n(1)  
   {  
   }  
  
protected:  
   int _n;  
};  
  
__gc class B : public A  
{  
public:  
   B() : _m(_n)  
   {  
   }  
private:  
   int _m;  
};  
```  
  
 Последовательности инициализации конструктора соответствии с описанной выше, мы должны увидеть следующий порядок выполнения, когда новые экземпляры класса `B` создаются:  
  
1.  Конструктор базового класса `A` вызывается. `_n` Член инициализируется `1`.  
  
2.  Список инициализации для класса `B` вычисляется. `_m` Член инициализируется `1`.  
  
3.  Тело кода класса `B` выполняется.  
  
 Теперь рассмотрим один и тот же код в новом синтаксисе Visual C++:  
  
```  
ref class A  
{  
public:  
   A() : _n(1)  
   {  
   }  
  
protected:  
   int _n;  
};  
  
ref class B : A  
{  
public:  
   B() : _m(_n)  
   {  
   }  
private:  
   int _m;  
};  
```  
  
 Порядок выполнения, когда новые экземпляры класса `B` создаются в новом синтаксис:  
  
1.  Список инициализации для класса `B` вычисляется. `_m` Член инициализируется `0` (`0` является неинициализированным значений `_m` член класса).  
  
2.  Конструктор базового класса `A` вызывается. `_n` Член инициализируется `1`.  
  
3.  Тело кода класса `B` выполняется.  
  
 Обратите внимание, что синтаксис, похожий выдает разные результаты в этих примерах кода. Конструктор класса `B` зависит от значения из базового класса `A` для инициализации своего элемента. Тем не менее конструктор класса `A` еще не был вызван. Такая зависимость может быть особенно небезопасной, когда унаследованный класс зависит от выделения памяти или ресурса в конструкторе базового класса.  
  
## <a name="what-this-means-going-from-managed-extensions-for-c-to-visual-c-2010"></a>Что означает переход от управляемых расширений для C++ к Visual C++ 2010  
 Во многих случаях изменения в последовательности выполнения конструкторов класса должно быть прозрачной для разработчиков, поскольку отсутствует понятие поведение наследуемых классов иметь базовые классы. Тем не менее как показывают эти примеры кода, конструкторы наследуемых классов может значительно снизиться их списки инициализации зависят от значений членов базового класса. При перемещении кода с управляемых расширений для C++ в новый синтаксис, рассмотрите возможность переноса таких конструкций в тело конструктора класса, где выполнение гарантированно происходит в последнюю очередь.  
  
## <a name="see-also"></a>См. также  
 [Управляемые типы (C + +/ CL)](../dotnet/managed-types-cpp-cl.md)   
 [Конструкторы](../cpp/constructors-cpp.md)   
 