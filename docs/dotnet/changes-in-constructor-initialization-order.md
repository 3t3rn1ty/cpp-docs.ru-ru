---
title: Изменения в последовательности инициализации конструктора | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-cli
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- constructors, C++
ms.assetid: 8892c38d-6bf7-4cf7-ac8f-15e052135a79
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- dotnet
ms.openlocfilehash: fd54e9810131f3ddfabe458c70ddef081568a9cd
ms.sourcegitcommit: 799f9b976623a375203ad8b2ad5147bd6a2212f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/19/2018
ms.locfileid: "46397693"
---
# <a name="changes-in-constructor-initialization-order"></a>Изменения в последовательности инициализации конструктора

Порядок инициализации конструкторов класса отличается от управляемых расширений для C++ в Visual C++.

## <a name="comparison-of-constructor-initialization-order"></a>Сравнение последовательности инициализации конструктора

В управляемых расширениях для C++ конструктор инициализации возникла в следующем порядке:

1. Вызывается конструктор базового класса, если таковые имеются.

1. Оценка списка инициализации класса.

1. Выполняется тело кода конструктора класса.

Этот порядок выполнения следует тем же правилам, как и в программирования машинного кода C++. Новый язык Visual C++ предписывает следующий порядок выполнения для классов среды CLR:

1. Оценка списка инициализации класса.

1. Вызывается конструктор базового класса, если таковые имеются.

1. Выполняется тело кода конструктора класса.

Обратите внимание, что это изменение применяется только к классам среды CLR; собственные классы в Visual C++ по-прежнему выполнить прежние соглашения. В обоих случаях эти правила каскадом вверх по цепи всей иерархии данного класса.

Рассмотрим следующий пример кода с помощью управляемых расширений для C++:

```
__gc class A
{
public:
   A() : _n(1)
   {
   }

protected:
   int _n;
};

__gc class B : public A
{
public:
   B() : _m(_n)
   {
   }
private:
   int _m;
};
```

Последовательности инициализации конструктора соответствии с описанной выше, мы должны увидеть следующий порядок выполнения, когда новые экземпляры класса `B` создаются:

1. Конструктор базового класса `A` вызывается. `_n` Член инициализируется `1`.

1. Список инициализации для класса `B` вычисляется. `_m` Член инициализируется `1`.

1. Основной текст кода класса `B` выполняется.

Теперь рассмотрим один и тот же код в новом синтаксисе Visual C++:

```
ref class A
{
public:
   A() : _n(1)
   {
   }

protected:
   int _n;
};

ref class B : A
{
public:
   B() : _m(_n)
   {
   }
private:
   int _m;
};
```

Порядок выполнения, когда новые экземпляры класса `B` создаются в новом синтаксис:

1. Список инициализации для класса `B` вычисляется. `_m` Член инициализируется `0` (`0` является инициализированным значением `_m` член класса).

1. Конструктор базового класса `A` вызывается. `_n` Член инициализируется `1`.

1. Основной текст кода класса `B` выполняется.

Обратите внимание на то, что аналогичный синтаксис выдает разные результаты в этих примерах кода. Конструктор класса `B` зависит от значения от базового класса `A` для инициализации своего элемента. Тем не менее конструктор для класса `A` еще не был вызван. Такая зависимость может быть особенно опасно, когда унаследованный класс зависит от выделения памяти или ресурсов, в конструктор базового класса.

## <a name="what-this-means-going-from-managed-extensions-for-c-to-visual-c-2010"></a>Что означает переход от управляемых расширений для C++ к Visual C++ 2010

Во многих случаях изменения в порядок выполнения конструкторов класса должно быть прозрачным для программиста, поскольку базовые классы не имеют представления о поведение наследуемых классов. Тем не менее как показывают эти примеры кода, конструкторы классов, наследуемых может значительно снизиться их списки инициализации зависят от значений членов базового класса. При перемещении кода из управляемых расширений для C++ новый синтаксис, рассмотрите возможность переноса таких конструкций в тело конструктора класса, где выполнение гарантированно происходит в последнюю очередь.

## <a name="see-also"></a>См. также

[Управляемые типы (C + +/ CL)](../dotnet/managed-types-cpp-cl.md)<br/>
[Конструкторы](../cpp/constructors-cpp.md)
