---
title: "Изменения в последовательности инициализации конструктора | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
helpviewer_keywords: constructors, C++
ms.assetid: 8892c38d-6bf7-4cf7-ac8f-15e052135a79
caps.latest.revision: "10"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.openlocfilehash: bdcfea2339bfe7aac93192e88a6ec39ce919c596
ms.sourcegitcommit: ebec1d449f2bd98aa851667c2bfeb7e27ce657b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/24/2017
---
# <a name="changes-in-constructor-initialization-order"></a>Изменения в последовательности инициализации конструктора
Последовательность инициализации конструкторов класса был изменен с управляемых расширений для C++ к Visual C++.  
  
## <a name="comparison-of-constructor-initialization-order"></a>Сравнение последовательности инициализации конструктора  
 В управляемых расширениях для C++ инициализация конструкторов выполнялась в следующем порядке:  
  
1.  Вызывается конструктор базового класса, при их наличии.  
  
2.  Оценка списка инициализации класса.  
  
3.  Выполняется тело кода конструктора класса.  
  
 Этот порядок выполнения следует тем же соглашениям программирования машинного кода C++. Новый язык Visual C++ существует рекомендуемый порядок выполнения следующих классов CLR:  
  
1.  Оценка списка инициализации класса.  
  
2.  Вызывается конструктор базового класса, при их наличии.  
  
3.  Выполняется тело кода конструктора класса.  
  
 Обратите внимание, что это изменение относится только к классам среды CLR. собственных классов в Visual C++ по-прежнему соглашениям предыдущего. В обоих случаях эти правила действуют каскадно снизу вверх по всей иерархии цепи данного класса.  
  
 Рассмотрим следующий пример кода, с помощью управляемых расширений для C++:  
  
```  
__gc class A  
{  
public:  
   A() : _n(1)  
   {  
   }  
  
protected:  
   int _n;  
};  
  
__gc class B : public A  
{  
public:  
   B() : _m(_n)  
   {  
   }  
private:  
   int _m;  
};  
```  
  
 Последовательности инициализации конструктора соответствии с описанной выше, мы должны увидеть следующий порядок выполнения, когда новые экземпляры класса `B` создаются:  
  
1.  Конструктор базового класса `A` вызывается. `_n` Член инициализируется `1`.  
  
2.  Список инициализации для класса `B` вычисляется. `_m` Член инициализируется `1`.  
  
3.  Тело кода класса `B` выполняется.  
  
 Теперь рассмотрим один и тот же код в новом синтаксисе Visual C++:  
  
```  
ref class A  
{  
public:  
   A() : _n(1)  
   {  
   }  
  
protected:  
   int _n;  
};  
  
ref class B : A  
{  
public:  
   B() : _m(_n)  
   {  
   }  
private:  
   int _m;  
};  
```  
  
 Порядок выполнения, когда новые экземпляры класса `B` создаются в новом синтаксис:  
  
1.  Список инициализации для класса `B` вычисляется. `_m` Член инициализируется `0` (`0` является неинициализированным значений `_m` член класса).  
  
2.  Конструктор базового класса `A` вызывается. `_n` Член инициализируется `1`.  
  
3.  Тело кода класса `B` выполняется.  
  
 Обратите внимание, что синтаксис, похожий выдает разные результаты в этих примерах кода. Конструктор класса `B` зависит от значения из базового класса `A` для инициализации своего элемента. Тем не менее конструктор класса `A` еще не был вызван. Такая зависимость может быть особенно небезопасной, когда унаследованный класс зависит от выделения памяти или ресурса в конструкторе базового класса.  
  
## <a name="what-this-means-going-from-managed-extensions-for-c-to-visual-c-2010"></a>Что означает переход от управляемых расширений для C++ к Visual C++ 2010  
 Во многих случаях изменения в последовательности выполнения конструкторов класса должно быть прозрачной для разработчиков, поскольку отсутствует понятие поведение наследуемых классов иметь базовые классы. Тем не менее как показывают эти примеры кода, конструкторы наследуемых классов может значительно снизиться их списки инициализации зависят от значений членов базового класса. При перемещении кода с управляемых расширений для C++ в новый синтаксис, рассмотрите возможность переноса таких конструкций в тело конструктора класса, где выполнение гарантированно происходит в последнюю очередь.  
  
## <a name="see-also"></a>См. также  
 [Управляемые типы (C + +/ CL)](../dotnet/managed-types-cpp-cl.md)   
 [Конструкторы](../cpp/constructors-cpp.md)   
 