---
title: "Как: перенести - clr | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-windows
ms.tgt_pltfrm: 
ms.topic: get-started-article
dev_langs:
- C++
helpviewer_keywords:
- upgrading Visual C++ applications, /clr compiler option
- compiling native code [C++]
- interoperability [C++], /clr compiler option
- interop [C++], /clr compiler option
- migration [C++], /clr compiler option
- /clr compiler option [C++], porting to
ms.assetid: c9290b8b-436a-4510-8b56-eae51f4a9afc
caps.latest.revision: 
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
- dotnet
ms.openlocfilehash: cd40443bc656b0e0ec02b1ec05b604a758628321
ms.sourcegitcommit: 185e11ab93af56ffc650fe42fb5ccdf1683e3847
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/29/2018
---
# <a name="how-to-migrate-to-clr"></a>Практическое руководство. Переход на /clr
В этом разделе рассматриваются проблемы, возникающие при компиляции машинного кода с **/CLR** (см. [/CLR (компиляция CLR)](../build/reference/clr-common-language-runtime-compilation.md) для получения дополнительной информации). **/ CLR** позволяет модулям Visual C++ для вызова неуправляемого кода и вызывать из сборок .NET, сохраняя совместимость с неуправляемыми модулями. В разделе [сборки смешанный (машинный и управляемый код)](../dotnet/mixed-native-and-managed-assemblies.md) и [машинного кода и .NET-взаимодействии](../dotnet/native-and-dotnet-interoperability.md) Дополнительные сведения о преимуществах компиляции с использованием **/CLR**.  
  
## <a name="known-issues-compiling-library-projects-with-clr"></a>Известные проблемы при компиляции проектов библиотек с параметром/CLR  
 Visual Studio содержит некоторые известные проблемы при компиляции проектов библиотек с **/CLR**:  
  
-   Код может запрашивать типов во время выполнения с [CRuntimeClass::FromName](../mfc/reference/cruntimeclass-structure.md#fromname). Тем не менее если тип является библиотекой DLL MSIL (скомпилированный с **/CLR**), вызов `FromName` может завершиться ошибкой, если он выполняется перед запуском статических конструкторов в управляемой DLL (недоступен для этой проблемы случае вызов FromName производится после кода выполняется в управляемой DLL). Чтобы обойти эту проблему, можно принудительно создать управляемый статический конструктор, определив функцию в управляемой DLL, экспортировав ее и вызвав из приложения машинного кода MFC. Пример:  
  
    ```  
    // MFC extension DLL Header file:  
    __declspec( dllexport ) void EnsureManagedInitialization () {  
       // managed code that won't be optimized away  
       System::GC::KeepAlive(System::Int32::MaxValue);  
    }  
    ```  
  
## <a name="compile-with-visual-c"></a>Компиляция с помощью Visual C++  
 Перед использованием **/CLR** к любому модулю проекта предварительно скомпилировать и скомпоновать собственный проект с помощью Visual Studio 2010.  
  
 В следующих шагах, в определенном порядке, представлены простейший способ **/CLR** компиляции. Очень важно для компиляции и запуска проекта после выполнения этих шагов.  
  
### <a name="versions-prior-to-visual-c-2003"></a>Версии до Visual C++ 2003  
 При обновлении до Visual Studio 2010 из версии до Visual C++ 2003, возможны ошибки компилятора, связанные с расширенным соответствием стандарту C++ в Visual C++ 2003  
  
### <a name="upgrading-from-visual-c-2003"></a>Обновление с Visual C++ 2003  
 Проекты, построенные с помощью Visual C++ 2003 ранее должны быть сначала скомпилированы без **/CLR** как в Visual Studio теперь более соответствие стандартам ANSI/ISO и ряд важных изменений. Изменение, скорее всего, требующих внимания наиболее [средства безопасности в CRT](../c-runtime-library/security-features-in-the-crt.md). Код, использующий библиотеку CRT, очень вероятно вызывать предупреждения об устаревании. Эти предупреждения можно отключить, однако переход на [версий из функции CRT](../c-runtime-library/security-enhanced-versions-of-crt-functions.md) является предпочтительным, поскольку они обеспечивают более высокий уровень безопасности и может открыть проблемы с безопасностью в коде.  
  
### <a name="upgrading-from-managed-extensions-for-c"></a>Обновление с управляемых расширений для C++  
 Начиная с Visual Studio 2005, код, написанный с помощью управляемых расширений для C++ не будет компилироваться при использовании **/CLR**.  
  
## <a name="convert-c-code-to-c"></a>Преобразование кода на языке C в C++  
 Несмотря на то, что Visual Studio скомпилирует файлы C, его необходимо преобразовать их в C++ для **/CLR** компиляции. Фактическое имя файла не должен быть изменен; можно использовать **/Tp** (см. [/Tc /Tp /TC, /TP (определение типа исходного файла)](../build/reference/tc-tp-tc-tp-specify-source-file-type.md).) Обратите внимание, что, несмотря на то, что требуются файлы исходного кода C++ для **/CLR**, нет необходимости повторной оптимизации кода для использования объектно ориентированных парадигм.  
  
 В коде C скорее всего потребуются изменения при компиляции в файле C++. Правила безопасности типов C++ неизменны, поэтому преобразования типов должны быть путем явного приведения. Например malloc возвращает указатель void, но могут быть назначены указатель на любой тип в языке C с помощью приведения:  
  
```  
int* a = malloc(sizeof(int));   // C code  
int* b = (int*)malloc(sizeof(int));   // C++ equivalent  
```  
  
 Указатели на функции являются строго типизированный в C++, поэтому следующий код C потребует изменения. В C++ лучше создать `typedef` , определяет тип указателя на функцию, а затем использовать этот тип для приведения указателей на функции:  
  
```  
NewFunc1 = GetProcAddress( hLib, "Func1" );   // C code  
typedef int(*MYPROC)(int);   // C++ equivalent  
NewFunc2 = (MYPROC)GetProcAddress( hLib, "Func2" );  
```  
  
 C++ требует функции или ее прототип или полностью определенный до ссылки или вызван.  
  
 Идентификаторы, используемые в коде C, находились ключевые слова в C++ (такие как `virtual`, `new`, `delete`, `bool`, `true`, `false`и т.д.) должен быть переименован. Как правило, это можно сделать с помощью простых операций поиска и замены.  
  
 Наконец в то время как вызовы COM в языке C требуют явного использования v таблицу и `this` указатель, не поддерживает C++:  
  
```  
COMObj1->lpVtbl->Method(COMObj, args);  // C code  
COMObj2->Method(args);  // C++ equivalent  
```  
  
## <a name="reconfigure-project-settings"></a>Изменение параметров проекта  
 После компиляции проекта и выполняется в Visual Studio 2010 необходимо создать новые конфигурации проекта для **/CLR** вместо изменения конфигурации по умолчанию. **/ CLR** несовместим с некоторыми параметрами компилятора и создание отдельных конфигураций позволяет построить проект как машинным или управляемым. Когда **/CLR** , выбранная в поле диалогового окна страницы свойств, параметры проекта, не совместим с **/CLR** отключены (и Выключенные параметры не будут восстановлены автоматически, если **/CLR** не впоследствии выбран).  
  
### <a name="create-new-project-configurations"></a>Создать новые конфигурации проекта  
 Можно использовать **Копировать параметры из** в диалоговом окне [новое диалоговое окно конфигурации проекта](http://msdn.microsoft.com/en-us/cca616dc-05a6-4fe3-bdc1-40c72a66f2be) Создание конфигурации проекта, в зависимости от текущих параметров проекта. Для этого один раз для конфигурации отладки и один раз для конфигурации выпуска. Затем все последующие изменения может применяться к **/CLR** -определенные конфигурации, остаются без изменений исходные конфигурации проекта.  
  
 Проекты, использующие настраиваемые правила построения могут потребовать особого внимания.  
  
 Этот шаг имеет различные последствия для проектов, использующих сборочных файлов проекта. В этом случае можно настроить отдельный целевой сборки, или версию, предназначенную для **/CLR** компиляции могут быть созданы из копии исходных.  
  
### <a name="change-project-settings"></a>Изменение параметров проекта  
 **/ CLR** могут быть выбраны в среде разработки, следуя инструкциям в разделе [/CLR (компиляция CLR)](../build/reference/clr-common-language-runtime-compilation.md). Как упоминалось ранее, этот шаг будет автоматически отключена конфликтующие параметры проекта.  
  
> [!NOTE]
>  При обновлении управляемой библиотеки или проекта веб-службы из Visual C++ 2003 **/Zl** компилятора параметр будет добавлен **командной строки** страницу свойств. Это приведет к ошибке LNK2001. Удалить **/Zl** из **командной строки** страницу свойств для решения. В разделе [/Zl (пропустить имя библиотеки по умолчанию)](../build/reference/zl-omit-default-library-name.md) и [работа со свойствами проекта](../ide/working-with-project-properties.md) для получения дополнительной информации. Или добавьте файлы msvcrt.lib и msvcmrt.lib в компоновщик **Дополнительные зависимости** свойство.  
  
 Для проектов, созданных с помощью файлов makefile, несовместимые параметры компилятора должны быть отключены вручную **/CLR** добавляется. В разделе /[ограничения/CLR](../build/reference/clr-restrictions.md) сведения о параметрах компилятора, несовместимые с **/CLR**.  
  
### <a name="precompiled-headers"></a>Предкомпилированные заголовочные файлы  
 Предкомпилированные заголовки, поддерживаемых в **/CLR**. Тем не менее если только компиляции некоторых CPP-файлов **/CLR** (компиляция rest как собственные) некоторые изменения будет требоваться потому, что предкомпилированные заголовки, созданные с помощью **/CLR** не совместимы с файлами создан без **/CLR**. Эта несовместимость из-за того, что **/CLR** приводит к возникновению ошибки и требует наличия метаданных. Модули, скомпилированные **/CLR** таким образом, не может использовать предкомпилированные заголовки, которые не содержат метаданные, а не **/CLR** модули нельзя использовать файлы предкомпилированных заголовков, содержащие метаданные.  
  
 Самым простым способом компиляции проекта, где некоторые модули компилируются **/CLR** является полностью отключить предкомпилированных заголовков. (В диалоговом окне страницы свойств проекта, откройте узел C/C++ и выберите предварительно скомпилированные заголовки. Затем измените свойство создать/использовать предварительно скомпилированные заголовки на «Не использовать предварительно скомпилированные заголовки».)  
  
 Однако особенно для больших проектов предкомпилированных заголовков обеспечивает гораздо более высокую скорость компиляции, поэтому отключение этой функции является нежелательным. В этом случае лучше всего настроить **/CLR** и не **/CLR** файлы для использования разных предкомпилированных заголовков. Это можно сделать за один прием, выбрать несколько модулей для компиляции **/CLR** с помощью обозревателя решений, правой кнопкой мыши на группе и Выбор свойств. Затем измените Create или используемый PCH-файл и файл предварительно скомпилированного заголовка свойства, которые будут использоваться разные имена заголовочных файлов и PCH-файл, соответственно.  
  
## <a name="fixing-errors"></a>Устранение ошибок  
 Компиляция с **/CLR** может привести к ошибкам компилятора, компоновщика или среды выполнения. В этом разделе рассматриваются наиболее распространенные проблемы.  
  
### <a name="metadata-merge"></a>Объединения метаданных  
 Различия в версиях типов данных может привести к компоновщика ошибкой, поскольку не соответствует метаданные, созданные для двух типов. (Обычно это вызывается условно определяются члены типа, если эти условия не одинаковы для всех CPP-файлов, которые используют тип.) В этом случае компоновщик завершается ошибкой, отчетов только имени символа и имени второго OBJ-файла, где определен тип. Часто бывает полезным изменить порядок, что OBJ-файлы передаются в компоновщик обнаружить расположение других версий типа данных.  
  
### <a name="loader-lock-deadlock"></a>Взаимоблокировка при блокировке загрузчика  
 В Visual Studio 2010 и более поздних версиях «взаимоблокировка при блокировке загрузчика» все равно может произойти в более ранних версиях, но является детерминированным и на нем обнаруживаются и во время выполнения. В разделе [Инициализация смешанных сборок](../dotnet/initialization-of-mixed-assemblies.md) подробные фона, рекомендации и решения.  
  
### <a name="data-exports"></a>Экспорт данных  
 Экспорт данных библиотек DLL, ошибкам и не рекомендуется. Это происходит потому раздел данных библиотеки DLL не обязательно инициализироваться, пока будет исполнена управляемого часть библиотеки DLL. Эталонные метаданные с [# директива using](../preprocessor/hash-using-directive-cpp.md).  
  
### <a name="type-visibility"></a>Видимость типов  
 Собственные типы являются закрытыми по умолчанию. Это может привести собственный тип, не являются видимыми вне библиотеки DLL. Устранить эту ошибку, добавив `public` для этих типов.  
  
### <a name="floating-point-and-alignment-issues"></a>С плавающей запятой и проблем с выравниванием  
 `__controlfp`не поддерживается в среде CLR (в разделе [_control87, _controlfp, \__control87_2](../c-runtime-library/reference/control87-controlfp-control87-2.md) для получения дополнительной информации). Среда CLR также не будут использовать [выравнивание](../cpp/align-cpp.md).  
  
### <a name="com-initialization"></a>Инициализация COM  
 Общеязыковая среда выполнения автоматически инициализирует COM при инициализации модуля (Если автоматическая инициализация COM производится в режиме многопотокового Подразделения). В результате явной инициализации COM будут коды возврата, указывающее, что COM уже инициализирована. Явно инициализировать COM с одной потоковой модели, когда среда CLR уже инициализирован COM иной потоковой модели может привести к сбою приложения.  
  
 Общеязыковая среда выполнения начинает COM в режиме многопотокового Подразделения по умолчанию. Используйте [/CLRTHREADATTRIBUTE (установить атрибут потока среды CLR)](../build/reference/clrthreadattribute-set-clr-thread-attribute.md) это изменение.  
  
### <a name="performance-issues"></a>Проблемы производительности  
 Может наблюдаться снижение производительности при вызове собственных методов C++, созданных в MSIL косвенно (вызовы виртуальных функций или использование указателей на функции). Дополнительные сведения об этом см. в разделе [двойного](../dotnet/double-thunking-cpp.md).  
  
 При перемещении из исходного в MSIL-код, можно заметить увеличение размера рабочего множества. Это так, как общеязыковая среда выполнения предоставляет множество функций для обеспечения правильной работы программы. Если ваш **/CLR** приложение работает неправильно, может потребоваться включить C4793 (отключено по умолчанию), в разделе [Предупреждение компилятора (уровень 1 и 3) C4793](../error-messages/compiler-warnings/compiler-warning-level-1-and-3-c4793.md) для получения дополнительной информации.  
  
### <a name="program-crashes-on-shutdown"></a>Сбой программы при завершении работы  
 В некоторых случаях среда CLR может завершить до завершения управляемого кода под управлением. С помощью `std::set_terminate` и `SIGTERM` могут быть вызваны. В разделе [константы signal](../c-runtime-library/signal-constants.md) и [set_terminate](../c-runtime-library/abnormal-termination.md) для получения дополнительной информации.  
  
## <a name="using-new-visual-c-features"></a>Использование новых возможностей Visual C++  
 После компиляции приложения, ссылок и запускается, вы можете использовать компоненты .NET в любом модуле, скомпилированном с **/CLR**. Дополнительные сведения см. в статье [Расширения компонентов для платформ среды выполнения](../windows/component-extensions-for-runtime-platforms.md).  
  
 При использовании управляемых расширений для C++, можно преобразовать код для использования нового синтаксиса. Дополнительные сведения о преобразовании управляемых расширений для C++ см. в разделе [C + +/ CLI Основы миграции](../dotnet/cpp-cli-migration-primer.md).  
  
 Сведения о программировании на языке Visual C++ .NET см.:  
  
-   [Программирование .NET с использованием C++/CLI (Visual C++)](../dotnet/dotnet-programming-with-cpp-cli-visual-cpp.md)  
  
-   [Взаимодействие исходного кода и платформы.NET](../dotnet/native-and-dotnet-interoperability.md)  
  
-   [Расширения компонентов для платформ среды выполнения](../windows/component-extensions-for-runtime-platforms.md)  
  
## <a name="see-also"></a>См. также  
 [Смешанные (собственные и управляемые) сборки](../dotnet/mixed-native-and-managed-assemblies.md)