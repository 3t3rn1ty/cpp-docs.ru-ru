---
title: "Как: перенести - clr: pure (C + +/ CLI) | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
helpviewer_keywords:
- /clr compiler option [C++], migrating to /clr:pure
- migration [C++], pure MSIL
- pure MSIL [C++], porting to
ms.assetid: 5ffb1184-2095-4ade-84aa-4fa6324bc764
caps.latest.revision: "15"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.openlocfilehash: ebff4ae1ac304ee0af073de49f4ee988922247d9
ms.sourcegitcommit: ebec1d449f2bd98aa851667c2bfeb7e27ce657b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/24/2017
---
# <a name="how-to-migrate-to-clrpure-ccli"></a>Практическое руководство. Миграция в /clr:pure (C++/CLI)
В этом разделе обсуждаются проблемы, которые могут возникнуть при миграции в чистый MSIL с помощью **/CLR: pure** (см. [/CLR (компиляция CLR)](../build/reference/clr-common-language-runtime-compilation.md) для получения дополнительной информации). В этом разделе предполагается, что подвергаемый миграции код был скомпилирован как смешанная сборка с помощью **/CLR** параметра, как пути миграции из неуправляемого кода в чистый MSIL не существует прямой. Неуправляемый код в разделе [как: переход на/CLR](../dotnet/how-to-migrate-to-clr.md) перед попыткой миграции в чистый MSIL.  
  
## <a name="basic-changes"></a>Основные изменения  
 Чистый MSIL состоит из инструкций MSIL, поэтому код с функциями, которые не могут быть выражены в MSIL будет препятствовать компиляции. Это касается и функций, использующих соглашения о вызовах, отличные от [__clrcall](../cpp/clrcall.md). (Отличные от __clrcall функции может быть вызван в компоненте чистого MSIL, но не определен.)  
  
 Чтобы избежать ошибок, следует включить предупреждение C4412. Включить C4412, добавив `#pragma warning (default : 4412)` в каждую единицу компиляции, которая компилируется с **/CLR: pure** и передает типы C++ в IJW (**/CLR)** или машинного кода. В разделе [Предупреждение компилятора (уровень 2) C4412](../error-messages/compiler-warnings/compiler-warning-level-2-c4412.md) для получения дополнительной информации.  
  
## <a name="architectural-considerations"></a>Архитектурные решения  
 Некоторые ограничения сборки чистого MSIL, перечисленные в [чистый и проверяемый код (C + +/ CLI)](../dotnet/pure-and-verifiable-code-cpp-cli.md) высокого уровня влияют на стратегий разработки приложения и миграции. Прежде всего в отличие от смешанных сборок, сборки чистого MSIL не может быть полной совместимости с неуправляемыми модулями.  
  
 Сборки чистого MSIL могут вызывать неуправляемые функции, но может вызываться из неуправляемой функции. В результате чистый MSIL является лучшим решением для клиентского кода, который использует неуправляемые функции, чем для кода сервера, который используется неуправляемой функцией. Если функции содержится в сборке чистого MSIL для использования неуправляемые функции, смешанной сборки должны использоваться как уровень интерфейса.  
  
 Приложения, использующие ATL и MFC, не подходят для миграции в чистый код MSIL, как эти библиотеки не поддерживаются в этой версии. Аналогичным образом [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)] содержит файл заголовка, который не компилируется с **/CLR: pure**.  
  
 Во время сборки чистого MSIL могут вызывать неуправляемые функции, эта возможность ограничена простых функций В стиле. Использование более сложных неуправляемых API, вероятно требуются неуправляемой функции должен быть предоставлен в виде COM-интерфейса или смешанной сборки, которая может действовать как интерфейс между чистого MSIL и неуправляемые компоненты. С помощью слоя смешанной сборки является единственным способом использование неуправляемых функций, принимающих функции обратного вызова, например, как чистые сборки не может предоставить собственный вызываемые функции для использования в качестве обратного вызова.  
  
## <a name="application-domains-and-calling-conventions"></a>Домены приложений и соглашения о вызовах  
 Несмотря на то, что возможно чистого MSIL сборки используйте неуправляемую функцию, функции и статистические данные обрабатываются по-разному. В чистых сборках функции реализуются с [__clrcall](../cpp/clrcall.md) соглашение о вызовах и статические данные — хранимых на уровне домена приложения. Это отличается от установленного по умолчанию в неуправляемых и смешанных сборках, которые используют [__cdecl](../cpp/cdecl.md) соглашение о вызовах для функций и хранения статических данных отдельно для каждого процесса.  
  
 В рамках контекста чистого MSIL (и проверяемого кода, скомпилированного с/CLR: safe) значения по умолчанию являются прозрачными, как [__clrcall](../cpp/clrcall.md) является соглашение о вызовах по умолчанию среды CLR, а домены приложений — собственной областью для статических и глобальные данные в приложениях .NET. Тем не менее при взаимодействии с неуправляемыми или смешанными компонентами разная обработка функций и глобальных данных может вызвать проблемы.  
  
 Например если компонент чистого MSIL, вызывать функции в библиотеке DLL неуправляемого или смешанных файл заголовка для библиотеки DLL будет использоваться для компиляции чистой сборки. Тем не менее, пока соглашение о вызовах для каждой функции в заголовке не будет явно обозначено, всем функциям будет присваиваться [__clrcall](../cpp/clrcall.md). Впоследствии это приведет к ошибкам во время выполнения, поскольку функции, скорее всего реализуется с помощью [__cdecl](../cpp/cdecl.md) соглашение. Функции в неуправляемом файле заголовка может быть явным образом помечен как [__cdecl](../cpp/cdecl.md), или же весь исходный код DLL должен быть перекомпилирован с **/CLR: pure**.  
  
 Аналогичным образом, указатели на функции предполагается, что пункты [__clrcall](../cpp/clrcall.md) функции в разделе **/CLR: pure** компиляции. Они слишком должен быть явно помечен правильное соглашение о вызовах.  
  
 Дополнительные сведения см. в разделе [домены приложений и Visual C++](../dotnet/application-domains-and-visual-cpp.md).  
  
## <a name="linking-limitations"></a>Ограничения компоновки  
 Компоновщик Visual C++ не будет пытаться связать смешанного и чистого OBJ-файлы, поскольку хранилище области и соглашения о вызове не совпадают.  
  
## <a name="see-also"></a>См. также  
 [Чистый и проверяемый код (C++/CLI)](../dotnet/pure-and-verifiable-code-cpp-cli.md)