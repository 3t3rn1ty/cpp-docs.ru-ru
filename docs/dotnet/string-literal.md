---
title: Строковый литерал | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-cli
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- string literals
- strings [C++], string literals
ms.assetid: 6d1fc3f8-0d58-4d68-9678-16b4f6dc4766
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- dotnet
ms.openlocfilehash: 9ac847f67421802fe4d31f2d66b34128e4b24794
ms.sourcegitcommit: 76b7653ae443a2b8eb1186b789f8503609d6453e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
---
# <a name="string-literal"></a>Строковый литерал
Обработка строковых литералов отличается от управляемых расширений для C++ к Visual C++.  
  
 В управляемых расширениях для конструкции языка C++ управляемый строковый литерал указывался с предшествующим строковый литерал с `S`. Например:  
  
```  
String *ps1 = "hello";  
String *ps2 = S"goodbye";  
```  
  
 Производительность нагрузку между двумя инициализаций оказывается не так просто, как следующие CIL показано представление в **ildasm**:  
  
```  
// String *ps1 = "hello";  
ldsflda    valuetype $ArrayType$0xd61117dd  
     modopt([Microsoft.VisualC]Microsoft.VisualC.IsConstModifier)   
     '?A0xbdde7aca.unnamed-global-0'  
  
newobj instance void [mscorlib]System.String::.ctor(int8*)  
stloc.0  
  
// String *ps2 = S"goodbye";  
ldstr      "goodbye"  
stloc.0  
```  
  
 Это исключительная экономии для только что запоминание (или обучения) к строковым литералом с `S`. В новом синтаксисе обработка строковых литералов является прозрачной, определяется контекстом. `S` Больше не должен быть указан.  
  
 Как насчет случаев, в которых необходимо явно направлять компилятор к одной или другой интерпретации? В таких случаях мы используется явное приведение. Например:  
  
```  
f( safe_cast<String^>("ABC") );  
```  
  
 Кроме того, соответствие между строковым литералом `String` с простой преобразования, а не стандартного преобразования. При этом не указывается насколько изменилось разрешение наборов перегруженных функций, включающих `String` и `const char*` как конкурирующих формальных параметров. Разрешение, назначенное один раз для `const char*` экземпляра теперь отмечено как неоднозначное. Например:  
  
```  
ref struct R {  
   void f(const char*);  
   void f(String^);  
};  
  
int main () {  
   R r;  
   // old syntax: f( const char* );  
   // new syntax: error: ambiguous  
   r.f("ABC");   
}  
```  
  
 Почему есть ли разница? Поскольку существует более одного экземпляра с именем `f` существует внутри программы, для этого функция перегружает алгоритм разрешения для применения к вызову. Формальное разрешение функции перегрузки состоит из трех этапов.  
  
1.  Коллекция потенциальных функций. Функции-кандидаты — в области методов, которые лексически соответствуют имени вызванной функции. Например, поскольку `f()` вызывается через экземпляр `R`, что все функции с именем `f` , не является членом `R` (или его иерархии базового класса) не являются потенциальными функциями. В данном примере существуют две функции-кандидаты. Это две функции-члены из `R` с именем `f`. Если возникнет ошибка во время этого этапа набор потенциальных функций пуст.  
  
2.  Набор переменных функций из числа потенциальных функций. Переменных функций — один, который может быть вызван с аргументами, которые указаны в вызове, учитывая количество аргументов и их типы. В нашем примере обе потенциальные функции также являются переменными функциями. Если возникнет ошибка во время этого этапа набор переменных функций пуст.  
  
3.  Выберите функции, наиболее точно соответствует вызова. Это делается путем ранжирования преобразований, используемых для трансформации аргументов в тип параметров переменной функции. Это довольно прост с помощью одного параметра функции; При наличии нескольких параметров становится более сложным. Вызов не выполняется на этом этапе, если не оптимальным. То есть если преобразования, необходимые для преобразования типа фактического аргумента в тип формального параметра, одинаково хорошо подходят. Вызов отмечается как неоднозначный.  
  
 В управляемых расширениях разрешение данного вызова обращается `const char*` экземпляр в качестве наилучшего совпадения. В новом синтаксисе преобразования, чтобы они соответствовали `"abc"` для `const char*` и `String^` эквивалентны теперь — то есть, хорошо -, поэтому вызов отмечен как несоответствующий - то есть, как неоднозначная.  
  
 Возникают два вопроса:  
  
-   Каков тип фактического аргумента `"abc"`?  
  
-   Что такое алгоритм определения, когда тип преобразования лучше, чем другой?  
  
 Тип строкового литерала `"abc"` — `const char[4]` -помните, что неявное значение null, завершающий символ в конце каждой строки литерала.  
  
 Алгоритм определения, когда тип преобразования лучше, чем другой, размещает потенциальные типы преобразований в иерархии. Далее приводится пояснение иерархии - этих преобразований, конечно, являются неявными. С помощью нотации явного приведения переопределяет иерархию, аналогично тому, как скобки переопределяют обычный порядок применения выражения.  
  
1.  Лучше всего точное соответствие. Удивительно, но аргумент точно совпадать, он не должен точно соответствует типу параметра; он просто должен быть достаточно близко. Это ключ понять, что происходит в этом примере и изменении языка.  
  
2.  Повышение лучше, чем стандартное преобразование. Например, повышение `short int` для `int` лучше, чем преобразование `int` в `double`.  
  
3.  Стандартное преобразование лучше, чем упаковка-преобразование. Например, преобразование `int` в `double` считается лучшим решением, упаковки-преобразования `int` в `Object`.  
  
4.  Упаковка-преобразование лучше, чем неявное преобразование определяемых пользователем. Например, упаковки-преобразования `int` в `Object` лучше, чем применение оператора преобразования `SmallInt` класса значений.  
  
5.  Неявное преобразование определяемых пользователем лучше, чем преобразования не вообще. Неявное определенное пользователем преобразование является последним способом избежания ошибки (с механизмом, что формальная подпись может содержать массив param и многоточие в этой позиции).  
  
 Таким образом что означает сказать, что точное соответствие не обязательно представляет точное соответствие? Например `const char[4]` точно соответствует либо `const char*` или `String^`, и еще неопределенность в примере между двумя конфликтующие точные совпадения!  
  
 Точное соответствие, оказывается, включает ряд стандартных преобразований. Существует четыре стандартных преобразования в ISO C++, могут применяться и все еще остаются точное соответствие. Три из них относятся к преобразованию. Четвертый тип называется преобразование квалификации. Три типа преобразования считаются лучшее точное соответствие, чем требуется преобразование квалификации.  
  
 Одна из форм lvalue преобразования является преобразование собственного массива в указатель. Это связано с компонентами соответствия `const char[4]` для `const char*`. Таким образом, соответствие `f("abc")` для `f(const char*)` является точным соответствием. В более ранних версиях языка это был оптимальным, на самом деле.  
  
 Флаг неопределенности, компилятор требует, преобразование `const char[4]` для `String^` также быть точным соответствием тривиальные преобразования. Это изменение, которая была введена в новой версии языка. И именно поэтому вызов теперь помечены как неоднозначная.  
  
## <a name="see-also"></a>См. также  
 [Общие изменения в языке (C + +/ CLI)](../dotnet/general-language-changes-cpp-cli.md)   
 [String](../windows/string-cpp-component-extensions.md)