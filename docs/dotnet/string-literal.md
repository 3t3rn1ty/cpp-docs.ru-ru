---
title: Строковый литерал | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-cli
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- string literals
- strings [C++], string literals
ms.assetid: 6d1fc3f8-0d58-4d68-9678-16b4f6dc4766
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- dotnet
ms.openlocfilehash: 41f1996cd4f4caf24ac08d09b05e636cb09f7eed
ms.sourcegitcommit: 799f9b976623a375203ad8b2ad5147bd6a2212f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/19/2018
ms.locfileid: "46415269"
---
# <a name="string-literal"></a>Строковый литерал

Обработка строковых литералов отличается от управляемых расширений для C++ в Visual C++.

В управляемых расширениях для конструкции языка C++, управляемый строковый литерал указывался с предшествующим строковый литерал с `S`. Пример:

```
String *ps1 = "hello";
String *ps2 = S"goodbye";
```

Производительность нагрузку между двумя инициализации оказывается не так просто, как CIL ниже показано представление в **ildasm**:

```
// String *ps1 = "hello";
ldsflda    valuetype $ArrayType$0xd61117dd
     modopt([Microsoft.VisualC]Microsoft.VisualC.IsConstModifier)
     '?A0xbdde7aca.unnamed-global-0'

newobj instance void [mscorlib]System.String::.ctor(int8*)
stloc.0

// String *ps2 = S"goodbye";
ldstr      "goodbye"
stloc.0
```

Это уникальной экономия для просто запоминание (или обучения) в качестве префикса строковый литерал с `S`. В новом синтаксисе обработка строковых литералов является прозрачной, определяется контекстом. `S` Больше не должны быть определены.

Как насчет случаев, в которых необходимо явно давать компилятору Указание одной или другой интерпретации? В этом случае мы применяем явное приведение. Пример:

```
f( safe_cast<String^>("ABC") );
```

Кроме того, теперь соответствует строковый литерал `String` простое преобразование, а не стандартное преобразование. При этом не указывается насколько изменилось разрешение наборов перегруженных функций, которые включают `String` и `const char*` как конкурирующих формальных параметров. Разрешение, назначенное один раз для `const char*` экземпляра теперь помечен как неоднозначная. Пример:

```
ref struct R {
   void f(const char*);
   void f(String^);
};

int main () {
   R r;
   // old syntax: f( const char* );
   // new syntax: error: ambiguous
   r.f("ABC"); 
}
```

Почему есть ли разница? Так как более одного экземпляра с именем `f` существует в рамках программы, для этого алгоритм разрешения перегрузки функции для применения к вызову. Формальное разрешение перегруженная функция состоит из трех этапов.

1. Коллекция функций-кандидатов. Функции-кандидаты являются те методы, в области, которые лексически совпадать с именем вызываемую функцию. Например, поскольку `f()` вызывается с помощью экземпляра `R`, что все функции, отобранные `f` , не является членом `R` (или его иерархии базового класса) не являются потенциальными функциями. В нашем примере есть две функции-кандидаты. Ниже приведены две функции-члены из `R` с именем `f`. Вызов завершается ошибкой во время этого этапа, если набор потенциальных функций пуст.

1. Набор переменных функций из числа потенциальных функций. Переменных функций — это приложения, может быть вызван с помощью аргументов, указанных в вызове, учитывая количество аргументов и их типы. В нашем примере обе функции-кандидаты также являются переменными функциями. Вызов завершается ошибкой во время этого этапа, если набор переменных функций пуст.

1. Выберите функцию, которая наиболее точно соответствует вызова. Это делается путем преобразования, применяемая для преобразования аргументов в тип параметров переменной функции ранжирования. Это сравнительно просто — с помощью одного параметра функции; При наличии нескольких параметров, становится несколько более сложным. Вызов завершается ошибкой во время этого этапа, если совпадения нет рекомендации. То есть если преобразования, необходимые для преобразования тип фактического аргумента в тип формального параметра, одинаково хорошо подходят. Вызов отмечен как неоднозначная.

В управляемых расширениях разрешение данного вызова обращается `const char*` экземпляр в качестве наилучшего совпадения. В новом синтаксисе, преобразование, чтобы они соответствовали `"abc"` для `const char*` и `String^` эквивалентны теперь - то есть, хорошо -, поэтому вызов отмечен как недопустимый - то есть как неоднозначная.

Это приводит нас к два вопроса:

- Что такое тип фактического аргумента, `"abc"`?

- Что такое алгоритм определения, когда тип преобразования лучше, чем другой?

Тип строкового литерала `"abc"` — `const char[4]` — помните, что неявное завершающий символ null в конце каждой строки литерала.

Алгоритм определения, когда тип преобразования лучше, чем другой заключается в размещении преобразования возможных типов в иерархии. Вот мое понимание этой иерархии - все преобразования, само собой, являются неявными. С помощью нотации явное приведение переопределяет иерархии, аналогично тому, как круглые скобки переопределяет обычный порядок применения выражения.

1. Лучше всего точное совпадение. Удивительно, что для аргумента точно совпадать, его не обязательно должен совпадать с типом параметра; оно просто должно обеспечивать достаточно близко. Это крайне важно понимание происходящего в данном примере, и как изменился язык.

1. Продвижение лучше, чем стандартное преобразование. Например, повышая уровень `short int` для `int` лучше, чем преобразование `int` в `double`.

1. Стандартное преобразование лучше, чем упаковка-преобразование. Например, преобразование `int` в `double` лучше, упаковки-преобразования `int` в `Object`.

1. Упаковка-преобразование лучше, чем неявное преобразование определяемых пользователем. Например, упаковка-преобразование `int` в `Object` лучше, чем применение оператора преобразования `SmallInt` класса значений.

1. Неявное преобразование определяемых пользователем лучше, чем преобразование не вообще. Неявное преобразование определяемых пользователем является последним способом до ошибки (с механизмом, что формальная подпись может содержать массив param и многоточие в этой позиции).

Таким образом что означает сказать, что точное соответствие не обязательно представляет точное соответствие? Например `const char[4]` полностью соответствует либо `const char*` или `String^`, а еще неопределенность в нашем примере — между двух конфликтующих точные совпадения!

Точное соответствие, оказывается, включает ряд стандартных преобразований. Существуют четыре стандартных преобразования в ISO-C++, можно применить и по-прежнему могут считаться точное совпадение. Три из них относятся к преобразованию. Четвертый тип называется преобразование квалификации. Три типа преобразования, рассматриваются как лучшее точное соответствие, чем та, требуя преобразование квалификации.

Одна форма lvalue преобразования является преобразование собственного массива в указатель. Это, что именно задействуется при сопоставлении `const char[4]` для `const char*`. Таким образом, соответствие `f("abc")` для `f(const char*)` должно точно совпадать. В более ранних версиях языка это было оптимальным, на самом деле.

Для компилятора отметить неоднозначность может возникнуть, необходимо, преобразование `const char[4]` для `String^` также полностью совпадать через тривиальное преобразование. Это изменение было представлено в новой версии языка. И именно по этой вызов теперь помечен как неоднозначная.

## <a name="see-also"></a>См. также

[Общие изменения в языке (C++/CLI)](../dotnet/general-language-changes-cpp-cli.md)<br/>
[String](../windows/string-cpp-component-extensions.md)