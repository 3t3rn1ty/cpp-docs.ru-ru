---
title: Значение семантику типа | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-cli
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- interior_ptr keyword [C++]
- virtual functions, value types
- inheritance, value types
- pinning pointers
- pin_ptr keyword [C++]
- __pin keyword
ms.assetid: 7f065589-ad25-4850-baf1-985142e35e52
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- dotnet
ms.openlocfilehash: 72dc6a613616d13e9ff92e8af0c39c63dfe63162
ms.sourcegitcommit: 799f9b976623a375203ad8b2ad5147bd6a2212f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/19/2018
ms.locfileid: "46413800"
---
# <a name="value-type-semantics"></a>Семантика типа значения

Семантика типа значения были изменены относительно управляемых расширений для C++ в Visual C++.

Ниже приведен каноническое значение простого типа, используется в управляемых расширениях для C++ спецификации.

```
__value struct V { int i; };
__gc struct R { V vr; };
```

В управляемых расширений может иметь четыре варианта написания типа значения (где формы 2 и 3 совпадают семантически):

```
V v = { 0 };       // Form (1)
V *pv = 0;         // Form (2) an implicit form of (3)
V __gc *pvgc = 0;  // Form (3)
__box V* pvbx = 0; // Form (4) must be local
```

## <a name="invoking-inherited-virtual-methods"></a>Вызов унаследованных виртуальных методов

`Form (1)` — Это объект каноническое значение, и достаточно хорошо понимают, за исключением случаев, когда кто-то пытается вызвать наследуемого виртуального метода, такие как `ToString()`. Пример:

```
v.ToString(); // error!
```

Чтобы вызвать этот метод, так как оно не переопределено в `V`, компилятор должен иметь доступ к связанной виртуальной таблице базового класса. Поскольку типы значений находятся в состоянии хранения указатель к виртуальной таблице (vptr), это требует, чтобы `v` быть упакован. В архитектуре управляемых расширений языка неявная упаковка-преобразование не поддерживается, но должен быть явно указан программистом, как показано на

```
__box( v )->ToString(); // Managed Extensions: note the arrow
```

Основной практичности разработанную воспитательный: базовый механизм должен быть виден программисту, таким образом, чтобы оценить «стоимость» не предоставления экземпляра в типе значений. Были `V` должен содержать экземпляр `ToString`, упаковка-преобразование не требовался бы.

Лексическая сложность явно упаковка-преобразование объекта, а не базовой стоимости упаковки-преобразования, будут удалены в новом синтаксисе:

```
v.ToString(); // new syntax
```

но за счет возможно в заблуждение разработчика класса стоимость не предоставив явный экземпляр `ToString` метода в `V`. Причина предпочтительного использования неявной упаковки-преобразования: как правило, только один конструктор классов, существуют неограниченное число пользователей, ни один из них не имеет возможности вносить изменения `V` во избежание затруднительной явной упаковки.

Критерии, которые определяют необходимость переопределения экземпляров из `ToString` в значение класса должна присутствовать частоту и место их использования. Если вызывается очень редко, это само собой мало пользы в своем определении. Аналогичным образом Если он вызывается в непродуктивных областях приложения, он будет добавление определения существенно не общую производительность приложения. Кроме того сохраняется дескриптор отслеживания для упакованных значений и вызовы через этот дескриптор не потребует упаковки-преобразования.

## <a name="there-is-no-longer-a-value-class-default-constructor"></a>Конструктор класса по умолчанию значение не существует

Еще одно различие с типом значения между управляемыми расширениями и новый синтаксис является удаление поддержки конструктором по умолчанию. Это обусловлено тем, бывают ситуации, во время выполнения, в котором среда CLR можно создать экземпляр типа значения без вызова конструктора по умолчанию. То есть намерение управляемых расширений для поддержки конструктора по умолчанию в пределах типа значения может фактически не гарантируется. В связи с отсутствием гарантии, мы проанализировали быть лучше полностью поддерживаться, а не его быть недетерминированным в приложении.

Это решение не так, как может показаться изначально. Это обусловлено автоматически обнуляется каждый объект типа значения (т. е каждого типа устанавливается равным значению по умолчанию). В результате членами локального экземпляра никогда не определены. В этом смысле потеря возможность определения тривиальный конструктор по умолчанию не так уж и потере вообще - и на самом деле является более эффективным, при выполнении в среде CLR.

Проблема возникает, когда пользователь управляемых расширений определяет конструктор по умолчанию не так просто. Это не имеет сопоставления нового синтаксиса. Код в конструктор будет необходимо перенести в именованный метод инициализации, затем должны явно вызываться пользователем.

Объявление объекта типа значения в новом синтаксисе остается неизменным. Отрицательной стороной этого является то, что типы значений не подходит для упаковки собственных типов по следующим причинам:

- Деструктор в типе значения не поддерживается. То есть нет способа автоматизировать набор действий, запускаемых в конце времени существования объекта.

- Собственного класса может содержаться только в пределах управляемого типа как указатель, который затем выделяется в неуправляемой куче.

Мы предлагаем программы-оболочки для небольших собственного класса в тип значения вместо ссылочного типа во избежание выделения памяти для кучи double: собственной кучи для хранения в собственный тип и в куче среды CLR для хранения управляемой оболочки. Перенос собственного класса в пределах типа значения позволяет избежать управляемой куче, но не предоставляет способ автоматизации реорганизации внутреннюю память из кучи. Ссылочные типы являются единственными практичными управляемый тип, в течение которого программы-оболочки для нетривиального собственных классов.

## <a name="interior-pointers"></a>Внутренних указателей

`Form (2)` и `Form (3)` могут обращаться практически для любого элемента в этом мире или следующего (то есть все, управляемый или машинный). Таким образом например, все следующие допускаются в управляемых расширений:

```
__value struct V { int i; };
__gc struct R { V vr; };

V v = { 0 };  // Form (1)
V *pv = 0;  // Form (2)
V __gc *pvgc = 0;  // Form (3)
__box V* pvbx = 0;  // Form (4)

R* r;

pv = &v;            // address a value type on the stack
pv = __nogc new V;  // address a value type on native heap
pv = pvgc;          // we are not sure what this addresses
pv = pvbx;          // address a boxed value type on managed heap
pv = &r->vr;        // an interior pointer to value type within a
                    //    reference type on the managed heap
```

Таким образом `V*` может способствовать расположение в пределах локального блока (и может быть висячей), в глобальной области, в собственный кучи (например, если он адресует объект уже удален) в куче среды CLR (и поэтому будут отслеживаться, если он должен перемещается во время сборки мусора) и внутри объекта ссылочного в куче среды CLR (внутренний указатель, как это называется также прозрачно отслеживаются).

В управляемых расширений не существует способа для разделения собственного аспекты `V*`; то есть он рассматривается как включенный, обрабатывающая возможность обратиться к объекту или вложенные объекты в управляемой куче.

В новом синтаксисе указатель типа значения добавляются в двух типов: `V*`, который имеет ограничение расположения кучи среды CLR и внутренний указатель, `interior_ptr<V>`, который позволяет, но не требует с адресом в управляемой куче.

```
// may not address within managed heap
V *pv = 0;

// may or may not address within managed heap
interior_ptr<V> pvgc = nullptr;
```

`Form (2)` и `Form (3)` управляемых расширений сопоставляются в `interior_ptr<V>`. `Form (4)` представляет собой дескриптор отслеживания. Он адресует ко всему объекту, упакованному в управляемой куче. Он преобразуется в новом синтаксисе в `V^`,

```
V^ pvbx = nullptr; // __box V* pvbx = 0;
```

Следующие объявления в управляемых расширениях, сопоставляются с внутренними указателями в новом синтаксисе. (Они являются типами значений в пределах `System` пространства имен.)

```
Int32 *pi;   // => interior_ptr<Int32> pi;
Boolean *pb; // => interior_ptr<Boolean> pb;
E *pe;       // => interior_ptr<E> pe; // Enumeration
```

Встроенные типы не считаются управляемыми, несмотря на то, что они выступают в качестве псевдонимов для типов в `System` пространства имен. Таким образом между управляемыми расширениями и новый синтаксис выполняются следующие сопоставления:

```
int * pi;     // => int* pi;
int __gc * pi2; // => interior_ptr<int> pi2;
```

При преобразовании `V*` в существующей программе, наиболее консервативной стратегией является всегда включить его `interior_ptr<V>`. Это, как его обработки в управляемых расширений. В новом синтаксисе, программист имеет возможность ограничить тип значения адресами неуправляемой кучи, указав `V*` вместо внутреннего указателя. При выполнении программы, можно сделать транзитивное замыкание всех их использования и убедитесь, что назначенный адрес не находится в управляемой куче, оставить как `V*` подходит.

## <a name="pinning-pointers"></a>Закрепляющие указатели

Сборщик мусора может при необходимости перемещать объекты, находящиеся в куче среды CLR в другое место в куче, обычно во время отсутствия фаза сравнения. Это перемещение не является проблемой для отслеживания дескрипторов, отслеживаемых ссылок и внутренних указателей, которое прозрачно обновляет эти сущности. Это перемещение проблема, тем не менее, если пользователь прошел адрес объекта в куче среды CLR, за пределами среды выполнения. В этом случае временное перемещение объекта может спровоцировать ошибку среды выполнения. Чтобы исключить объекты из перемещения, необходимо локально закрепить их на место в пределах области внешнего использования.

В управляемых расширениях *закрепляющий указатель* объявляется путем уточнения объявления указателя с `__pin` ключевое слово. Вот пример немного изменен из спецификации управляемых расширений:

```
__gc struct H { int j; };

int main()
{
   H * h = new H;
   int __pin * k = & h -> j;

   // ...
};
```

В новой конструкции языка закрепляющий указатель объявлен с синтаксисом, аналогично внутреннему указателю.

```
ref struct H
{
public:
   int j;
};

int main()
{
   H^ h = gcnew H;
   pin_ptr<int> k = &h->j;

   // ...
}
```

Закрепляющий указатель в новом синтаксисе является особым случаем внутреннего указателя. Исходные ограничения на закрепляющий указатель остаются. Например нельзя использовать в качестве параметра или возвращаемого типа метода; его можно объявить только на локальный объект. Количество дополнительные ограничения, тем не менее, были добавлены в новом синтаксисе.

Значение по умолчанию закрепляющий указатель — `nullptr`, а не `0`. Объект `pin_ptr<>` невозможно инициализировать или назначить `0`. Все назначения `0` в имеющемся коде должны быть изменены для `nullptr`.

Закрепляющий указатель в управляемых расширениях была разрешена для решения объекту в целом, как показано в следующем примере, взятом из спецификации управляемых расширений:

```
__gc class G {
public:
   void incr(int* pi) { pi += 1; }
};
__gc struct H { int j; };
void f( G * g ) {
   H __pin * pH = new H;
   g->incr(& pH -> j);
};
```

В новом синтаксисе закрепления всего объекта возвращаться `new` выражение не поддерживается. Вместо этого адрес внутреннего члена должен быть закреплен. Например, примененная к объекту директива

```
ref class G {
public:
   void incr(int* pi) { *pi += 1; }
};
ref struct H { int j; };
void f( G^ g ) {
   H ^ph = gcnew H;
   Console::WriteLine(ph->j);
   pin_ptr<int> pj = &ph->j;
   g->incr(  pj );
   Console::WriteLine(ph->j);
}
```

## <a name="see-also"></a>См. также

[Типы значений и их режимы работы (C++/CLI)](../dotnet/value-types-and-their-behaviors-cpp-cli.md)<br/>
[Классы и структуры](../windows/classes-and-structs-cpp-component-extensions.md)<br/>
[interior_ptr (C++/CLI)](../windows/interior-ptr-cpp-cli.md)<br/>
[pin_ptr (C++/CLI)](../windows/pin-ptr-cpp-cli.md)