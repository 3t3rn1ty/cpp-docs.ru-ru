---
title: Значение семантики | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-cli
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- interior_ptr keyword [C++]
- virtual functions, value types
- inheritance, value types
- pinning pointers
- pin_ptr keyword [C++]
- __pin keyword
ms.assetid: 7f065589-ad25-4850-baf1-985142e35e52
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- dotnet
ms.openlocfilehash: 44662f2ad8e79712b4aab17e2784a72e01ec4116
ms.sourcegitcommit: 76b7653ae443a2b8eb1186b789f8503609d6453e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
ms.locfileid: "33171858"
---
# <a name="value-type-semantics"></a>Семантика типа значения
Семантика типа значения были изменены с управляемых расширений для C++ к Visual C++.  
  
 Вот каноническое значение простого типа, используется в управляемых расширениях для C++ спецификации:  
  
```  
__value struct V { int i; };  
__gc struct R { V vr; };  
```  
  
 В управляемых расширениях может иметь четыре варианта написания типа значения (где формы 2 и 3 будут такими же семантически):  
  
```  
V v = { 0 };       // Form (1)  
V *pv = 0;         // Form (2) an implicit form of (3)  
V __gc *pvgc = 0;  // Form (3)  
__box V* pvbx = 0; // Form (4) must be local   
```  
  
## <a name="invoking-inherited-virtual-methods"></a>Вызов унаследованных виртуальных методов  
 `Form (1)` каноническое значение объект и его достаточно хорошо изучены, за исключением случаев, когда кто-то пытается вызвать наследуемый виртуальный метод, такие как `ToString()`. Пример:  
  
```  
v.ToString(); // error!  
```  
  
 Для вызова этого метода, так как оно не переопределено в `V`, компилятор должен иметь доступ к связанной виртуальной таблице базового класса. Поскольку типы значений находятся в состоянии хранения указатель к виртуальной таблице (vptr), это требует, чтобы `v` должен быть упакован. В управляемых расширениях конструкции языка неявная упаковка-преобразование не поддерживается, но должен быть явно указан с программист, как и в  
  
```  
__box( v )->ToString(); // Managed Extensions: note the arrow  
```  
  
 Основной Цель такой подход учебных: базовый механизм должен быть виден программисту, чтобы оценить «затраты» не предоставления экземпляра в типе значений. Были `V` содержать экземпляр `ToString`, упаковка не является обязательной.  
  
 Лексическая сложность явной упаковки-преобразования объекта, а не базовые затраты упаковкой-преобразованием, будут удалены в новом синтаксисе:  
  
```  
v.ToString(); // new syntax  
```  
  
 но за счет вероятность ввода в заблуждение разработчика класса стоимости, не предоставив явный экземпляр `ToString` метода в `V`. Причина предпочтительного использования неявной упаковки-преобразования: как правило, лишь один конструктор классов, существуют неограниченное количество пользователей, ни один из них не имеет возможности вносить изменения `V` Чтобы избежать затруднительной явной упаковки.  
  
 Критериями, которые определяют необходимость переопределения экземпляров `ToString` внутри значения должен быть класс, частоту и место их использования. Он вызывается очень редко, существует ли конечно мало пользы в его определении. Аналогичным образом при вызове в областях, отличных от высокопроизводительных приложения, он будет добавление определения существенно не общую производительность приложения. Кроме того сохраняется дескриптор отслеживания для упакованных значений и вызовы с помощью дескриптора, не запрашивает упаковки-преобразования.  
  
## <a name="there-is-no-longer-a-value-class-default-constructor"></a>Больше не существует конструктор по умолчанию класс значений  
 Еще одно различие с типом значения между управляемыми расширениями и новый синтаксис является удаление поддержки конструктором по умолчанию. Это вызвано бывают ситуации, во время выполнения, в которой среда CLR можно создать экземпляр типа значения без вызова конструктора по умолчанию. То есть намерение управляемых расширений для поддержки конструктора по умолчанию в пределах типа значения может фактически не гарантируется. В связи с отсутствием гарантии, было принято решение лучше было бы полностью поддерживаться вместо быть недетерминированным в приложении.  
  
 Это решение не как изначально может показаться. Это, поскольку каждый объект типа значения обнуляется автоматически (то есть каждый тип инициализируется значением по умолчанию). В результате члены локального экземпляра всегда были определены. В этом смысле потери возможность определения тривиальный конструктор по умолчанию не действительно потеря вообще - и фактически является более эффективной при выполнении средой CLR.  
  
 Проблема возникает, когда пользователь управляемых расширений определяет конструктор по умолчанию не так просто. Это не имеет сопоставления нового синтаксиса. Код в конструкторе будет необходимо перенести в именованный метод инициализации, затем должны быть явно вызывается пользователем.  
  
 Объявление объекта типа значения в новом синтаксисе остается неизменным. С другой стороны, это является то, что типы значений не подходит для упаковки собственных типов по следующим причинам:  
  
-   Деструктор в типе значения не поддерживается. То есть нет способа автоматизировать набор действий, запускаемые в конце времени существования объекта.  
  
-   Экземпляр собственного класса может содержаться только в пределах управляемого типа как указатель, который затем распределяется в собственной куче.  
  
 Мы бы хотели wrap небольшой класс собственный тип значения, а не ссылочный тип double кучу во избежание: собственной кучи для хранения в собственный тип и кучи CLR для хранения управляемую оболочку. Перенос собственного класса в пределах типа значения позволяет избежать в управляемой куче, но не предоставляет способ автоматизации реорганизации памяти машинной кучи. Ссылочные типы — это только неосуществимым управляемого типа, в течение которого программы-оболочки для нетривиального собственных классов.  
  
## <a name="interior-pointers"></a>Внутренние указатели  
 `Form (2)` и `Form (3)` могут обращаться практически ничего в мире и за его пределами (то есть все, управляемые или собственные). Таким образом например, все следующие допускаются в управляемых расширениях:  
  
```  
__value struct V { int i; };  
__gc struct R { V vr; };  
  
V v = { 0 };  // Form (1)  
V *pv = 0;  // Form (2)  
V __gc *pvgc = 0;  // Form (3)  
__box V* pvbx = 0;  // Form (4)  
  
R* r;  
  
pv = &v;            // address a value type on the stack  
pv = __nogc new V;  // address a value type on native heap  
pv = pvgc;          // we are not sure what this addresses  
pv = pvbx;          // address a boxed value type on managed heap  
pv = &r->vr;        // an interior pointer to value type within a  
                    //    reference type on the managed heap  
```  
  
 Таким образом `V*` можно устранить на место в пределах локального блока (и может быть висячей), в глобальной области, в собственный в куче среды CLR в куче (например, если он относится объект уже был удален) (и следовательно будут отслеживаться, если он должен перенести во время сборки мусора) и в пределах внутреннюю часть ссылочного объекта в куче среды CLR (внутренний указатель, как это называется также прозрачно отслеживаются).  
  
 В управляемых расширениях нет возможности разделять машинные аспекты `V*`; то есть, он рассматривается как включенный, обрабатывающая вероятность его обратиться к объекту или вложенные объекты в управляемой куче.  
  
 В новом синтаксисе указатель типа значения представлен в двух типах: `V*`, который имеет ограничение расположения кучи среды CLR и внутренний указатель, `interior_ptr<V>`, который позволяет, но не требует указания адреса в пределах управляемой кучи.  
  
```  
// may not address within managed heap   
V *pv = 0;   
  
// may or may not address within managed heap  
interior_ptr<V> pvgc = nullptr;   
```  
  
 `Form (2)` и `Form (3)` управляемых расширений сопоставляются в `interior_ptr<V>`. `Form (4)` представляет собой дескриптор отслеживания. Она решает весь объект, который был упакован в управляемой куче. Он преобразуется в новом синтаксисе в `V^`,  
  
```  
V^ pvbx = nullptr; // __box V* pvbx = 0;    
```  
  
 Следующие объявления в управляемых расширениях полностью соответствуют внутренним указателям в новом синтаксисе. (Они представляют типы значений в `System` пространства имен.)  
  
```  
Int32 *pi;   // => interior_ptr<Int32> pi;  
Boolean *pb; // => interior_ptr<Boolean> pb;  
E *pe;       // => interior_ptr<E> pe; // Enumeration  
```  
  
 Встроенные типы не считаются управляемыми, несмотря на то, что они выполняют роль псевдонимов для типов в `System` пространства имен. Таким образом между управляемыми расширениями и нового синтаксиса справедливых следующие сопоставления:  
  
```  
int * pi;     // => int* pi;  
int __gc * pi2; // => interior_ptr<int> pi2;  
```  
  
 При преобразовании `V*` в существующей программе, наиболее консервативной стратегией является всегда включить его `interior_ptr<V>`. Это процесс его обработки в управляемых расширениях. В новом синтаксисе, программист имеет возможность ограничить тип значения адресами неуправляемой кучи, указав `V*` вместо внутреннего указателя. При выполнении программы, можно сделать транзитивное замыкание их использования и быть в том, что в управляемой куче нет присвоенных адресов, оставить формат `V*` нормально.  
  
## <a name="pinning-pointers"></a>Закрепление указателей  
 Сборщик мусора может при необходимости перемещать объекты, находящиеся в куче среды CLR в разные расположения в куче, обычно во время фаза сравнения. Такое перемещение не представляет проблему для отслеживания дескрипторов, отслеживаемых ссылок и внутренних указателей, которое прозрачно обновляет эти сущности. Такое перемещение проблема, тем не менее, если пользователь прошел адрес объекта в куче среды CLR за пределами среды выполнения. В этом случае временное перемещение объекта может спровоцировать ошибку среды выполнения. Чтобы исключить объекты из перемещения, необходимо локально закрепить их на место в пределах области внешнего использования.  
  
 В управляемых расширениях *закрепляющий указатель* объявляется путем уточнения объявления указателя с `__pin` ключевое слово. Ниже приведен пример немного изменены из спецификации управляемых расширений:  
  
```  
__gc struct H { int j; };  
  
int main()   
{  
   H * h = new H;  
   int __pin * k = & h -> j;  
  
   // ...  
};  
```  
  
 В новой конструкции языка закрепляющий указатель объявлен с синтаксисом, аналогичным внутреннего указателя.  
  
```  
ref struct H  
{  
public:  
   int j;  
};  
  
int main()  
{  
   H^ h = gcnew H;  
   pin_ptr<int> k = &h->j;  
  
   // ...  
}  
```  
  
 Закрепляющий указатель в новом синтаксисе является особым случаем внутреннего указателя. Исходные ограничения на закрепляющий указатель остаются. Например нельзя использовать в качестве параметра или возвращаемого типа метода. он может быть объявлен только на локальный объект. Число дополнительных ограничений, однако были добавлены в новом синтаксисе.  
  
 Значение по умолчанию закрепляющего указателя — `nullptr`, а не `0`. Объект `pin_ptr<>` не может инициализироваться или получать `0`. Все назначения значения `0` в имеющемся коде должны быть изменены для `nullptr`.  
  
 Закрепляющий указатель в управляемых расширениях была разрешена обращаться к целому объекту, как в следующем примере, взяты из спецификации управляемых расширений:  
  
```  
__gc class G {  
public:  
   void incr(int* pi) { pi += 1; }  
};  
__gc struct H { int j; };  
void f( G * g ) {  
   H __pin * pH = new H;     
   g->incr(& pH -> j);     
};  
```  
  
 В новом синтаксисе закрепление всего объекта возвращенных `new` выражение не поддерживается. Вместо этого адрес внутреннего члена должен быть администратором. Например, примененная к объекту директива  
  
```  
ref class G {  
public:  
   void incr(int* pi) { *pi += 1; }  
};  
ref struct H { int j; };  
void f( G^ g ) {  
   H ^ph = gcnew H;  
   Console::WriteLine(ph->j);  
   pin_ptr<int> pj = &ph->j;  
   g->incr(  pj );  
   Console::WriteLine(ph->j);  
}  
```  
  
## <a name="see-also"></a>См. также  
 [Типы значений и их поведение (C + +/ CLI)](../dotnet/value-types-and-their-behaviors-cpp-cli.md)   
 [Классы и структуры](../windows/classes-and-structs-cpp-component-extensions.md)   
 [interior_ptr (C + +/ CLI)](../windows/interior-ptr-cpp-cli.md)   
 [pin_ptr (C++/CLI)](../windows/pin-ptr-cpp-cli.md)