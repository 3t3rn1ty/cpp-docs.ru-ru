---
title: "Неявная упаковка-преобразование типов значений | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
helpviewer_keywords:
- boxing, Visual C++
- __box keyword
- boxing
- boxing, __box keyword
- value types, boxed
ms.assetid: 9597c92f-a3fe-44af-ad80-f9d656847a35
caps.latest.revision: "9"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.openlocfilehash: 1f489c686a182840e142264476c3906d0cbfe97b
ms.sourcegitcommit: ebec1d449f2bd98aa851667c2bfeb7e27ce657b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/24/2017
---
# <a name="implicit-boxing-of-value-types"></a>Неявная упаковка-преобразование типов значений
Упаковка-преобразование типов значений отличается от управляемых расширений для C++ к Visual C++.  
  
 В конструкции языка была построена на философии практический опыт с компонентом, и на практике она была допущена ошибка. По аналогии в исходном несколько конструкции языка наследования Страуструп сделал в конструктор производного класса не удалось инициализировать дочерний объект виртуального базового класса, что таким образом, язык требовал, любого выступает в роли виртуального базового класса класс должен определять конструктор по умолчанию. Это может быть вызвана любым последующим виртуальным наследованием конструктор по умолчанию.  
  
 Проблема иерархии виртуальных базовых классов в том, что ответственность за инициализацию общих виртуальных дочерних объектов начинается с каждого последующего производного. Например если определить базовый класс для инициализации которого требуется выделение буфера, определяемый пользователем размера этого буфера может быть передан в качестве аргумента конструктора. Затем, если выполнить два последовательных наследования, их вызова `inputb` и `outputb`, каждая из них содержит определенное значение в конструктор базового класса. Теперь, после выполнения наследования `in_out` класс как из `inputb` и `outputb`, ни одно из этих значений дочернему объекту общий виртуальный базовый класс может быть определено для оценки.  
  
 Таким образом первоначально языка Страуструп запретил явную инициализацию виртуального базового класса в списке инициализации членов конструктора производного класса. Хотя это решение проблемы, на практике невозможность направления инициализации виртуальных базовых классов оказалась нецелесообразной. Кит Горлен из национального института здравоохранения, который версию библиотеки коллекций SmallTalk вызывается nihcl, был принцип голоса в убедить Страуструп что придумать более гибким языка.  
  
 Принцип объектно-ориентированного иерархическая схема содержит, производный класс должен быть связан только с открытой реализацией непосредственных базовых классов. Для поддержки гибкости структуры инициализации для виртуального наследования, Страуструп был вынужден нарушить такой принцип. Наиболее производный класс в иерархии несет ответственности за все инициализации виртуальных дочерних объектов независимо от того, насколько глубоко в иерархии, к которой он происходит. Например `inputb` и `outputb` присутствуют ответственны за явную инициализацию их непосредственного виртуального базового класса. Когда `in_out` наследует от `inputb` и `outputb`, `in_out` становится ответственным за инициализацию удаленного виртуального базового класса, а инициализация, выполняющаяся явно в пределах `inputb` и `outputb` — подавляется.  
  
 Это обеспечивает гибкость, требуемую разработчиками языка, но за счет усложнения семантики. Эту нагрузку усложнении пропадает, если ввести ограничения виртуального базового класса без состояния и разрешив ему самому указывать интерфейс. Это рекомендуемая идиома C++. В рамках программирования в среде CLR оно возникает в политику с типом интерфейса.  
  
 Ниже приведен пример простого кода — и в этом случае явная упаковка не требуется:  
  
```  
// Managed Extensions for C++ requires explicit __box operation  
int my1DIntArray __gc[] = { 1, 2, 3, 4, 5 };  
Object* myObjArray __gc[] = {   
   __box(26), __box(27), __box(28), __box(29), __box(30)  
};  
  
Console::WriteLine( "{0}\t{1}\t{2}", __box(0),  
   __box(my1DIntArray->GetLowerBound(0)),  
   __box(my1DIntArray->GetUpperBound(0)) );  
```  
  
 Как видите, имеется гораздо упаковка происходит. В Visual C++, тип значения является неявной упаковки-преобразования:  
  
```  
// new syntax makes boxing implicit  
array<int>^ my1DIntArray = {1,2,3,4,5};  
array<Object^>^ myObjArray = {26,27,28,29,30};  
  
Console::WriteLine( "{0}\t{1}\t{2}", 0,   
   my1DIntArray->GetLowerBound( 0 ),   
   my1DIntArray->GetUpperBound( 0 ) );  
```  
  
## <a name="see-also"></a>См. также  
 [Типы значений и их поведение (C + +/ CLI)](../dotnet/value-types-and-their-behaviors-cpp-cli.md)   
 [Упаковка-преобразование](../windows/boxing-cpp-component-extensions.md)