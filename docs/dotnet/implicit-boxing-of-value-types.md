---
title: Неявная упаковка-преобразование типов значений | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-cli
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- boxing, Visual C++
- __box keyword
- boxing
- boxing, __box keyword
- value types, boxed
ms.assetid: 9597c92f-a3fe-44af-ad80-f9d656847a35
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- dotnet
ms.openlocfilehash: e9c232dba6d766d0855bb4bb29e33d85b5fd5a2d
ms.sourcegitcommit: 799f9b976623a375203ad8b2ad5147bd6a2212f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/19/2018
ms.locfileid: "46387592"
---
# <a name="implicit-boxing-of-value-types"></a>Неявная упаковка-преобразование типов значений

Упаковка-преобразование типов значений отличается от управляемых расширений для C++ в Visual C++.

В конструкции языка была построена на философии практический опыт с функцией, и на практике сделано по ошибке. По аналогии в исходном несколько конструкции языка наследования Страуструп сделал дочерний объект виртуального базового класса не удалось инициализировать в конструктор производного класса, что таким образом, язык требовал, любой класс, выступая в качестве виртуального базового класс должен определять конструктор по умолчанию. Это конструктор по умолчанию будет вызван любым последующим виртуальным наследованием.

Проблема иерархии виртуальных базовых классов в том, что ответственность за инициализацию общих виртуальных дочерних объектов, переходит с каждой последующей наследования. Например если определить базовый класс для инициализации которого требуется выделение буфера, определяемое пользователем размера буфера может передаваться в качестве аргумента в конструктор. Затем, если выполнить два последовательных наследования, их вызова `inputb` и `outputb`, каждый из которых обеспечивает определенное значение в конструктор базового класса. Теперь, когда я производным `in_out` от оба класса `inputb` и `outputb`, ни один из этих значений дочернему объекту общий виртуальный базовый класс может быть определено для оценки.

Таким образом заданный первоначально языка Страуструп запретил явную инициализацию виртуального базового класса в списке инициализации членов конструктора производного класса. Хотя это решение проблемы, на практике невозможность направления инициализации виртуальных базовых классов было найдено подходящих нецелесообразной. Кит Горлен национальный институт из работоспособности, который версию библиотеку коллекции SmallTalk, называемую nihcl, сыграл в убедить Страуструпом, что придумать более гибким языка.

Принцип объектно-ориентированного проектирования иерархических содержит, что производный класс должен быть связан только с открытой реализацией непосредственных базовых классов. Для поддержки гибкости структуры инициализации для виртуальное наследование, Страуструп был нарушение этого принципа. Наиболее производный класс в иерархии несет ответственность за все инициализации виртуальных дочерних объектов независимо от того, насколько глубоко в иерархии, которому она применяется. Например `inputb` и `outputb` оба несут ответственность за явной инициализации их непосредственного виртуального базового класса. Когда `in_out` наследует от `inputb` и `outputb`, `in_out` становится ответственным за инициализацию удаленного виртуального базового класса, и инициализация, выполняющаяся явно в пределах `inputb` и `outputb` — подавить.

Это обеспечивает гибкость, необходимые разработчиками языка, но за счет усложнения семантики. Эту нагрузку усложнения пропадает, если ввести ограничения виртуального базового класса без состояния и просто разрешить ее, указав интерфейс. Это рекомендуемая идиома C++. В рамках программирования в среде CLR это событие возникает в политику с типом интерфейса.

Ниже приведен пример простого кода — и в этом случае явная упаковка-преобразование не требуется:

```
// Managed Extensions for C++ requires explicit __box operation
int my1DIntArray __gc[] = { 1, 2, 3, 4, 5 };
Object* myObjArray __gc[] = {
   __box(26), __box(27), __box(28), __box(29), __box(30)
};

Console::WriteLine( "{0}\t{1}\t{2}", __box(0),
   __box(my1DIntArray->GetLowerBound(0)),
   __box(my1DIntArray->GetUpperBound(0)) );
```

Как вы видите, есть много упаковка происходит. Тип значения в группе Visual C++, упаковки-преобразования является неявным:

```
// new syntax makes boxing implicit
array<int>^ my1DIntArray = {1,2,3,4,5};
array<Object^>^ myObjArray = {26,27,28,29,30};

Console::WriteLine( "{0}\t{1}\t{2}", 0,
   my1DIntArray->GetLowerBound( 0 ),
   my1DIntArray->GetUpperBound( 0 ) );
```

## <a name="see-also"></a>См. также

[Типы значений и их режимы работы (C++/CLI)](../dotnet/value-types-and-their-behaviors-cpp-cli.md)<br/>
[Упаковка-преобразование](../windows/boxing-cpp-component-extensions.md)