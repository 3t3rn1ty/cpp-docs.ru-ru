---
title: Изменения в семантике деструктора | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-cli
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- finalizers [C++]
- destructors, C++
ms.assetid: f1869944-a407-452f-b99a-04d8c209f0dc
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- dotnet
ms.openlocfilehash: c25045291afed1e8072867ee668716b2f396ef30
ms.sourcegitcommit: 799f9b976623a375203ad8b2ad5147bd6a2212f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/19/2018
ms.locfileid: "46420027"
---
# <a name="changes-in-destructor-semantics"></a>Изменения в семантике деструктора

Семантика для деструкторов класса значительно изменилась от управляемых расширений для C++ в Visual C++.

В управляемых расширениях деструктор класса была разрешена ссылочным классом, но не внутри класса значений. Это поведение не изменено в новом синтаксисе. Тем не менее семантика деструктор класса были изменены. В этом разделе рассматриваются причины, изменение и обсуждается, как это влияет на перевод существующего кода среды CLR. Это, вероятно, самое важное изменение уровня программист между двумя версиями языка.

## <a name="non-deterministic-finalization"></a>Недетерминированное завершение

Прежде чем память, связанную с объектом будет удален сборщиком мусора, связанным `Finalize` , если он имеется, вызывается метод. Можно считать этот метод своего рода супердеструктором, поскольку он не связан с программным временем жизни объекта. Мы называем это финализации. Время и ли `Finalize` вызова метода не определено. Это, что мы имеем в виду когда мы говорим, что сбор мусора представляет недетерминированное завершение.

Недетерминированные финализация хорошо работает с динамическим управлением памятью. При переполнении доступной памяти, сборщик мусора будет запущено. В разделе сборки мусора собранные среды, деструкторов для освобождения памяти не нужны. Недетерминированное завершение не работает, тем не менее, если объект удерживает важный ресурс, например подключение к базе данных или блокировки какого-либо рода. В этом случае мы должен освободить этот ресурс как можно скорее. В машинном мире, этого можно добиться с помощью пары конструктора или деструктора. Сразу же завершает время существования объекта, либо при завершении локального блока, в котором он объявлен, либо когда происходит развертывание стека из-за созданного исключения, деструктор выполняет и ресурс автоматически освобождается. Этот подход работает очень хорошо, и их отсутствия в управляемых расширениях хватало было пропущено.

Решение, предоставляемое CLR предназначено для класса для реализации `Dispose` метод `IDisposable` интерфейс. Проблема здесь в том, что `Dispose` должен явно вызываться пользователем. Это ошибкам. В языке C# предусмотрена некоторая автоматизации в виде специального `using` инструкции. При разработке управляемых расширений не предоставляет специальной поддержки.

## <a name="destructors-in-managed-extensions-for-c"></a>Деструкторы в управляемых расширениях для C++

В управляемых расширениях деструктор ссылочного класса реализуется с помощью двух этапов:

1. Предоставленный пользователем деструктор внутренне переименовывается на `Finalize`. Если класс имеет базовый класс (Помните, что в модели объектов CLR поддерживается только одиночное наследование), компилятор вызывает метод завершения после выполнения пользовательского кода. Например рассмотрим следующую простую иерархию из спецификации управляемых расширений языка:

```
__gc class A {
public:
   ~A() { Console::WriteLine(S"in ~A"); }
};

__gc class B : public A {
public:
   ~B() { Console::WriteLine(S"in ~B");  }
};
```

В этом примере оба деструктора переименовываются `Finalize`. `B`в `Finalize` вызывается `A` `Finalize` метода, добавленного после вызова `WriteLine`. Это, что сборщик мусора будет вызывать по умолчанию во время завершения. Вот, как может выглядеть внутреннее преобразование:

```
// internal transformation of destructor under Managed Extensions
__gc class A {
public:
   void Finalize() { Console::WriteLine(S"in ~A"); }
};

__gc class B : public A {
public:
   void Finalize() {
      Console::WriteLine(S"in ~B");
      A::Finalize();
   }
};
```

1. На втором этапе компилятор синтезирует виртуальный деструктор. Этот деструктор является то, что программах пользователя управляемых расширений вызывать напрямую или через приложения выражения delete. Он никогда не вызывается сборщиком мусора.

     Две инструкции помещаются в этот Синтезированная деструктор. Один из них представляет собой вызов `GC::SuppressFinalize` чтобы убедиться, что нет дополнительные вызовы `Finalize`. Второй — фактический вызов `Finalize`, который представляет деструктор, предоставленный пользователем, для этого класса. Вот, как это может выглядеть:

```
__gc class A {
public:
   virtual ~A() {
      System::GC::SuppressFinalize(this);
      A::Finalize();
   }
};

__gc class B : public A {
public:
   virtual ~B() {
      System::GC::SuppressFinalize(this);
      B::Finalize();
   }
};
```

Эта реализация позволяет пользователю явно вызывать класс `Finalize` метод теперь вместо одновременно можно было управлять, она не обеспечивает действительную с помощью `Dispose` метод решения. Это изменение в Visual C++.

## <a name="destructors-in-new-syntax"></a>Деструкторы в новом синтаксисе

В новом синтаксисе деструктор внутренне переименовывается на `Dispose` метод и ссылочный класс автоматически расширяется, чтобы реализовать `IDispose` интерфейс. То есть в Visual C++, наши пара классов преобразуется следующим образом:

```
// internal transformation of destructor under the new syntax
__gc class A : IDisposable {
public:
   void Dispose() {
      System::GC::SuppressFinalize(this);
      Console::WriteLine( "in ~A");
   }
};

__gc class B : public A {
public:
   void Dispose() {
      System::GC::SuppressFinalize(this);
      Console::WriteLine( "in ~B");
      A::Dispose();
   }
};
```

При явном вызове деструктора в новом синтаксисе или `delete` применяется к дескриптору отслеживания базовый `Dispose` метод будет вызываться автоматически. Если он является производным от класса, вызов `Dispose` метод базового класса вставляется в конец созданного метода.

Но это не всегда вплоть до детерминированную финализацию. Чтобы достигнуть, полностью дополнительная поддержка локальные ссылочные объекты. (Это имеет не аналогично поддержке в управляемых расширений, и поэтому он не является преобразованием).

## <a name="declaring-a-reference-object"></a>Объявление объекта ссылочного

Visual C++ поддерживает объявление объекта ссылочного класса в локальном стеке или члена класса, как если бы он был доступен напрямую. При сочетании деструктора с `Dispose` , результатом является автоматизированный вызов семантики завершения в ссылочных типов.

Во-первых определим ссылочный класс таким образом, что создание объекта функционирует как получение ресурса с помощью конструктора классов. Во-вторых в пределах деструктор класса, мы выпускаем ресурс, полученный при создании объекта.

```
public ref class R {
public:
   R() { /* acquire expensive resource */ }
   ~R() { /* release expensive resource */ }

   // everything else...
};
```

Объект объявлен локально, используя имя типа, но без соответствующей позиции. Все случаи использования объекта, например вызов метода, выполняются с помощью точку (`.`) вместо стрелки (`->`). В конце блока, связанный деструктор, преобразуются в `Dispose`, вызывается автоматически, как показано ниже:

```
void f() {
   R r;
   r.methodCall();

   // r is automatically destructed here -
   // that is, r.Dispose() is invoked
}
```

Как и в `using` инструкции в C# этот пример не изменяет используемого ограничения среды CLR, что все ссылочные типы должны быть расположены в куче среды CLR. Базовая семантика остается без изменений. Пользователь либо было бы написать следующее (и это, скорее всего внутреннее преобразование, выполненное компилятором):

```
// equivalent implementation
// except that it should be in a try/finally clause
void f() {
   R^ r = gcnew R;
   r->methodCall();

   delete r;
}
```

По сути, в новом синтаксисе деструкторы работают в паре с конструкторами как автоматического получения и освобождения механизм привязан к времени существования локальный объект.

## <a name="declaring-an-explicit-finalize"></a>Объявление явного метода завершения

В новом синтаксисе, как мы уже видели, деструктор является фальшивый синтезированный ввод в `Dispose` метод. Это означает, что если деструктор не вызывается явно, сборщик мусора во время завершения, будет не как и раньше найти связанный `Finalize` метода для объекта. Чтобы обеспечить поддержку разрушение и завершение, мы представили специальный синтаксис для обеспечения метода завершения. Пример:

```
public ref class R {
public:
   !R() { Console::WriteLine( "I am the R::finalizer()!" ); }
};
```

`!` Префикс является аналогом тильда (`~`), вводится деструктор класса — то есть оба метода имеют маркер, вставляя перед именем класса. Если синтезированный `Finalize` происходит метод в производном классе, вызов метода базового класса `Finalize` метод вставляется со своей стороны. Если деструктор вызывается явно, то метод финализации не срабатывает. Вот, как может выглядеть преобразования:

```
// internal transformation under new syntax
public ref class R {
public:
   void Finalize() {
      Console::WriteLine( "I am the R::finalizer()!" );
   }
};
```

## <a name="moving-from-managed-extensions-for-c-to-visual-c-2010"></a>Переход от управляемых расширений для C++ для Visual C++ 2010

При компиляции в Visual C++ всякий раз, когда ссылочный класс содержит деструктор нетривиальные, изменяется поведение среды выполнения управляемых расширений для C++. Требуемый алгоритм трансформации следующего вида:

1. Если деструктор, перепишите его метод завершения класса.

1. Если `Dispose` метод присутствует, переписать это в деструкторе класса.

1. Если имеется деструктор, но не `Dispose` метод, сохраните деструктор во время выполнения первого элемента.

При перемещении кода из управляемых расширений для нового синтаксиса, можно пропустить выполнение этого преобразования. Если приложение зависит от каким-либо образом выполнение связанных методов завершения, поведение приложения без вмешательства пользователя отличается от того, который планировалось.

## <a name="see-also"></a>См. также

[Управляемые типы (C + +/ CL)](../dotnet/managed-types-cpp-cl.md)<br/>
[Деструкторы и методы завершения в разделе: определение и использование классов и структур (C + +/ CLI)](../dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli.md#BKMK_Destructors_and_finalizers)