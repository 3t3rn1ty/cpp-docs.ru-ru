---
title: "Изменения в семантике деструктора | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
helpviewer_keywords:
- finalizers [C++]
- destructors, C++
ms.assetid: f1869944-a407-452f-b99a-04d8c209f0dc
caps.latest.revision: 
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
- dotnet
ms.openlocfilehash: c85ac0b082e8ea1dfbff007a68061e6a286390cd
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="changes-in-destructor-semantics"></a>Изменения в семантике деструктора
Семантика для деструкторов класса значительно изменилась от управляемых расширений для C++ к Visual C++.  
  
 В управляемых расширениях деструктор класса было разрешено ссылочным классом, но не в классе значения. Не изменилась в новом синтаксисе. Тем не менее семантика деструктора класса изменилась. Этот раздел посвящен причины изменений и обсуждается, его влияние на преобразование кода в среде CLR. Это, вероятно, наиболее важные изменения уровне программистов между двумя версиями языка.  
  
## <a name="non-deterministic-finalization"></a>Недетерминированное завершение  
 Прежде чем памяти, связанный с объектом, будет уничтожен сборщиком мусора, связанный с ним `Finalize` , если он имеется, вызывается метод. Можно считать этот метод своего рода супер-деструктор, так как он не связан с программным временем жизни объекта. Мы называем это финализации. Выбор времени и ли `Finalize` вызова метода не определено. Это означает когда мы говорим, что сбор мусора представляет недетерминированное завершение.  
  
 Недетерминированное завершение хорошо работает с динамическое управление памятью. При переполнении доступной памяти, сборщик мусора будет запущено. В области сборки мусора, собранных среды, необязательны, деструкторы для освобождения памяти. Недетерминированное завершение не подходит, тем не менее, если объект поддерживает важный ресурс, например подключение к базе данных или блокировку определенного рода. В этом случае следует как можно быстрее завершить этот ресурс. В собственной среде, осуществляется с помощью конструктора или деструктора пары. Сразу после окончания времени существования объекта, при завершении локального блока, в котором она объявлена или если происходит развертывание стека из-за исключения, выполняется деструктор и ресурс автоматически освобождается. Этот подход хорошо работает и его отсутствия в управляемых расширениях хватало было пропущено.  
  
 — Решение, предоставляемую средой CLR для класса для реализации `Dispose` метод `IDisposable` интерфейса. Проблема здесь в том, что `Dispose` должен явно вызываться пользователем. Это вероятность ошибок. Язык C# предоставляет недостаточный уровень автоматизации в виде специального `using` инструкции. При разработке управляемых расширений не предоставляет специальной поддержки.  
  
## <a name="destructors-in-managed-extensions-for-c"></a>Деструкторы в управляемых расширениях для C++  
 В управляемых расширениях деструктор ссылочного класса реализуется с помощью следующие два действия:  
  
1.  Предоставленный пользователем деструктор внутренне переименовывается на `Finalize`. Если класс имеет базовый класс (Помните, что в объектной модели CLR поддерживается только одиночное наследование), компилятор вызывает метод завершения после выполнения пользовательского кода. Например рассмотрим следующую простую иерархию из спецификации языка управляемых расширений.  
  
```  
__gc class A {  
public:  
   ~A() { Console::WriteLine(S"in ~A"); }  
};  
  
__gc class B : public A {  
public:  
   ~B() { Console::WriteLine(S"in ~B");  }  
};  
```  
  
 В этом примере оба деструктора переименовываются `Finalize`. `B`в `Finalize` вызывается `A` `Finalize` метод добавлен следующий вызов `WriteLine`. Это то, что сборщик мусора будет вызывать по умолчанию во время завершения. Вот, как может выглядеть внутреннее преобразование:  
  
```  
// internal transformation of destructor under Managed Extensions  
__gc class A {  
public:  
   void Finalize() { Console::WriteLine(S"in ~A"); }  
};  
  
__gc class B : public A {  
public:  
   void Finalize() {   
      Console::WriteLine(S"in ~B");  
      A::Finalize();   
   }  
};  
```  
  
1.  На втором этапе компилятор синтезирует виртуальный деструктор. Этот деструктор является то, что наши пользовательские программы управляемых расширений вызвать напрямую или через приложения выражений delete. Он никогда не вызывается сборщиком мусора.  
  
     В этом синтезированную деструктор размещаются два оператора. Одно представляет собой вызов `GC::SuppressFinalize` , чтобы убедиться, что нет дополнительные вызовы `Finalize`. Второй является действительным вызовом метода `Finalize`, который представляет деструктор, предоставленный пользователем, для этого класса. Вот, как это может выглядеть.  
  
```  
__gc class A {  
public:  
   virtual ~A() {  
      System::GC::SuppressFinalize(this);  
      A::Finalize();  
   }  
};  
  
__gc class B : public A {  
public:  
   virtual ~B() {  
      System::GC::SuppressFinalize(this);  
      B::Finalize();  
   }  
};  
```  
  
 Эта реализация позволяет пользователю явно вызывать класс `Finalize` метод теперь вместо одновременно, у вас нет контроля над, она не действительную с `Dispose` метод решения. Это изменение в Visual C++.  
  
## <a name="destructors-in-new-syntax"></a>Деструкторы в новом синтаксисе  
 В новом синтаксисе деструктор переименовывается внутренне в `Dispose` метод и ссылочный класс автоматически расширяется, чтобы реализовать `IDispose` интерфейса. То есть в Visual C++ трансформируется пара классов преобразуется следующим образом:  
  
```  
// internal transformation of destructor under the new syntax  
__gc class A : IDisposable {  
public:  
   void Dispose() {   
      System::GC::SuppressFinalize(this);  
      Console::WriteLine( "in ~A");  
   }  
};  
  
__gc class B : public A {  
public:  
   void Dispose() {   
      System::GC::SuppressFinalize(this);  
      Console::WriteLine( "in ~B");    
      A::Dispose();   
   }  
};  
```  
  
 Если деструктор вызывается явно в новом синтаксисе или `delete` применяется к дескриптору отслеживания базовый `Dispose` автоматически вызывается метод. Если он является производным классом, вызов `Dispose` метод базового класса вставляется в конец созданного метода.  
  
 Но это не всегда вплоть до детерминированное завершение. Чтобы достигнуть, нам нужна дополнительная поддержка локальных ссылочных объектов. (Это не имеет аналогичные поддержки в управляемых расширениях, и он не является преобразованием.)  
  
## <a name="declaring-a-reference-object"></a>Объявление объекта ссылочного  
 Visual C++ поддерживает объявление объекта ссылочного класса в локальном стеке или члена класса, как если бы он был доступен напрямую. При сочетании деструктора с `Dispose` , результатом является автоматизированный вызов семантики завершения в ссылочных типов.  
  
 Во-первых определим ссылочный класс таким образом, что создание объекта функционирует в качестве выделения ресурса с помощью конструктора класса. Во-вторых в деструкторе классов освободить ресурс, полученный при создании объекта.  
  
```  
public ref class R {  
public:  
   R() { /* acquire expensive resource */ }  
   ~R() { /* release expensive resource */ }  
  
   // everything else...  
};  
```  
  
 Объект объявляется локально с помощью имени типа, но без соответствующей позиции. Все случаи использования объекта, например вызов метода, выполняются с помощью элементного подбора точки (`.`) вместо стрелки (`->`). В конце блока связанный деструктор, преобразуются в `Dispose`, вызывается автоматически, как показано ниже:  
  
```  
void f() {  
   R r;   
   r.methodCall();  
  
   // r is automatically destructed here -  
   // that is, r.Dispose() is invoked  
}  
```  
  
 Как и в `using` инструкции в C# этот пример не изменяет используемого ограничения среды CLR, что все типы ссылок должны выделяться в куче среды CLR. Семантика остаются без изменений. Пользователь либо было бы написать следующее (и это, скорее всего, внутреннее преобразование, выполненное компилятором):  
  
```  
// equivalent implementation  
// except that it should be in a try/finally clause  
void f() {  
   R^ r = gcnew R;   
   r->methodCall();  
  
   delete r;  
}  
```  
  
 По сути, в новом синтаксисе деструкторы работают в паре с конструкторами как автоматического получения и освобождения механизм привязан к времени существования локального объекта.  
  
## <a name="declaring-an-explicit-finalize"></a>Объявление явного метода завершения  
 В новом синтаксисе, как мы увидели, деструктор является созданным в `Dispose` метод. Это означает, что если деструктор явно не вызывается, сборщик мусора во время завершения, будет не как раньше найти связанный `Finalize` метода для объекта. Для поддержки разрушение и завершение, мы разработали специальный синтаксис для обеспечения метода завершения. Пример:  
  
```  
public ref class R {  
public:  
   !R() { Console::WriteLine( "I am the R::finalizer()!" ); }  
};  
```  
  
 `!` Префикс является аналогом тильды (`~`), вводит деструктор класса — оба метода есть маркер, вставляя перед именем класса. Если синтезированную `Finalize` происходит метод в производном классе, вызов метода базового класса `Finalize` вставляется в его конец. Если деструктор явно вызван, метод завершения подавляется. Вот, как может выглядеть преобразования:  
  
```  
// internal transformation under new syntax  
public ref class R {  
public:  
   void Finalize() {  
      Console::WriteLine( "I am the R::finalizer()!" );  
   }  
};   
```  
  
## <a name="moving-from-managed-extensions-for-c-to-visual-c-2010"></a>Переход от управляемых расширений для C++ к Visual C++ 2010  
 При компиляции в Visual C++ всякий раз, когда ссылочный класс содержит необычный деструктор, поведение среды выполнения программы управляемых расширений для C++ изменяется. Требуемый алгоритм трансформации следующего вида:  
  
1.  Если имеется деструктор, перепишите это в качестве метода завершения класса.  
  
2.  Если `Dispose` присутствует метод, переписать это в деструкторе класса.  
  
3.  Если имеется деструктор, но не `Dispose` метод, сохраните деструктор во время выполнения первой операции.  
  
 При переходе кода из управляемых расширений для нового синтаксиса, можно пропустить выполнение этого преобразования. Если приложение зависит от каким-либо образом выполнения связанных методов завершения, поведение приложения автоматически будут отличаться от того, которое вы собирались.  
  
## <a name="see-also"></a>См. также  
 [Управляемые типы (C + +/ CL)](../dotnet/managed-types-cpp-cl.md)   
 [Деструкторы и методы завершения в разделе: определение и использование классов и структур (C + +/ CLI)](../dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli.md#BKMK_Destructors_and_finalizers)