---
title: Нотация приведения типов и знакомство с safe_cast&lt; &gt; | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-cli
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- casting
- C-style casts and /clr, motivation for new cast notation
- safe_cast keyword [C++]
ms.assetid: 4eb1d000-3b93-4394-a37b-8b8563f8dc4d
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- dotnet
ms.openlocfilehash: 88e8165bde08b65b4f078c4b48863c2088132fca
ms.sourcegitcommit: 799f9b976623a375203ad8b2ad5147bd6a2212f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/19/2018
ms.locfileid: "46427870"
---
# <a name="cast-notation-and-introduction-of-safecastltgt"></a>Нотация приведения типов и знакомство с safe_cast&lt;&gt;

Нотация приведения типов отличается от управляемых расширений для C++ в Visual C++.

Изменение существующей структуры — это разные и сложнее, чем берет на себя создание начальной структуры. Существуют меньшее число степеней свободы и решение стремится к компромиссу между идеальной реструктуризацией и что такое возможно, учитывая существующие структурные зависимости.

Другим примером является расширение языка. В начале 1990-х как объектно-ориентированное программирование стало важным принципом, потребность в тип образовывать на C++ стало нажатия клавиши. Приведение — это пользователь явного преобразования указателя базового класса или ссылка на указатель или ссылка производного класса. Приведение требуется явное приведение. Причина в том, что фактический тип указателя базового класса является аспектом среды выполнения; Компилятор таким образом не может проверить его. Или, словами, приведения типов, так же, как вызов виртуальной функции требуется определенная динамическое разрешение. В связи с этим возникает два вопроса:

- Почему приведения не требуется в парадигме объектно-ориентированного? Недостаточно механизма виртуальных функций? То есть, почему нельзя сказать, что потребность приведения (или приведение каких-либо) происходит сбой разработки?

- Почему поддержки образования производных типов должна стать проблемой в C++? В конце концов, это не проблема в объектно ориентированных языках, таких как Smalltalk (или, впоследствии, Java и C#)? Что такое о C++, который упрощает поддержку для приведения типов, которые сложно?

Виртуальная функция представляет алгоритм зависящие от типа, общий для семейства типов. (Мы не рассматриваем интерфейсов, который не поддерживается в ISO-C++, но доступны в программировании в среде CLR и представляют об интересной альтернативе разработки). Структура этого семейства, как правило, представлен в виде иерархии классов, в котором есть абстрактный базовый класс, объявленный общий интерфейс (виртуальные функции) и набор конкретных производных классов, которые представляют фактические типы семейства в приложении домен.

Объект `Light` иерархии в изображениях созданный компьютер (CGI) домене приложения, например, будет иметь общие атрибуты, такие как `color`, `intensity`, `position`, `on`, `off`, и т. д. Несколько источников света, можно управлять с помощью общий интерфейс, не беспокоясь ли определенного источника света spotlight, направленный свет, свет Ненаправленные (Вспомните Солнца) или возможно двухстороннее какой света. В этом случае приведение для конкретного светло типа для виртуального интерфейса не требуется. В рабочей среде тем не менее, скорость играет важную роль. Один можно создавать производные классы и явным образом вызывать каждый метод, если и в результате встроенного выполнения вызовов могут выполняться вместо использования виртуального механизм.

Таким образом одна из причин для производных типов в C++ необходимо для подавления механизма виртуальных функций значительного повышения производительности во время выполнения. (Обратите внимание, что автоматизация этот ручной оптимизации активной областью исследования. Однако это более сложной задачей, чем просто явное использование `register` или `inline` ключевое слово.)

Вторая причина для производных типов в случае прекращения двойственности полиморфизма. Один из способов Полиморфизм можно рассматривать как разделение пару пассивном, так и динамических форм.

Вызов виртуальных функций (и образование производных типов) представляет динамического использования полиморфизма: один выполняет действие на основании фактического типа указателя базового класса при этому конкретному экземпляру выполнения программы.

Тем не менее, присвоить объект производного класса ее указатель базового класса, является пассивной формой полиморфизма; он является использование полиморфизма как механизма передачи. Это является основным вариантом применения `Object`, например, предварительно универсального программировании в среде CLR. При использовании пассивно, указатель базового класса, выбранный для передачи и хранения, обычно предлагает интерфейс, который слишком абстрактный. `Object`, например, предоставляет примерно пять методов, доступных через его интерфейс; любой более конкретное поведение требует явного приведения. Например если мы хотим изменить угол света или коэффициент падения, нам пришлось бы нисходящее приведение типа явным образом. Виртуальный интерфейс в рамках семейства подтипов может подмножеством всех возможных методов его многочисленных дочерних объектов, и поэтому приведения типов он понадобится всегда в объектно ориентированного языка.

Безопасный нисходящее приведение типа помещению необходимости в объектно ориентированного языка, то почему заняло C++ так много времени для добавления одного? Проблема заключается в том, как для предоставления сведений о времени выполнения тип указателя. В случае виртуальная функция данных времени выполнения в виде двух частей настроен компилятором:

- Объект класса содержит член указатель дополнительную виртуальную таблицу (либо в начале или конце объекта класса; это имеет само по себе является отдельной темой обсуждения), посвященное соответствующей виртуальной таблице. Например объект spotlight адреса к виртуальной таблице, направленный свет, направление света виртуальной таблицы и т. д.

- Каждую виртуальную функцию имеет связанную фиксированную ячейку в таблице, и реальный экземпляр для вызова представлен по адресу, сохраненному в пределах таблицы. Например, виртуальный `Light` деструктор может быть связан с ячейкой 0, `Color` с ячейкой 1 и т. д. Это эффективной в том случае, если неудобными стратегии, так как он настроен во время компиляции и представляет минимальных издержек.

Эту проблему, затем, как это можно сделать сведения о типе доступных на курсор без изменения размера указателей C++, путем добавления второго адреса или путем непосредственного добавления какую-либо тип кодировки. Это не будет приемлема для программистов (и программ), целесообразно не использовать объектно ориентированной парадигмы - которого был по-прежнему сообщества преобладающим пользователей. Другим вариантом было представить специальный указатель для типов полиморфных классов, но это может ввести в заблуждение и затруднить между смешивать два, особенно при работе с проблемы с указателями. Также не было бы приемлемым для поддержания таблицу во время выполнения, которая связывает каждый указатель с текущим связанным типом и динамически обновлять ее.

Проблемы, то пара сообщества пользователей, имеющих различными подходами программирования оба. Решение должно представлять собой компромисс между двумя сообществами, что позволяет каждому не только их целью, но возможность взаимодействия. Это означает, что для решений, предлагаемых с обеих сторон, скорее всего, будет невозможно, так и для решения развернуть и, наконец, чтобы обеспечить далек от совершенства. Фактическое разрешение связано с определением полиморфного класса: полиморфный класс является версией, которая содержит виртуальную функцию. Полиморфный класс поддерживает динамические образования производных типов. Это решает проблему Ведение указатель адреса, так как все полиморфных классов содержит дополнительный элемент указателя к связанной виртуальной таблице. Таким образом, данные связанного типа могут храниться в расширенной виртуальной таблице. Стоимость образования производных типов (почти) локализован на пользователей данной функции.

Еще одной проблемой с типобезопасное является синтаксис. Так как это приведение исходного предложения для Комитет ISO-C++ используется простой синтаксис приведения типов, как в следующем примере:

```
spot = ( SpotLight* ) plight;
```

но это было отклонено комитетом, поскольку он не разрешает пользователю контролировать затраты на приведение. Если динамическое типобезопасное имеет такой же синтаксис, как небезопасные ранее, но статической нотации, то он становится подстановки и пользователь не обладает способностью отключать издержки на этапе выполнения, если ненужные и, возможно, слишком высокие.

Как правило в C++, всегда есть механизм подавления функциональные возможности, поддерживаемые компилятором. Например, можно отключить механизм использования виртуальных функций с помощью оператора область класса (`Box::rotate(angle)`) или путем вызова виртуального метода через объект класса (а не указателя или ссылки этого класса). Это не является обязательным в данном языке, но является вопросам реализации, аналогичную подавление построения временных в объявление следующего вида:

```
// compilers are free to optimize away the temporary
X x = X::X( 10 );
```

Поэтому предложение было передано для дальнейшего рассмотрения, и несколько альтернативных нотаций учитывались была восстановлена комитет по той формы (`?type`), которой указано его неопределенном - то есть динамической природы. Этот модуль позволял пользователю переключаться между двумя формами — статический или динамический -, но никто не слишком довольны ее. Поэтому он был получен переписывания. Третья и успешно нотация является теперь стандартный `dynamic_cast<type>`, которой был обобщен набор четырех нотаций новый стиль приведения типов.

В ISO-C++ `dynamic_cast` возвращает `0` при применяется к несоответствующему типу указателя и создает `std::bad_cast` исключения при применении к ссылочному типу. В управляемых расширениях для C++ применение `dynamic_cast` управляемому ссылочному типу (из-за представления указателя) всегда возвращается `0`. `__try_cast<type>` была введена как аналог вызову исключений `dynamic_cast`, за исключением того, что он создает `System::InvalidCastException` в случае сбоя приведения.

```
public __gc class ItemVerb;
public __gc class ItemVerbCollection {
public:
   ItemVerb *EnsureVerbArray() [] {
      return __try_cast<ItemVerb *[]>
         (verbList->ToArray(__typeof(ItemVerb *)));
   }
};
```

В новом синтаксисе `__try_cast` была приведена как `safe_cast`. Ниже приведен тот же фрагмент кода в новом синтаксисе.

```
public ref class ItemVerb;
public ref class ItemVerbCollection {
public:
   array<ItemVerb^>^ EnsureVerbArray() {
      return safe_cast<array<ItemVerb^>^>
         ( verbList->ToArray( ItemVerb::typeid ));
   }
};
```

В управляемой среде важно обеспечить более проверяемый код, ограничивая возможности программистов для приведения между типами образом непроверяемым. Это критически важным аспектом динамического программирования, представленной нового синтаксиса. По этой причине экземпляры приведения старого стиля свести внутренне как во время выполнения так, например:

```
// internally recast into the
// equivalent safe_cast expression above
( array<ItemVerb^>^ ) verbList->ToArray( ItemVerb::typeid );
```

С другой стороны поскольку полиморфизм имеет активный и пассивный режим, это иногда необходимо выполнять приведение просто для получения доступа к API невиртуальный подтипа. Это может произойти, например, к элементам класса, к адресу любое типу в иерархии (пассивный полиморфизм как механизма передачи), но для которого известен фактический экземпляр в контексте определенной программы. В этом случае необходимости проверки во время выполнения для приведения может быть неприемлемо нагрузку. Если новый синтаксис для использования в качестве языка программирования управляемых систем, он должен предоставлять средства, позволяющие во время компиляции (то есть статический) нисходящее приведение типа. Вот почему применения `static_cast` нотации может оставаться нисходящее приведение типа во время компиляции:

```
// ok: cast performed at compile-time.
// No run-time check for type correctness
static_cast< array<ItemVerb^>^>(verbList->ToArray(ItemVerb::typeid));
```

Проблема заключается, что нет способа гарантировать, что программист выполнив `static_cast` правильное и намерениями; то есть, нет способа заставить управляемого кода в проверяемые. Это является более срочным, проблемой в разделе парадигму динамического программирования, чем в машинный код, но недостаточно для языка системного программирования запретить пользователю переключаться между статическим и приведение во время выполнения.

Ловушки производительности и ошибок в новом синтаксисе, однако есть. В программировании собственного кода, нет никакой разницы в производительности между нотации старой и новой `static_cast` нотации. Но в новом синтаксисе нотация приведения типов в старом стиле значительно дороже, чем использование новой `static_cast` нотации. Причина в том, что компилятор выполняет внутреннее преобразование нотации старого стиля в проверки во время выполнения, который создает исключение. Кроме того, он также изменяет профиль выполнения кода, так как он вызывает исключение перевод работу приложения — возможно, разумно, но та же ошибка не вызовет исключение, если `static_cast` использовались нотации. Можно утверждать, что это поможет пользователям продукта в нотации новый стиль. Но только в случае сбоя. в противном случае это вызовет программы, использующие старую нотацию существенно замедлить работу без видимых причин, аналогичную следующие проблемы программиста C:

```
// pitfall # 1:
// initialization can remove a temporary class object,
// assignment cannot
Matrix m;
m = another_matrix;

// pitfall # 2: declaration of class objects far from their use
Matrix m( 2000, 2000 ), n( 2000, 2000 );
if ( ! mumble ) return;
```

## <a name="see-also"></a>См. также

[Общие изменения в языке (C++/CLI)](../dotnet/general-language-changes-cpp-cli.md)<br/>
[Приведение в стиле C с параметром/CLR (C + +/ CLI)](../windows/c-style-casts-with-clr-cpp-cli.md)<br/>
[safe_cast](../windows/safe-cast-cpp-component-extensions.md)