---
title: Изменение операторов преобразования | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-cli
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- conversion operators
- operators [C++], explicit type conversion
- type conversion, explicit conversions
- conversions, explicit
- explicit keyword [C++]
ms.assetid: 9b83925c-71b7-4bd3-ac2e-843dd7c7f184
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- dotnet
ms.openlocfilehash: 03b17c5abc559289a9f85a10b9c5914b49498922
ms.sourcegitcommit: 799f9b976623a375203ad8b2ad5147bd6a2212f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/19/2018
ms.locfileid: "46381118"
---
# <a name="changes-to-conversion-operators"></a>Изменение операторов преобразования

Синтаксис для операторов преобразования отличается от управляемых расширений для C++ в Visual C++.

Одним из примеров является написание `op_Implicit` для указания преобразования. Вот определение `MyDouble` взяты из спецификации языка:

```
__gc struct MyDouble {
   static MyDouble* op_Implicit( int i );
   static int op_Explicit( MyDouble* val );
   static String* op_Explicit( MyDouble* val );
};
```

В этом примере указано, что является целым числом, алгоритм преобразования целого числа в `MyDouble` обеспечивается `op_Implicit` оператор. Кроме того это преобразование выполняется неявно компилятором. Аналогичным образом, учитывая `MyDouble` двумя `op_Explicit` операторы предоставляют алгоритмы преобразования объекта в целое число или управляемый `String` сущности. Тем не менее компилятор не будет выполнять преобразование, если явно не указано пользователем.

В C# это выглядит следующим образом:

```
class MyDouble {
   public static implicit operator MyDouble( int i );
   public static explicit operator int( MyDouble val );
   public static explicit operator string( MyDouble val );
};
```

Код на C# больше похож на C++, чем управляемых расширений для C++. Это не так в новом синтаксисе.

Комитет ISO-C++ ввел ключевое слово, `explicit`, во избежание непредвиденных последствий - например, `Array` класс, который принимает один целочисленный аргумент, как измерения, неявно преобразует любое целое число в `Array` объекта, который — не нужны. Один из способов избежать этого — в стандартном фиктивного второго аргумента конструктора

С другой стороны не следует предоставлять пару преобразования при разработке типа класса в C++. Лучшим примером этого является класс стандартную строку. Неявное преобразование не конструктор одним аргументом, принимающий строку C-стиля. Тем не менее, она предоставляет соответствующий оператор неявного преобразования -, для преобразования строкового объекта в строку в стиле C, но требует от пользователя, для явного вызова именованная функция — в этом случае `c_str()`.

Таким образом отображается связывание неявных или явных поведения в отношении оператора преобразования (и как вложение набор преобразований в одну форму объявления) представляет собой улучшенную поддержку исходного C++ операторов преобразования, которая привела к `explicit` ключевое слово. Поддержка языка Visual C++ для операторов преобразования выглядит следующим образом, дает несколько менее многословной, чем C#, из-за оператора, поддерживающих неявное применение алгоритма преобразования по умолчанию:

```
ref struct MyDouble {
public:
   static operator MyDouble^ ( int i );
   static explicit operator int ( MyDouble^ val );
   static explicit operator String^ ( MyDouble^ val );
};
```

Другое изменение заключается в том, что единый конструктор аргумента рассматривается как, если он объявлен как `explicit`. Это означает, что для инициирования его вызова, явное приведение является обязательным. Обратите внимание, что если определен оператор явного преобразования, он и не конструктор одним аргументом, вызывается.

## <a name="see-also"></a>См. также

[Объявления членов в пределах класса или интерфейса (C++/CLI)](../dotnet/member-declarations-within-a-class-or-interface-cpp-cli.md)