---
title: Руководство разработчика C++ для гипотетического каналов стороны выполнения | Документы Microsoft
ms.custom: ''
ms.date: 05/03/2018
ms.technology:
- cpp-windows
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- Visual C++, security
- security [C++]
- security [C++], best practices
- Spectre
- CVE-2017-5753
- Speculative Execution
author: mamillmsft
ms.author: mikeblome
ms.workload:
- cplusplus
ms.openlocfilehash: 0a7e7ddb51f07f7fe6be1da017d8feae9cc4919e
ms.sourcegitcommit: 96cdc2da0d8c3783cc2ce03bd280a5430e1ac01d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/10/2018
---
# <a name="c-developer-guidance-for-speculative-execution-side-channels"></a>Руководство разработчика C++ для гипотетического каналов стороны выполнения

Эта статья содержит рекомендации для разработчиков для упрощения идентификации и устранения Упреждающее исполнение стороне канал оборудования уязвимостей в программном обеспечении C++. Эти уязвимости могут содержать конфиденциальные сведения о через границы доверия и может повлиять на программное обеспечение, запущенное процессоров, поддерживающих наблюдающей внеочередной из выполнения инструкции. Этот класс уязвимостей был первым, описанные в январе, 2018 и Дополнительные сведения и инструкции можно найти в [рекомендации по безопасности корпорации Майкрософт](https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/ADV180002).

Руководства, предоставленного в этой статье относится к классу, уязвимостей, представленный CVE-2017 г-5753, также известный как Spectre вариант 1. Этот класс оборудования уязвимость относится к стороне каналов, которые могут возникнуть из-за выполнения наблюдающей, возникшего в результате условного ветвлений. Компилятор Visual C++ в Visual Studio 2017 г. (начиная с версии 15.5.5) включает поддержку `/Qspectre` коммутатор обеспечивает защиту во время компиляции для ограниченного набора потенциально уязвимой шаблоны кодирования, связанных с CVE-2017 г-5753. Документация по [/Qspectre](https://docs.microsoft.com/en-us/cpp/build/reference/qspectre) флаг предоставляет дополнительные сведения по его последствия и использования. 

Вводные сведения доступны Упреждающее исполнение стороне канал уязвимостей можно найти в презентации под названием [случай Spectre и Meltdown](https://www.youtube.com/watch?v=_4O0zMW-Zu4) одним research команд, которые обнаружены следующие проблемы.

## <a name="what-are-speculative-execution-side-channel-hardware-vulnerabilities"></a>Что такое канала со стороны выполнения наблюдающая оборудования уязвимостей

Современных процессоров предоставляют расширенными возможностями производительности, делая использование наблюдающей и ожидания порядок выполнения инструкций. Часто, это достигается путем прогнозирование целью ветвей (условное и indrect), которая позволяет Процессору для начала выполнения инструкции в целевом предсказанные ветви, что позволяет избежать зависания до конечный адрес ветвления фактическое гипотетически Разрешить. В случае, если ЦП позже обнаруживает, что произошло неверным прогнозированием, удаляются все сведения о состоянии компьютера, вычисленная гипотетически. Это гарантирует, что не с точки зрения архитектуры видимые эффекты Неверно предсказанные предположение.

Во время выполнения наблюдающей не влияет на состояние видимости architecturaly, его можно оставить остаточные трассировки-архитектуры состояния, например различные кэши, используемых ресурсов ЦП. Именно эти остаточные трассировки наблюдающей выполнения, которое может привести к появлению уязвимостей стороны канала. Чтобы лучше понять это, рассмотрим следующий фрагмент кода, которой является примером 5753 CVE 2017 г. (проверьте обход границы).

```cpp
// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

unsigned char ReadByte(unsigned char *buffer, unsigned int buffer_size, unsigned int untrusted_index) {
    if (untrusted_index < buffer_size) {
        unsigned char value = buffer[untrusted_index];
        return shared_buffer[value * 4096];
    }
}
```

В этом примере `ReadByte` — предоставленный буфер, размер буфера и индекса в этот буфер. Параметр индекса в соответствии с `untrusted_index`, предоставляемые меньше привилегированного контекста, например обычных процесса. Если `untrusted_index` — меньше, чем `buffer_size`, а затем символ с таким индексом, считанный из `buffer` и используется для индекса в общей области памяти, на который ссылается `shared_buffer`.

С точки зрения архитектуры этой последовательности кода абсолютно безопасных как гарантируется, что `untrusted_index` всегда будет меньше, чем `buffer_size`. Однако при наличии Упреждающее исполнение это ЦП mispredict условной ветви и выполняет тело, если инструкция, даже когда `untrusted_index` больше или равно `buffer_size`. В результате ЦП может гипотетически считывает байт из-за пределов границы `buffer` (это может быть секрет) и затем может использовать это значение byte для вычисления адрес последующую загрузку через `shared_buffer`. 

Во время ЦП в конечном итоге определит это неверным прогнозированием, остаточные побочные эффекты могут остаться в кэше ЦП, который раскрывать информацию о значении байтов, считанный за пределы допустимого диапазона от `buffer`. Эти побочные эффекты могут быть обнаружены на меньшее привилегированный контекст, запущенных в системе, насколько быстро проверки каждого кэша строку в `shared_buffer` осуществляется. Приведены шаги, которые могут быть выполнены для выполнения этой задачи.

1. **Вызвать `ReadByte` несколько раз с `untrusted_index` , меньше, чем `buffer_size`** . Вредоносная контекста может привести к жертвы контекст для вызова `ReadByte` (например, через RPC) таким образом, что является прогнозом ветвь обучена быть не передано как `untrusted_index` — меньше, чем `buffer_size`.

2. **Очистить все строки кэша в `shared_buffer`** . Вредоносная контекста необходимо очистить кэш строк в области общей памяти, на который ссылается `shared_buffer`. Поскольку область памяти является общим, это довольно просто и может выполняться с помощью встроенных функций, таких как `_mm_clflush`.

3. **Вызвать `ReadByte` с `untrusted_index` , размер которых превышает `buffer_size`** . Контекст вредоносная вызывает жертвы контекст для вызова `ReadByte` таким образом, что неправильно прогнозирует ветвь не будет выполнено. Это приводит процессора гипотетически выполнения основной части if блоке с `untrusted_index` , размер которых превышает `buffer_size`, таким образом, что приведет к выходящие за пределы области чтения из `buffer`. Следовательно `shared_buffer` индексируется с помощью потенциально секретное значение прочитанное вне допустимых границ, тем самым вызывая строки соответствующих кэша загрузки ЦП.

4. **Просмотрите каждую строку кэша в `shared_buffer` для просмотра которой осуществляется быстрее всего**. Вредоносная контекст может считывать каждой строке кэша в `shared_buffer` и определить строку кэша, которая значительно быстрее, чем другие. Это строка кэша, который, скорее всего, которые были перенесены шаге 3. Поскольку между байтов значение и кэша строкой в этом примере имеется отношение 1:1, это позволяет злоумышленнику получить фактическое значение байтов, считанный вне допустимых границ.

Указанные выше шаги укажите с помощью техники, известный как ДИСК + ПЕРЕЗАГРУЗИТЬ в сочетании с использованием экземпляра CVE 2017 г. 5753 пример.

## <a name="what-software-scenarios-can-be-impacted"></a>Могут быть затронуты сценариев программного обеспечения?

Разработка безопасных программного обеспечения с помощью процесса, таких как [жизненного цикла разработки безопасности](https://www.microsoft.com/en-us/sdl/) (SDL) обычно требует разработчиков для определения границы доверия, которые существуют в своих приложениях. Границы доверия существует в местах, где приложение может взаимодействовать с данным, предоставленным менее доверенного контекста, например другой системе или в процессе режим прав администратора в случае драйвер устройства режима ядра. Новый класс уязвимостей, включающих каналы стороны Упреждающее исполнение относится ко многим границы доверия в существующих моделей безопасности программного обеспечения, которые изолировать код и данные на устройстве.

В следующей таблице приведены Сводка моделей безопасности программного обеспечения, где разработчикам может потребоваться беспокоиться о происходящих уязвимости:

|Граница доверия|Описание|
|----------------|----------------|
|Граница виртуальной машины|Приложения, которые изолируют рабочие нагрузки на отдельных виртуальных машинах, получающих непроверенных данных из другой виртуальной машины может оказаться под угрозой.|
|Границы ядра|Драйвер устройства режима ядра, который получает непроверенных данных из процесса режим обычных пользователей может оказаться под угрозой.|
|Границ процесса|Приложения, которое получает непроверенных данных из другой процесс, работающий в локальной системе, например, посредством удаленного вызова процедур (RPC), общая память или другие связи между процесса (IPC) механизмы может оказаться под угрозой.|
|Enclave границ|Приложение, которое выполняется в безопасный enclave (например, Intel SGX), который получит ненадежных данных не из enclave может оказаться под угрозой.|
|Язык границ|Приложение, обрабатывающее или JIT – JIT компилирует и выполняет ненадежного кода, написанного на более высокого уровня языка может оказаться под угрозой.|

Приложения, которые имеют уязвимость предоставляется для любого из указанных выше доверять границы необходимо просмотреть код на уязвимость, чтобы выявлять и устранять возможные экземпляры Упреждающее исполнение стороне канал уязвимостей. Следует отметить, что границы доверия, доступ к области удаленной атаки, например удаленных сетевых протоколов, не была продемонстрирована нарушения Упреждающее исполнение стороне канал уязвимостей.

## <a name="potentially-vulnerable-coding-patterns"></a>Потенциально уязвимой шаблоны кодирования

Упреждающее исполнение стороне канал уязвимости может возникать вследствие нескольких шаблоны кодирования. В этом разделе описаны потенциально уязвимой шаблоны кодирования и примеры для каждого, но он должен распознаваться, могут существовать разновидности эти темы. Таким образом разработчикам рекомендуется использовать эти шаблоны в качестве примеров, а не полный список всех потенциально уязвимой шаблоны кодирования.

Как правило связаны с условной ветвлений стороны Упреждающее исполнение каналы могут возникнуть при условного выражения применяются к данным, управляемому или зависят от контекста, надежный. Например, это может включать условного выражения, используемые в `if`, `for`, `while`, `switch`, или троичный инструкций. Для каждого из этих инструкций компилятор может создать условной ветви, которая ЦП может затем прогнозировать конечный адрес ветвления для во время выполнения.

Для каждого примера вставляется комментарий с фразой «ПРЕДПОЛОЖЕНИЕ БАРЬЕРА» где разработчик может привести к барьер с целью предотвращения. Эта процедура рассматривается более подробно в разделе на способы их устранения.

### <a name="speculative-out-of-bounds-load"></a>Загрузить наблюдающая вне допустимых границ

Шаблоны кода эта категория включает в себя условного ветвлений, пониманию наблюдающей вне допустимых границ доступ к памяти.

#### <a name="array-out-of-bounds-load-feeding-a-load"></a>Загрузить массива вне допустимых границ, передав нагрузки

Этот способ кодировки является изначально описанных уязвимым кодирования для 5753 CVE 2017 г. (проверьте обход границы). Фон части этой статьи объясняется подробно этот шаблон.

```cpp
// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

unsigned char ReadByte(unsigned char *buffer, unsigned int buffer_size, unsigned int untrusted_index) {
    if (untrusted_index < buffer_size) {
        // SPECULATION BARRIER
        unsigned char value = buffer[untrusted_index];
        return shared_buffer[value * 4096];
    }
}
```

Аналогичным образом массива вне допустимых границ нагрузка может возникнуть в сочетании с цикл, который превышает ее завершение условие из-за ошибочного прогнозирования. В этом примере условной ветви, связанные с `x < buffer_size` выражение может mispredict и гипотетически выполнения основной части `for` цикла `x` больше или равно `buffer_size`, таким образом в наблюдающей результате Загрузите вне допустимых границ.

```cpp
// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

unsigned char ReadBytes(unsigned char *buffer, unsigned int buffer_size) {
    for (unsigned int x = 0; x < buffer_size; x++) {
        // SPECULATION BARRIER
        unsigned char value = buffer[untrusted_index];
        return shared_buffer[value * 4096];
    }
}
```

#### <a name="array-out-of-bounds-load-feeding-an-indirect-branch"></a>Загрузить массива вне допустимых границ передав косвенных ветви

Этот способ кодировки входит случай, где условного ветвлений может привести к вне допустимых границ доступ на массив указателей на функции, какие затем интересы косвенных ветвь в целевой адрес, выходящие за пределы области чтения. Следующий фрагмент кода содержит пример, демонстрирующий это. 

В этом примере идентификатор ненадежных сообщение передается DispatchMessage через `untrusted_message_id` параметра. Если `untrusted_message_id` — меньше, чем `MAX_MESSAGE_ID`, то он используется для индексации массива указателей на функции и переход на соответствующий конечный адрес ветвления. Данный пример кода является безопасным с точки зрения архитектуры, но если ЦП Неверно предсказанные с условной ветви, это может привести к `DispatchTable` с индексом `untrusted_message_id` при его значение больше или равно `MAX_MESSAGE_ID`, таким образом, что приведет к доступ вне допустимых границ. Это может привести к Упреждающее исполнение с адреса целевой ветви, выведенная за пределы массива, что может привести к раскрытию информации в зависимости от того, что гипотетически выполняемый код.

```cpp
#define MAX_MESSAGE_ID 16

typedef void (*MESSAGE_ROUTINE)(unsigned char *buffer, unsigned int buffer_size);

const MESSAGE_ROUTINE DispatchTable[MAX_MESSAGE_ID];

void DispatchMessage(unsigned int untrusted_message_id, unsigned char *buffer, unsigned int buffer_size) {
    if (untrusted_message_id < MAX_MESSAGE_ID) {
        // SPECULATION BARRIER
        DispatchTable[untrusted_message_id](buffer, buffer_size);
    }
}
```

Как с обращением массива вне допустимых границ загрузить передав другой нагрузки, это условие также могут возникать в сочетании с цикл, который превышает ее завершающий условие из-за ошибочного прогнозирования.

### <a name="speculative-type-confusion"></a>Тип наблюдающей путаницы

Эта категория Шаблоны кода включает в себя условного ветвлений, приводит к путанице наблюдающей типа. Шаблоны кодирования в этом разделе будет ссылаться на приведенном ниже примере кода.

```cpp
enum TypeName {
    Type1,
    Type2
};

class CBaseType {
public:
    CBaseType(TypeName type) : type(type) {}
    TypeName type;
};

class CType1 : public CBaseType {
public:
    CType1() : CBaseType(Type1) {}
    char field1[256];
    unsigned char field2;
};

class CType2 : public CBaseType {
public:
    CType2() : CBaseType(Type2) {}
    void (*dispatch_routine)();
    unsigned char field2;
};

// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

unsigned char ProcessType(CBaseType *obj)
{
    if (obj->type == Type1) {
        // SPECULATION BARRIER
        CType1 *obj1 = static_cast<CType1 *>(obj);

        unsigned char value = obj1->field2;

        return shared_buffer[value * 4096];
    }
    else if (obj->type == Type2) {
        // SPECULATION BARRIER
        CType2 *obj2 = static_cast<CType2 *>(obj);

        obj2->dispatch_routine();

        return obj2->field2;
    }
}
```

#### <a name="speculative-type-confusion-leading-to-an-out-of-bounds-load"></a>Путаницы наблюдающей типа приведет к загрузить вне допустимых границ

Этот способ кодировки входит случай, когда путаницы наблюдающей типа могут привести к вне допустимых границ или доступ к полю путать тип, где загруженное значение веб-каналы адрес последующие загрузки. Это похоже на шаблон массива вне допустимых границ кодирования, но оно представлено через вместо написания последовательности, как показано выше. В этом примере вредоносная контекста может привести к жертвы контекст для выполнения `ProcessType` несколько раз с объектом типа `CType1` (`type` поле равно `Type1`). Это приведет к получению результата обучения условной ветви для первого `if` инструкции для прогнозирования не получен. Вредоносная контекста может привести жертвы контекст для выполнения `ProcessType` с объектом типа `CType2`. Это может привести к путанице наблюдающей тип Если условное ветвление для первого `if` инструкция Неверно предсказанные с и выполняет тело `if` инструкции, таким образом, приведение объекта типа `CType2` для `CType1`. Поскольку `CType2` меньше, чем `CType1`, доступ к памяти для `CType1::field2` результат в наблюдающей вне допустимых границ загрузит данных, которые могут быть секретным. Затем это значение используется в нагрузки из `shard_buffer` наблюдаемый побочные эффекты, что позволяет создавать с помощью массива вне допустимых границ примере описано выше.

#### <a name="speculative-type-confusion-leading-to-an-indirect-branch"></a>Начальные косвенных ветвь путаницы наблюдающей типа

Это шаблоны кодирования включает случай, когда путаницы наблюдающей типа могут привести к ветвь небезопасный косвенных во время выполнения наблюдающей. В этом примере вредоносная контекста может привести к жертвы контекст для выполнения `ProcessType` несколько раз с объектом типа `CType2` (`type` поле равно `Type2`). Это приведет к получению результата обучения условной ветви для первого `if` инструкции для выполнения и `else if` инструкции, которые не должны выполняться. Вредоносная контекста может привести жертвы контекст для выполнения `ProcessType` с объектом типа `CType1`. Это может привести к путанице наблюдающей тип Если условное ветвление для первого `if` инструкции прогнозирует выполнены и `else if` таким образом инструкции прогнозирует не получен, выполняется тело `else if` и приведение объекта типа `CType1` для `CType2`. Поскольку `CType2::dispatch_routine` поле пересекается с `char` массива `CType1::field1`, это может привести к наблюдающей косвенных ветвь в целевом объекте непредусмотренных ветви. Если вредоносная контекст можно управлять байтовых значений в `CType1::field1` массива, они могут смогут управлять конечный адрес ветвления.

## <a name="mitigation-options"></a>Возможности по устранению рисков

Упреждающее исполнение стороне канал уязвимостей можно устранить путем изменения исходного кода. Эти изменения могут включать Сдерживание конкретные экземпляры уязвимость, например, путем добавления *барьера предположение*, или внесения изменений в структуре приложения, чтобы сделать конфиденциальной информации, недоступной, наблюдающей выполнение.

### <a name="speculation-barrier-via-manual-instrumentation"></a>Барьер отражение через инструментарий вручную

Объект *барьера предположение* может быть вставлен вручную разработчика, чтобы прекратить выполнение наблюдающей останавливающие-архитектуры пути. Например, разработчик вставить барьер предположение перед шаблон небезопасные кодирования в теле условный блок, либо в начале блока (после условной ветви) или до первой загрузки, который является важным. Это предотвратит условного ветвлений выполнение небезопасного кода на контуре архитектуры путем выполнения сериализации. Последовательность барьера предположение отличается архитектурой оборудования, как описано в следующей таблице:

|Архитектура|Барьер отражение|
|----------------|----------------|
|x86/x64|_mm_lfence()|
|ARM|В настоящее время недоступна|
|ARM64|В настоящее время недоступна|


Например, следующий шаблон кода можно снизить, используя `_mm_lfence` встроенная функция, как показано ниже.

```cpp
// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

unsigned char ReadByte(unsigned char *buffer, unsigned int buffer_size, unsigned int untrusted_index) {
    if (untrusted_index < buffer_size) {
        _mm_lfence();
        unsigned char value = buffer[untrusted_index];
        return shared_buffer[value * 4096];
    }
}
```

### <a name="speculation-barrier-via-compiler-time-instrumentation"></a>Барьер отражение через компилятора во время инструментирования

Компилятор Visual C++ в Visual Studio 2017 г. (начиная с версии 15.5.5) включает поддержку `/Qspectre` переключатель, который автоматически вставляет барьер отражение для ограниченного набора потенциально уязвимой шаблоны кодирования, связанных с CVE-2017 г-5753. Документация по [/Qspectre](https://docs.microsoft.com/en-us/cpp/build/reference/qspectre) флаг предоставляет дополнительные сведения по его последствия и использования. Важно отметить, что этот флаг не распространяется на все потенциально уязвимой шаблоны кодирования и таким образом разработчики не следует полагаться на его как комплексное решение для этого класса уязвимостей.

### <a name="removing-sensitive-information-from-memory"></a>Удаление конфиденциальной информации из памяти

Другим способом, который может использоваться для уменьшения уязвимости канала стороны наблюдающей выполнения — Чтобы удалить конфиденциальные сведения из памяти. Разработчики программного обеспечения можно искать возможности рефакторинг свои приложения так, чтобы конфиденциальные данные не доступны во время выполнения наблюдающей. Это можно сделать путем оптимизации проектирования приложения, чтобы изолировать конфиденциальные данные в отдельных процессах. Например веб-приложения браузера, попытайтесь изолировать данные, связанные с каждый источник web в отдельные процессы, позволяя избежать один процесс не сможет получить доступ к данным независимо от источника по наблюдающей выполнения.

## <a name="see-also"></a>См. также

[Рекомендации для снижения уязвимости Упреждающее исполнение стороне канала](https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/ADV180002)

[Сдерживание Упреждающее исполнение стороне канал оборудования уязвимостей](https://blogs.technet.microsoft.com/srd/2018/03/15/mitigating-speculative-execution-side-channel-hardware-vulnerabilities/)
