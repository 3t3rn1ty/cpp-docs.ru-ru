---
title: Руководство разработчика C++ для гипотетического каналов стороны выполнения | Документы Microsoft
ms.custom: ''
ms.date: 05/21/2018
ms.technology:
- cpp-windows
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- Visual C++, security
- security [C++]
- security [C++], best practices
- Spectre
- CVE-2017-5753
- Speculative Execution
author: mamillmsft
ms.author: mikeblome
ms.workload:
- cplusplus
ms.openlocfilehash: 515e2223e67d86da12488d9880a1a0a258fc4bdf
ms.sourcegitcommit: 4b2c3b0c720aef42bce7e1e5566723b0fec5ec7f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/22/2018
---
# <a name="c-developer-guidance-for-speculative-execution-side-channels"></a>Руководство разработчика C++ для гипотетического каналов стороны выполнения

Эта статья содержит рекомендации для разработчиков для упрощения идентификации и устранения Упреждающее исполнение стороне канал оборудования уязвимостей в программном обеспечении C++. Эти уязвимости могут содержать конфиденциальные сведения о через границы доверия и может повлиять на программное обеспечение, запущенное процессоров, поддерживающих наблюдающей внеочередной из выполнения инструкции. Этот класс уязвимостей был первым, описанные в январе, 2018 и Дополнительные сведения и инструкции можно найти в [рекомендации по безопасности корпорации Майкрософт](https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/ADV180002).

Руководства, предоставленного в этой статье относится к классы уязвимостей, представленного параметром:

1. CVE-2017 г-5753, также известный как Spectre вариант 1. Этот класс оборудования уязвимость относится к стороне каналов, которые могут возникнуть из-за выполнения наблюдающей, возникшего в результате условного ветвлений. Компилятор Visual C++ в Visual Studio 2017 г. (начиная с версии 15.5.5) включает поддержку `/Qspectre` переключатель, который обеспечивает защиту во время компиляции для ограниченного набора потенциально уязвимой шаблоны кодирования, связанных с CVE-2017 г-5753. Документация по [/Qspectre](https://docs.microsoft.com/en-us/cpp/build/reference/qspectre) флаг предоставляет дополнительные сведения по его последствия и использования.

2. CVE-2018-3639, также известные как [наблюдающей обхода хранилища (SSB)](https://aka.ms/sescsrdssb). Этот класс оборудования уязвимость относится к стороне каналов, которые могут возникнуть из-за выполнения наблюдающей загрузки опережает зависимых хранилища, в результате неверным прогнозированием доступа к памяти.

Вводные сведения доступны Упреждающее исполнение стороне канал уязвимостей можно найти в презентации под названием [случай Spectre и Meltdown](https://www.youtube.com/watch?v=_4O0zMW-Zu4) одним research команд, которые обнаружены следующие проблемы.

## <a name="what-are-speculative-execution-side-channel-hardware-vulnerabilities"></a>Что такое канала со стороны выполнения наблюдающая оборудования уязвимостей

Современных процессоров предоставляют расширенными возможностями производительности, делая использование наблюдающей и ожидания порядок выполнения инструкций. Часто, это достигается путем прогнозирование целью ветвей (условного и косвенных), которая позволяет Процессору начнет гипотетически выполнение инструкции на целевом предсказанные ветви, что позволяет избежать зависания до конечный адрес ветвления фактический Разрешить. В случае, если ЦП позже обнаруживает, что произошло неверным прогнозированием, удаляются все сведения о состоянии компьютера, вычисленная гипотетически. Это гарантирует, что не с точки зрения архитектуры видимые эффекты Неверно предсказанные предположение.

Пока Упреждающее исполнение не влияет на состояние с точки зрения архитектуры видимости, его можно оставить остаточные трассировки-архитектуры состояния, например различные кэши, используемых ресурсов ЦП. Именно эти остаточные трассировки наблюдающей выполнения, которое может привести к появлению уязвимостей стороны канала. Чтобы лучше понять это, рассмотрим следующий фрагмент кода, которой является примером 5753 CVE 2017 г. (проверьте обход границы).

```cpp
// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

unsigned char ReadByte(unsigned char *buffer, unsigned int buffer_size, unsigned int untrusted_index) {
    if (untrusted_index < buffer_size) {
        unsigned char value = buffer[untrusted_index];
        return shared_buffer[value * 4096];
    }
}
```

В этом примере `ReadByte` — предоставленный буфер, размер буфера и индекса в этот буфер. Параметр индекса в соответствии с `untrusted_index`, предоставляемые меньше привилегированного контекста, например обычных процесса. Если `untrusted_index` — меньше, чем `buffer_size`, а затем символ с таким индексом, считанный из `buffer` и используется для индекса в общей области памяти, на который ссылается `shared_buffer`. 

С точки зрения архитектуры этой последовательности кода абсолютно безопасных как гарантируется, что `untrusted_index` всегда будет меньше, чем `buffer_size`. Однако при наличии Упреждающее исполнение это ЦП mispredict условной ветви и выполняет тело, если инструкция, даже когда `untrusted_index` больше или равно `buffer_size`. В результате ЦП может гипотетически считывает байт из-за пределов границы `buffer` (это может быть секрет) и затем может использовать это значение byte для вычисления адрес последующую загрузку через `shared_buffer`. 

Во время ЦП в конечном итоге определит это неверным прогнозированием, остаточные побочные эффекты могут остаться в кэше ЦП, который раскрывать информацию о значении байтов, считанный за пределы допустимого диапазона от `buffer`. Эти побочные эффекты могут быть обнаружены на меньшее привилегированный контекст, запущенных в системе, насколько быстро проверки каждого кэша строку в `shared_buffer` осуществляется. Приведены шаги, которые могут быть выполнены для выполнения этой задачи.

1. **Вызвать `ReadByte` несколько раз с `untrusted_index` , меньше, чем `buffer_size`** . Вредоносная контекста может привести к жертвы контекст для вызова `ReadByte` (например, через RPC) таким образом, что является прогнозом ветвь обучена быть не передано как `untrusted_index` — меньше, чем `buffer_size`.

2. **Очистить все строки кэша в `shared_buffer`** . Вредоносная контекста необходимо очистить кэш строк в области общей памяти, на который ссылается `shared_buffer`. Поскольку область памяти является общим, это довольно просто и может выполняться с помощью встроенных функций, таких как `_mm_clflush`.

3. **Вызвать `ReadByte` с `untrusted_index` , размер которых превышает `buffer_size`** . Контекст вредоносная вызывает жертвы контекст для вызова `ReadByte` таким образом, что неправильно прогнозирует ветвь не будет выполнено. Это приводит процессора гипотетически выполнения основной части if блоке с `untrusted_index` , размер которых превышает `buffer_size`, таким образом, что приведет к выходящие за пределы области чтения из `buffer`. Следовательно `shared_buffer` индексируется с помощью потенциально секретное значение прочитанное вне допустимых границ, тем самым вызывая строки соответствующих кэша загрузки ЦП.

4. **Просмотрите каждую строку кэша в `shared_buffer` для просмотра которой осуществляется быстрее всего**. Вредоносная контекст может считывать каждой строке кэша в `shared_buffer` и определить строку кэша, которая значительно быстрее, чем другие. Это строка кэша, который, скорее всего, которые были перенесены шаге 3. Поскольку между байтов значение и кэша строкой в этом примере имеется отношение 1:1, это позволяет злоумышленнику получить фактическое значение байтов, считанный вне допустимых границ.

Указанные выше шаги укажите с помощью техники, известный как ДИСК + ПЕРЕЗАГРУЗИТЬ в сочетании с использованием экземпляра CVE 2017 г. 5753 пример.

## <a name="what-software-scenarios-can-be-impacted"></a>Могут быть затронуты сценариев программного обеспечения?

Разработка безопасных программного обеспечения с помощью процесса, таких как [жизненного цикла разработки безопасности](https://www.microsoft.com/en-us/sdl/) (SDL) обычно требует разработчиков для определения границы доверия, которые существуют в своих приложениях. Границы доверия существует в местах, где приложение может взаимодействовать с данным, предоставленным менее доверенного контекста, например другой системе или в процессе режим прав администратора в случае драйвер устройства режима ядра. Новый класс уязвимостей, включающих каналы стороны Упреждающее исполнение относится ко многим границы доверия в существующих моделей безопасности программного обеспечения, которые изолировать код и данные на устройстве. 

В следующей таблице приведены Сводка моделей безопасности программного обеспечения, где разработчикам может потребоваться беспокоиться о происходящих уязвимости:

|Граница доверия|Описание|
|----------------|----------------|
|Граница виртуальной машины|Приложения, которые изолируют рабочие нагрузки на отдельных виртуальных машинах, получающих непроверенных данных из другой виртуальной машины может оказаться под угрозой.| 
|Границы ядра|Драйвер устройства режима ядра, который получает непроверенных данных из процесса режим обычных пользователей может оказаться под угрозой.| 
|Границ процесса|Приложения, которое получает непроверенных данных из другой процесс, работающий в локальной системе, например, посредством удаленного вызова процедур (RPC), общая память или другие связи между процесса (IPC) механизмы может оказаться под угрозой.|
|Enclave границ|Приложения, выполняемого в рамках безопасного enclave (например, Intel SGX), принимающий ненадежных данных не из enclave может оказаться под угрозой.|
|Язык границ|Приложение, обрабатывающее или JIT – JIT компилирует и выполняет ненадежного кода, написанного на более высокого уровня языка может оказаться под угрозой.|

Приложения, которые имеют уязвимость предоставляется для любого из указанных выше доверять границы необходимо просмотреть код на уязвимость, чтобы выявлять и устранять возможные экземпляры Упреждающее исполнение стороне канал уязвимостей. Следует отметить, что границы доверия, доступ к области удаленной атаки, например удаленных сетевых протоколов, не была продемонстрирована нарушения Упреждающее исполнение стороне канал уязвимостей.

## <a name="potentially-vulnerable-coding-patterns"></a>Потенциально уязвимой шаблоны кодирования

Упреждающее исполнение стороне канал уязвимости может возникать вследствие нескольких шаблоны кодирования. В этом разделе описаны потенциально уязвимой шаблоны кодирования и примеры для каждого, но он должен распознаваться, могут существовать разновидности эти темы. Таким образом разработчикам рекомендуется использовать эти шаблоны в качестве примеров, а не полный список всех потенциально уязвимой шаблоны кодирования.

Как правило связаны с условной ветвлений стороны Упреждающее исполнение каналы могут возникнуть при условного выражения применяются к данным, управляемому или зависят от контекста, надежный. Например, это может включать условного выражения, используемые в `if`, `for`, `while`, `switch`, или троичный инструкций. Для каждого из этих инструкций компилятор может создать условной ветви, которая ЦП может затем прогнозировать конечный адрес ветвления для во время выполнения.

Для каждого примера вставляется комментарий с фразой «ПРЕДПОЛОЖЕНИЕ БАРЬЕРА» где разработчик может привести к барьер с целью предотвращения. Эта процедура рассматривается более подробно в разделе на способы их устранения.

## <a name="speculative-out-of-bounds-load"></a>Загрузить наблюдающая вне допустимых границ

Шаблоны кода эта категория включает в себя условного ветвлений, пониманию наблюдающей вне допустимых границ доступ к памяти.

### <a name="array-out-of-bounds-load-feeding-a-load"></a>Загрузить массива вне допустимых границ, передав нагрузки

Этот способ кодировки является изначально описанных уязвимым кодирования для 5753 CVE 2017 г. (проверьте обход границы). Фон части этой статьи объясняется подробно этот шаблон.

```cpp
// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

unsigned char ReadByte(unsigned char *buffer, unsigned int buffer_size, unsigned int untrusted_index) {
    if (untrusted_index < buffer_size) {
        // SPECULATION BARRIER
        unsigned char value = buffer[untrusted_index];
        return shared_buffer[value * 4096];
    }
}
```

Аналогичным образом массива вне допустимых границ нагрузка может возникнуть в сочетании с цикл, который превышает ее завершение условие из-за ошибочного прогнозирования. В этом примере условной ветви, связанные с `x < buffer_size` выражение может mispredict и гипотетически выполнения основной части `for` цикла `x` больше или равно `buffer_size`, таким образом в наблюдающей результате Загрузите вне допустимых границ.

```cpp
// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

unsigned char ReadBytes(unsigned char *buffer, unsigned int buffer_size) {
    for (unsigned int x = 0; x < buffer_size; x++) {
        // SPECULATION BARRIER
        unsigned char value = buffer[untrusted_index];
        return shared_buffer[value * 4096];
    }
}
```

### <a name="array-out-of-bounds-load-feeding-an-indirect-branch"></a>Загрузить массива вне допустимых границ передав косвенных ветви

Этот способ кодировки входит случай, где условного ветвлений может привести к вне допустимых границ доступ на массив указателей на функции, какие затем интересы косвенных ветвь в целевой адрес, выходящие за пределы области чтения. Следующий фрагмент кода содержит пример, демонстрирующий это. 

В этом примере идентификатор ненадежных сообщение передается DispatchMessage через `untrusted_message_id` параметра. Если `untrusted_message_id` — меньше, чем `MAX_MESSAGE_ID`, то он используется для индексации массива указателей на функции и переход на соответствующий конечный адрес ветвления. Данный пример кода является безопасным с точки зрения архитектуры, но если ЦП Неверно предсказанные с условной ветви, это может привести к `DispatchTable` с индексом `untrusted_message_id` при его значение больше или равно `MAX_MESSAGE_ID`, таким образом, что приведет к доступ вне допустимых границ. Это может привести к Упреждающее исполнение с адреса целевой ветви, выведенная за пределы массива, что может привести к раскрытию информации в зависимости от того, что гипотетически выполняемый код.

```cpp
#define MAX_MESSAGE_ID 16

typedef void (*MESSAGE_ROUTINE)(unsigned char *buffer, unsigned int buffer_size);

const MESSAGE_ROUTINE DispatchTable[MAX_MESSAGE_ID];

void DispatchMessage(unsigned int untrusted_message_id, unsigned char *buffer, unsigned int buffer_size) {
    if (untrusted_message_id < MAX_MESSAGE_ID) {
        // SPECULATION BARRIER
        DispatchTable[untrusted_message_id](buffer, buffer_size);
    }
}
```

Как с обращением массива вне допустимых границ загрузить передав другой нагрузки, это условие также могут возникать в сочетании с цикл, который превышает ее завершающий условие из-за ошибочного прогнозирования.

## <a name="speculative-type-confusion"></a>Тип наблюдающей путаницы

Эта категория представлены шаблоны, которые могут привести к появлению путаницы наблюдающей тип кода. Это происходит при обращении к памяти с помощью неверного типа-архитектуры пути во время выполнения наблюдающей. Условного ветвлений и обхода наблюдающей хранилище потенциально может привести к путанице наблюдающей типа. 

Для обхода наблюдающей хранилища это может произойти в сценариях, где компилятор использует расположении стека для переменные разных типов. Это из-за архитектуры хранилища данных переменную типа `A` может обойти, позволяя таким образом нагрузку типа `A` гипотетически выполнение перед переменной присваивается. Если ранее сохраненный переменной другого типа, это можно создать условия путаницы наблюдающей типа.

В следующем фрагменте кода для условного ветвлений, будут использоваться для описания различных условий можно предоставить путаницы наблюдающей тип нарастание до.

```cpp
enum TypeName {
    Type1,
    Type2
};

class CBaseType {
public:
    CBaseType(TypeName type) : type(type) {}
    TypeName type;
};

class CType1 : public CBaseType {
public:
    CType1() : CBaseType(Type1) {}
    char field1[256];
    unsigned char field2;
};

class CType2 : public CBaseType {
public:
    CType2() : CBaseType(Type2) {}
    void (*dispatch_routine)();
    unsigned char field2;
};

// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

unsigned char ProcessType(CBaseType *obj)
{
    if (obj->type == Type1) {
        // SPECULATION BARRIER
        CType1 *obj1 = static_cast<CType1 *>(obj);

        unsigned char value = obj1->field2;

        return shared_buffer[value * 4096];
    }
    else if (obj->type == Type2) {
        // SPECULATION BARRIER
        CType2 *obj2 = static_cast<CType2 *>(obj);

        obj2->dispatch_routine();

        return obj2->field2;
    }
}
```

### <a name="speculative-type-confusion-leading-to-an-out-of-bounds-load"></a>Путаницы наблюдающей типа приведет к загрузить вне допустимых границ

Этот способ кодировки входит случай, когда путаницы наблюдающей типа могут привести к вне допустимых границ или доступ к полю путать тип, где загруженное значение веб-каналы адрес последующие загрузки. Это похоже на шаблон массива вне допустимых границ кодирования, но оно представлено через вместо написания последовательности, как показано выше. В этом примере вредоносная контекста может привести к жертвы контекст для выполнения `ProcessType` несколько раз с объектом типа `CType1` (`type` поле равно `Type1`). Это приведет к получению результата обучения условной ветви для первого `if` инструкции для прогнозирования не получен. Вредоносная контекста может привести жертвы контекст для выполнения `ProcessType` с объектом типа `CType2`. Это может привести к путанице наблюдающей тип Если условное ветвление для первого `if` инструкция Неверно предсказанные с и выполняет тело `if` инструкции, таким образом, приведение объекта типа `CType2` для `CType1`. Поскольку `CType2` меньше, чем `CType1`, доступ к памяти для `CType1::field2` результат в наблюдающей вне допустимых границ загрузит данных, которые могут быть секретным. Затем это значение используется в нагрузки из `shared_buffer` наблюдаемый побочные эффекты, что позволяет создавать с помощью массива вне допустимых границ примере описано выше.

### <a name="speculative-type-confusion-leading-to-an-indirect-branch"></a>Начальные косвенных ветвь путаницы наблюдающей типа

Этот способ кодировки входит случай, когда путаницы наблюдающей типа могут привести к ветвь небезопасный косвенных во время выполнения наблюдающей. В этом примере вредоносная контекста может привести к жертвы контекст для выполнения `ProcessType` несколько раз с объектом типа `CType2` (`type` поле равно `Type2`). Это приведет к получению результата обучения условной ветви для первого `if` инструкции для выполнения и `else if` инструкции, которые не должны выполняться. Вредоносная контекста может привести жертвы контекст для выполнения `ProcessType` с объектом типа `CType1`. Это может привести к путанице наблюдающей тип Если условное ветвление для первого `if` инструкции прогнозирует выполнены и `else if` таким образом инструкции прогнозирует не получен, выполняется тело `else if` и приведение объекта типа `CType1` для `CType2`. Поскольку `CType2::dispatch_routine` поле пересекается с `char` массива `CType1::field1`, это может привести к наблюдающей косвенных ветвь в целевом объекте непредусмотренных ветви. Если вредоносная контекст можно управлять байтовых значений в `CType1::field1` массива, они могут смогут управлять конечный адрес ветвления.

## <a name="speculative-uninitialized-use"></a>Используйте наблюдающей неинициализированным

Эта категория Шаблоны кода включает в себя сценарии, где Упреждающее исполнение может получить доступ к неинициализированной памяти и использовать его для последующей загрузки или косвенные ветви. Эти шаблоны кодирования для злоумышленник сможет злоумышленник необходимо иметь возможность управлять или осмысленным образом влияют на содержимое памяти, который используется без инициализации этого контекст, который используется в.

### <a name="speculative-uninitialized-use-leading-to-an-out-of-bounds-load"></a>Наблюдающей неинициализированным используйте приведет к загрузить вне допустимых границ

Наблюдающей неинициализированным используйте потенциально может привести к вне допустимых границ можно загрузить с помощью значение злоумышленнику управлять. В примере ниже значения `index` назначается `trusted_index` во всех путях архитектуры и `trusted_index` считается меньше или равно `buffer_size`. Тем не менее, в зависимости от кода, созданного компилятором, возможна обхода наблюдающей хранилища может произойти в том, позволяющий нагрузки от `buffer[index]` и зависимых выражения для выполнения до присвоения `index`. В этом случае неинициализированное значение для `index` будет использоваться как смещение в `buffer` которого может дать злоумышленнику возможность чтения вне допустимых границ конфиденциальной информации и делать выводы, это через канал через зависимых нагрузку на стороне `shared_buffer` .

```cpp
// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

void InitializeIndex(unsigned int trusted_index, unsigned int *index) {
    *index = trusted_index;
}

unsigned char ReadByte(unsigned char *buffer, unsigned int buffer_size, unsigned int trusted_index) {
    unsigned int index;

    InitializeIndex(trusted_index, &index); // not inlined

    // SPECULATION BARRIER
    unsigned char value = buffer[index];
    return shared_buffer[value * 4096];
}
```

### <a name="speculative-uninitialized-use-leading-to-an-indirect-branch"></a>Наблюдающей неинициализированным используйте начальные косвенных ветвь

Наблюдающей неинициализированным используйте потенциально может привести к ветвь косвенных которых конечный адрес ветвления управляется злоумышленник. В следующем примере `routine` назначается либо `DefaultMessageRoutine1` или `DefaultMessageRoutine` в зависимости от значения `mode`. В архитектуре пути, в результате `routine` всегда инициализировать опережает косвенных ветви. Однако в зависимости от кода, созданного компилятором, обход наблюдающей хранилища может возникнуть, позволяющий косвенных ветвь через `routine` гипотетически выполняться до присвоения `routine`. В этом случае злоумышленник может быть невозможно выполнить гипотетически из произвольных адрес, при условии, что злоумышленник может повлиять на или контролировать неинициализированным значение `routine`.

```cpp
#define MAX_MESSAGE_ID 16

typedef void (*MESSAGE_ROUTINE)(unsigned char *buffer, unsigned int buffer_size);

const MESSAGE_ROUTINE DispatchTable[MAX_MESSAGE_ID];
extern unsigned int mode;

void InitializeRoutine(MESSAGE_ROUTINE *routine) {
    if (mode == 1) {
        *routine = &DefaultMessageRoutine1;
    }
    else {
        *routine = &DefaultMessageRoutine;
    }
}

void DispatchMessage(unsigned int untrusted_message_id, unsigned char *buffer, unsigned int buffer_size) {
    MESSAGE_ROUTINE routine;

    InitializeRoutine(&routine); // not inlined

    // SPECULATION BARRIER
    routine(buffer, buffer_size);
}
```

## <a name="mitigation-options"></a>Возможности по устранению рисков

Упреждающее исполнение стороне канал уязвимостей можно устранить путем изменения исходного кода. Эти изменения могут включать Сдерживание конкретные экземпляры уязвимость, например, путем добавления *барьера предположение*, или внесения изменений в структуре приложения, чтобы сделать конфиденциальной информации, недоступной, наблюдающей выполнение.

### <a name="speculation-barrier-via-manual-instrumentation"></a>Барьер отражение через инструментарий вручную

Объект *барьера предположение* может быть вставлен вручную разработчика, чтобы прекратить выполнение наблюдающей останавливающие-архитектуры пути. Например, разработчик вставить барьер предположение перед шаблон небезопасные кодирования в теле условный блок, либо в начале блока (после условной ветви) или до первой загрузки, который является важным. Это предотвратит условного ветвлений выполнение небезопасного кода на контуре архитектуры путем выполнения сериализации. Последовательность барьера предположение отличается архитектурой оборудования, как описано в следующей таблице:

|Архитектура|Встроенная функция для CVE-2017 г-5753 барьера отражение|Встроенная функция для CVE-2018-3639 барьера отражение|
|----------------|----------------|----------------|
|x86/x64|_mm_lfence()|_mm_lfence()|
|ARM|в настоящее время недоступно|__dsb(0)|
|ARM64|в настоящее время недоступно|__dsb(0)|

Например, следующий шаблон кода можно снизить, используя `_mm_lfence` встроенная функция, как показано ниже.

```cpp
// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

unsigned char ReadByte(unsigned char *buffer, unsigned int buffer_size, unsigned int untrusted_index) {
    if (untrusted_index < buffer_size) {
        _mm_lfence();
        unsigned char value = buffer[untrusted_index];
        return shared_buffer[value * 4096];
    }
}
```

### <a name="speculation-barrier-via-compiler-time-instrumentation"></a>Барьер отражение через компилятора во время инструментирования

Компилятор Visual C++ в Visual Studio 2017 г. (начиная с версии 15.5.5) включает поддержку `/Qspectre` переключатель, который автоматически вставляет барьер отражение для ограниченного набора потенциально уязвимой шаблоны кодирования, связанных с CVE-2017 г-5753. Документация по [/Qspectre](https://docs.microsoft.com/en-us/cpp/build/reference/qspectre) флаг предоставляет дополнительные сведения по его последствия и использования. Важно отметить, что этот флаг не распространяется на все потенциально уязвимой шаблоны кодирования и таким образом разработчики не следует полагаться на его как комплексное решение для этого класса уязвимостей.

## <a name="masking-array-indices"></a>Индексы массивов маски

В случаях, где наблюдающей вне допустимых границ загрузки может возникнуть, индекс массива можно быть строго ограничены по архитектуре и архитектуры пути Добавление логики явно привязано индекса массива. Например если массив можно выделить до размера, который выравнивается по возведения в квадрат, затем простой маски могут быть введены. Это показано в следующем примере, где предполагается, что `buffer_size` выравнивается по возведения в квадрат. Это гарантирует, что `untrusted_index` — всегда меньше, чем `buffer_size`, даже если происходит условного ветвлений и `untrusted_index` передается с значение больше или равно `buffer_size`.

Следует отметить, что здесь выполняется маски индекса могут быть применены обхода наблюдающей хранилища, в зависимости от того, код, созданный компилятором.

```cpp
// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

unsigned char ReadByte(unsigned char *buffer, unsigned int buffer_size, unsigned int untrusted_index) {
    if (untrusted_index < buffer_size) {
        untrusted_index &= (buffer_size - 1);
        unsigned char value = buffer[untrusted_index];
        return shared_buffer[value * 4096];
    }
}
```

## <a name="removing-sensitive-information-from-memory"></a>Удаление конфиденциальной информации из памяти

Другим способом, который может использоваться для уменьшения уязвимости канала стороны наблюдающей выполнения — Чтобы удалить конфиденциальные сведения из памяти. Разработчики программного обеспечения можно искать возможности рефакторинг свои приложения так, чтобы конфиденциальные данные не доступны во время выполнения наблюдающей. Это можно сделать путем оптимизации проектирования приложения, чтобы изолировать конфиденциальные данные в отдельных процессах. Например веб-приложения браузера, попытайтесь изолировать данные, связанные с каждый источник web в отдельные процессы, позволяя избежать один процесс не сможет получить доступ к данным независимо от источника по наблюдающей выполнения.

## <a name="see-also"></a>См. также

[Рекомендации для снижения уязвимости стороне канала Упреждающее исполнение](https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/ADV180002)
[Сдерживание Упреждающее исполнение стороне канал оборудования уязвимостей](https://blogs.technet.microsoft.com/srd/2018/03/15/mitigating-speculative-execution-side-channel-hardware-vulnerabilities/)