---
title: Одномерные массивы | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-language
ms.topic: language-reference
dev_langs:
- C++
helpviewer_keywords:
- brackets [ ]
- brackets [ ], arrays
- one-dimensional arrays
- arrays [C++], one-dimensional
- square brackets [ ]
- square brackets [ ], arrays
- subscript expressions
ms.assetid: e28536e5-3b77-46b5-97fd-9b938c771816
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: a8d7366a2c0a1b8ae9ed4e37eaaa89de9baf794d
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
---
# <a name="one-dimensional-arrays"></a>Одномерные массивы
Постфиксное выражение, за которым следует выражение в квадратных скобках (**[ ]**), является представлением элемента объекта массива с индексом. Выражение с индексом в представленной ниже форме ссылается на значение, размешенное по адресу на *expression* позиций дальше *postfix-expression*:  
  
```  
  
postfix-expression  
[  
expression  
]  
  
```  
  
 Обычно *postfix-expression* является указателем, например идентификатором массива, а *expression* является целочисленным значением. Однако все, что необходимо синтаксически, — это чтобы одно из выражений имело тип указателя, а другие — целочисленный тип. Таким образом, целочисленное значение может находиться в позиции *postfix-expression*, а значение указателя — в "позиции индекса", т. е. *expression*. Например, такой код является допустимым:  
  
```  
// one_dimensional_arrays.c  
int sum, *ptr, a[10];  
int main() {  
   ptr = a;  
   sum = 4[ptr];  
}  
```  
  
 Выражения индекса обычно используются для ссылки на элементы массива, но индекс может применяться к любому указателю. Независимо от порядка значений, выражение *expression* должно быть заключено в квадратные скобки (**[ ]**).  
  
 Выражение индекса вычисляется путем добавления целочисленного значения к значению указателя, а результат передается в оператор косвенного обращения (**\***). (Этот механизм обсуждается в статье [Операторы косвенного обращения и адреса операнда](../c-language/indirection-and-address-of-operators.md).) В конечном итоге в случае одномерного массива следующие 4 выражения эквивалентны, при условии что `a` является указателем, а `b` — целым числом:  
  
```  
a[b]  
*(a + b)  
*(b + a)  
b[a]  
```  
  
 В соответствии с правилами преобразования для оператора сложения (их описание вы найдете в статье [Аддитивные операторы в C](../c-language/c-additive-operators.md)) целочисленное значение преобразуется в смещение адреса путем умножения целочисленного значения на длину типа, на который указывает указатель.  
  
 Например, предположим, что идентификатор `line` ссылается на массив значений `int`. Для вычисления выражения индекса `line[ i ]` используется следующая процедура:  
  
1.  Целочисленное значение `i` умножается на количество байт, определенное как длина элемента `int`. Преобразованное значение `i` представляет позиции `i` `int`.  
  
2.  Это преобразованное значение добавляется к исходному значению указателя (`line`) для получения адреса, представляющего позиции, смещенные на `i` `int` относительно `line`.  
  
3.  Оператор косвенного обращения применяется к новому адресу. Результат представляет собой значение элемента массива в этой позиции (интуитивно, `line [ i ]`).  
  
 Выражение индекса `line[0]` представляет значение первого элемента массива line, поскольку смещение от адреса, представляемого `line`, равно 0. Аналогично, выражение `line[5]` ссылается на элемент, смещенный на 5 позиций относительно line, или на шестой элемент массива.  
  
## <a name="see-also"></a>См. также  
 [Subscript Operator](../cpp/subscript-operator.md) (Подстрочный оператор)