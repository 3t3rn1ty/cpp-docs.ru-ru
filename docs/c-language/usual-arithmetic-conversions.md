---
title: "Обычные арифметические преобразования | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
  - "C"
helpviewer_keywords: 
  - "арифметические преобразования [C++]"
  - "арифметические операторы [C++], преобразования типов"
  - "преобразования [C++], арифметические"
  - "преобразование типов данных [C++], арифметические"
  - "операторы [C], арифметические преобразования"
  - "преобразование типов [С++], арифметические"
ms.assetid: bfa49803-0efd-45d0-b987-111412a140d7
caps.latest.revision: 7
caps.handback.revision: 7
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Обычные арифметические преобразования
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Большинство операторов C выполняют преобразования типов для приведения операндов выражения к общему типу или для расширения коротких значений в соответствии с размером целого числа, используемым в машинных операциях.  Преобразования, выполняемые с помощью операторов С, зависят от конкретного оператора и типа операнда или операндов.  Однако многие операторы выполняют аналогичные преобразования с операндами целочисленного типа и типа с плавающей запятой.  Эти преобразования называются арифметическими преобразованиями. В результате преобразования значения операнда в совместимый тип значение не меняется.  
  
 Арифметические преобразования, представленные ниже, называются обычными арифметическими преобразованиями. Эти шаги применяются только к бинарным операторам, ожидающим арифметический тип.  Цель — получить общий тип, который также будет типом результата.  Чтобы определить, какие преобразования выполняются на самом деле, компилятор применяет следующий алгоритм к бинарным операциям в выражении.  Шаги ниже представлены не в порядке приоритета.  
  
1.  Если какой\-либо из операндов имеет тип `long double`, то другой операнд преобразуется в тип `long double`.  
  
2.  Если вышеуказанное условие не выполняется и какой\-либо из операндов имеет тип **double**, то другой операнд преобразуется в тип **double**.  
  
3.  Если два вышеуказанных условия не выполняются и какой\-либо из операндов имеет тип **float**, то другой операнд преобразуется в тип **float**.  
  
4.  Если три вышеуказанных условия не выполняются \(ни один из операндов не принадлежит типам с плавающей запятой\), то целочисленные преобразования операндов выполняются следующим образом.  
  
    -   Если какой\-либо из операндов имеет тип `unsigned long`, то другой операнд преобразуется в тип `unsigned long`.  
  
    -   Если вышеуказанное условие не выполняется и какой\-либо из операндов имеет тип **long**, а другой операнд имеет тип `unsigned int`, то оба операнда преобразуются в тип `unsigned long`.  
  
    -   Если два вышеуказанных условия не выполняются и какой\-либо из операндов имеет тип **long**, то другой операнд преобразуется в тип **long**.  
  
    -   Если три вышеуказанных условия не выполняются и какой\-либо из операндов имеет тип `unsigned int`, то другой операнд преобразуется в тип `unsigned int`.  
  
    -   Если ни одно из вышеуказанных условий не соблюдается, то оба операнда преобразуются в тип `int`.  
  
 Эти правила преобразования демонстрируются в следующем примере.  
  
```  
float   fVal;  
double  dVal;  
int   iVal;  
unsigned long ulVal;  
  
dVal = iVal * ulVal; /* iVal converted to unsigned long  
                      * Uses step 4.  
                      * Result of multiplication converted to double   
                      */  
dVal = ulVal + fVal; /* ulVal converted to float  
                      * Uses step 3.  
                      * Result of addition converted to double   
                      */   
```  
  
## См. также  
 [Операторы в C](../c-language/c-operators.md)