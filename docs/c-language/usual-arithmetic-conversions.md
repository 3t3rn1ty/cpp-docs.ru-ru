---
title: "Обычные арифметические преобразования | Документация Майкрософт"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-language
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
helpviewer_keywords:
- arithmetic conversions [C++]
- type conversion [C++], arithmetic
- operators [C], arithmetic conversions
- data type conversion [C++], arithmetic
- conversions [C++], arithmetic
- arithmetic operators [C++], type conversions
ms.assetid: bfa49803-0efd-45d0-b987-111412a140d7
caps.latest.revision: 7
author: mikeblome
ms.author: mblome
manager: ghogen
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: Human Translation
ms.sourcegitcommit: d6eb43b2e77b11f4c85f6cf7e563fe743d2a7093
ms.openlocfilehash: 2dd676c9e566e0b0ed67a2ea6d9f1222582f0815
ms.contentlocale: ru-ru
ms.lasthandoff: 05/18/2017

---
# <a name="usual-arithmetic-conversions"></a>Обычные арифметические преобразования
Большинство операторов C выполняют преобразования типов для приведения операндов выражения к общему типу или для расширения коротких значений в соответствии с размером целого числа, используемым в машинных операциях. Преобразования, выполняемые с помощью операторов С, зависят от конкретного оператора и типа операнда или операндов. Однако многие операторы выполняют аналогичные преобразования с операндами целочисленного типа и типа с плавающей запятой. Эти преобразования называются арифметическими преобразованиями. В результате преобразования значения операнда в совместимый тип значение не меняется.  
  
 Арифметические преобразования, представленные ниже, называются обычными арифметическими преобразованиями. Эти шаги применяются только к бинарным операторам, ожидающим арифметический тип. Цель — получить общий тип, который также будет типом результата. Чтобы определить, какие преобразования выполняются на самом деле, компилятор применяет следующий алгоритм к бинарным операциям в выражении. Шаги ниже представлены не в порядке приоритета.  
  
1.  Если какой-либо из операндов имеет тип `long double`, то другой операнд преобразуется в тип `long double`.  
  
2.  Если вышеуказанное условие не выполняется, а один из операндов имеет тип **double**, то второй операнд преобразуется в тип **double**.  
  
3.  Если оба вышеуказанных условия не выполняются, а один из операндов имеет тип **float**, то второй операнд преобразуется в тип **float**.  
  
4.  Если три вышеуказанных условия не выполняются (ни один из операндов не принадлежит типам с плавающей запятой), то целочисленные преобразования операндов выполняются следующим образом.  
  
    -   Если какой-либо из операндов имеет тип `unsigned long`, то другой операнд преобразуется в тип `unsigned long`.  
  
    -   Если вышеуказанное условие не выполняется, при этом один из операндов имеет тип **long**, а второй — тип `unsigned int`, то оба операнда преобразуются в тип `unsigned long`.  
  
    -   Если два вышеуказанных условия не выполняются, а один из операндов имеет тип **long**, то второй операнд преобразуется в тип **long**.  
  
    -   Если три вышеуказанных условия не выполняются и какой-либо из операндов имеет тип `unsigned int`, то другой операнд преобразуется в тип `unsigned int`.  
  
    -   Если ни одно из вышеуказанных условий не соблюдается, то оба операнда преобразуются в тип `int`.  
  
 Эти правила преобразования демонстрируются в следующем примере.  
  
```  
float   fVal;  
double  dVal;  
int   iVal;  
unsigned long ulVal;  
  
dVal = iVal * ulVal; /* iVal converted to unsigned long  
                      * Uses step 4.  
                      * Result of multiplication converted to double   
                      */  
dVal = ulVal + fVal; /* ulVal converted to float  
                      * Uses step 3.  
                      * Result of addition converted to double   
                      */   
```  
  
## <a name="see-also"></a>См. также  
 [Операторы в C](../c-language/c-operators.md)
