---
title: "Преобразования из типов чисел без знака | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
  - "C"
helpviewer_keywords: 
  - "преобразование типов данных [C++], целые числа со знаком и без"
  - "целые числа, преобразование"
  - "преобразования целочисленных типов, из чисел без знака"
  - "приведения типа, включение целых чисел"
  - "преобразование типов [С++], целые числа со знаком и без"
ms.assetid: 60fb7e10-bff9-4a13-8a48-e19f25a36a02
caps.latest.revision: 10
caps.handback.revision: 10
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Преобразования из типов чисел без знака
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Целое число без знака преобразуется в более короткое целое число без знака или со знаком путем усечения битов высокого порядка или в более длинное целое число со знаком или без знака путем нулевого расширения \(см. таблицу [Преобразования целочисленных типов без знака](#_clang_table_4..3) \).  
  
 Если значение с целочисленным типом понижено до целого числа со знаком меньшего размера или целое число без знака преобразовано в соответствующее целое число со знаком, значение остается неизменным, если его можно представить в новом типе.  Однако это значение представляет изменения, если бит знака задан, как показано в следующем примере.  
  
```  
int j;  
unsigned short k = 65533;  
  
j = k;  
printf_s( "%hd\n", j );   // Prints -3  
```  
  
 Если осуществить представление невозможно, результат определяется реализацией.  См. раздел [Преобразования приведений типа](../c-language/type-cast-conversions.md) для получения сведений об обработке понижения целых чисел компилятором Microsoft C.  То же поведение является результатом преобразования целого числа или типового приведения целого числа.  
  
 Значения без знака преобразуются так, чтобы сохранить свое значение, и не представлены непосредственно в С.  Единственное исключение — это преобразование из `unsigned long` в **float**, которое теряется на уровне битов самого низкого порядка.  В противном случае значение сохраняется \(со знаком или без\).  Если значение целочисленного типа преобразуется в тип с плавающей запятой и это значение находится за пределами представляемого диапазона, результат не определен. \(См. раздел [Сохранение базовых типов](../c-language/storage-of-basic-types.md) для получения сведений о диапазоне для целочисленных типов и типов с плавающей запятой.\)  
  
 В следующей таблице перечислены преобразования из целочисленных типов без знака.  
  
### Преобразования из целочисленных типов без знака  
  
|Исходный тип|Целевой тип|Метод|  
|------------------|-----------------|-----------|  
|`unsigned char`|`char`|Сохранение битового шаблона; бит высокого порядка становится битом знака|  
|`unsigned char`|**short**|Нулевое расширение|  
|`unsigned char`|**long**|Нулевое расширение|  
|`unsigned char`|**unsigned short**|Нулевое расширение|  
|`unsigned char`|`unsigned long`|Нулевое расширение|  
|`unsigned char`|**float**|Преобразование в значение **long**; преобразование значения **long** в **float**|  
|`unsigned char`|**double**|Преобразование в значение **long**; преобразование значения **long** в **double**|  
|`unsigned char`|`long double`|Преобразование в значение **long**; преобразование значения **long** в **double**|  
|**unsigned short**|`char`|Сохранение байта низкого порядка|  
|**unsigned short**|**short**|Сохранение битового шаблона; бит высокого порядка становится битом знака|  
|**unsigned short**|**long**|Нулевое расширение|  
|**unsigned short**|`unsigned char`|Сохранение байта низкого порядка|  
|**unsigned short**|`unsigned long`|Нулевое расширение|  
|**unsigned short**|**float**|Преобразование в значение **long**; преобразование значения **long** в **float**|  
|**unsigned short**|**double**|Преобразование в значение **long**; преобразование значения **long** в **double**|  
|**unsigned short**|`long double`|Преобразование в значение **long**; преобразование значения **long** в **double**|  
|`unsigned long`|`char`|Сохранение байта низкого порядка|  
|`unsigned long`|**short**|Сохранение слова низкого порядка|  
|`unsigned long`|**long**|Сохранение битового шаблона; бит высокого порядка становится битом знака|  
|`unsigned long`|`unsigned char`|Сохранение байта низкого порядка|  
|`unsigned long`|**unsigned short**|Сохранение слова низкого порядка|  
|`unsigned long`|**float**|Преобразование в значение **long**; преобразование значения **long** в **float**|  
|`unsigned long`|**double**|Непосредственное преобразование в **double**|  
|`unsigned long`|`long double`|Преобразование в значение **long**; преобразование значения **long** в **double**|  
  
 **Блок, относящийся только к системам Microsoft**  
  
 Для 32\-разрядного компилятора Microsoft С тип `unsigned int` эквивалентен типу `unsigned long`.  Преобразование значения `unsigned int` выполняется так же, как и преобразование `unsigned long`.  Преобразования значений `unsigned long` в **float** не точны, если преобразуемое значение больше, чем максимальное положительное значение **long** со знаком.  
  
 **Завершение блока, относящегося только к системам Microsoft**  
  
## См. также  
 [Преобразования назначений](../c-language/assignment-conversions.md)