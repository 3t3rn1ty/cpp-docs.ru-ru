---
title: "Аргументы | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "аргументы [C++], функция"
  - "аргументы функций"
  - "вызовы функций, аргументы"
  - "параметры функции"
  - "параметры функции, сведения о параметрах функции"
  - "функции [C], параметры"
ms.assetid: 14cf0389-2265-41f0-9a96-f2223eb406ca
caps.latest.revision: 7
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 7
---
# Аргументы
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Аргументы в вызове функции могут иметь следующую форму:  
  
```  
  
expression ( expression-list <SUB>opt</SUB> )  /* Function call */  
```  
  
 В вызове функции параметр *список\-выражений* обозначает список выражений, которые разделяются запятыми.  Значения этих выражений являются аргументами, которые передаются функции.  Если функция не принимает аргументы, то в *списке\-выражений* должно содержаться ключевое слово `void`.  
  
 Аргументом может быть любое значение фундаментального типа или типа структуры, объединения или указателя.  Все аргументы передаются по значению.  Это означает, что параметру присваивается копия соответствующего аргумента,  а где именно переданный аргумент находится в памяти, функции неизвестно.  Она лишь обрабатывает полученную копию, не затрагивая исходную переменную.  
  
 Хотя массивы и функции не могут передаваться в качестве аргументов, вы можете передать указатели на них.  Благодаря этому функция сможет обращаться к значению по ссылке.  Поскольку указатель на переменную содержит адрес переменной, то функция может обращаться к значению по этому адресу.  Аргументы\-указатели позволяют функции обращаться к массивам и функциям, хотя сами они и не могут передаваться в качестве аргументов.  
  
 Порядок вычисления аргументов может различаться в зависимости от конкретного компилятора и уровня оптимизации.  Однако аргументы и все побочные эффекты полностью вычисляются до входа в функцию.  Дополнительные сведения см. в разделе [Побочные эффекты](../c-language/side-effects.md).  
  
 Все выражения из *списка\-выражений* в вызове функции вычисляются. С каждым аргументом выполняются обычные арифметические преобразования.  Если доступен прототип, то результат вычисления аргументов сравнивается по типу с соответствующим параметром прототипа.  Если они не совпадают, то либо выполняется преобразование, либо выводится диагностическое сообщение.  Для параметров также проводятся обычные арифметические преобразования.  
  
 Количество выражений в *списке\-выражений* должно соответствовать количеству параметров. Единственное исключение — когда в прототипе или определении функции явно указано переменное количество аргументов.  В этом случае компилятор проверяет столько аргументов, сколько имен типов содержится в списке параметров. При необходимости он преобразует их, как описано выше.  Дополнительные сведения см. в разделе [Вызовы с переменным числом аргументов](../c-language/calls-with-a-variable-number-of-arguments.md).  
  
 Если список параметров прототипа содержит только ключевое слово `void`, то компилятор не ожидает ни аргументов в вызове функции, ни параметров в определении.  Если аргументы будут обнаружены, он выведет диагностическое сообщение.  
  
## Пример  
 В следующем примере в качестве аргументов используются указатели:  
  
```  
int main()  
{  
    /* Function prototype */  
  
    void swap( int *num1, int *num2 );  
    int x, y;  
    .  
    .  
    .  
    swap( &x, &y );  /* Function call */  
}  
  
/* Function definition */  
  
void swap( int *num1, int *num2 )  
{  
    int t;  
  
    t = *num1;  
    *num1 = *num2;  
    *num2 = t;  
}  
```  
  
 В этом примере функция `swap` объявлена внутри функции `main`. Она имеет два аргумента, `num1` и `num2`, которые являются указателями на значения типа `int`.  Параметры `num1` и `num2` в определении прототипа также объявляются как указатели на значения типа `int`.  
  
 Функция вызывается следующей инструкцией:  
  
```  
swap( &x, &y )  
```  
  
 Адрес `x`, который здесь используется, сохраняется в аргументе `num1`, а адрес `y` — в аргументе `num2`.  Теперь для одного и того же местоположения имеется два имени, или псевдонима.  Ссылки на значения `*num1` и `*num2` в функции `swap` одновременно представляют собой ссылки на значения `x` и `y` в функции `main`.  Присваивания внутри функции `swap`, по сути, меняют содержимое переменных `x` и `y`.  Поэтому оператор `return` не требуется.  
  
 Компилятор выполняет проверку типов для аргументов функции `swap`, поскольку в прототипе `swap` указаны типы аргументов для каждого параметра.  Идентификаторы, приведенные в круглых скобках в прототипе и определении функции, могут совпадать, но могут и различаться.  Важно лишь то, что типы аргументов в функции должны соответствовать типам параметров как в прототипе, так и в определении.  
  
## См. также  
 [Вызовы функций](../c-language/function-calls.md)