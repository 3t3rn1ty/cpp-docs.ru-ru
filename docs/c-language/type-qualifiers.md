---
title: "Квалификаторы типов | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
  - "C"
helpviewer_keywords: 
  - "const - ключевое слово [C]"
  - "память, доступ с использованием оператора volatile"
  - "квалификаторы для типов"
  - "квалификаторы типов"
  - "volatile - ключевое слово [C]"
  - "volatile - ключевое слово [C], квалификатор типа"
  - "volatile - ключевое слово [C], спецификатор типов"
ms.assetid: bb4c6744-1dd7-40a8-b4eb-f5585be30908
caps.latest.revision: 7
caps.handback.revision: 7
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Квалификаторы типов
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Квалификаторы типов предоставляют идентификатору одно из двух свойств.  Квалификатор типа **const** объявляет объект как неизменяемый.  Квалификатор типа `volatile` объявляет элемент, значение которого можно изменить допустимым образом с помощью средств, недоступных программе, в которой он находится, таких как выполняемый в данный момент поток.  
  
 Квалификаторы типов **const** и `volatile` могут использоваться в объявлении только один раз.  Квалификаторы типов могут использоваться с любым описателем типа; однако они не могут находиться после первой запятой в объявлении нескольких элементов.  Например, следующие объявления допустимы.  
  
```  
typedef volatile int VI;  
const int ci;  
```  
  
 Следующие объявления не допустимы.  
  
```  
typedef int *i, volatile *vi;  
float f, const cf;     
```  
  
 Квалификаторы типов имеют смысл только при обращении к идентификаторам как к l\-значениям в выражениях.  Дополнительные сведения об l\-значениях и выражениях см. в разделе [Выражения l\-значений и r\-значений](../Topic/L-Value%20and%20R-Value%20Expressions.md).  
  
## Синтаксис  
 *квалификатор\-типа*:  
 **constvolatile**  
  
 Ниже представлены допустимые объявления **const** и `volatile`.  
  
```  
int const *p_ci;       /* Pointer to constant int */  
int const (*p_ci);     /* Pointer to constant int */  
int *const cp_i;       /* Constant pointer to int */  
int (*const cp_i);     /* Constant pointer to int */  
int volatile vint;     /* Volatile integer        */  
```  
  
 Если спецификация типа массива включает квалификаторы типов, определяется элемент, а не тип массива.  Если спецификация типа функции включает квалификаторы, поведение не определено.  Ни `volatile`, ни **const** не влияет на диапазон значений или арифметические свойства объекта.  
  
 В следующем списке приводится описание использования **const** и `volatile`.  
  
-   Ключевое слово **const** можно использовать для изменения любого фундаментального или агрегатного типа, указателя на объект любого типа или `typedef`.  Если элемент объявлен только с квалификатором типа **const**, считается, что он имеет тип **const int**.  Переменную **const** можно инициализировать или поместить в область хранения, доступную только для чтения.  Ключевое слово **const** полезно при объявлении указателей на **const**, поскольку для этого требуется, чтобы функция не изменяла указатель.  
  
-   Компилятор предполагает, что в любом месте программы к переменной `volatile` можно получить доступ в ходе неизвестного процесса, в котором используется или изменяется ее значение.  Следовательно, независимо от оптимизаций, указанных в командной строке, необходимо создать код для каждого назначения переменной `volatile` или ссылки на нее, даже если кажется, что это ничего не изменит.  
  
     Если `volatile` используется отдельно, предполагается `int`.  Описатель типа `volatile` можно использовать для предоставления надежного доступа к специальным адресам памяти.  Используйте `volatile` с объектами данных, к которым можно получить доступ или которые можно изменить с помощью обработчиков сигналов, одновременного выполнения программ или специального оборудования, например регистров управления MMIO.  Можно объявить переменную как `volatile` на протяжении ее времени жизни или привести одну ссылку ко значению `volatile`.  
  
-   Элемент может быть и **const**, и `volatile`. В последнем случае элемент невозможно изменить допустимым образом в собственной программе, но можно изменить в некотором асинхронном процессе.  
  
## См. также  
 [Объявления и типы](../c-language/declarations-and-types.md)