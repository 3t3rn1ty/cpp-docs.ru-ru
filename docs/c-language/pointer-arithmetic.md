---
title: "Вычисления с указателями | Документация Майкрософт"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-language
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
helpviewer_keywords:
- pointer arithmetic
- arithmetic pointer
ms.assetid: eb924a29-59d3-48a5-9d62-9424790730eb
caps.latest.revision: 
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: 94f18b8a81cfde8d45a4e9e0256dd99a21bdd6a8
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="pointer-arithmetic"></a>Расчеты с указателями
Операции сложения, выполняемые с указателем и целым числом, дают значимые результаты, только если операнд-указатель адресует элемент массива, а целое число задает смещение в пределах этого массива. Когда целое значение преобразуется в смещение адреса, компилятор предполагает, что между исходным адресом и адресом плюс смещение в памяти находятся только элементы одинакового размера.  
  
 Это предположение верно для элементов массива. По определению, массив представляет собой ряд значений одного и того же типа; его элементы размещаются в памяти в последовательных расположениях. Однако в случае любых других типов, кроме элементов массивов, не гарантируется, что память будет заполнена идентификаторами одинакового типа. То есть, между позициями в памяти могут быть пропуски, даже если это позиции одного типа. Поэтому операции сложения или вычитания, выполняемые с адресами любых элементов, кроме элементов массивов, дают неопределенные результаты.  
  
 Аналогично, когда производится вычитание значений двух указателей, при преобразовании предполагается, что между адресами, заданными операндами, лежат только значения одного типа, без пропусков.  
  
## <a name="see-also"></a>См. также  
 [Аддитивные операторы в C](../c-language/c-additive-operators.md)