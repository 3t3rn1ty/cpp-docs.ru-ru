---
title: "Преобразования с приведением типов | Документация Майкрософт"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-language
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
helpviewer_keywords:
- data type conversion [C++], type-cast conversions
- conversions [C++], type-cast
- type casts
- explicit type conversions
- type casts [C++], about type-cast conversion
- type-cast conversions [C++]
ms.assetid: 57ab5902-f12f-4326-a2f6-6282f1d4025a
caps.latest.revision: 
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: f402eb49e86c8d6d3ce6c332172375125f577a2b
ms.sourcegitcommit: 9239c52c05e5cd19b6a72005372179587a47a8e4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/16/2018
---
# <a name="type-cast-conversions"></a>Преобразования приведений типов
Приведения типов можно использовать для явного преобразования типов.  
  
 **Синтаксис**  
  
 *cast-expression*:  
 *унарное выражение*  
  
 **(**  *type-name*  **)**  *cast-expression*  
  
 *type-name*:  
 *specifier-qualifier-list abstract-declarator* opt  
  
 *type-name* обозначает тип, а *cast-expression* содержит значение, которое требуется привести к этому типу. Выражение с приведением типов не является L-значением. *cast-expression* преобразуется так, как если бы оно было присвоено переменной с типом *type-name*. Правила преобразования при операциях присваивания (которые описаны в статье [Преобразования назначений](../c-language/assignment-conversions.md)) применяются и к приведению типов. В следующей таблице показаны типы, которые могут приводиться к любому заданному типу.  
  
### <a name="legal-type-casts"></a>Допустимые приведения типов  
  
|Целевые типы|Потенциальные источники|  
|-----------------------|-----------------------|  
|Целочисленные типы|Любой целочисленный тип, тип с плавающей запятой или указатель на объект|  
|С плавающей запятой|Любой арифметический тип|  
|Указатель на объект или (**void \***)|Любой целочисленный тип, (**void \***), указатель на объект или указатель функции|  
|Указатель на функцию|Любой целочисленный тип, указатель на объект или указатель функции|  
|Структура, объединение или массив|Нет|  
|Тип void|Любой тип|  
  
 Любой идентификатор можно привести к типу `void`. Однако если тип, указанный в выражении приведения типа, отличается от типа `void`, идентификатор, приводимый к этому типу, не может быть выражением `void`. Любое выражение можно привести к типу `void`, но выражение типа `void` невозможно привести к любому другому типу. Например, функция с возвращаемым типом `void` не может иметь обратное приведение к другому типу.  
  
 Обратите внимание, что выражение **void \*** содержит указатель типа `void`, а не тип `void`. Если объект приводится к типу `void`, результирующее выражение невозможно присвоить никакому элементу. Аналогично объект приведения типа не является приемлемым L-значением, поэтому для такого объекта невозможно выполнить присваивание.  
  
 **Блок, относящийся только к системам Microsoft**  
  
 Приведение типа может быть выражением L-значения, если размер идентификатора не изменяется. Дополнительные сведения о левосторонних значениях см. в статье [Выражения L-Value и R-Value](../c-language/l-value-and-r-value-expressions.md).  
  
 **Завершение блока, относящегося только к системам Майкрософт**  
  
 Выражение можно преобразовать в тип `void` с помощью приведения, но результирующее выражение можно использовать только в том случае, если значение не требуется. После преобразования в тип **void \*** и обратно в исходный тип любой указатель объекта возвращается к своему исходному значению.  
  
## <a name="see-also"></a>См. также  
 [Преобразования типов](../c-language/type-conversions-c.md)