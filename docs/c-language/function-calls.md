---
title: "Вызовы функций | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
  - "C"
helpviewer_keywords: 
  - "вызовы функций"
  - "вызовы функций, о вызовах функции"
  - "вызовы функций, функции C"
  - "функции [C], вызов"
ms.assetid: 2cfa897d-3874-4820-933c-e624f75d1712
caps.latest.revision: 8
caps.handback.revision: 8
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Вызовы функций
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

*Вызовом функции* называется выражение, которое передает функции управление и аргументы \(если они есть\) и имеет следующую форму:  
  
 *expression* \(*expression\-list* \(необязательно\)\)  
  
 где *expression* — имя функции или выражение, результатом которого является адрес функции, а *expression\-list* — список выражений \(разделенных запятыми\).  Значения этих выражений являются аргументами, которые передаются функции.  Если функция не возвращает значения, то при ее объявлении необходимо указать, что она возвращает тип `void`.  
  
 Если объявление указывается до вызова функции, однако информация о ее параметрах не приводится, то для любых необъявленных аргументов выполняются обычные арифметические преобразования.  
  
> [!NOTE]
>  Выражения в списке аргументов функции могут оцениваться в любом порядке, поэтому аргументы, значения которых могут изменяться в качестве побочного эффекта других аргументов, имеют неопределенные значения.  Точка следования, определяемая оператором вызова функции, гарантирует только то, что все побочные эффекты в списке аргументов будут оценены до того, как управление будет передано вызванной функции. \(Обратите внимание, что порядок, в котором аргументы отправляются в стек, — это отдельная тема.\) Дополнительные сведения см. в разделе [Точки следования](../c-language/c-sequence-points.md).  
  
 Единственное требование к любому вызову функции заключается в том, что выражение перед скобками должно иметь своим результатом адрес функции.  Это означает, что функцию можно вызвать любым выражением, значением которого является указатель функции.  
  
## Пример  
 В следующем примере представлен вызов функций, совершаемый из оператора `switch`:  
  
```  
int main()  
{  
    /* Function prototypes */  
  
    long lift( int ), step( int ), drop( int );  
    void work( int number, long (*function)(int i) );  
  
    int select, count;  
    .  
    .  
    .  
    select = 1;  
    switch( select )   
    {  
        case 1: work( count, lift );  
                break;  
  
        case 2: work( count, step );  
                break;  
  
        case 3: work( count, drop );  
                /* Fall through to next case */  
        default:  
                break;  
    }  
}  
  
/* Function definition */  
  
void work( int number, long (*function)(int i) )  
{  
    int i;  
    long j;  
  
    for ( i = j = 0; i < number; i++ )  
            j += ( *function )( i );  
}  
```  
  
 В этом примере вызов функции располагается в функции `main`:  
  
```  
work( count, lift );  
```  
  
 Он передает функции `work` целочисленную переменную `count`, а также адрес функции `lift`.  Обратите внимание, что адрес функции передается просто в виде идентификатора функции, поскольку он равен выражению указателя.  Чтобы идентификатор функции можно было использовать таким образом, функцию необходимо объявить и определить до того, как будет использован идентификатор; в противном случае идентификатор не будет распознан.  В этом случае прототип функции `work` задан в начале функции `main`.  
  
 Параметр `function` в функции `work` объявлен как указатель на функцию, принимающую один аргумент типа `int` и возвращающую значение типа **long**.  Скобки вокруг имени параметра являются обязательными. без них это объявление будет означать, что функция возвращает указатель на значение типа **long**.  
  
 Функция `work` вызывает выбранную функцию из цикла **for** при помощи следующего вызова функции:  
  
```  
( *function )( i );  
```  
  
 Вызываемой функции передается один аргумент, `i`:  
  
## См. также  
 [Функции](../Topic/Functions%20\(C\).md)