---
title: "Основанные указатели (C) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
  - "C"
helpviewer_keywords: 
  - "__based - ключевое слово [C]"
  - "основанная адресация"
  - "основанные указатели"
  - "указатели, основанный"
ms.assetid: b5446920-89e0-4e2f-91f3-1f2a769a08e8
caps.latest.revision: 10
caps.handback.revision: 10
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Основанные указатели (C)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

**Блок, относящийся только к системам Microsoft**  
  
 [\_\_based \(Справочник по C \+\+\)](../Topic/Based%20Pointers%20\(C++\).md)  
  
 В 32\- и 64\-разрядных компиляторах Microsoft базовый указатель является 32\- или 64\-разрядным смещением от 32\- или 64\-разрядной базы указателя.  Базовая адресация полезна для управления разделами, в которых размещены объекты, поскольку уменьшается размер исполняемого файла и увеличивается скорость выполнения.  Как правило, используется следующая форма определения относительного указателя.  
  
```  
  
type __based( base ) declarator   
```  
  
 Вариант базовой адресации, основанный на указателе, позволяет использовать спецификацию указателя в качестве базы.  В свою очередь, относительный указатель является смещением в раздел памяти, который начинается в начале указателя, на котором он основан.  Указатели, основанные на адресах указателей, являются единственной формой ключевого слова `__based`, допустимой в 32\- и 64\-разрядных компиляциях.  В таких компиляциях они представляют собой 32\- или 64\-разрядные смещения от 32\- или 64\-разрядной базы.  
  
 Указатели на основе указателей, в частности, используются для постоянных идентификаторов, которые содержат указатели.  Связанный список, состоящий из указателей на основе указателей, можно сохранить на диск, а затем перезагрузить в другое место в памяти. При этом все указатели останутся действительными.  
  
 В следующем примере показан указатель на основе указателя.  
  
```  
void *vpBuffer;  
  
struct llist_t  
{  
    void __based( vpBuffer ) *vpData;  
    struct llist_t __based( vpBuffer ) *llNext;  
};  
```  
  
 Указателю `vpBuffer` назначается адрес в памяти, который выделяется на более позднем этапе программы.  Связанный список перемещается относительно значения `vpBuffer`.  
  
 **Завершение блока, относящегося только к системам Microsoft**  
  
## См. также  
 [Деклараторы и объявления переменных](../c-language/declarators-and-variable-declarations.md)