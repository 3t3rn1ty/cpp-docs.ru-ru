---
title: "Идентификаторы C | Документация Майкрософт"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-language
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
helpviewer_keywords:
- identifiers, C
- naming identifiers
- identifiers
- symbols, C identifiers
- identifiers, case sensitivity
- symbols, case sensitivity
ms.assetid: d02edbbc-85a0-4118-997b-84ee6b972eb6
caps.latest.revision: 12
author: mikeblome
ms.author: mblome
manager: ghogen
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: Human Translation
ms.sourcegitcommit: d6eb43b2e77b11f4c85f6cf7e563fe743d2a7093
ms.openlocfilehash: fca83b12e469401fe18632a1df9f876964b8a493
ms.contentlocale: ru-ru
ms.lasthandoff: 05/18/2017

---
# <a name="c-identifiers"></a>Идентификаторы C
"Идентификаторы" или "символы" — это имена, задаваемые в программе для переменных, типов, функций и меток. Написание и регистр символов в именах идентификаторов должны отличаться от всех ключевых слов. Не допускается использовать ключевые слова (C или Microsoft) в качестве идентификаторов; они зарезервированы для специального применения. Идентификатор создается путем его указания в объявлении переменной, типа или функции. В этом примере `result` представляет собой идентификатор целой переменной, а `main` и `printf` — это имена идентификаторов для функций.  
  
```  
#include <stdio.h>  
  
int main()  
{  
    int result;  
  
    if ( result != 0 )  
        printf_s( "Bad file handle\n" );  
}  
```  
  
 Объявленный идентификатор можно использовать в последующих операторах программы для ссылки на соответствующее значение.  
  
 Специальный вид идентификатора, называемый меткой оператора, может использоваться в операторах `goto`. (Объявления рассматриваются в разделе [Объявления и типы](../c-language/declarations-and-types.md). Метки операторов рассматриваются в разделе [Оператор goto и помеченные операторы](../c-language/goto-and-labeled-statements-c.md).)  
  
## <a name="syntax"></a>Синтаксис  
 *identifier*:  
 *nondigit*  
  
 *identifier nondigit*  
  
 *identifier digit*  
  
 `nondigit`: один из следующих символов:  
 **_ a b c d e f g h i j k l m n o p q r s t u v w x y z**  
  
 **A B C D E F G H I J K L M N O P Q R S T U V W X Y Z**  
  
 `digit`: один из следующих символов:  
 **0 1 2 3 4 5 6 7 8 9**  
  
 Первый символ имени идентификатора должен принадлежать к группе `nondigit` (т. е., первым символом должен быть знак подчеркивания или прописная либо строчная буква). Стандарт ANSI допускает 6 значащих символов в имени внешнего идентификатора и 31 символ для имен внутренних (внутри функции) идентификаторов. На имена внешних идентификаторов (идентификаторов, объявленных в глобальной области или с классом хранения `extern`) могут накладываться дополнительные ограничения, поскольку эти идентификаторы должны обрабатываться другим программным обеспечением, таким как компоновщики.  
  
 **Блок, относящийся только к системам Майкрософт**  
  
 Хотя стандарт ANSI допускает 6 значащих символов в именах внешних идентификаторов и 31 символ в именах внутренних (внутри функции) идентификаторов, компилятор Microsoft C допускает 247 символов в именах внутренних и внешних идентификаторов. Если совместимость со стандартом ANSI не требуется, можно увеличить или уменьшить это значение по умолчанию с помощью параметра /H (ограничение длины внешних имен).  
  
 **Завершение блока, относящегося только к системам Майкрософт**  
  
 В компиляторе языка C прописные и строчные буквы считаются разными символами. Эта особенность, называемая "учетом регистра", позволяет создавать различные идентификаторы, состоящие из одинаковых букв в различных регистрах. Например, каждый из следующих идентификаторов является уникальным:  
  
```  
add  
ADD  
Add  
aDD  
```  
  
 **Блок, относящийся только к системам Майкрософт**  
  
 Не выбирайте для идентификаторов имена, которые начинаются с двух символов подчеркивания или с одного символа подчеркивания и последующей прописной буквы. Стандарт ANSI языка C разрешает резервировать имена идентификаторов, начинающиеся с таких сочетаний символов, для использования компилятором. Идентификаторы с областью действия на уровне файлов также не должны начинаться со знака подчеркивания и последующей строчной буквы. Имена идентификаторов, начинающиеся с таких символов, также зарезервированы. По принятому соглашению в системах Microsoft символ подчеркивания и прописная букву используются в начале имен макросов, а два символа подчеркивания используются для специальных ключевых слова систем Microsoft. Во избежание каких-либо конфликтов имен никогда не выбирайте имена идентификаторов, которые начинаются с одного или двух символов подчеркивания или с символа подчеркивания и последующей прописной буквы.  
  
 **Завершение блока, относящегося только к системам Майкрософт**  
  
 Ниже приведены примеры допустимых идентификаторов, которые соответствуют ограничениям на имена, накладываемым стандартом ANSI или системами Microsoft:  
  
```  
j  
count  
temp1  
top_of_page  
skip12  
LastNum  
```  
  
 **Блок, относящийся только к системам Майкрософт**  
  
 Хотя по умолчанию в файлах исходного кода учитывается регистр символов в идентификаторах, в символах объектных файлов регистр не учитывается. Microsoft C обрабатывает идентификаторы в единице компиляции с учетом регистра.  
  
 Компоновщик Microsoft учитывает регистр. Необходимо указывать все идентификаторы единообразно с учетом регистра.  
  
 "Исходная кодировка" — это набор допустимых символов, которые могут использоваться в файлах исходного кода. Для Microsoft C исходной кодировкой является стандартный набор символов ASCII. Исходная кодировка и кодировка выполнения содержат символы ASCII, используемые в виде escape-последовательностей. Сведения о кодировке выполнения см. в статье [Константы символов в C](../c-language/c-character-constants.md).  
  
 **Завершение блока, относящегося только к системам Майкрософт**  
  
 У идентификатора имеется "область", т. е. область программы, в которой он определен, и "компоновка", которая определяет, ссылается ли то же самое имя из другой области на этот же идентификатор. Эти вопросы рассматриваются в разделе [Время существования, область, видимость и компоновка](../c-language/lifetime-scope-visibility-and-linkage.md).  
  
## <a name="see-also"></a>См. также  
 [Элементы языка C](../c-language/elements-of-c.md)
