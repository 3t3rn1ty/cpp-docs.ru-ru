---
title: "Контейнеры STL | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "Стандартная библиотека C++, контейнеры класса шаблонов"
  - "контейнеры STL"
ms.assetid: 8e915ca1-19ba-4f0d-93c8-e2c3bfd638eb
caps.latest.revision: 29
author: "corob-msft"
ms.author: "corob"
manager: "ghogen"
caps.handback.revision: 29
---
# Контейнеры STL
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Стандартная библиотека предоставляет различные типобезопасные контейнеры для хранения коллекций связанных объектов. Контейнеры — это шаблоны классов. При объявлении переменной контейнера указывается тип элементов, которые будет содержать контейнер. Контейнеры могут создаваться с использованием списков инициализаторов. Они содержат функции-члены для добавления и удаления элементов и выполнения других операций.  
  
 Перебор элементов в контейнере и доступ к отдельным элементам с помощью [итераторы](../Topic/Iterators.md). Вы можете использовать итераторы явно, с помощью их функций-членов и операторов, а также глобальных функций. Вы можете также использовать их неявно, например с помощью цикла range-for. Итераторы для всех контейнеров STL имеют общий интерфейс, но каждый контейнер определяет собственные специализированные итераторы.  
  
 Контейнеры можно разделить на три категории: последовательные контейнеры, ассоциативные контейнеры и контейнеры-адаптеры.  
  
##  <a name="a-namesequencecontainersa-sequence-containers"></a><a name="sequence_containers"></a> Контейнеры последовательности  
 Последовательные контейнеры поддерживают указанный пользователем порядок вставляемых элементов.  
  
 Контейнер `vector` ведет себя как массив, но может автоматически увеличиваться по мере необходимости. Он поддерживает прямой доступ и связанное хранение и имеет очень гибкую длину. По этим и многим другим причинам контейнер `vector` является наиболее предпочтительным последовательным контейнером для большинства областей применения. Если вы сомневаетесь в выборе вида последовательного контейнера, начните с использования вектора. Дополнительные сведения см. в разделе [класс vector](vector%20Class.md).  
  
 Контейнер `array` обладает некоторыми преимуществами контейнера `vector`, однако его длина не обладает такой гибкостью. Дополнительные сведения см. в разделе [класс array](../standard-library/array-class-stl.md).  
  
 Контейнер `deque` (двусторонняя очередь) обеспечивает быструю вставку и удаление в начале и в конце контейнера. Он, как и контейнер `vector`, обладает преимуществами прямого доступа и гибкой длины, но не обеспечивает связанное хранение. Дополнительные сведения см. в разделе [класс deque](../standard-library/deque-class.md).  
  
 Контейнер `list` — это двунаправленный список, который обеспечивает двунаправленный доступ, быструю вставку и удаления в любом месте контейнера, но не поддерживает прямой доступ к элементам контейнера. Дополнительные сведения см. в разделе [класс list](../standard-library/list-class.md).  
  
 Контейнер `forward_list` — однонаправленный список. Это версия контейнера `list` только с доступом в прямом направлении. Дополнительные сведения см. в разделе [класс forward_list](../standard-library/forward-list-class.md).  
  
## <a name="associative-containers"></a>Ассоциативные контейнеры  
 В ассоциативных контейнерах элементы вставляются в предварительно определенном порядке — например, с сортировкой по возрастанию. Также доступны неупорядоченные ассоциативные контейнеры. Ассоциативные контейнеры можно объединить в два подмножества: сопоставления (set) и наборы (map).  
  
 Контейнер `map`, который иногда называют словарем, состоит из пар "ключ-значение". Ключ используется для упорядочивания последовательности, а значение связано с ключом. Например, `map` может содержать ключи, представляющие каждое уникальное ключевое слово в тексте, и соответствующие значения, которые обозначают количество повторений каждого слова в тексте. `map` — это неупорядоченная версия `unordered_map`. Дополнительные сведения см. в разделе [класс map](../Topic/map%20Class.md) и [класс unordered_map](../standard-library/unordered-map-class.md).  
  
 `set` — это контейнер уникальных элементов, упорядоченных по возрастанию. Каждое его значение также является и ключом. `set` — это неупорядоченная версия `unordered_set`. Дополнительные сведения см. в разделе [класс](../standard-library/set-class.md) и [класс unordered_set](../standard-library/unordered-set-class.md).  
  
 Контейнеры `map` и `set` разрешают вставку только одного экземпляра ключа или элемента. Если необходимо включить несколько экземпляров элемента, следует использовать контейнер `multimap` или `multiset`. Неупорядоченные версии этих контейнеров — `unordered_multimap` и `unordered_multiset`. Дополнительные сведения см. в разделе [класс multimap](../standard-library/multimap-class.md), [класс unordered_multimap](../standard-library/unordered-multimap-class.md), [класс multiset](../Topic/multiset%20Class.md), и [класс unordered_multiset](../standard-library/unordered-multiset-class.md).  
  
 Упорядоченные контейнеры map и set поддерживают двунаправленные итераторы, а их неупорядоченный аналоги — итераторы с перебором в прямом направлении. Дополнительные сведения см. в разделе [итераторы](../Topic/Iterators.md).  
  
### <a name="heterogeneous-lookup-in-associative-containers-c14"></a>Разнородный поиск в ассоциативных контейнерах (C++ 14)  
 Упорядоченные ассоциативные контейнеры (сопоставление, мультиотображение, набор и мультинабор) теперь поддерживают разнородный поиск. Это означает, что вам больше не нужно передавать объект точно такого же типа как ключ или элемент в функциях-членах, таких как `find()` и `lower_bound()`. Вы можете передать объект любого типа, для которого определен перегруженный `operator<`, позволяющий выполнять сравнение с типом ключа.  
  
 Разнородный поиск включается дополнительно, когда указывается средство сравнения "ромбовидный функтор" `std::less<>` или `std::greater<>` при объявлении переменной контейнера, как показано ниже:  
  
```  
std::set<BigObject, std::less<>> myNewSet;  
```  
  
 Если используется средство сравнения, заданное по умолчанию, контейнер ведет себя точно так же, как в C++ 11 и более ранних версиях.  
  
 В следующем примере показано, как можно перегрузить `operator<`, чтобы дать возможность пользователям `std::set` выполнять поиск, просто передав небольшую строку, которую можно сравнивать с членом `BigObject::id` каждого объекта.  
  
```  
#include <set>  
#include <string>  
#include <iostream>  
#include <functional>  
  
using namespace std;  
  
class BigObject  
{  
public:  
    string id;  
    explicit BigObject(const string& s) : id(s) {}  
    bool operator< (const BigObject& other) const  
    {  
        return this->id < other.id;  
    }  
  
    // Other members....  
};  
  
inline bool operator<(const string& otherId, const BigObject& obj)  
{  
    return otherId < obj.id;  
}  
  
inline bool operator<(const BigObject& obj, const string& otherId)  
{  
    return obj.id < otherId;  
}  
  
int main()  
{  
    // Use C++14 brace-init syntax to invoke BigObject(string).  
    // The s suffix invokes string ctor. It is a C++14 user-defined  
    // literal defined in <string>  
    BigObject b1{ "42F"s };   
    BigObject b2{ "52F"s };  
    BigObject b3{ "62F"s };  
    set<BigObject, less<>> myNewSet; // C++14  
    myNewSet.insert(b1);  
    myNewSet.insert(b2);  
    myNewSet.insert(b3);  
    auto it = myNewSet.find(string("62F"));  
    if (it != myNewSet.end())  
        cout << "myNewSet element = " << it->id << endl;   
    else  
        cout << "element not found " << endl;  
  
    // Keep console open in debug mode:  
    cout << endl << "Press Enter to exit.";  
    string s;  
    getline(cin, s);  
    return 0;  
}  
  
//Output: myNewSet element = 62F  
  
```  
  
 Следующие функции-члены в контейнерах "сопоставление", "мультиотображение", "набор" и "мультинабор" были перегружены для поддержки разнородного поиска:  
  
1.  find  
  
2.  count  
  
3.  lower_bound  
  
4.  upper_bound  
  
5.  equal_range  
  
## <a name="container-adapters"></a>Контейнеры-адаптеры  
 Контейнер-адаптер — это разновидность последовательного или ассоциативного контейнера, который ограничивает интерфейс для простоты и ясности. Контейнеры-адаптеры не поддерживают итераторы.  
  
 Контейнер `queue` соответствует семантике FIFO (первым поступил — первым обслужен). Первый элемент *передается*— то есть, помещается в очередь — должен быть первым *извлекается*— то есть, удаленных из очереди. Дополнительные сведения см. в разделе [класс queue](../standard-library/queue-class.md).  
  
 Контейнер `priority_queue` упорядочен таким образом, что первым в очереди всегда оказывается элемент с наибольшим значением. Дополнительные сведения см. в разделе [класс priority_queue](../standard-library/priority-queue-class.md).  
  
 Контейнер `stack` соответствует семантике LIFO (последним поступил — первым обслужен). Последний элемент, отправленный в стек, становится первым извлекаемым элементом. Дополнительные сведения см. в разделе [класс stack](../standard-library/stack-class.md).  
  
 Поскольку контейнеры-адаптеры не поддерживают итераторы, их нельзя использовать в алгоритмах STL. Дополнительные сведения см. в разделе [алгоритмы](../standard-library/algorithms.md).  
  
## <a name="requirements-for-container-elements"></a>Требования для элементов контейнеров  
 Как правило, элементы, вставленные в контейнер STL, могут быть практически любого типа объекта, если их можно копировать. Элементы, доступные только для перемещения — например, объекты `vector<unique_ptr<T>>`, создаваемые с помощью `unique_ptr<>`, — также можно использовать, если вы не вызываете функции-члены, которые пытаются скопировать их.  
  
 Деструктору не разрешено вызывать исключение.  
  
 Для упорядоченных ассоциативных контейнеров — ранее описанных в этом разделе — необходимо определить открытый оператор сравнения. (По умолчанию это оператор `operator<`, однако поддерживаются даже типы, которые не работают с `operator<`.)  
  
 Для некоторых операций в контейнерах может также потребоваться открытый конструктор по умолчанию и открытый оператор равенства. Например, неупорядоченным ассоциативным контейнерам требуется поддержка сравнения на равенство и хэширования.  
  
## <a name="accessing-container-elements"></a>Доступ к элементам контейнера  
 Доступ к элементам контейнеров осуществляется с помощью итераторов. Дополнительные сведения см. в разделе [итераторы](../Topic/Iterators.md).  
  
> [!NOTE]
>  Можно также использовать [основе диапазонов для циклов](../Topic/Range-based%20for%20Statement%20\(C++\).md) для перебора коллекций STL.  
  
## <a name="comparing-containers"></a>Сравнение контейнеров  
 Все контейнеры перегружают оператор == для сравнения двух контейнеров одного типа, содержащих элементы одного типа. Можно использовать == для сравнения вектора \< строка> к другому вектору \< строка>, но его нельзя использовать для сравнения вектора \< строка> в список \< строка> или вектор \< строка> вектор \< char * >.  В C ++ 98/03 можно использовать [std::equal](../Topic/equal.md) или [std::mismatch](../Topic/mismatch.md) для сравнения контейнеров разного типа или типов элементов. В C ++ 11 можно также использовать [std::is_permutation](../Topic/is_permutation.md). Но во всех этих случаях при работе функций предполагается, что контейнеры имеют одинаковую длину. Если второй диапазон короче первого, результат будет неопределенным. Если второй диапазон длиннее, результат также может быть неверным, поскольку сравнение не будет выполнено за пределами первого диапазона.  
  
### <a name="comparing-dissimilar-containers-c14"></a>Сравнение контейнеров разного типа (C++ 14)  
 В C ++ 14 и более поздних версиях можно сравнивать контейнеры и элементы разного типа с помощью одного из [std::equal](../Topic/equal.md), [std::mismatch](../Topic/mismatch.md), или [std::is_permutation](../Topic/is_permutation.md) функция перегрузки, которые принимают два полных диапазона. Эти перегрузки позволяют сравнивать контейнеры разной длины. Эти перегрузки намного менее подвержены ошибкам пользователя и оптимизированы для возврата значения false в одно и то же время, когда сравниваются контейнеры разной длины. Поэтому рекомендуется использовать эти перегрузки, если (1) есть отчетливую Причина не или (2) вы используете [std::list](../standard-library/list-class.md) контейнер, в котором не реализуются преимущества двух диапазонной оптимизации.  
  
## <a name="see-also"></a>См. также раздел  
 [Контейнеры](../Topic/Containers%20\(Modern%20C++\).md)   
 [Библиотека стандартных шаблонов](../misc/standard-template-library.md)   
 [\< образец контейнера>](../standard-library/sample-container.md)   
 [Потокобезопасность в стандартной библиотеке C++](../standard-library/thread-safety-in-the-cpp-standard-library.md)

