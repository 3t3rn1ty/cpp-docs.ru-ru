---
title: "Операторы &lt;new&gt; | Документы Майкрософт"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords:
- new/std::operator delete
- new/std::operator new
ms.assetid: d1af4b56-9a95-4c65-ab01-bf43e982c7bd
caps.latest.revision: 8
manager: ghogen
translationtype: Machine Translation
ms.sourcegitcommit: 3f69f0c3176d2fbe19e11ce08c071691a72d858d
ms.openlocfilehash: c74b76d842878bb2811a5ff9714cb6d2cfa436b3
ms.lasthandoff: 02/24/2017

---
# <a name="ltnewgt-operators"></a>Операторы &lt;new&gt;
||||  
|-|-|-|  
|[Оператор delete](#operator_delete)|[Оператор delete[]](#operator_delete_arr)|[Оператор new](#operator_new)|  
|[Оператор new[]](#operator_new_arr)|  
  
##  <a name="operator_delete"></a>  Оператор delete  
 Функция, вызываемая с помощью выражения delete для отмены выделения хранилища для отдельных объектов.  
  
```
void operator delete(void* ptr) throw();

void operator delete(void *,
    void*) throw();

void operator delete(void* ptr,
    const std::nothrow_t&) throw();
```  
  
### <a name="parameters"></a>Параметры  
 `ptr`  
 Указатель, значение которого при удалении устанавливается в недействительное.  
  
### <a name="remarks"></a>Примечания  
 Первая функция вызывается с помощью выражения удаления для установки значения `ptr` в недействительное. Программа может определить функцию с помощью сигнатуры этой функции, которая заменяет версию по умолчанию из стандартной библиотеки C++. Требуемое поведение — принимать значение `ptr` (null или результат предыдущего вызова [оператора new](../standard-library/new-operators.md#operator_new)( **size_t**)).  
  
 По умолчанию при значении null для `ptr` функция не должна выполнять никаких действий. Любое другое значение `ptr` должно быть значением, возвращенным ранее в результате вызова, как описано выше. Поведение по умолчанию для значения `ptr`, отличного от null, — освободить память, выделенную предыдущим вызовом. Не уточняется, при каких условиях часть или вся такая освобожденная память должна выделяться последующим вызовом `operator new`( **size_t**), `calloc`( **size_t**), `malloc`( **size_t**) или `realloc`( **void\***, **size_t**).  
  
 Вторая функция вызывается помещением выражения delete, соответствующего новому выражению, в форме **new**( **std::size_t**). Она ничего не делает.  
  
 Третья функция вызывается помещением выражения delete, соответствующего новому выражению, в форме **new**( **std::size_t**, **conststd::nothrow_t&**). Программа может определить функцию с помощью сигнатуры этой функции, которая заменяет версию по умолчанию из стандартной библиотеки C++. Требуемое поведение: принимать значение `ptr` — null или результат возврата предыдущего вызова `operator new`( **size_t**). Поведение по умолчанию — вычислить **delete**( `ptr`).  
  
### <a name="example"></a>Пример  
  См. раздел [Оператор new](../standard-library/new-operators.md#operator_new) с примером использования `operator delete`.  
  
##  <a name="operator_delete_arr"></a>  Оператор delete[]  
 Функция, вызываемая с помощью выражения delete для отмены выделения хранилища для массива объектов.  
  
```
void operator delete[](void* ptr) throw();

void operator delete[](void *,
    void*) throw();

void operator delete[](void* ptr,
    const std::nothrow_t&) throw();
```  
  
### <a name="parameters"></a>Параметры  
 `ptr`  
 Указатель, значение которого при удалении устанавливается в недействительное.  
  
### <a name="remarks"></a>Примечания  
 Первая функция вызывается выражением `delete[]` и устанавливает значение `ptr` в недействительное. Это заменяемая функция, так как в программе можно определить функцию с сигнатурой этой функции, которая заменит версию по умолчанию из стандартной библиотеки C++. Требуемое поведение: принимать значение `ptr` — null или то, что было возвращено при предыдущем вызове [оператора new&#91;&#93;](../standard-library/new-operators.md#operator_new_arr)( **size_t**). По умолчанию при значении null для `ptr` функция не должна выполнять никаких действий. Любое другое значение `ptr` должно быть значением, возвращенным ранее в результате вызова, как описано выше. Поведение по умолчанию для значения `ptr`, отличного от null, — освободить память, выделенную предыдущим вызовом. Не указано, при каких условиях часть или вся такая освобожденная память должна выделяться последующим вызовом [оператора new](../standard-library/new-operators.md#operator_new)( **size_t**), `calloc`( **size_t**), `malloc`( **size_t**) или `realloc`( **void\***, **size_t**).  
  
 Вторая функция вызывается помещением выражения `delete[]`, соответствующего выражению `new[]` в форме `new[]`( **std::size_t**). Она ничего не делает.  
  
 Третья функция вызывается помещением выражения delete, соответствующего выражению `new[]` в форме `new[]`( **std::size_t**, **const std::nothrow_t&**). Программа может определить функцию с помощью сигнатуры этой функции, которая заменяет версию по умолчанию из стандартной библиотеки C++. Требуемое поведение: принимать значение `ptr`  или результат предыдущего вызова оператора `new[]`( **size_t**). Поведение по умолчанию — вычислить `delete[]`( `ptr`).  
  
### <a name="example"></a>Пример  
  См. раздел [Оператор new&#91;&#93;](../standard-library/new-operators.md#operator_new_arr) с примерами использования `operator delete[]`.  
  
##  <a name="operator_new"></a>  Оператор new  
 Функция вызывается выражением new для выделения памяти для отдельных объектов.  
  
```
void* operator new(std::size_t count) throw(bad_alloc);

void* operator new(std::size_t count,
    const std::nothrow_t&) throw();

void* operator new(std::size_t count,
    void* ptr) throw();
```  
  
### <a name="parameters"></a>Параметры  
 `count`  
 Количество байт памяти для выделения.  
  
 `ptr`  
 Возвращаемый указатель.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Указатель на адрес младшего байта выделенной памяти. Или `ptr.`  
  
### <a name="remarks"></a>Примечания  
 Первая функция вызывается выражением new для выделения `count` байт памяти, подходящим образом выровненных для представления любого объекта такого размера. Программа может определить альтернативную функцию с сигнатурой этой функции, что заменит версию по умолчанию из стандартной библиотеки C++, поэтому функция является заменяемой.  
  
 Требуемое поведение — вернуть указатель, отличный от null, только если память может быть выделена, как это запрошено. Каждое такое выделение выдает указатель на память, которая не пересекается ни с одной другой выделенной памятью. Порядок и непрерывность памяти, выделяемой последовательными вызовами, не уточняется. Начальное сохраненное значение не уточняется. Возвращаемый указатель указывает на начало (адрес младшего байта) выделенной памяти. Если счетчик равен нулю, возвращенное значение не будет равно ни одному другому значению, возвращенному функцией.  
  
 Поведение по умолчанию — выполнить цикл. Внутри цикла функция сначала пытается выделить запрошенную память. Будут ли эти попытки включать вызов `malloc`( **size_t**), не уточняется. Если попытка успешна, функция возвращает указатель на выделенную память. В противном случае функция вызывает назначенный [обработчик new](../standard-library/new-typedefs.md#new_handler). Если вызванная функция возвращает управление, цикл повторяется. Цикл прекращается, когда попытка выделения запрошенной памяти завершилась успехом или если вызванная функция не вернула управление.  
  
 Требуемое поведение обработчика new — выполнить одну из следующих операций:  
  
-   Сделать больше памяти, доступной для выделения, и завершить выполнение.  
  
-   Вызвать либо **abort**, либо **exit**( `int`).  
  
-   Выдать объект типа **bad_alloc.**  
  
 Поведение по умолчанию для [обработчика new](../standard-library/new-typedefs.md#new_handler) — выдать объект типа `bad_alloc`. Пустой указатель обозначает обработчик new по умолчанию.  
  
 Порядок и непрерывность памяти, выделяемой последовательными вызовами `operator new`( **size_t**) не уточняется, как и начальные значения, которые там сохраняются.  
  
 Вторая функция вызывается выражением new для выделения `count` байт памяти, подходящим образом выровненных для представления любого объекта такого размера. Программа может определить альтернативную функцию с сигнатурой этой функции, что заменит версию по умолчанию из стандартной библиотеки C++, поэтому функция является заменяемой.  
  
 Поведением по умолчанию является возврат `operator new`( `count`), если эта функция выполняется успешно. В противном случае метод возвращает пустой указатель.  
  
 Третья функция вызывается выражением **new** в форме **new** ( *args*) T. Здесь *args* состоит из одного указателя на объект. Это может быть полезно для создания объекта по известному адресу. Функция возвращает *ptr*.  
  
 Для освобождения памяти, выделенной `operator new`, следует вызвать [оператор delete](../standard-library/new-operators.md#operator_delete).  
  
 Для информации о поведении new с выдачей исключений и без выдачи исключений см. раздел [Операторы new и delete](../cpp/new-and-delete-operators.md).  
  
### <a name="example"></a>Пример  
  
```cpp  
// new_op_new.cpp  
// compile with: /EHsc  
#include<new>  
#include<iostream>  
  
using namespace std;  
  
class MyClass   
{  
public:   
   MyClass( )  
   {  
      cout << "Construction MyClass." << this << endl;  
   };  
  
   ~MyClass( )  
   {  
      imember = 0; cout << "Destructing MyClass." << this << endl;  
   };  
   int imember;  
};  
  
int main( )   
{  
   // The first form of new delete  
   MyClass* fPtr = new MyClass;  
   delete fPtr;  
  
   // The second form of new delete  
   MyClass* fPtr2 = new( nothrow ) MyClass;  
   delete fPtr2;  
  
   // The third form of new delete  
   char x[sizeof( MyClass )];  
   MyClass* fPtr3 = new( &x[0] ) MyClass;  
   fPtr3 -> ~MyClass();  
   cout << "The address of x[0] is : " << ( void* )&x[0] << endl;  
}  
```  
  
##  <a name="operator_new_arr"></a>  Оператор new[]  
 Функция выделения, вызываемая выражением new для выделения памяти для массива объектов.  
  
```
void* operator new[](std::size_t count) throw(std::bad_alloc);

void* operator new[](std::size_t count,
    const std::nothrow_t&) throw();

void* operator new[](std::size_t count,
    void* ptr) throw();
```  
  
### <a name="parameters"></a>Параметры  
 `count`  
 Число байт памяти, которые нужно выделить для объекта-массива.  
  
 `ptr`  
 Возвращаемый указатель.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Указатель на адрес младшего байта выделенной памяти. Или `ptr.`  
  
### <a name="remarks"></a>Примечания  
 Первая функция вызывается выражением `new[]` для выделения `count` байт памяти, подходящим образом выровненной для представления любого объекта-массива такого или меньшего размера. Программа может определить функцию с помощью сигнатуры этой функции, которая заменяет версию по умолчанию из стандартной библиотеки C++. Требуемое поведение такое же, как для [оператора new](../standard-library/new-operators.md#operator_new)( **size_t**). Поведение по умолчанию — вернуть `operator new`( `count`).  
  
 Вторая функция вызывается выражением `new[]` для выделения `count` байт памяти, подходящим образом выровненной для представления любого объекта-массива такого размера. Программа может определить функцию с помощью сигнатуры этой функции, которая заменяет версию по умолчанию из стандартной библиотеки C++. Поведение по умолчанию — вернуть **оператор new**( `count`), если эта функция выполняется успешно. В противном случае метод возвращает пустой указатель.  
  
 Третья функция вызывается выражением `new[]` в форме **new** ( *args*) **T**[ **N**]. Здесь *args* — указатель на единичный объект. Функция возвращает `ptr`.  
  
 Для освобождения памяти, выделенной `operator new[]`, вызовите [оператор delete&#91;&#93;](../standard-library/new-operators.md#operator_delete_arr).  
  
 Для информации о поведении new с выдачей исключений и без выдачи исключений см. раздел [Операторы new и delete](../cpp/new-and-delete-operators.md).  
  
### <a name="example"></a>Пример  
  
```cpp  
// new_op_alloc.cpp  
// compile with: /EHsc  
#include <new>  
#include <iostream>  
  
using namespace std;  
  
class MyClass {  
public:  
   MyClass() {  
      cout << "Construction MyClass." << this << endl;  
   };  
  
   ~MyClass() {  
      imember = 0; cout << "Destructing MyClass." << this << endl;  
      };  
   int imember;  
};  
  
int main() {  
   // The first form of new delete  
   MyClass* fPtr = new MyClass[2];  
   delete[ ] fPtr;  
  
   // The second form of new delete  
   char x[2 * sizeof( MyClass ) + sizeof(int)];  
  
   MyClass* fPtr2 = new( &x[0] ) MyClass[2];  
   fPtr2[1].~MyClass();  
   fPtr2[0].~MyClass();  
   cout << "The address of x[0] is : " << ( void* )&x[0] << endl;  
  
   // The third form of new delete  
   MyClass* fPtr3 = new( nothrow ) MyClass[2];  
   delete[ ] fPtr3;  
}  
```  
  
## <a name="see-also"></a>См. также  
 [\<new>](../standard-library/new.md)




