---
title: "Алгоритмы | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "соглашения библиотеки C++ функций шаблонов алгоритмов"
  - "алгоритмы [C++], C++"
  - "соглашения [C++], алгоритм C++"
  - "библиотеки [C++], соглашения алгоритмов C++"
  - "Стандартная библиотека C++, алгоритмы"
ms.assetid: dec9b373-7d5c-46cc-b7d2-21a938ecd0a6
caps.latest.revision: 10
author: "corob-msft"
ms.author: "corob"
manager: "ghogen"
caps.handback.revision: 9
---
# Алгоритмы
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Алгоритмы являются важной частью библиотеки стандартных шаблонов.  Алгоритмы работают с контейнерами не самостоятельно, а с помощью итераторов.  Поэтому один и тот же алгоритм можно использовать с большинством, а то и со всеми контейнерами STL.  В этом разделе рассматриваются правила и терминология алгоритмов STL.  
  
## Заметки  
 В описаниях функций шаблонов алгоритмов используется ряд стандартных сокращенных фраз:  
  
-   Фраза «в диапазоне \[*A*, *B*\)» означает последовательность из нуля или больше дискретных значения, начиная с  *A* до, но не включая *B*.  Диапазон является допустимым только в случае, если *B* доступен из *A;* можно хранить *A* в объекте *N* \(*N* \= *A*\), приращивать объект ноль или более раз \(\+\+*N*\), а также сравнивать объект с *B* после конечного числа приращений \(N \=\= B*\).*  
  
-   Фраза «каждый *N* в диапазоне \[*A*, *B*\)» означает, что *N* начинается со значения *A* и приращивается ноль или более раз до тех пор, пока не будет равно значению *B*.  Случай *N* \=\= *B* не находится в диапазоне.  
  
-   Фраза «наименьшее значение *N* в диапазоне \[*A*, *B*\) таким образом, что *X*» означает, что условие *X* определяется для каждого *N* в диапазоне \[*A*, *B*\) вплоть до выполнения условия *X*.  
  
-   Фраза «наибольшее значение *N* в диапазоне \[*A*, *B*\) таким образом, что *X*» означает, что условие *X* определяется для каждого *N* в диапазоне \[*A*, *B*\).  Функция сохраняет в `K` копию *N* каждый раз при выполнении условия *X*.  При каждом таком сохранении функция заменяет конечное значение *N*, равное *B*, значением `K`.  Для двунаправленного итератора или итератора произвольного доступа это также  может означать, что *N* начинается с наибольшего значения в диапазоне и постепенно уменьшается вплоть до выполнения условия *X*.  
  
-   Выражения, такие как *X* \- *Y*, где *X* и *Y* могут быть итераторами, отличными от итераторов произвольного доступа, предусмотрены по математическим соображениям.  Функция не обязательно вычисляет оператор**\-**, если она должна определить такое значение.  Это также верно для таких выражений как *X* \+ *N* и *X* \- *N*, где *N* — целое число.  
  
 Несколько алгоритмов используют предикат, выполняющие попарное сравнение, например, `operator==`, для получения результата `bool`.  Функция предиката `operator==` или любая ее замена не должны изменять ни один из операндов.  Она должна возвращать одинаковый результат `bool` при каждом вычислении, а также должна возвращать такой же результат, если операнд заменяется копией одного из операндов.  
  
 Некоторые алгоритмы используют предикат, который налагает строгое слабое упорядочение к парам элементов из последовательности.  Для предиката `pr`\(*X*, *Y*\):  
  
-   Strict означает, что `pr`\(*X*, *X*\) имеет значение false.  
  
-   Weak означает, что *X* и *Y* имеют равноценное упорядочение, если \!`pr`\(*X*, *Y*\) && \!`pr`\(*Y*, *X*\) \(*X* \=\= *Y* не требуется определять\).  
  
-   Упорядочение означает, что из `pr`\(*X*, *Y*\) && `pr`\(*Y*, Z\) следует `pr`\(*X*, Z\).  
  
 Некоторые из алгоритмов неявно использую предикат *X* \< *Y*.  Другие предикаты, удовлетворяющие требованию строгого слабого упорядочения: *X* \> *Y*, **меньше**\(*X*, *Y*\) и `greater`\(*X*, *Y*\).  Обратите внимание, однако, предикаты например *X* \< \= *Y* и *X* \> \= *Y* не удовлетворяют этим требованиям.  
  
 Последовательность элементов, обозначенная итераторами в диапазоне \[`First`, `Last`\), является последовательностью, упорядоченной оператором**\<** если для каждого *N* в диапазоне \[0, `Last` \- `First`\) и для каждого *M* в диапазоне \(N, `Last` \- `First`\) предикат \!\(\*\(`First` \+ *M*\) \< \*\(*First* \+ *N*\)\) имеет значение true.  \(Обратите внимание, что элементы сортируются по возрастанию\). Функция предиката **operator\<** или любая ее замена не должна изменять ни один из операндов.  Она должна возвращать одинаковый результат `bool` при каждом вычислении, а также должна возвращать такой же результат, если операнд заменяется копией одного из операндов.  Кроме того она должен применить строгого слабое упорядочение с операндами, которые она сравнивает.  
  
 Последовательность элементов, обозначенная итераторами в диапазоне \[`First`, `Last`\), является кучей, упорядоченной **оператором\<**, если для каждого *N* в диапазоне \[1, `Last` \- `First`\) предикат \!\(\*`First` \< \*\(`First` \+ *N*\)\) имеет значение true.  \(Первый элемент является наибольшим.\) Его внутренняя структура известна только для функций шаблонов [make\_heap](../Topic/make_heap.md), [pop\_heap](../Topic/pop_heap.md) и [push\_heap](../Topic/push_heap.md).  Как и в упорядоченной последовательности, функция предиката **оператор \<** или любая его замена не должна изменять его операнды и должна налагать строгое слабое упорядочение на сравниваемые операнды.  Она должна возвращать одинаковый результат `bool` при каждом вычислении, а также должна возвращать такой же результат, если операнд заменяется копией одного из операндов.  
  
 Алгоритмы STL находятся в файлах заголовков  [\<algorithm\>](../standard-library/algorithm.md) и [\<numeric\>](../standard-library/numeric.md).  
  
## См. также  
 [Библиотека стандартных шаблонов](../misc/standard-template-library.md)   
 [Потокобезопасность в стандартной библиотеке C\+\+](../standard-library/thread-safety-in-the-cpp-standard-library.md)