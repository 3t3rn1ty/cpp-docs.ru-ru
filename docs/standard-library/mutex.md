---
title: "&lt;Мьютекс&gt; | Документы Майкрософт"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-cpp
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords:
- <mutex>
dev_langs:
- C++
ms.assetid: efb60c89-687a-4e38-8fe4-694e11c4e8a3
caps.latest.revision: 17
author: corob-msft
ms.author: corob
manager: ghogen
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
translationtype: Machine Translation
ms.sourcegitcommit: cc82b83860786ffc3f0aee73ede18ecadef16a7a
ms.openlocfilehash: 7e6aaf9ae1817da4a532b00fe0bf54afc5e9cd17
ms.lasthandoff: 02/24/2017

---
# <a name="ltmutexgt"></a>&lt;Мьютекс&gt;
Включите стандартный заголовок \<mutex> для определения классов `mutex`, `recursive_mutex`, `timed_mutex` и `recursive_timed_mutex`, шаблонов `lock_guard` и `unique_lock`, а также поддерживающих типов и функций, определяющих взаимоисключающие регионы кода.  
  
> [!WARNING]
>  Типы синхронизации стандартной библиотеки С++ в Visual Studio 2015 основаны на примитивах синхронизации Windows и больше не используют ConcRT (кроме случаев программирования под Windows XP). Типы, определенные в \<mutex>, не должны использоваться с какими-либо типами или функциями ConcRT.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
#include <mutex>  
```  
  
## <a name="remarks"></a>Примечания  
  
> [!NOTE]
>  В коде, который компилируется с помощью **/CLR**, этот заголовок будет заблокирован.  
  
 Классы `mutex` и `recursive_mutex` имеют *тип мьютекса*. Тип мьютекса содержит конструктор по умолчанию и деструктор, который не вызывает исключения. Эти объекты содержат методы, обеспечивающие взаимное исключение в случаях, когда несколько потоков пытаются заблокировать один объект. В частности, тип мьютекса содержит методы `lock`, `try_lock` и `unlock`:  
  
-   Метод `lock` блокирует вызывающий поток до тех пор, пока этот поток не получит права владения мьютексом. Его возвращаемое значение игнорируется.  
  
-   Метод `try_lock` пытается получить права владения мьютексом без блокировки. Его возвращаемое значение можно преобразовать в `bool` и оно является `true`, если метод получает права владения; в противном случае — `false`.  
  
-   Метод `unlock` выпускает права владения мьютексом из вызывающего потока.  
  
 Вы можете использовать типы мьютекса в качестве аргументов для создания экземпляров шаблонов `lock_guard` и `unique_lock`. Вы можете использовать объекты этих типов в качестве аргумента `Lock` для функций-членов wait в шаблоне [condition_variable_any](../standard-library/condition-variable-any-class.md).  
  
 *Тип мьютекса с ограничением по времени* удовлетворяет требованиям к типу мьютексов. Кроме того, он содержит методы `try_lock_for` и `try_lock_until`, которые должны вызываться с помощью одного аргумента и должны возвращать тип, доступный для преобразования в `bool`. Тип мьютекса с ограничением по времени может определять эти функции с помощью дополнительных аргументов, если эти дополнительные аргументы имеют значения по умолчанию.  
  
-   Метод `try_lock_for` должен иметь возможность вызова с одним аргументом `Rel_time`, тип которого является экземпляром [chrono::duration](../standard-library/duration-class.md). Метод пытается получить права владения мьютексом, но возвращается в период времени, назначенный `Rel_time`, независимо от успешности выполнения операции. Возвращенное значение преобразуется в `true`, если метод получает права владения; в противном случае возвращаемое значение преобразуется в `false`.  
  
-   Метод `try_lock_until` должен быть доступен для вызова с одним аргументом `Abs_time`, тип которого является экземпляром [chrono::time_point](../standard-library/time-point-class.md). Метод пытается получить права владения мьютексом, но возвращается раньше окончания периода, назначенного `Abs_time`, независимо от успешности выполнения операции. Возвращенное значение преобразуется в `true`, если метод получает права владения; в противном случае возвращаемое значение преобразуется в `false`.  
  
 Тип мьютекса также известен как *блокируемый тип*. Если он не предоставляет функцию-член `try_lock`, это *базовый блокируемый тип*. Мьютекс с ограничением по времени также известен как *блокируемый тип с ограничением по времени *.  
  
### <a name="classes"></a>Классы  
  
|Имя|Описание|  
|----------|-----------------|  
|[Класс lock_guard](../standard-library/lock-guard-class.md)|Представляет шаблон, для которого можно создать экземпляры и объект, деструктор которого разблокирует `mutex`.|  
|[Класс mutex (Стандартная библиотека C++)](../standard-library/mutex-class-stl.md)|Представляет тип мьютекса. Используйте объекты этого типа для принудительного взаимного исключения в программе.|  
|[Класс recursive_mutex](../standard-library/recursive-mutex-class.md)|Представляет тип мьютекса. В отличие от класса `mutex`, поведение вызывающих методов блокировки для объектов, которые уже заблокированы, четко определено.|  
|[Класс recursive_timed_mutex](../standard-library/recursive-timed-mutex-class.md)|Представляет тип мьютекса с ограничением по времени. Используйте объекты этого типа для принудительного взаимного исключения с ограниченной по времени блокировкой в программе. В отличие от объектов типа `timed_mutex`, эффект вызова методов блокировки для объектов `recursive_timed_mutex` четко определен.|  
|[Класс timed_mutex](../standard-library/timed-mutex-class.md)|Представляет тип мьютекса с ограничением по времени. Используйте объекты этого типа для принудительного взаимного исключения с ограниченной по времени блокировкой в программе.|  
|[Класс unique_lock](../standard-library/unique-lock-class.md)|Представляет шаблон, для которого можно создать экземпляры и объекты, управляющие блокировкой и разблокировкой `mutex`.|  
  
### <a name="functions"></a>Функции  
  
|Имя|Описание|  
|----------|-----------------|  
|[Функция call_once](../standard-library/mutex-functions.md#call_once_function)|Предоставляет механизм для однократного вызова указанного объекта во время выполнения.|  
|[Функция lock](../standard-library/mutex-functions.md#lock_function)|Пытается заблокировать все аргументы без взаимоблокировки.|  
  
### <a name="structs"></a>структурам;  
  
|Имя|Описание|  
|----------|-----------------|  
|[Структура adopt_lock_t](../standard-library/adopt-lock-t-structure.md)|Представляет тип, который используется для определения `adopt_lock`.|  
|[Структура defer_lock_t](../standard-library/defer-lock-t-structure.md)|Представляет тип, который определяет объект `defer_lock`, используемый для выбора одного из перегруженных конструкторов `unique_lock`.|  
|[Структура once_flag](../standard-library/once-flag-structure.md)|Представляет объект `struct`, который используется с функцией шаблона `call_once` для обеспечения однократного вызова кода инициализации даже при наличии нескольких потоков выполнения.|  
|[Структура try_to_lock_t](../standard-library/try-to-lock-t-structure.md)|Представляет объект `struct`, который определяет объект `try_to_lock` и используется для выбора одного из перегруженных конструкторов `unique_lock`.|  
  
### <a name="variables"></a>Переменные  
  
|Имя|Описание|  
|----------|-----------------|  
|[Переменная adopt_lock](../standard-library/mutex-functions.md#adopt_lock_variable)|Представляет объект, который можно передать в конструкторы для `lock_guard` и `unique_lock`, чтобы указать на блокировку объекта мьютекса, также передаваемого в конструктор.|  
|[Переменная defer_lock](../standard-library/mutex-functions.md#defer_lock_variable)|Представляет объект, который можно передать в конструктор для `unique_lock`, чтобы указать, что конструктор не должен блокировать объект мьютекса, который также передается в него.|  
|[Переменная try_to_lock](../standard-library/mutex-functions.md#try_to_lock_variable)|Представляет объект, который можно передать в конструктор для `unique_lock`, чтобы указать, что конструктор должен попытаться разблокировать объект `mutex`, который также передается в него без блокировки.|  
  
## <a name="see-also"></a>См. также  
 [Справочник по файлам заголовков](../standard-library/cpp-standard-library-header-files.md)




