---
title: "&lt;mutex&gt; | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "<mutex>"
dev_langs: 
  - "C++"
ms.assetid: efb60c89-687a-4e38-8fe4-694e11c4e8a3
caps.latest.revision: 17
author: "corob-msft"
ms.author: "corob"
manager: "ghogen"
caps.handback.revision: 17
---
# &lt;mutex&gt;
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Включите стандартный заголовок \<mutex\> для определения классов `mutex`, `recursive_mutex`, `timed_mutex` и `recursive_timed_mutex`, шаблоны `lock_guard` и `unique_lock`, а также поддерживающие типы и функции, определяющие взаимоисключающие регионы кода.  
  
> [!WARNING]
>  Типы синхронизации STL в Visual Studio 2015 основаны на примитивах синхронизации Windows и больше не используют ConcRT \(кроме случаев, когда целевая платформа — Windows XP\).  Типы, определенные в \<mutex\>, не должны использоваться с какими\-либо типами или функциями ConcRT.  
  
## Синтаксис  
  
```cpp  
#include <mutex>  
```  
  
## Заметки  
  
> [!NOTE]
>  В коде, скомпилированном с помощью **\/clr** или **\/clr:pure**, этот заголовок блокируется.  
  
 Классы `mutex` и `recursive_mutex` являются *типами мьютексов*.  Тип мьютекса содержит конструктор по умолчанию и деструктор, который не вызывает исключения.  Эти объекты содержат методы, обеспечивающие взаимное исключение в случаях, когда несколько потоков пытаются заблокировать один объект.  В частности, тип мьютекса содержит методы `lock`, `try_lock` и `unlock`:  
  
-   Метод `lock` блокирует вызывающий поток до тех пор, пока этот поток не получит права владения мьютексом.  Его возвращаемое значение игнорируется.  
  
-   Метод `try_lock` пытается получить права владения мьютексом без блокировки.  Его возвращаемое значение можно преобразовать в `bool` и оно является `true`, если метод получает права владения; в противном случае — `false`.  
  
-   Метод `unlock` выпускает права владения мьютексом из вызывающего потока.  
  
 Вы можете использовать типы мьютекса в качестве аргументов для создания экземпляров шаблонов `lock_guard` и `unique_lock`.  Вы можете использовать объекты этих типов в качестве аргумента `Lock` для функций\-членов wait в шаблоне [condition\_variable\_any](../standard-library/condition-variable-any-class.md).  
  
 *Тип мьютекса с ограничением по времени* удовлетворяет требованиям к типу мьютексов.  Кроме того, он содержит методы `try_lock_for` и `try_lock_until`, которые должны вызываться с помощью одного аргумента и должны возвращать тип, доступный для преобразования в `bool`.  Тип мьютекса с ограничением по времени может определять эти функции с помощью дополнительных аргументов, если эти дополнительные аргументы имеют значения по умолчанию.  
  
-   Метод `try_lock_for` должен быть доступен для вызова с помощью одного аргумента `Rel_time`, тип которого является экземпляром [chrono::duration](../standard-library/duration-class.md).  Метод пытается получить права владения мьютексом, но возвращается в период времени, назначенный `Rel_time`, независимо от успешности выполнения операции.  Возвращенное значение преобразуется в `true`, если метод получает права владения; в противном случае возвращаемое значение преобразуется в `false`.  
  
-   Метод `try_lock_until` должен быть доступен для вызова с помощью одного аргумента `Abs_time`, тип которого является экземпляром [chrono::time\_point](../standard-library/time-point-class.md).  Метод пытается получить права владения мьютексом, но возвращается раньше окончания периода, назначенного `Abs_time`, независимо от успешности выполнения операции.  Возвращенное значение преобразуется в `true`, если метод получает права владения; в противном случае возвращаемое значение преобразуется в `false`.  
  
 Тип мьютекса, также известный как *блокируемый тип*.  Если он не предоставляет функцию\-член `try_lock`, это *базовый блокируемый тип*.  Тип мьютекса с ограничением по времени также известен как *блокируемый тип с ограничением по времени*.  
  
### Классы  
  
|Имя|Описание|  
|---------|--------------|  
|[Класс lock\_guard](../standard-library/lock-guard-class.md)|Представляет шаблон, для которого можно создать экземпляры и объект, деструктор которого разблокирует `mutex`.|  
|[Класс mutex \(STL\)](../standard-library/mutex-class-stl.md)|Представляет тип мьютекса.  Используйте объекты этого типа для принудительного взаимного исключения в программе.|  
|[Класс recursive\_mutex](../standard-library/recursive-mutex-class.md)|Представляет тип мьютекса.  В отличие от класса `mutex`, поведение вызывающих методов блокировки для объектов, которые уже заблокированы, четко определено.|  
|[Класс recursive\_timed\_mutex](../standard-library/recursive-timed-mutex-class.md)|Представляет синхронизированный тип мьютекса.  Используйте объекты этого типа для принудительного взаимного исключения с ограниченной по времени блокировкой в программе.  В отличие от объектов типа `timed_mutex`, эффект вызова методов блокировки для объектов `recursive_timed_mutex` четко определен.|  
|[Класс timed\_mutex](../standard-library/timed-mutex-class.md)|Представляет тип мьютекса с ограничением по времени.  Используйте объекты этого типа для принудительного взаимного исключения с ограниченной по времени блокировкой в программе.|  
|[Класс unique\_lock](../standard-library/unique-lock-class.md)|Представляет шаблон, для которого можно создать экземпляры и объекты, управляющие блокировкой и разблокировкой `mutex`.|  
  
### Функции  
  
|Имя|Описание|  
|---------|--------------|  
|[Функция call\_once](../Topic/call_once%20Function.md)|Предоставляет механизм для однократного вызова указанного объекта во время выполнения.|  
|[Функция lock](../Topic/lock%20Function.md)|Пытается заблокировать все аргументы без взаимоблокировки.|  
  
### Структуры  
  
|Имя|Описание|  
|---------|--------------|  
|[Структура adopt\_lock\_t](../standard-library/adopt-lock-t-structure.md)|Представляет тип, который используется для определения `adopt_lock`.|  
|[Структура defer\_lock\_t](../standard-library/defer-lock-t-structure.md)|Представляет тип, который определяет объект `defer_lock`, используемый для выбора одного из перегруженных конструкторов `unique_lock`.|  
|[Структура once\_flag](../standard-library/once-flag-structure.md)|Представляет объект `struct`, который используется с функцией шаблона `call_once` для обеспечения однократного вызова кода инициализации даже при наличии нескольких потоков выполнения.|  
|[Структура try\_to\_lock\_t](../Topic/try_to_lock_t%20Structure.md)|Представляет объект `struct`, который определяет объект `try_to_lock` и используется для выбора одного из перегруженных конструкторов `unique_lock`.|  
  
### Переменные  
  
|Имя|Описание|  
|---------|--------------|  
|[Переменная adopt\_lock](../Topic/adopt_lock%20Variable.md)|Представляет объект, который можно передать в конструкторы для `lock_guard` и `unique_lock`, чтобы указать на блокировку объекта мьютекса, также передаваемого в конструктор.|  
|[Переменная defer\_lock](../Topic/defer_lock%20Variable.md)|Представляет объект, который можно передать в конструктор для `unique_lock`, чтобы указать, что конструктор не должен блокировать объект мьютекса, который также передается в него.|  
|[Переменная try\_to\_lock](../Topic/try_to_lock%20Variable.md)|Представляет объект, который можно передать в конструктор для `unique_lock`, чтобы указать, что конструктор должен попытаться разблокировать объект `mutex`, который также передается в него без блокировки.|  
  
## См. также  
 [Справочные материалы по файлам заголовков](../standard-library/cpp-standard-library-header-files.md)