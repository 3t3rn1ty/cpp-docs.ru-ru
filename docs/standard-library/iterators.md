---
title: "Итераторы | Документы Майкрософт"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-standard-libraries
ms.tgt_pltfrm: 
ms.topic: reference
dev_langs:
- C++
helpviewer_keywords:
- iterator conventions
- C++ Standard Library, iterator conventions
ms.assetid: 2f746be7-b37d-4bfc-bf05-be4336ca982f
caps.latest.revision: 
author: corob-msft
ms.author: corob
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: b75a4f682b83fb8a738a5b19a7c5aa9a1b38166a
ms.sourcegitcommit: d51ed21ab2b434535f5c1d553b22e432073e1478
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/23/2018
---
# <a name="iterators"></a>Итераторы
Итератор — это объект, который может перебирать элементы в контейнере стандартной библиотеки С++ и предоставлять доступ к отдельным элементам. Все контейнеры стандартной библиотеки С++ предоставляют итераторы, чтобы алгоритмы могли получить доступ к их элементам стандартным способом, независимо от типа контейнера, в котором сохранены элементы.  
  
 Вы можете использовать итераторы явно, с помощью члена и глобальных функций, таких как begin() и end(), а также операторов ++ и -- для перемещения вперед или назад. Вы можете также использовать итераторы неявно, с циклом range-for или (для некоторых типов итераторов) подстрочным оператором [].  
  
 В стандартной библиотеке С++ началом последовательности или диапазона является первый элемент. Конец последовательности или диапазона всегда определяется как элемент, следующий за последним элементом. Глобальные функции begin и end возвращают итераторы в указанный контейнер. Типичный цикл явных итераторов, включающий все элементы, выглядит следующим образом:  
  
```  
 
vector<int> vec{ 0,1,2,3,4 };  
for (auto it = begin(vec);

it != end(vec);

it++)  
{  // Access element using dereference operator
    cout <<*it <<" ";  
}  
```  
  
 Того же можно достичь более простым способом, с помощью цикла range-for:  
  
```  
for (auto num : vec)  
 {  // no deference operator
    cout <<num <<" ";  
 }  
```  
  
 Существует пять категорий итераторов. Ниже описаны категории в порядке возрастания силы.  
  
- **Вывод**. Итератор вывода `X` может выполнить итерацию последовательности с помощью оператора ++ и один раз записать элемент с помощью оператора *.  
  
- **Ввод**. Итератор ввода `X` может выполнить итерацию последовательности с помощью оператора ++ и прочитать элемент любое количество раз с помощью оператора *. Вы можете сравнить итераторы ввода с помощью операторов ++ и !=. После выполнения приращения любой копии итератора ввода ни одну из других копий нельзя будет безопасно сравнивать, разыменовывать и выполнять приращение.  
  
- **Прямой**. Однонаправленный итератор `X` может выполнять итерацию последовательности с помощью оператора ++ и прочитать любой элемент или записать неконстантные элементы любое количество раз с помощью оператора *. Вы можете получить доступ к членам элементов с помощью оператора -> и сравнить однонаправленные итераторы с помощью операторов == и !=. Вы можете сделать несколько копий однонаправленного итератора, каждая из которых может быть разыменована и для нее может быть выполнено независимое приращение. Однонаправленный итератор, который инициализируется без ссылки на какой-либо контейнер, вызывается в пустом однонаправленном итераторе. Пустые однонаправленные итераторы всегда равны.  
  
-   Двунаправленный. Двунаправленный итератор `X` может использоваться вместо прямого итератора. Вы можете также выполнить уменьшение двунаправленного итератора, как в --`X`, `X`-- или (`V` = *`X`--). Получить доступ к членам элементов и сравнить двунаправленные итераторы можно так же, как и однонаправленные итераторы.  
  
- **Произвольный доступ**. Итератор произвольного доступа `X` может использоваться вместо двунаправленного итератора. С итератором произвольного доступа можно использовать подстрочный оператор [] для доступа к элементам. Вы можете использовать операторы +, -, += и -= для перемещения указанного количества элементов вперед или назад, а также для вычисления расстояния между итераторами. Вы можете сравнить двунаправленные итераторы с помощью ==, !=, \<, >, \<=, and >=.  
  
 Все итераторы можно назначать и копировать. Они считаются простыми объектами и поэтому часто передаются и возвращаются по значению, а не по ссылке. Обратите внимание, что ни одна из операций, описанных выше, не может создавать исключения при выполнении с допустимым итератором.  
  
 Иерархия категорий итераторов может быть представлена в виде трех последовательностей. Для доступа в режиме только для записи в последовательность можно использовать любой из следующих итераторов.  
  
```  
output iterator  
 -> forward iterator  
 -> bidirectional iterator  
 -> random-access iterator  
```  
  
 Стрелка вправо означает "могут быть заменены". Любой алгоритм, использующий итератор вывода, должен хорошо работать, например, с однонаправленным итератором, но *не* наоборот.  
  
 Для доступа в режиме только для чтения в последовательность можно использовать любой из следующих итераторов.  
  
```  
input iterator  
 -> forward iterator  
 -> bidirectional iterator  
 -> random-access iterator  
```  
  
 Итератор ввода является самым слабым по всем категориям в этом смысле.  
  
 Наконец, для доступа в режиме чтения и записи в последовательность можно использовать любой из следующих итераторов.  
  
```  
forward iterator  
 -> bidirectional iterator  
 -> random-access iterator  
```  
  
 Указатель на объект всегда можно использовать как итератор произвольного доступа, поэтому он может относиться к любой категории итераторов, если он поддерживает необходимый уровень доступа для чтения и записи в последовательность, которую он обозначает.  
  
 Итератор `Iterator`, не являющийся указателем на объект, должен также определять типы элементов, необходимые для специализации `iterator_traits<Iterator>`. Обратите внимание, что эти требования могут быть выполнены путем наследования `Iterator` от общего базового класса [iterator](../standard-library/iterator-struct.md).  
  
 Важно знать возможности и ограничения каждой категории итераторов, чтобы понимать, как итераторы используются контейнерами и алгоритмами в стандартной библиотеке С++.  
  
> [!NOTE]
>  Вы можете избежать явного использования итераторов с помощью циклов range-for. Дополнительные сведения см. в разделе [Циклы (современный C++)](http://msdn.microsoft.com/en-us/b1b2779c-750e-4576-a514-a84178eae9da).  
  
 Visual C++ теперь предоставляет итераторы и итераторы, чтобы убедиться, что перезаписи границ контейнера. Дополнительные сведения см. в разделах [Проверяемые итераторы](../standard-library/checked-iterators.md) и [Поддержка отладочных итераторов](../standard-library/debug-iterator-support.md).  
  
## <a name="see-also"></a>См. также  
 [Справочник по стандартной библиотеке C++](../standard-library/cpp-standard-library-reference.md)   
 [Потокобезопасность в стандартной библиотеке C++](../standard-library/thread-safety-in-the-cpp-standard-library.md)

