---
title: "&lt; режим &gt; | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "<functional>"
  - "functional/std::<functional>"
  - "std.<functional>"
  - "std::<functional>"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "функторы"
  - "functional - заголовок"
ms.assetid: 7dd463e8-a29f-49bc-aedd-8fa53b54bfbc
caps.latest.revision: 27
author: "corob-msft"
ms.author: "corob"
manager: "ghogen"
caps.handback.revision: 27
---
# &lt; режим &gt;
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Определяет стандартные функции библиотеки, помогающие создавать *функции объекты*— также называется функторы и их привязки. Объект-функция — это объект типа, который определяет `operator()`. Объект-функция может быть указателем на функцию, но, как правило, он используется для хранения дополнительных сведений, которые могут потребоваться при вызове функции.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
#include <functional>  
```  
  
## <a name="remarks"></a>Заметки  
 Алгоритмам требуются два вида объектов-функций: унарные и бинарные. Унарным объектам-функциям требуется один аргумент, и бинарным — два аргумента. Объект-функция и указатели на функции могут передаваться как предикат для алгоритма, но объекты-функции также могут настраиваться и расширяют область, а также повышают гибкость и эффективность STL. Если, например, требуется привязать значение к функции перед передачей алгоритму, указатель на функцию не может использоваться. Адаптеры функций преобразуют указатели на функции в гибкие объекты-функции, которые можно привязать к значению. Заголовок \< функциональной> также содержит адаптеры члена функции, позволяющие вызывать как объекты адаптируемых функция функции члена. Функции могут настраиваться, если у них есть объявления вложенных типов, указывающие типы аргументов и типы возвращаемого значения. Согласно стандарту C++ такая адаптивность должна реализоваться следующим образом: все стандартные классы объектов наследуют от базовых классов unary_function или binary_function. Объекты-функции и их адаптеры позволяют STL обновить существующие приложения и облегчают интеграцию STL в среде программирования C++.  
  
  [!INCLUDE[vcprvc](../build/includes/vcprvc_md.md)] Реализацию функции объектов в \< функциональной> включает *прозрачные функторы операторов*, которой специализации standard функции объектов и не принимать никаких параметров шаблона, а выполнять точную пересылку аргументов функции и идеальный возвращаемого результата. Эта возможность является частью спецификации черновой версии стандарта C++ 14. Эти специализации шаблона не требуют указывать типы аргументов при вызове функторов арифметических операций, операций сравнения, логических операций и функторов побитовых операторов. Вы можете перегружать арифметические, логические, побитовые операторы и операторы сравнения для собственных типов или сочетания разнородных типов, а затем использовать прозрачные функторы операторов в качестве аргументов функции. Например если ваш тип *MyType* реализует `operator<`, можно вызвать `sort(my_collection.begin(), my_collection.end(), less<>())` вместо явного указания типа `sort(my_collection.begin(), my_collection.end(), less<MyType>())`.  
  
## <a name="c11c14-implementation"></a>Реализация C++ 11/C++ 14  
 В реализации C++ 11/C++ 14 в Visual C++ добавлены следующие возможности.  
  
-   A *подписи вызова* имя тип возвращаемого значения следует список разделенных запятой скобки ноль или более типов аргументов.  
  
-   A *вызываемой типа* является указателем на функцию, указатель на функцию-член, указатель на данные-член или тип класса, объекты которого могут немедленно отображаются слева от оператора вызова функции.  
  
-   A *вызываемый объект* — это объект вызываемой типа.  
  
-   A *вызова типа оболочки* — это тип, который содержит вызываемый объект и поддерживает операцию вызова, который перенаправляет на этот объект.  
  
-   A *обертки для вызовов* является объектом типа вызова оболочки.  
  
-   A *целевой объект* является вызываемый объект, удерживаемые объект-оболочку вызова.  
  
 Псевдофункция `INVOKE(f, t1, t2, ..., tN)` означает одно из следующего:  
  
- `(t1.*f)(t2, ..., tN)`, если `f` — это указатель на функцию-член класса `T`, а `t1` — это объект типа `T`, ссылка на объект типа `T` или ссылка на объект типа, производного от `T`.  
  
- `((*t1).*f)(t2, ..., tN)`, если `f` — это указатель на функцию-член класса `T`, а `t1` не является одним из типов, описанных в предыдущем пункте.  
  
- `t1.*f`, если N == 1, а `f` — это указатель на данные-член класса `T` и `t1` — это объект типа `T`, ссылка на объект типа `T` или ссылка на объект типа, производного от `T`.  
  
- `(*t1).*f`, если N == 1, а `f` — это указатель на данные-член класса `T` и `t1` не является одним из типов, описанных в предыдущем пункте.  
  
- В остальных случаях — `f(t1, t2, ..., tN)`.  
  
 Псевдофункция `INVOKE(f, t1, t2, ..., tN, R)` означает `INVOKE(f, t1, t2, ..., tN)`, неявно преобразованный в `R`.  
  
 Если вызов оболочки *слабые результирующий тип*, его тип члена `result_type` основан на типе `T` целевого объекта оболочки, как показано ниже:  
  
-   Если `T` — указатель на функцию, `result_type` — это синоним возвращаемого типа `T`.  
  
-   Если `T` — указатель на функцию-член, `result_type` — это синоним возвращаемого типа `T`.  
  
-   Если `T` — тип класса с типом члена `result_type`, `result_type` — это синоним `T::result_type`.  
  
-   В противном случае член `result_type` не существует.  
  
 У каждой оболочки вызова есть конструктор перемещения и конструктор копирования. A *оболочки простой вызов* является оболочкой вызова, имеется назначение оператора и которого конструктор копии, конструктор перемещения и оператор присваивания не создают исключений. A *пересылку обертки для вызовов* является оболочкой вызова, могут быть вызваны с помощью списка произвольных аргументов и предоставляющая аргументы в оболочку вызываемый объект как ссылки. Все аргументы rvalue предоставляются как ссылки rvalue, а аргументы lvalue — как ссылки lvalue.  
  
### <a name="classes"></a>Классы  
  
|||  
|-|-|  
|[bad_function_call](../standard-library/bad-function-call-class.md)|Класс, который описывает исключение, которое создается, чтобы указать, что вызов `operator()` на [функция](../standard-library/function-class.md) объекта не удалось, так как объект был пуст.|  
|[binary_negate](../Topic/binary_negate%20Class.md)|Класс шаблона, предоставляющий функцию-член, которая инвертирует возвращаемое значение указанной бинарной функции.|  
|[binder1st](../standard-library/binder1st-class.md)|Класс шаблона, предоставляющий конструктор, который преобразует объект бинарной функции в объект унарной функции, привязывая первый аргумент бинарной функции к указанному значению.|  
|[binder2nd](../standard-library/binder2nd-class.md)|Класс шаблона, предоставляющий конструктор, который преобразует объект бинарной функции в объект унарной функции, привязывая второй аргумент бинарной функции к указанному значению.|  
|[const_mem_fun_ref_t](../standard-library/const-mem-fun-ref-t-class.md)|Класс адаптера, который позволяет вызывать функцию-член-константу, не принимающую аргументы, как объект унарной функции при инициализации с ссылочным аргументом.|  
|[const_mem_fun_t](../standard-library/const-mem-fun-t-class.md)|Класс адаптера, который позволяет вызывать функцию-член-константу, не принимающую аргументы, как объект унарной функции при инициализации с аргументом указателя.|  
|[const_mem_fun1_ref_t](../standard-library/const-mem-fun1-ref-t-class.md)|Класс адаптера, который позволяет вызывать функцию-член-константу, принимающую один аргумент, как объект бинарной функции при инициализации с ссылочным аргументом.|  
|[const_mem_fun1_t](../standard-library/const-mem-fun1-t-class.md)|Класс адаптера, который позволяет вызывать функцию-член-константу, принимающую один аргумент, как объект бинарной функции при инициализации с аргументом указателя.|  
|[функция](../standard-library/function-class.md)|Класс, создающий оболочку для вызываемого объекта.|  
|[хэш](hash%20Class.md)|Класс, который вычисляет хэш-код для значения.|  
|[is_bind_expression](../standard-library/is-bind-expression-class.md)|Класс, который проверяет, можно ли создать определенный тип, вызывая `bind`.|  
|[is_placeholder](../Topic/is_placeholder%20Class.md)|Класс, который проверяет, является ли определенный тип заполнителем.|  
|[mem_fun_ref_t](../Topic/mem_fun_ref_t%20Class.md)|Класс адаптера, который позволяет **non_const** без аргументов для вызова как объект унарной функции инициализирован с ссылочный аргумент функции-члена.|  
|[mem_fun_t](../standard-library/mem-fun-t-class.md)|Класс адаптера, который позволяет **non_const** функция-член вызывается как объект унарной функции инициализирован с аргументом указателя без аргументов.|  
|[mem_fun1_ref_t](../standard-library/mem-fun1-ref-t-class.md)|Класс адаптера, который позволяет **non_const** принимает один аргумент для вызова как объект бинарной функции инициализирован с ссылочный аргумент функции-члену.|  
|[mem_fun1_t](../Topic/mem_fun1_t%20Class.md)|Класс адаптера, который позволяет **non_const** функции-члена, принимающего один аргумент, вызываемый как объект бинарной функции инициализирован с указатель в качестве аргумента.|  
|[pointer_to_binary_function](../standard-library/pointer-to-binary-function-class.md)|Преобразует указатель на бинарную функцию в адаптируемую бинарную функцию.|  
|[pointer_to_unary_function](../standard-library/pointer-to-unary-function-class.md)|Преобразует указатель на унарную функцию в адаптируемую унарную функцию.|  
|[reference_wrapper](../Topic/reference_wrapper%20Class.md)|Класс, который создает оболочку для ссылки.|  
|[result_of](../standard-library/result-of-class2.md)|Структура, содержащая тип возвращаемого значения вызываемого объекте в оболочке.|  
|[unary_negate](../standard-library/unary-negate-class.md)|Класс шаблона, предоставляющий функцию-член, которая инвертирует возвращаемое значение указанной унарной функции.|  
  
### <a name="functions"></a>Функции  
  
|||  
|-|-|  
|[Привязка](../Topic/%3Cfunctional%3E%20functions.md#bind_function)|Привязывает аргументы к вызываемому объекту.|  
|[bind1st](../Topic/%3Cfunctional%3E%20functions.md#bind1st_function)|Вспомогательная функция шаблона, которая создает адаптер для преобразования объекта бинарной функции в объект унарной функции, привязывая первый аргумент бинарной функции к указанному значению.|  
|[bind2nd](../Topic/%3Cfunctional%3E%20functions.md#bind2nd_function)|Вспомогательная функция шаблона, которая создает адаптер для преобразования объекта бинарной функции в объект унарной функции, привязывая второй аргумент бинарной функции к указанному значению.|  
|[bit_and](../Topic/%3Cfunctional%3E%20functions.md#bit_and_function)|Возвращает результат применения побитовой логической операции И (бинарный оператор &) между двумя параметрами.|  
|[bit_not](../Topic/%3Cfunctional%3E%20functions.md#bit_not_function)|Возвращает результат применения логического дополнения (оператор ~) к параметру.|  
|[bit_or](../Topic/%3Cfunctional%3E%20functions.md#bit_or_function)|Возвращает побитового логического или (оператор &#124;) из двух параметров.|  
|[bit_xor](../Topic/%3Cfunctional%3E%20functions.md#bit_xor_function)|Возвращает результат применения логической операции ИСКЛЮЧАЮЩЕЕ ИЛИ (оператор ^) между двумя параметрами.|  
|[cref](../Topic/%3Cfunctional%3E%20functions.md#cref_function)|Создает конструкцию `reference_wrapper` из аргумента.|  
|[mem_fn](../Topic/%3Cfunctional%3E%20functions.md#mem_fn_function)|Создает простую оболочку вызова.|  
|[mem_fun](../Topic/%3Cfunctional%3E%20functions.md#mem_fun_function)|Вспомогательные функции шаблона, которые используются для создания адаптеров объекта-функции для функций-членов при инициализации с аргументами указателя.|  
|[mem_fun_ref](../Topic/%3Cfunctional%3E%20functions.md#mem_fun_ref_function)|Вспомогательная функция шаблона, которая используется для создания адаптеров объекта-функции для функций-членов при инициализации с ссылочными аргументами.|  
|[not1](../Topic/%3Cfunctional%3E%20functions.md#not1_function)|Возвращает дополнение унарного предиката.|  
|[not2](../Topic/%3Cfunctional%3E%20functions.md#not2_function)|Возвращает дополнение бинарного предиката.|  
|[ptr_fun](../Topic/%3Cfunctional%3E%20functions.md#ptr_fun_function)|Вспомогательная функция шаблона, которая используется для преобразования указателей на унарные и бинарные функция в унарные и бинарные адаптируемые функции соответственно.|  
|[ref](../Topic/%3Cfunctional%3E%20functions.md#ref_function)|Создает `reference_wrapper` из аргумента.|  
|[Переключение](../Topic/%3Cfunctional%3E%20functions.md#swap_function)|Меняет местами два объекта `function`.|  
  
### <a name="structs"></a>Структуры  
  
|||  
|-|-|  
|[binary_function](../Topic/binary_function%20Struct.md)|Пустой базовый класс, определяющий типы, которые могут наследоваться производным классом, предоставляющим объект бинарной функции.|  
|[Делит](../standard-library/divides-struct.md)|Этот класс предоставляет стандартный объект-функцию, который выполняет арифметическую операцию деления элементов заданного типа значения.|  
|[equal_to](../standard-library/equal-to-struct.md)|Бинарный предикат, который проверяет, равно ли значение заданного типа другому значению этого типа.|  
|[больше](../standard-library/greater-struct.md)|Бинарный предикат, который проверяет, больше ли значение заданного типа другого значения этого типа.|  
|[greater_equal](../standard-library/greater-equal-struct.md)|Бинарный предикат, который проверяет, больше или равно ли значение заданного типа другого значения этого типа.|  
|[меньше](../standard-library/less-struct.md)|Бинарный предикат, который проверяет, меньше ли значение заданного типа другого значения этого типа.|  
|[less_equal](../standard-library/less-equal-struct.md)|Бинарный предикат, который проверяет, меньше или равно ли значение заданного типа другого значения этого типа.|  
|[logical_and](../Topic/logical_and%20Struct.md)|Этот класс предоставляет стандартный объект-функцию, который применяет логическую операцию конъюнкции к элементам заданного типа значения и проверяет истинность или ложность результата.|  
|[logical_not](../Topic/logical_not%20Struct.md)|Этот класс предоставляет стандартный объект-функцию, который применяет логическую операцию отрицания к элементам заданного типа значения и проверяет истинность или ложность результата.|  
|[logical_or](../standard-library/logical-or-struct.md)|Этот класс предоставляет стандартный объект-функцию, который применяет логическую операцию логического сложения к элементам заданного типа значения и проверяет истинность или ложность результата.|  
|[минус](../standard-library/minus-struct.md)|Этот класс предоставляет стандартный объект-функцию, который выполняет арифметическую операцию вычитания для элементов заданного типа значения.|  
|[остатка от деления](../standard-library/modulus-struct.md)|Этот класс предоставляет стандартный объект-функцию, который выполняет арифметическую операцию модуля для элементов заданного типа значения.|  
|[Умножает](../standard-library/multiplies-struct.md)|Этот класс предоставляет стандартный объект-функцию, который выполняет арифметическую операцию умножения для элементов заданного типа значения.|  
|[отрицание](../standard-library/negate-struct.md)|Этот класс предоставляет стандартный объект-функцию, который возвращает отрицательное значение элемента.|  
|[not_equal_to](../standard-library/not-equal-to-struct.md)|Бинарный предикат, который проверяет, не равно ли значение заданного типа другому значению этого типа.|  
|[плюс](../standard-library/plus-struct.md)|Этот класс предоставляет стандартный объект-функцию, который выполняет арифметическую операцию сложения для элементов заданного типа значения.|  
|[unary_function](../Topic/unary_function%20Struct.md)|Пустой базовый класс, определяющий типы, которые могут наследоваться производным классом, предоставляющим объект унарной функции.|  
  
### <a name="objects"></a>объектов  
  
|||  
|-|-|  
|[_1.._M](../standard-library/1-object.md)|Заполнители для подстановочных аргументов.|  
  
### <a name="operators"></a>Операторы  
  
|||  
|-|-|  
|[оператор ==](../Topic/%3Cfunctional%3E%20operators.md#operator_eq_eq)|Запрещает сравнение вызываемых объектов на равенство.|  
|[оператор! =](../Topic/%3Cfunctional%3E%20operators.md#operator_neq)|Запрещает сравнение вызываемых объектов на неравенство.|  
  
## <a name="see-also"></a>См. также  
 [Справочные материалы по файлам заголовков](../standard-library/cpp-standard-library-header-files.md)   
 [Потокобезопасность в стандартной библиотеке C++](../standard-library/thread-safety-in-the-cpp-standard-library.md)   
 [Библиотека стандартных шаблонов](../misc/standard-template-library.md)

