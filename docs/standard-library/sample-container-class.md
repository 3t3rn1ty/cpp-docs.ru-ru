---
title: "Класс образцов контейнера | Документы Майкрософт"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-standard-libraries
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
helpviewer_keywords: container classes [C++]
ms.assetid: 5b1451f2-c708-45da-bbf0-9e42fd687a1a
caps.latest.revision: "10"
author: corob-msft
ms.author: corob
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: 3666bf4ee03149a9c00ec93d9fc1dc536ce2d080
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="sample-container-class"></a>Пример класса контейнера
> [!NOTE]
>  Данный раздел включен в документацию Visual C++ в качестве нефункционального примера контейнеров, используемых в стандартной библиотеке C++. Дополнительные сведения см. в разделе [Контейнеры стандартной библиотеки C++](../standard-library/stl-containers.md).  
  
 Описывает объект, управляющий последовательностью элементов переменной длины, как правило типа **Ty**. Последовательность сохраняется по-разному в зависимости от фактического контейнера.  
  
 Может возникнуть ситуация, когда конструктор контейнеров или функция-член вызовет конструктор **Ty**(**const Ty&**) или функцию **Ty::operator=**(**const Ty&**). Если такой вызов порождает исключение, объект-контейнер должен сохранять свою целостность и поэтому он повторно создает любое перехватываемое исключение. Можно безопасно заменять, назначать, удалять или уничтожать объект-контейнер после того, как он создаст одно из следующих исключений. В целом, тем не менее, невозможно иначе спрогнозировать состояние последовательности, контролируемой объектом-контейнером.  
  
 Несколько дополнительных предупреждений:  
  
-   Если выражение **~Ty** создает исключение, результирующее состояние объекта-контейнера не определено.  
  
-   Если контейнер сохраняет объект-распределитель *al* и *al* создает исключение, отличающееся от результата вызова *al***.allocate**, получившееся состояние объекта-контейнера не определено.  
  
-   Если контейнер сохраняет объект-функцию *comp*, чтобы определить, как упорядочить контролируемую последовательность, и *comp* создает исключение любого вида, получившееся состояние объекта-контейнера не определено.  
  
 Классы контейнеров, определяемые стандартной библиотекой C++, удовлетворяют несколько дополнительных требований, как показано ниже.  
  
 Класс шаблонов контейнера [list](../standard-library/list-class.md) предоставляет детерминированное и полезное поведение даже в присутствии вышеуказанных исключений. Например, если исключение создается во время вставки одного или более элементов контейнер не меняется, а исключение создается снова.  
  
 Для *всех* классов контейнеров, определяемых стандартной библиотекой C++: если исключение создается во время вызовов следующих функций-членов:  
  
```  
<A NAME="vclrfcontainerinsert"></A>insert // single element inserted  
<A NAME="vclrfcontainerpushback"></A>push_back  
<A NAME="vclrfcontainerpushfront"></A>push_front  
```  
  
 контейнер не изменяется, а исключение создается повторно.  
  
 Для *всех* классов контейнеров, определяемых стандартной библиотекой C++, исключение не создается во время вызовов следующих функций-членов:  
  
```  
<A NAME="vclrfcontainerpopback"></A>pop_back  
<A NAME="vclrfcontainerpopfront"></A>pop_front  
```  
  
 Функция-член [erase](../standard-library/container-class-erase.md) создает исключение, только если операция копирования (назначение или создание копии) создает исключение.  
  
 Кроме того, исключение не создается при копировании итератора, возвращаемого функцией-членом.  
  
 Функция-член [swap](../standard-library/container-class-swap.md) делает дополнительные обещания для *всех* классов контейнеров, определяемых стандартной библиотекой C++:  
  
-   Функция-член создает исключение, только если контейнер хранит объект-распределитель al и `al` создает исключение при копировании.  
  
-   Ссылки, указатели и итераторы, обозначающие элементы заменяемой управляемой последовательности, остаются действительными.  
  
 Объект класса контейнера, определяемый стандартной библиотекой C++, выделяет и освобождает хранилище для последовательности, которой он управляет через хранимый объект типа `Alloc`, который, как правило, является параметром шаблона. Такой объект-распределитель должен иметь такой же внешний интерфейс, как объект класса **allocator\<Ty>**. В частности, `Alloc` должен иметь тот же тип, что и **Alloc::rebind<value_type>::other**  
  
 Для *всех* классов контейнеров, определяемых стандартной библиотекой C++, функция-член **Alloc get_allocator const;** возвращает копию хранимого объекта-распределителя. Обратите внимание, что сохраненный объект-распределитель *не* копируется, если назначается объект контейнера. Все конструкторы инициализируют значение, хранимое в **распределителе**, в `Alloc`, если конструктор не содержит параметр распределителя.  
  
 Согласно стандарту C++, класс контейнера, определяемый стандартной библиотекой C++, может допускать следующее:  
  
-   Все объекты класса `Alloc` равны при сравнении.  
  
-   Тип **Alloc::const_pointer** совпадает с типом **const Ty \***.  
  
-   Тип **Alloc::const_reference** совпадает с типом **const Ty&**.  
  
-   Тип **Alloc::pointer** совпадает с типом **Ty \***.  
  
-   Тип **Alloc::reference** совпадает с типом **Ty&**.  
  
 В этой реализации, однако, контейнеры не делают таких упрощающих допущений. Следовательно, они правильно работают с более требовательными объектами-распределителями:  
  
-   Объектам класса `Alloc` не нужно быть равными при сравнении. (Можно иметь несколько пулов носителей.)  
  
-   Тип **Alloc::const_pointer** не должен совпадать с **const Ty \***. (Константный указатель может быть классом.)  
  
-   Тип **Alloc::pointer** не должен совпадать с типом **Ty \***. (Указатель может быть классом.)  
  
## <a name="requirements"></a>Требования  
 **Заголовок**: \<образец контейнера>  
  
## <a name="see-also"></a>См. также  
 [\<образец контейнера>](../standard-library/sample-container.md)

