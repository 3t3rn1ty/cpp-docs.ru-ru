---
title: Класс образцов контейнера | Документы Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-standard-libraries
ms.topic: reference
dev_langs:
- C++
helpviewer_keywords:
- container classes [C++]
ms.assetid: 5b1451f2-c708-45da-bbf0-9e42fd687a1a
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 4a6205247a468f403357245f9b2e8d1abd558f95
ms.sourcegitcommit: d55ac596ba8f908f5d91d228dc070dad31cb8360
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/08/2018
ms.locfileid: "33858371"
---
# <a name="sample-container-class"></a>Пример класса контейнера

> [!NOTE]
> Данный раздел включен в документацию Visual C++ в качестве нефункционального примера контейнеров, используемых в стандартной библиотеке C++. Дополнительные сведения см. в разделе [Контейнеры стандартной библиотеки C++](../standard-library/stl-containers.md).

Описывает объект, управляющий последовательностью элементов переменной длины, как правило типа **Ty**. Последовательность сохраняется по-разному в зависимости от фактического контейнера.

Может возникнуть ситуация, когда конструктор контейнеров или функция-член вызовет конструктор **Ty**(**const Ty&**) или функцию **Ty::operator=**(**const Ty&**). Если такой вызов порождает исключение, объект-контейнер должен сохранять свою целостность и поэтому он повторно создает любое перехватываемое исключение. Можно безопасно заменять, назначать, удалять или уничтожать объект-контейнер после того, как он создаст одно из следующих исключений. В целом, тем не менее, невозможно иначе спрогнозировать состояние последовательности, контролируемой объектом-контейнером.

Несколько дополнительных предупреждений:

- Если выражение **~Ty** создает исключение, результирующее состояние объекта-контейнера не определено.

- Если контейнер хранит объект распределителя *al*, и *al* приводит к возникновению исключения, отличных от в результате вызова *al***.allocate**, результирующее состояние контейнера объект не определен.

- Если контейнер сохраняет объект-функцию *comp*, чтобы определить, как упорядочить контролируемую последовательность, и *comp* создает исключение любого вида, получившееся состояние объекта-контейнера не определено.

Классы контейнеров, определяемые стандартной библиотекой C++, удовлетворяют несколько дополнительных требований, как показано ниже.

Класс шаблонов контейнера [list](../standard-library/list-class.md) предоставляет детерминированное и полезное поведение даже в присутствии вышеуказанных исключений. Например, если исключение создается во время вставки одного или более элементов контейнер не меняется, а исключение создается снова.

Для *все* контейнера классы, определенные стандартной библиотеки C++, если исключение создается при вызове следующей функции-члены, **вставить**, **push_back**, или **push_front**, контейнера не изменяется, и создается исключение.

Для *все* контейнера классов, определенных перечислением стандартной библиотеки C++, исключение не возникает при вызове следующих функций-членов: **pop_back**, **pop_front**.

Функция-член [erase](../standard-library/container-class-erase.md) создает исключение, только если операция копирования (назначение или создание копии) создает исключение.

Кроме того, исключение не создается при копировании итератора, возвращаемого функцией-членом.

Функция-член [swap](../standard-library/container-class-swap.md) делает дополнительные обещания для *всех* классов контейнеров, определяемых стандартной библиотекой C++:

- Функция-член создает исключение, только если контейнер хранит объект-распределитель al и `al` создает исключение при копировании.

- Ссылки, указатели и итераторы, обозначающие элементы заменяемой управляемой последовательности, остаются действительными.

Объект класса контейнера, определяемый стандартной библиотекой C++, выделяет и освобождает хранилище для последовательности, которой он управляет через хранимый объект типа `Alloc`, который, как правило, является параметром шаблона. Такой объект-распределитель должен иметь такой же внешний интерфейс, как объект класса **allocator\<Ty>**. В частности, `Alloc` должен иметь тот же тип, что и **Alloc::rebind<value_type>::other**

Для *всех* классов контейнеров, определяемых стандартной библиотекой C++, функция-член **Alloc get_allocator const;** возвращает копию хранимого объекта-распределителя. Обратите внимание, что сохраненный объект-распределитель *не* копируется, если назначается объект контейнера. Все конструкторы инициализируют значение, хранимое в **распределителе**, в `Alloc`, если конструктор не содержит параметр распределителя.

Согласно стандарту C++, класс контейнера, определяемый стандартной библиотекой C++, может допускать следующее:

- Все объекты класса `Alloc` равны при сравнении.

- Тип **Alloc::const_pointer** совпадает с типом **const Ty \****.

- Тип **Alloc::const_reference** совпадает с типом **const Ty&**.

- Тип **Alloc::pointer** совпадает с типом **Ty \****.

- Тип **Alloc::reference** совпадает с типом **Ty&**.

В этой реализации, однако, контейнеры не делают таких упрощающих допущений. Следовательно, они правильно работают с более требовательными объектами-распределителями:

- Объектам класса `Alloc` не нужно быть равными при сравнении. (Можно иметь несколько пулов носителей.)

- Тип **Alloc::const_pointer** не должен совпадать с **const Ty \***. (Константный указатель может быть классом.)

- Тип **Alloc::pointer** не должен совпадать с типом **Ty \****. (Указатель может быть классом.)

## <a name="requirements"></a>Требования

**Заголовок**: \<образец контейнера>

## <a name="see-also"></a>См. также

[\<образец контейнера>](../standard-library/sample-container.md)<br/>
