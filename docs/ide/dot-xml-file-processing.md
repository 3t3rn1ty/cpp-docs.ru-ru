---
title: "Обработка XML-файлов | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "документация XML, обработка XML-файла"
ms.assetid: e70fdeae-80ac-4872-ab24-771c5635cfbf
caps.latest.revision: 15
caps.handback.revision: 15
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Обработка XML-файлов
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Компилятор создает строку идентификатора для каждой конструкции в коде, отмеченной для создания документации  Дополнительные сведения см. в разделе [Рекомендуемые теги документирующие комментарии](../Topic/Recommended%20Tags%20for%20Documentation%20Comments%20\(Visual%20C++\).md).  Строка идентификатора однозначно определяет конструкцию.  Программы, процесс XML\-файл может использовать идентификатор строки для определения соответствующей метаданных платформы .NET Framework или элемент отражения, к которым применяется документации.  
  
 Xml\-файл нет иерархического представления кода, его плоский список с созданным идентификатор для каждого элемента.  
  
 Компилятор следует приведенным ниже правилам при формировании строк идентификаторов:  
  
-   Пробел не помещается в строку.  
  
-   Первая часть строки идентификатора определяет тип идентифицированного члена в виде одного символа с последующим двоеточием.  Используются следующие типы элементов.  
  
    |Знак|Описание|  
    |----------|--------------|  
    |N|namespace<br /><br /> Нельзя добавлять комментарии в пространство имен, документации cref ссылки на пространство имен возможна.|  
    |T|тип: класс, интерфейс, структура, перечисление, делегат|  
    |D|typedef|  
    |F|поле|  
    |P|свойство \(включая индексаторы или другие индексированные свойства\)|  
    |M|метод \(включая такие специальные методы как конструкторы, операторы и так далее\)|  
    |E|event|  
    |\!|Строка ошибки<br /><br /> Остальная часть строки содержит сведения об ошибке.  Компилятор Visual C\+\+ создает C \- сведения об ошибке для связей, которые нельзя разрешить.|  
  
-   Вторая часть строки – это полное имя элемента, начиная с корневого пространства имен.  Имя элемента, его внешний тип или типы, а пространство имен разделяются по точки.  Если имя элемента содержит точки, они заменяются решетками \(\#\).  Он предполагать, что несуществующий элемент имеет хэш\- подпись непосредственно в своем имени.  Например, полное имя конструктора `String` будет "System.String.\#ctor".  
  
-   Для свойств и методов при наличии аргументов метода, список аргументов следует заключить в скобки.  Если аргументов нет, скобки отсутствуют.  Несколько аргументов разделяются запятыми.  Кодировка каждого аргумента следует непосредственно из того, как он кодируется в сигнатуре .NET Framework.  
  
    -   Базовые типы.  Обычные типы \(ELEMENT\_TYPE\_CLASS или ELEMENT\_TYPE\_VALUETYPE\) представлены полным именем типа.  
  
    -   Встроенные типы \(например, ELEMENT\_TYPE\_I4, ELEMENT\_TYPE\_OBJECT, ELEMENT\_TYPE\_STRING, ELEMENT\_TYPE\_TYPEDBYREF.  и представлены ELEMENT\_TYPE\_VOID\), полное имя соответствующего полного типа, например **System.Int32** или **System.TypedReference**.  
  
    -   ELEMENT\_TYPE\_PTR представлен символом звездочки \(“\*”\) после измененного типа.  
  
    -   ELEMENT\_TYPE\_BYREF представлен символом “@” после измененного типа.  
  
    -   ELEMENT\_TYPE\_PINNED представлен символом “^” после измененного типа.  Компилятор Visual C\+\+ C никогда не создает это.  
  
    -   ELEMENT\_TYPE\_CMOD\_REQ представлен символом “&#124;” и полным именем класса модификатора после измененного типа.  Компилятор Visual C\+\+ C никогда не создает это.  
  
    -   ELEMENT\_TYPE\_CMOD\_OPT представляется символом "\!" и полным именем класса модификатора после измененного типа.  
  
    -   ELEMENT\_TYPE\_SZARRAY представлен символом “\[\]” после типа элемента массива.  
  
    -   ELEMENT\_TYPE\_GENERICARRAY представлен символом “\[?\]” после типа элемента массива.  Компилятор Visual C\+\+ C никогда не создает это.  
  
    -   ELEMENT\_TYPE\_ARRAY представлен \[*нижняя граница*:`size`,*нижняя граница*:`size`\], где число запятых это ранг \- 1, а нижние границы и размер каждой размерности \(если они известны\) представлены десятичными числами.  Если нижняя граница или размер не указаны, они просто опускаются.  Если нижняя граница и размер для определенной размерности опущены, “:” также опускается.  Например, двухмерный массив с 1 в качестве нижних границ и незаданными размерами – \[1:,1:\].  
  
    -   ELEMENT\_TYPE\_FNPTR представлен "\=FUNC:`type`\(*сигнатура*\)", где `type` – возвращаемый тип, а *сигнатура* – аргументы метода.  Если аргументы отсутствуют, скобки опускаются.  Компилятор Visual C\+\+ C никогда не создает это.  
  
     Следующие компоненты сигнатуры не представляются, так как они никогда не используются для разграничения перегруженных методов:  
  
    -   соглашение при вызове  
  
    -   возвращаемый тип  
  
    -   ELEMENT\_TYPE\_SENTINEL  
  
-   Для операторов преобразования только кодировано возвращаемое значение метода как "&#124;" следовать возвращаемым типом, как ранее кодировкой.  
  
-   Для универсальных типов после имени типа будет следовать символ “\`”, а затем число, указывающее количество параметров универсальных типов.  Например:  
  
<CodeContentPlaceHolder>0</CodeContentPlaceHolder>  
     Для типа определенного как `public class MyClass\<T, U>`.  
  
     Для методов, принимающих в качестве параметров универсальные типы, параметры универсальных типов указываются в виде чисел, которым предшествуют символы “\`” \(например, \`0,\`1\).  Каждое число, представляющее нулевую нотацию массива для универсальных параметров типа.  
  
## Пример  
 В следующих примерах показано, как бы создавались идентификатор класса и его элементов.  
  
```  
// xml_id_strings.cpp  
// compile with: /clr /doc /LD  
///   
namespace N {    
// "N:N"  
  
   /// <see cref="System" />  
   //  <see cref="N:System"/>  
   ref class X {      
   // "T:N.X"  
  
   protected:  
      ///   
      !X(){}     
      // "M:N.X.Finalize", destructor's representation in metadata  
  
   public:  
      ///   
      X() {}     
      // "M:N.X.#ctor"  
  
      ///   
      static X() {}     
      // "M:N.X.#cctor"  
  
      ///   
      X(int i) {}     
      // "M:N.X.#ctor(System.Int32)"  
  
      ///   
      ~X() {}     
      // "M:N.X.Dispose", Dispose function representation in metadata  
  
      ///   
      System::String^ q;     
      // "F:N.X.q"  
  
      ///   
      double PI;     
      // "F:N.X.PI"  
  
      ///   
      int f() { return 1; }     
      // "M:N.X.f"  
  
      ///   
      int bb(System::String ^ s, int % y, void * z) { return 1; }  
      // "M:N.X.bb(System.String,System.Int32@,System.Void*)"  
  
      ///   
      int gg(array<short> ^ array1, array< int, 2 >^ IntArray) { return 0; }   
      // "M:N.X.gg(System.Int16[], System.Int32[0:,0:])"  
  
      ///   
      static X^ operator+(X^ x, X^ xx) { return x; }  
     // "M:N.X.op_Addition(N.X,N.X)"  
  
      ///   
      property int prop;     
      // "M:N.X.prop"  
  
      ///   
      property int prop2 {     
      // "P:N.X.prop2"  
  
         ///   
         int get() { return 0; }  
         // M:N.X.get_prop2  
  
         ///   
         void set(int i) {}  
         // M:N.X.set_prop2(System.Int32)  
      }  
  
      ///   
      delegate void D(int i);   
      // "T:N.X.D"  
  
      ///   
      event D ^ d;   
      // "E:N.X.d"  
  
      ///   
      ref class Nested {};   
      // "T:N.X.Nested"  
  
      ///   
      static explicit operator System::Int32 (X x) { return 1; }   
      // "M:N.X.op_Explicit(N.X!System.Runtime.CompilerServices.IsByValue)~System.Int32"  
   };  
}  
```  
  
## См. также  
 [Документация XML](../ide/xml-documentation-visual-cpp.md)