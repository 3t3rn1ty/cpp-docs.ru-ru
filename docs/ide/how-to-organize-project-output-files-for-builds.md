---
title: "Как: организация выходных файлов проекта для построения | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-ide
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
helpviewer_keywords:
- Visual C++, output files
- output files, organizing
ms.assetid: 521d95ea-2dcc-4da0-b5eb-ac3e57941446
caps.latest.revision: 
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: 648321c41fe02541eeb746bae24236c40dc5325e
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="how-to-organize-project-output-files-for-builds"></a>Практическое руководство. Организация выходных файлов проекта для построения
В этом разделе приводятся рекомендации по организации выходных файлов проекта. Построение ошибки могут возникать при неправильной настройке выходных файлов проекта. В этом разделе также описаны преимущества и недостатки каждого из вариантов организации выходных файлов проекта.  
  
## <a name="referencing-clr-assemblies"></a>Ссылки на сборки среды CLR  
  
#### <a name="to-reference-assemblies-with-using"></a>Для ссылок на сборки с #using  
  
1.  Сборки могут ссылаться непосредственно из программного кода с помощью #using директивы, такие как `#using <System.Data.dll>`. Дополнительные сведения см. в разделе [# директива using](../preprocessor/hash-using-directive-cpp.md).  
  
     Указанный файл может быть .dll, .exe, .netmodule или .obj, поскольку он находится в MSIL. Указанный компонент может быть построен на любом языке. При использовании этого параметра будет иметь доступ к Intellisense, так как метаданные извлекаются из кода MSIL. Файл должен находиться в пути для проекта; в противном случае проект не будет компилироваться и Intellisense будет недоступен. Простой способ определить, является ли файл в пути — щелкните правой кнопкой мыши #using строки и выберите **открытый документ** команды. Вы получите уведомление, если не удается найти файл.  
  
     Если вы не хотите указывать полный путь к файлу, можно использовать **/AI** параметр компилятора, чтобы изменить путь поиска для #using ссылок. Дополнительные сведения см. в разделе [/AI (указание каталогов метаданных)](../build/reference/ai-specify-metadata-directories.md).  
  
#### <a name="to-reference-assemblies-with-fu"></a>Ссылок на сборки с помощью параметра /FU  
  
1.  Вместо создания ссылки на сборку непосредственно из файла кода, как описано выше, можно использовать **/FU** параметр компилятора. Преимуществом этого метода является не необходимости для добавления отдельного #using в каждый файл, ссылающийся на данную сборку.  
  
     Чтобы задать этот параметр, откройте **страницы свойств** для проекта. Разверните **свойства конфигурации** узел, а затем разверните **C/C++** , а затем выберите **Дополнительно**. Добавьте необходимые сборки в **Force #using**. Дополнительные сведения см. в разделе [/FU (именование файла с принудительно используемым атрибутом #using)](../build/reference/fu-name-forced-hash-using-file.md).  
  
#### <a name="to-reference-assemblies-with-add-new-reference"></a>Ссылок на сборки с добавить новую ссылку  
  
1.  Это самый простой способ использования сборок CLR. Во-первых, убедитесь, что при компиляции проекта **/CLR** параметр компилятора. После этого щелкните правой кнопкой мыши проект из **обозревателе решений** и выберите **добавить**, **ссылки**. **Страницы свойств** появится диалоговое окно.  
  
2.  Из **страницы свойств** диалогового окна выберите **добавить новую ссылку**. Откроется диалоговое окно со списком всех .NET, COM и других сборок, доступных в текущем проекте. Выберите требуемую сборку и нажмите кнопку **ОК**.  
  
     После задания ссылки на проект автоматически обрабатываются соответствующих зависимостей. Кроме того поскольку метаданные являются частью сборки, нет необходимости для добавления файла заголовка или прототип элементов, которые используются из управляемых сборок.  
  
## <a name="referencing-native-dlls-or-static-libraries"></a>Создание ссылок на неуправляемые библиотеки DLL или статические библиотеки  
  
#### <a name="to-reference-native-dlls-or-static-libraries"></a>Для ссылки на неуправляемые библиотеки DLL или статические библиотеки  
  
1.  Ссылку на файл в соответствующий заголовок кода с #include. Файл заголовка должен быть в путь поиска включаемых файлов или частью текущего проекта. Дополнительные сведения см. в разделе [#include-директива (C/C++)](../preprocessor/hash-include-directive-c-cpp.md).  
  
2.  Можно также задать зависимости проекта. Зависимости проекта гарантирует две вещи. Во-первых она обеспечивает построении проектов в правильном порядке, чтобы проект всегда можно найти зависимые файлы, которые необходимы. Во-вторых он неявно добавляет зависимый проект выходной каталог в путь, чтобы файлы можно легко найти во время компоновки.  
  
3.  Для развертывания приложения, необходимо поместить библиотеки DLL в соответствующем месте. Это может быть одно из следующих:  
  
    1.  Тот же путь, что и исполняемый файл.  
  
    2.  В любом месте в системный путь ( **путь** переменной среды).  
  
    3.  В сборке side-by-side. Дополнительные сведения см. в разделе [построение C/C++-параллельных сборок](../build/building-c-cpp-side-by-side-assemblies.md).  
  
## <a name="working-with-multiple-projects"></a>Работа с несколькими проектами  
 По умолчанию проекты создаются таким образом, что все выходные файлы создаются в подкаталоге каталога проекта. Каталог на основе конфигурации построения (например отладка или выпуск). Чтобы родственные проекты могли ссылаться друг с другом каждый проект необходимо явно добавить другие каталоги проектов выходные данные для связывания для успешного выполнения в путь. Это выполняется автоматически при установке зависимостей проекта. Тем не менее если вы не используете зависимости, вы должны соблюдать осторожность, поскольку сборки может стать очень сложно управлять. Например если проект содержит конфигураций отладки и выпуска, а также внешней библиотеки из того же уровня проекта, следует использовать разные файлы библиотеки в зависимости от того, что при построении конфигурации. Таким образом жестко запрограммированные этих путей может быть непростой задачей.  
  
 Все основные выходные файлы (например, исполняемые файлы, файлы инкрементного компоновщика и PDB-файлы) копируются в общий каталог решения. Таким образом при работе с решения, содержащего несколько проектов C++ с одинаковой конфигурацией, все выходные файлы хранятся централизовано упрощает компоновку и развертывание. Можно быть уверенным, что приложение или библиотека будет работать должным образом, если эти файлы хранятся вместе (так как файлы, обязательно находиться в пути).  
  
 Расположение выходных файлов может быть очень важна при выполнении развертывания в рабочей среде. При запуске проекта в Интегрированной среде разработки, пути к включенным библиотекам не обязательно являются такими же, как в рабочей среде. Например, если у вас есть `#using "../../lib/debug/mylib.dll"` в коде, а затем развернуть mylib.dll в другое относительное положение, приложение завершится с ошибкой во время выполнения. Чтобы избежать этого, не следует использовать относительные пути в #include инструкции в коде. Лучше убедитесь, что необходимые файлы в папке сборки проекта и аналогично гарантирует правильное размещение соответствующих рабочих файлов.  
  
#### <a name="how-to-specify-where-output-files-go"></a>Как указать, где выходных файлов  
  
1.  Расположение проекта выходные параметры можно найти в проекте **страницы свойств**. Разверните узел рядом с **свойства конфигурации** и выберите **Общие**. Расположение выходных данных указывается рядом с **выходной каталог**. Дополнительные сведения см. в разделе [свойств «Общие» (проект)](../ide/general-property-page-project.md).  
  
## <a name="see-also"></a>См. также  
 [Типы проектов Visual C++](../ide/visual-cpp-project-types.md)