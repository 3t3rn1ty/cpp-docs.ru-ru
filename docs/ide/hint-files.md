---
title: "Указание файлов | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-ide
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords:
- cpp.hint
- vc.hint.file
dev_langs: C++
helpviewer_keywords:
- stop file
- cpp.hint
- hint file
- cpp.stop
- Class View, hint file
ms.assetid: 17194f66-cf62-4523-abec-77db0675ab65
caps.latest.revision: "32"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: 432b5fa5041a7997c9df0593dc511c29854387ab
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="hint-files"></a>Файлы подсказок
Объект *файл подсказок* помогает Visual Studio интегрированной среды разработки (IDE) интерпретировать идентификаторы Visual C++, такие как имена функций и макросов. При открытии проекта Visual C++, интегрированной среды разработки *система анализа* анализирует код в каждом исходном файле в проекте и собирает информацию обо всех идентификаторах. Затем IDE использует эту информацию для поддержки функций, таких как **представление классов** браузера и **панель навигации**.  
  
 Система анализа, появившаяся в Visual C++ 2010, распознает синтаксис C/C++, но может неправильно интерпретировать инструкцию, которая содержит макрос. Если макрос вызывает исходный код для синтаксически неверно, поскольку записать инструкции могут быть неправильно интерпретированы. Инструкция может стать синтаксически правилен, при компиляции исходного кода, а препроцессор заменит [макроса идентификатор](../preprocessor/hash-define-directive-c-cpp.md) с его определением. Система анализа работает без необходимости построения проекта, поскольку он использует файлы подсказок для интерпретации макросов. Таким образом, просмотр функции например **представление классов** сразу становятся доступными.  
  
 Файл подсказок содержит настраиваемые пользователем *указания*, которые имеют тот же синтаксис определений макросов C/C++. Visual C++ включает встроенный файл подсказок, вполне достаточно для большинства проектов, но можно создать собственные файлы подсказок для улучшения обработки Visual Studio обрабатывает идентификаторы.  
  
> [!IMPORTANT]
>  Если вы измените или добавьте файл подсказок, необходимо удалить SDF-файл или файл VC.db в решении, чтобы изменения вступили в силу.  
  
## <a name="scenario"></a>Сценарий  
 Предположим, что следующий код в исходный файл, который вы проверяете с **представление классов** браузера. `STDMETHOD` Макрос объявляет метод с именем `myMethod` , принимает один параметр и возвращает указатель на **HRESULT**.  
  
```  
// Source code file.  
STDMETHOD(myMethod)(int parameter1);  
```  
  
 Следующие определения макросов находятся в отдельном файле заголовка.  
  
```  
// Header file.  
#define STDMETHOD(method) HRESULT (STDMETHODCALLTYPE * method)  
#define STDMETHODCALLTYPE __stdcall  
#define HRESULT void*  
```  
  
 Система анализа не может интерпретировать исходный код, так как функция с именем STDMETHOD объявляться и это объявление синтаксически неверно, поскольку он содержит два списка параметров. Система анализа не открывается файл заголовка для определения для обнаружения `STDMETHOD`, `STDMETHODCALLTYPE`, и `HRESULT` макросы. Поскольку система анализа не может интерпретировать `STDMETHOD` макрос, она пропускает инструкцию целиком и продолжает анализ.  
  
 Система анализа не использует файлы заголовков, поскольку проект может зависеть от одного или нескольких файлов важные заголовок. При изменении любого файла заголовка, система анализа может потребоваться заново проверить все файлы заголовков в проекте, что замедлит работу интегрированной среды разработки. Вместо этого система анализа использует подсказки, которые указывают способ обработки `STDMETHOD`, `STDMETHODCALLTYPE`, и `HRESULT` макросы.  
  
 Как узнать, что требуется подсказка? И, если вам требуется указание, какой тип следует использовать? Один знак, что требуется указание Если представление идентификатора в **представление классов** не согласуется с представлением в **редактор**. Например **представление классов** могут не должно отображаться член класса, который точно существует, или указано неверное имя элемента. Дополнительные сведения о типах подсказок, которые позволяют решать стандартные проблемы см. в том, что макросы требуется указание? раздел далее в этом разделе.  
  
## <a name="architecture"></a>Архитектура  
 Файлы подсказок хранятся в физических каталогов, не в логических каталогах показано **обозревателе решений**. Необходимо добавить файл подсказок в проект файл подсказок вступил в силу. Система анализа использует файлы подсказок только в том случае, если он анализирует исходные файлы.  
  
 Каждый файл подсказок называется **cpp.hint**. Таким образом много каталогов может содержать файл подсказок, но только один файл подсказок могут возникать в конкретном каталоге.  
  
 Проекта могут быть затронуты ноль или более файлов подсказок. Если файлы подсказок отсутствуют, система анализа использует методы восстановления после ошибок игнорировать нечитаемыми исходного кода. В противном случае система анализа использует следующие стратегии для обнаружения и сбора подсказок.  
  
### <a name="search-order"></a>Порядок поиска  
 Система анализа осуществляет каталоги для файлов подсказок в следующем порядке.  
  
-   Каталог, содержащий пакет установки для Visual C++ (**vcpackages**). Этот каталог содержит встроенный файл подсказок, описаны символы в часто используемых системных файлов, таких как **windows.h**. Следовательно проект автоматически наследует большую часть подсказок, которые ему необходимы.  
  
-   Путь из корневого каталога исходного файла в каталог, содержащий сам исходный файл. В большинстве проектов Visual C++ корневой каталог содержит файл решения или проекта.  
  
     Исключение из этого правила — если *Стоп-файл* находится в пути к файлу исходного кода. Стоп-файл обеспечивает дополнительный уровень контроля над порядком поиска и — это любой файл, который называется **cpp.stop**. Вместо, начиная с корневого каталога система анализа осуществляет из каталога, содержащего Стоп-файл в каталог, который содержит исходный файл. В типовом проекте не обязательно Стоп-файл.  
  
### <a name="hint-gathering"></a>Сбор подсказок  
 Файл подсказок содержит ноль или более *указания*. Указание определяются и удаляются так же, как макросов C/C++. То есть `#define` директивы препроцессора, создает или переопределяет подсказку и `#undef` директива удаляет ее.  
  
 Система анализа открывает каждый файл подсказок в указанном выше порядке поиска, собирает подсказки каждого файла в набор *действующие подсказки*, а затем использует действующие подсказки для интерпретации идентификаторов в коде.  
  
 Система анализа использует следующие правила для сбора подсказок.  
  
-   Если новая подсказка задает имя, которое еще не определен, новая подсказка добавляет имя действующие подсказки.  
  
-   Если новая подсказка задает имя, которое уже определено, новая подсказка переопределяет имеющуюся подсказку.  
  
-   Если новая подсказка `#undef` директив, указывающий имеющуюся действующую подсказку, новая подсказка удаляет имеющуюся.  
  
 Первое правило означает, что действующие подсказки наследуются из ранее открытых файлов подсказок. Последние два правила означают, что подсказки, обнаруженные позже в порядке поиска могут переопределить подсказки, которые были обнаружены ранее. Например можно переопределить все имеющиеся подсказки при создании файл подсказок в каталог, содержащий исходный файл.  
  
 Описание сбора подсказок см `Example` далее в этом разделе.  
  
### <a name="syntax"></a>Синтаксис  
 Подсказки создаются и удаляются с помощью синтаксиса директивы препроцессора, создания и удаления макросов. На самом деле система анализа использует препроцессора C/C++ для вычисления подсказок. Дополнительные сведения о директивах препроцессора см. в разделе [#define-директива (C/C++)](../preprocessor/hash-define-directive-c-cpp.md) и [(C/C++) директива #undef](../preprocessor/hash-undef-directive-c-cpp.md).  
  
 Единственными необычными синтаксис элементы, `@<`, `@=`, и `@>` строки замены. Это файл подсказок конкретной замены строки, которые используются только с *карты* макросы. Карта — это набор макросов, которые связывают данные, функции и события для других данных, функций и обработчики событий. Например `MFC` используются для создания [схемы сообщений](../mfc/reference/message-maps-mfc.md), и `ATL` используются для создания [объекта карты](../atl/reference/object-map-macros.md). Конкретной замены строки подсказкам указывают промежуточного, начальный и конечный элементов сопоставления. Важен только имя макроса сопоставления. Таким образом каждая строка сопоставления намеренно скрывает реализацию макроса.  
  
 Подсказки, используйте следующий синтаксис.  
  
|Синтаксис|Значение|  
|------------|-------------|  
|`#define`*Указание имени* *строка замены*<br /><br /> `#define`*Указание имени* `(` *параметр*,... `)` *строка замены*|Директива препроцессора, которая определяет новую подсказку или переопределяет имеющуюся подсказку. После директивы препроцессор заменяет каждое вхождение *Указание имени* в исходном коде с *строку замены*.<br /><br /> Вторая синтаксическая форма определяет подсказка. Если подсказка находится в исходном коде, препроцессор сначала заменяет каждое вхождение *параметр* в *строку замены* с соответствующего аргумента в исходный код и заменяет *Указание имени* с *строку замены*.|  
|`@<`|Конкретный файл подсказок *строку замены* указывает начало набора элементов карты.|  
|`@=`|Конкретный файл подсказок *строку замены* указывает промежуточный элемент сопоставления. Карта может содержать несколько элементов карты.|  
|`@>`|Конкретный файл подсказок *строку замены* указывает конец набора элементов карты.|  
|`#undef`*Указание имени*|Директива препроцессора, которая удаляет имеющуюся подсказку. Имя подсказки обеспечивается *Указание имени* идентификатор.|  
|`//`*комментария*|Однострочный комментарий.|  
|`/*` *comment* `*/`|Многострочный комментарий.|  
  
## <a name="what-macros-require-a-hint"></a>Что макросов требуется подсказка?  
 Макросы определенных типов могут мешать система анализа. В этом разделе описываются типы макросов, которые могут вызвать проблемы и тип подсказок, можно создать для решения этой проблемы.  
  
### <a name="disruptive-macros"></a>Критические макросы  
 Некоторые макросы привести к неправильной интерпретации исходного кода в системе синтаксического анализа, но можно пропустить без ущерба для работы в Интернете. Например, язык исходного кода заметки ([SAL](../c-runtime-library/sal-annotations.md)) макросы разрешаются в атрибуты C++, которые помогают находить ошибки программ. Если требуется игнорировать заметки SAL, при просмотре кода, можно создать файл подсказок, который скрывает заметки.  
  
 В следующем коде исходный тип параметра для `FormatWindowClassName()` функция `PXSTR`, и имя параметра `szBuffer`. Тем не менее ошибки синтаксического анализа системы `_Pre_notnull_` и `_Post_z_` примечания SAL для типа параметра или имени параметра.  
  
 **Исходный код:**  
  
```  
static void FormatWindowClassName(_Pre_notnull__Post_z_ PXSTR szBuffer)  
```  
  
 **Стратегия:** значение Null, определение  
  
 В этом случае рекомендуется считать заметки SAL, они не существуют. Для этого укажите подсказку, строка замены которого имеет значение null. В результате система анализа будет пропускать эти заметки и **представление классов** браузер не отображает их. (Visual C++ включает встроенный файл подсказок, скрывает заметки SAL.)  
  
 **Указание файла:**  
  
```  
#define _Pre_notnull_  
```  
  
### <a name="concealed-cc-language-elements"></a>Элементы языка скрытого C/C++  
 Типичная причина, что система анализа неверно интерпретирует код является, если макрос скрывает C/C++ [знак препинания](../cpp/punctuators-cpp.md) или [ключевое слово](../cpp/keywords-cpp.md) токена. То есть макрос может содержать половину из пары знаков препинания, такие как `<>`, `[]`, `{}`, и `()`.  
  
 В следующем коде исходный `START_NAMESPACE` макрос скрывает непарные открывающая фигурная скобка (`{`).  
  
 **Исходный код:**  
  
```  
#define START_NAMESPACE namespace MyProject {  
```  
  
 **Стратегия:** прямой копирования  
  
 Если семантика макроса являются критическими для работу в Интернете, создайте подсказку, которая идентична макрос. Система анализа разрешит макрос в определение в файле подсказок.  
  
 Обратите внимание, что если макрос в исходном файле содержит другие макросы, эти макросы будут интерпретированы только в том случае, если они уже находятся в наборе действующих подсказок.  
  
 **Указание файла:**  
  
```  
#define START_NAMESPACE namespace MyProject {  
```  
  
### <a name="maps"></a>Карты  
 Сопоставление состоит из макросов, которые определяют начальный элемент, конечный элемент и ноль или более промежуточных элементов. Система анализа неверно интерпретирует сопоставления, поскольку каждый макрос сопоставления скрывает элементы языка C/C++, а синтаксис является законченным оператором C/C++ распределяется между несколькими отдельными макросами.  
  
 Определяет следующий исходный код `BEGIN_CATEGORY_MAP`, `IMPLEMENTED_CATEGORY`, и `END_CATEGORY_MAP` макросы.  
  
 **Исходный код:**  
  
```  
#define BEGIN_CATEGORY_MAP(x)\  
static const struct ATL::_ATL_CATMAP_ENTRY* GetCategoryMap() throw() {\  
static const struct ATL::_ATL_CATMAP_ENTRY pMap[] = {  
#define IMPLEMENTED_CATEGORY( catid ) { _ATL_CATMAP_ENTRY_IMPLEMENTED, &catid },  
#define END_CATEGORY_MAP()\  
   { _ATL_CATMAP_ENTRY_END, NULL } };\  
   return( pMap ); }  
```  
  
 **Стратегия:** элементов сопоставления удостоверений  
  
 Укажите подсказки для начала, середины (если таковые имеются) и конечного элементов сопоставления. Используйте специальные строки подстановки сопоставления, `@<`, `@=`, и `@>`. Дополнительные сведения см. в разделе `Syntax` в этой статье.  
  
 **Указание файла:**  
  
```  
// Start of the map.  
#define BEGIN_CATEGORY_MAP(x) @<  
// Intermediate map element.  
#define IMPLEMENTED_CATEGORY( catid ) @=  
// Intermediate map element.  
#define REQUIRED_CATEGORY( catid ) @=  
// End of the map.  
#define END_CATEGORY_MAP() @>  
```  
  
### <a name="composite-macros"></a>Составные макросы  
 Составные макросы содержат один или несколько типов макросов, неверно интерпретируемых системой анализа.  
  
 Следующий исходный код содержит `START_NAMESPACE` макросом, который задает начало области пространства имен, и `BEGIN_CATEGORY_MAP` макросом, который задает начало сопоставления.  
  
 **Исходный код:**  
  
```  
#define NSandMAP START_NAMESPACE BEGIN_CATEGORY_MAP  
```  
  
 **Стратегия:** прямой копирования  
  
 Создайте подсказки для `START_NAMESPACE` и `BEGIN_CATEGORY_MAP` макросы, а затем создайте подсказку для `NSandMAP` макрос, который является таким же, как показано выше, в исходном коде. Кроме того Если составной макрос состоит только критические макросы и пробелы, можно определить подсказку, замещающая строка — определение null.  
  
 В этом примере предполагается, `START_NAMESPACE` уже имеется подсказка, как описано в этом разделе в `Concealed C/C++ Language Elements` подзаголовка. И предполагается `BEGIN_CATEGORY_MAP` содержит подсказку, как описано выше в `Maps`.  
  
 **Указание файла:**  
  
```  
#define NSandMAP START_NAMESPACE BEGIN_CATEGORY_MAP  
```  
  
### <a name="inconvenient-macros"></a>Неудобно макросы  
 Некоторые макросы могут интерпретироваться системой анализа, но исходный код будет трудно читать, так как макрос длинное или сложное. Для удобочитаемости можно предоставить подсказку, которая упрощает отображение макроса.  
  
 **Исходный код:**  
  
```  
#define STDMETHOD(methodName) HRESULT (STDMETHODCALLTYPE * methodName)  
```  
  
 **Стратегия:** упрощение  
  
 Создайте подсказку, которая отображает более простое определение макроса.  
  
 **Указание файла:**  
  
```  
#define STDMETHOD(methodName) void* methodName  
```  
  
## <a name="example"></a>Пример  
 В следующем примере показано, как происходит сбор подсказок из файлов подсказок. Стоп-файлы не используются в этом примере.  
  
 На следующем рисунке показана часть физические каталоги проекта Visual C++. Файлы подсказок расположены в `vcpackages`, `Debug`, `A1`, и `A2` каталоги.  
  
### <a name="hint-file-directories"></a>Каталоги файлов подсказок  
 ![Общие и проекта &#45; каталоги файлов подсказок определенных. ] (../ide/media/hintfile.png "HintFile")  
  
### <a name="directories-and-hint-file-contents"></a>Каталоги и содержимое файлов подсказок  
 Ниже перечислены каталоги в этом проекте, которые содержат файлы подсказок и содержимое этих файлов подсказок. Только некоторые из множества подсказок в `vcpackages` , перечислены в файле подсказок из каталога.  
  
-   vcpackages  
  
    ```  
    // vcpackages (partial list)  
    #define _In_  
    #define _In_opt_  
    #define _In_z_  
    #define _In_opt_z_  
    #define _In_count_(size)  
    ```  
  
-   Отладка  
  
    ```  
    // Debug  
    #undef _In_  
    #define OBRACE {  
    #define CBRACE }  
    #define RAISE_EXCEPTION(x) throw (x)  
    #define START_NAMESPACE namespace MyProject {  
    #define END_NAMESPACE }  
    ```  
  
-   A1  
  
    ```  
    // A1  
    #define START_NAMESPACE namespace A1Namespace {  
    ```  
  
-   A2  
  
    ```  
    // A2  
    #undef OBRACE  
    #undef CBRACE  
    ```  
  
### <a name="effective-hints"></a>Действующие подсказки  
 В следующей таблице перечислены действующие подсказки для исходных файлов в этом проекте.  
  
-   Исходный файл: A1_A2_B.cpp  
  
-   Действующие подсказки:  
  
    ```  
    // vcpackages (partial list)  
    #define _In_opt_  
    #define _In_z_  
    #define _In_opt_z_  
    #define _In_count_(size)  
    // Debug...  
    #define RAISE_EXCEPTION(x) throw (x)  
    // A1  
    #define START_NAMESPACE namespace A1Namespace {   
    // ...Debug  
    #define END_NAMESPACE }  
    ```  
  
 Следующие примечания применяются в предыдущем списке.  
  
-   Действующие подсказки получены из `vcpackages`, `Debug`, `A1`, и `A2` каталоги.  
  
-   **#Undef** директиву `Debug` удален файл подсказок `#define _In_` указание в `vcpackages` указание файла каталога.  
  
-   Файл подсказок в `A1` переопределяет каталог `START_NAMESPACE`.  
  
-   `#undef` Указание в `A2` каталог удаляется подсказки для `OBRACE` и `CBRACE` в `Debug` указание файла каталога.  
  
## <a name="see-also"></a>См. также  
 [Типы файлов, создаваемых для проектов Visual C++](../ide/file-types-created-for-visual-cpp-projects.md)    
 [#define-директива (C/C++)](../preprocessor/hash-define-directive-c-cpp.md)   
 [#undef директивы (C/C++)](../preprocessor/hash-undef-directive-c-cpp.md)   
 [Заметки SAL](../c-runtime-library/sal-annotations.md)   
 [Схемы сообщений](../mfc/reference/message-maps-mfc.md)   
 [Макросы схемы сообщений](../atl/reference/message-map-macros-atl.md)   
 [Макросы сопоставления объектов](../atl/reference/object-map-macros.md)