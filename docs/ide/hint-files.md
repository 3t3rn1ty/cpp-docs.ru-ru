---
title: "Файлы подсказок | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "cpp.hint"
  - "vc.hint.file"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "STOP-файл"
  - "cpp.hint"
  - "HINT-файл"
  - "cpp.stop"
  - "Представление классов, файл подсказок"
ms.assetid: 17194f66-cf62-4523-abec-77db0675ab65
caps.latest.revision: 32
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 32
---
# Файлы подсказок
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

A *файл подсказок* помогает Visual Studio интегрированной среды разработки (IDE) интерпретировать идентификаторы Visual C++, например имена функций и макросов. При открытии проекта Visual C++, Интегрированной в *Система анализа* анализирует код в каждый исходный файл в проекте и собирает информацию обо всех идентификаторах. Затем IDE использует эту информацию для поддержки функций, таких как **Представление классов** браузера и **Панель навигации**.  
  
 Система анализа, появившаяся в [!INCLUDE[cpp_dev10_long](../Token/cpp_dev10_long_md.md)], распознает синтаксис C/C++, но может неправильно интерпретировать инструкции, содержащие макросы. Если макрос вызывает исходный код становится синтаксически некорректным записью может быть ошибочно интерпретирована инструкцию. Инструкция может стать синтаксически корректной, когда исходный код будет скомпилирован, а препроцессор заменит [идентификатор макрос](../preprocessor/hash-define-directive-c-cpp.md) с его определением. Система анализа работает без необходимости выполнять построение проекта, поскольку для интерпретации макросов она использует файлы подсказок. Таким образом, Просмотр возможностей например **Представление классов** немедленно становится доступной.  
  
 Файл подсказок содержит настраиваемые пользователем *подсказки*, которые имеют тот же синтаксис определений макросов C/C++. Visual C++ включает встроенный файл подсказок, достаточно для большинства проектов, но можно создать собственные файлы подсказок, чтобы улучшить способ Visual Studio обрабатывает идентификаторы.  
  
> [!IMPORTANT]
>  Если изменить или добавить файл подсказок, необходимо удалить SDF-файл или файл VC.db в решении, чтобы изменения вступили в силу.  
  
## <a name="scenario"></a>Сценарий  
 Предположим, что следующий код в исходном файле, просматриваемый с **Представление классов** браузера.  `STDMETHOD` Макрос объявляет метод с именем `myMethod` принимает один параметр и возвращает указатель на **HRESULT**.  
  
```  
// Source code file.  
STDMETHOD(myMethod)(int parameter1);  
```  
  
 Следующие определения макросов расположены в отдельном файле заголовка.  
  
```  
// Header file.  
#define STDMETHOD(method) HRESULT (STDMETHODCALLTYPE * method)  
#define STDMETHODCALLTYPE __stdcall  
#define HRESULT void*  
```  
  
 Система анализа не может интерпретировать исходный код, так как функция с именем STDMETHOD объявляться и это объявление синтаксически неверно, так как он содержит два списка параметров. Система анализа не открыть файл заголовка для обнаружения определения `STDMETHOD`, `STDMETHODCALLTYPE`, и `HRESULT` макросы. Поскольку система анализа не может интерпретировать `STDMETHOD` макрос, она пропускает инструкцию целиком и продолжает анализ.  
  
 Система анализа не использует файлы заголовков, поскольку проект может зависеть от одного или нескольких файлов важные заголовок. При изменении любого файла заголовка, система анализа может потребоваться пересмотреть все файлы заголовков в проекте, что замедлит работу интегрированной среды разработки. Вместо этого система анализа использует подсказки, которые указывают способ обработки `STDMETHOD`, `STDMETHODCALLTYPE`, и `HRESULT` макросы.  
  
 Как узнать, что требуется подсказка? И если вам требуется указание, какие следует использовать? Один знак, что требуется указание при представлении идентификатора в **Представление классов** несовместим с помощью представления в **редактор**. Например **Представление классов** может не отображать члена класса, вы знаете, существует или указано неверное имя элемента. Дополнительные сведения о типах подсказок, которые позволяют решать стандартные проблемы см. что макросов требуется подсказка? подразделе этого раздела.  
  
## <a name="architecture"></a>Архитектура  
 Файлы подсказок хранятся в физических каталогах, показанном не в логических каталогах **обозревателе решений**. Необходимо добавить файл подсказок в проект файл подсказок вступил в силу. Система анализа использует файлы подсказок только в том случае, если он анализирует исходные файлы.  
  
 Каждый файл подсказок называется **cpp.hint**. Таким образом количество каталогов может содержать файл подсказок, но только один файл подсказок могут возникать в конкретном каталоге.  
  
 Проект может повлиять ноль или более файлов подсказок. Если файлы подсказок отсутствуют, система анализа использует методы восстановления после ошибок пропускать нечитаемыми исходного кода. В противном случае — система анализа использует следующие стратегии для обнаружения и сбора подсказок.  
  
### <a name="search-order"></a>Порядок поиска  
 Система анализа осуществляет каталоги файлов подсказок в следующем порядке.  
  
-   Каталог, содержащий пакет установки для Visual C++ (**vcpackages**). Этот каталог содержит встроенный файл подсказки, такие как описаны символы в часто используемых системных файлах **windows.h**. Следовательно проект автоматически наследует большую часть подсказок, которые ему необходимы.  
  
-   Путь из корневого каталога исходного файла в каталог, содержащий сам исходный файл. В большинстве проектов Visual C++ корневой каталог содержит файл решения или проекта.  
  
     Исключение из этого правила — если *Стоп-файл* находится в путь к файлу исходного кода. Стоп-файл обеспечивает дополнительный контроль над порядком поиска и — это любой файл с именем **cpp.stop**. Вместо начиная с корневого каталога система анализа осуществляет из каталога, содержащего Стоп-файл в каталог, который содержит исходный файл. В обычном проекте не обязательно Стоп-файл.  
  
### <a name="hint-gathering"></a>Сбор подсказок  
 Файл подсказок содержит ноль или более *подсказки*. Подсказки определяются и удаляются подобно макросам C/C++. То есть `#define` директивы препроцессора создает или переопределяет подсказку и `#undef` директива удаляет ее.  
  
 Система анализа открывает каждый файл подсказок в указанном выше порядке поиска, собирает подсказки каждого файла в набор *действующие подсказки*, а затем использует действующие подсказки для интерпретации идентификаторов в коде.  
  
 Система анализа использует следующие правила для сбора подсказок.  
  
-   Если новая подсказка задает имя, которое еще не определен, новая подсказка добавляет имя действующие подсказки.  
  
-   Если новая подсказка задает имя, которое уже определено, новая подсказка переопределяет имеющуюся подсказку.  
  
-   Если новая подсказка `#undef` директива указывает имеющуюся действующую подсказку, новая подсказка удаляет имеющуюся подсказку.  
  
 Первое правило означает, что действующие подсказки наследуются из ранее открытых файлов подсказок. Последние два правила означают, что подсказки, обнаруженные позже в порядке поиска могут переопределить подсказки, которые были обнаружены ранее. Например можно переопределить все имеющиеся подсказки при создании файл подсказок в каталоге, содержащем исходный файл.  
  
 Иллюстрацию сбора подсказок см `Example` подразделе этого раздела.  
  
### <a name="syntax"></a>Синтаксис  
 Подсказки создаются и удаляются с помощью синтаксиса в директивах препроцессора для создания и удаления макросов. На самом деле система анализа использует препроцессора C/C++ для вычисления подсказок. Дополнительные сведения о директивах препроцессора см. в разделе [#define-директива (C/C++)](../preprocessor/hash-define-directive-c-cpp.md) и [директива #undef (C/C++)](../preprocessor/hash-undef-directive-c-cpp.md).  
  
 Элементы только необычную синтаксическую структуру, `@<`, `@=`, и `@>` строки замены. Это подсказкам конкретной замены строки, которые используются только с *карты* макросы. Карта — это набор макросов, которые связывают данные, функции или события для других данных, функций и обработчики событий. Например `MFC` используются для создания [схемы сообщений](../mfc/reference/message-maps-mfc.md), и `ATL` используются для создания [объекта карты](../atl/reference/object-map-macros.md). Указание файла конкретной замены строки указывают начальный, промежуточные и конечные элементы сопоставления. Важен только имя макроса сопоставления. Таким образом каждая строка сопоставления намеренно скрывает реализацию макроса.  
  
 В подсказках используется следующий синтаксис.  
  
|Синтаксис|Значение|  
|------------|-------------|  
|`#define` *Указание имени* *Строка замены*<br /><br /> `#define` *Указание имени* `(` *параметр*, ...`)`*Строка замены*|Директива препроцессора, которая определяет новую подсказку или переопределяет имеющуюся подсказку. После директивы препроцессор заменяет каждое вхождение *Указание имени* в исходном коде с *строку замены*.<br /><br /> Вторая синтаксическая форма определяет подсказка. Если подсказка появляется в исходный код, препроцессор сначала заменяет каждое вхождение *параметр* в *строку замены* на соответствующий аргумент в исходном коде, а затем заменяет *Указание имени* с *строку замены*.|  
|`@<`|Конкретный файл подсказок *строку замены* указывает начало набора элементов сопоставления.|  
|`@=`|Конкретный файл подсказок *строку замены* указывает промежуточный элемент сопоставления. Сопоставление может иметь несколько элементов сопоставления.|  
|`@>`|Конкретный файл подсказок *строку замены* указывающее конец набора элементов сопоставления.|  
|`#undef` *Указание имени*|Директивы препроцессора, которая удаляет имеющуюся подсказку. Имя подсказки обеспечивается *Указание имени* идентификатор.|  
|`//` *комментарий*|Однострочный комментарий.|  
|`/*` *комментарий* `*/`|Многострочный комментарий.|  
  
## <a name="what-macros-require-a-hint"></a>Что макросов требуется подсказка?  
 Макросы определенных типов могут мешать система анализа. В этом разделе описаны типы макросов, которые могут вызывать проблемы и типы подсказок, можно создать для решения этой проблемы.  
  
### <a name="disruptive-macros"></a>Критические макросы  
 Некоторые макросы, привести к неправильной интерпретации исходного кода анализа системы, но можно пропустить без ущерба для работы в Интернете. Например, язык исходного кода заметки ([SAL](../c-runtime-library/sal-annotations.md)) макросы разрешаются в атрибуты C++, которые помогают находить ошибки программ. Если требуется игнорировать заметки SAL, как просмотреть код, можно создать файл подсказок, который скрывает заметки.  
  
 В следующем коде исходный тип параметра для `FormatWindowClassName()` функция `PXSTR`, и имя параметра `szBuffer`. Однако ошибки синтаксического анализа системы `_Pre_notnull_` и `_Post_z_` примечания SAL для типа параметра или имени параметра.  
  
 **Исходный код:**  
  
```  
static void FormatWindowClassName(_Pre_notnull__Post_z_ PXSTR szBuffer)  
```  
  
 **Стратегии:** значение Null, определение  
  
 Решением в данной ситуации является трактовка заметок SAL, как если бы они не существуют. Для этого укажите подсказку, строка замены имеет значение null. Следовательно, система анализа будет пропускать эти заметки и **Представление классов** браузера не отображаются. (Visual C++ включает встроенный файл подсказок, скрывает заметки SAL.)  
  
 **Указание файла.**  
  
```  
#define _Pre_notnull_  
```  
  
### <a name="concealed-cc-language-elements"></a>Элементы языка скрытого C/C++  
 Типичная причина, что система анализа неверно интерпретирует код является Если макрос скрывает C/C++ [знак препинания](../cpp/punctuators-cpp.md) или [ключевое слово](../cpp/keywords-cpp.md) маркеров. То есть, что макрос может содержать половину из пары знаков препинания, такие как `<>`, `[]`, `{}`, и `()`.  
  
 В следующем коде исходный `START_NAMESPACE` макрос скрывает непарные открывающая фигурная скобка (`{`).  
  
 **Исходный код:**  
  
```  
#define START_NAMESPACE namespace MyProject {  
```  
  
 **Стратегии:** прямое копирование  
  
 Если семантика макроса важны для возможности работы в Интернете, создайте подсказку, которая идентична макрос. Система анализа разрешит макрос в определение в файле подсказок.  
  
 Обратите внимание, что если макрос в исходном файле содержит другие макросы, эти макросы будут интерпретированы, только в том случае, если они уже находятся в наборе действующих подсказок.  
  
 **Указание файла.**  
  
```  
#define START_NAMESPACE namespace MyProject {  
```  
  
### <a name="maps"></a>Карты  
 Сопоставление состоит из макросов, которые определяют начальный элемент, конечный элемент и ноль или более промежуточных элементов. Система анализа неверно интерпретирует сопоставления, поскольку каждый макрос сопоставления скрывает элементы языка C/C++, а синтаксис полную инструкцию C/C++ распределяется между несколькими отдельными макросами.  
  
 Следующий исходный код определяет `BEGIN_CATEGORY_MAP`, `IMPLEMENTED_CATEGORY`, и `END_CATEGORY_MAP` макросы.  
  
 **Исходный код:**  
  
```  
#define BEGIN_CATEGORY_MAP(x)\  
static const struct ATL::_ATL_CATMAP_ENTRY* GetCategoryMap() throw() {\  
static const struct ATL::_ATL_CATMAP_ENTRY pMap[] = {  
#define IMPLEMENTED_CATEGORY( catid ) { _ATL_CATMAP_ENTRY_IMPLEMENTED, &catid },  
#define END_CATEGORY_MAP()\  
   { _ATL_CATMAP_ENTRY_END, NULL } };\  
   return( pMap ); }  
```  
  
 **Стратегии:** Определение элементов сопоставления  
  
 Укажите подсказки для начала, середины (если есть) и конечного элементов сопоставления. Используйте специальные строки подстановки сопоставления, `@<`, `@=`, и `@>`. Дополнительные сведения см. в разделе `Syntax` в этой статье.  
  
 **Указание файла.**  
  
```  
// Start of the map.  
#define BEGIN_CATEGORY_MAP(x) @<  
// Intermediate map element.  
#define IMPLEMENTED_CATEGORY( catid ) @=  
// Intermediate map element.  
#define REQUIRED_CATEGORY( catid ) @=  
// End of the map.  
#define END_CATEGORY_MAP() @>  
```  
  
### <a name="composite-macros"></a>Составные макросы  
 Составные макросы содержат один или несколько типов макросов, неверно интерпретируемых системой анализа.  
  
 Следующий исходный код содержит `START_NAMESPACE` макрос, который задает начало области пространства имен, и `BEGIN_CATEGORY_MAP` макрос, который задает начало сопоставления.  
  
 **Исходный код:**  
  
```  
#define NSandMAP START_NAMESPACE BEGIN_CATEGORY_MAP  
```  
  
 **Стратегии:** прямое копирование  
  
 Создайте подсказки для `START_NAMESPACE` и `BEGIN_CATEGORY_MAP` макросы, а затем создайте подсказку для `NSandMAP` макрос, который является таким же, как было показано ранее в исходном коде. Кроме того Если составной макрос состоит только критические макросы и пробелы, можно определить подсказку, строка замены будет определение null.  
  
 В этом примере предполагается `START_NAMESPACE` уже имеется подсказка, как описано в этом разделе в `Concealed C/C++ Language Elements` подзаголовка. И Предположим, `BEGIN_CATEGORY_MAP` уже имеется подсказка, как описано в `Maps`.  
  
 **Указание файла.**  
  
```  
#define NSandMAP START_NAMESPACE BEGIN_CATEGORY_MAP  
```  
  
### <a name="inconvenient-macros"></a>Неудобные макросы  
 Некоторые макросы могут интерпретироваться системой анализа, но исходный код сложно прочитать, поскольку макрос длинных и сложных. Ради удобства чтения можно предоставить подсказку, которая упрощает отображение макроса.  
  
 **Исходный код:**  
  
```  
#define STDMETHOD(methodName) HRESULT (STDMETHODCALLTYPE * methodName)  
```  
  
 **Стратегии:** Упрощение  
  
 Создайте подсказку, которая отображает более простое определение макроса.  
  
 **Указание файла.**  
  
```  
#define STDMETHOD(methodName) void* methodName  
```  
  
## <a name="example"></a>Пример  
 В следующем примере показано, как происходит сбор подсказок из файлов подсказок. Стоп-файлы в этом примере не используются.  
  
 На следующем рисунке показана некоторые физические каталоги проекта Visual C++. Файлы подсказок расположены в `vcpackages`, `Debug`, `A1`, и `A2` каталоги.  
  
### <a name="hint-file-directories"></a>Каталоги файлов подсказок  
 ![Общие и #45; & проекта каталоги файлов подсказок конкретных.](../ide/media/hintfile.png "HintFile")  
  
### <a name="directories-and-hint-file-contents"></a>Каталоги и указание файла содержимого  
 Ниже перечислены каталоги этого проекта, которые содержат файлы подсказок и содержимое этих файлов подсказок. Только некоторые из множества подсказок в `vcpackages` перечислены в файле подсказок из каталога.  
  
-   vcpackages  
  
    ```  
    // vcpackages (partial list)  
    #define _In_  
    #define _In_opt_  
    #define _In_z_  
    #define _In_opt_z_  
    #define _In_count_(size)  
    ```  
  
-   Отладка  
  
    ```  
    // Debug  
    #undef _In_  
    #define OBRACE {  
    #define CBRACE }  
    #define RAISE_EXCEPTION(x) throw (x)  
    #define START_NAMESPACE namespace MyProject {  
    #define END_NAMESPACE }  
    ```  
  
-   A1  
  
    ```  
    // A1  
    #define START_NAMESPACE namespace A1Namespace {  
    ```  
  
-   A2  
  
    ```  
    // A2  
    #undef OBRACE  
    #undef CBRACE  
    ```  
  
### <a name="effective-hints"></a>Действующие подсказки  
 В следующей таблице перечислены действующие подсказки для исходных файлов в этом проекте.  
  
-   Исходный файл: A1_A2_B.cpp  
  
-   Действующие подсказки:  
  
    ```  
    // vcpackages (partial list)  
    #define _In_opt_  
    #define _In_z_  
    #define _In_opt_z_  
    #define _In_count_(size)  
    // Debug...  
    #define RAISE_EXCEPTION(x) throw (x)  
    // A1  
    #define START_NAMESPACE namespace A1Namespace {   
    // ...Debug  
    #define END_NAMESPACE }  
    ```  
  
 Следующие примечания применяются для приведенного выше списка.  
  
-   Действующие подсказки получены из `vcpackages`, `Debug`, `A1`, и `A2` каталоги.  
  
-    **#Undef** директиву `Debug` удален файл подсказок `#define _In_` подсказка в `vcpackages` файле подсказок из каталога.  
  
-   Файл подсказок в `A1` переопределяет каталог `START_NAMESPACE`.  
  
-    `#undef` Указание в `A2` Удалить каталог подсказки для `OBRACE` и `CBRACE` в `Debug` файле подсказок из каталога.  
  
## <a name="see-also"></a>См. также раздел  
 [Типы файлов, создаваемых для проектов Visual C++](../ide/file-types-created-for-visual-cpp-projects.md)   
 [Создание и управление средой Windows](../Topic/Creating%20and%20Controlling%20Environment%20Windows.md)   
 [#define-директива (C/C++)](../preprocessor/hash-define-directive-c-cpp.md)   
 [Директива #undef (C/C++)](../preprocessor/hash-undef-directive-c-cpp.md)   
 [Заметки SAL](../c-runtime-library/sal-annotations.md)   
 [Схемы сообщений](../mfc/reference/message-maps-mfc.md)   
 [Макросы схемы сообщений](../atl/reference/message-map-macros-atl.md)   
 [Макросы схемы объекта](../atl/reference/object-map-macros.md)