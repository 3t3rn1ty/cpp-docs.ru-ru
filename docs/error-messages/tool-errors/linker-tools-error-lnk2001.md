---
title: "Ошибка средств компоновщика LNK2001 | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-cpp
ms.tgt_pltfrm: 
ms.topic: error-reference
f1_keywords:
- LNK2001
dev_langs:
- C++
helpviewer_keywords:
- LNK2001
ms.assetid: dc1cf267-c984-486c-abd2-fd07c799f7ef
caps.latest.revision: 21
author: corob-msft
ms.author: corob
manager: ghogen
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
translationtype: Machine Translation
ms.sourcegitcommit: 9dee257bec0f09bd729bf10c4a1468ecb20dfa61
ms.openlocfilehash: 3629075e5659cb89ab751b011f3ce2cbf89397cc
ms.lasthandoff: 02/24/2017

---
# <a name="linker-tools-error-lnk2001"></a>Ошибка средств компоновщика LNK2001
неразрешенный внешний символ «символ»  
  
 Код ссылается на что-нибудь (например, функцией, переменной или метки), компоновщик не удается найти в библиотеках или объектных файлах.  
  
 Это сообщение об ошибке сопровождается неустранимой ошибки [LNK1120](../../error-messages/tool-errors/linker-tools-error-lnk1120.md).  
  
 **Возможные причины**  
  
-   При обновлении управляемой библиотеки или проекта веб-службы из Visual C++ 2003 **/Zl** добавляется параметр компилятора **командной строки** страницу свойств. Это приведет к ошибке LNK2001.  
  
     Чтобы устранить эту ошибку, либо добавьте файлы msvcrt.lib и msvcmrt.lib свойство Дополнительные зависимости компоновщика. Можно также удалить **/Zl** из **командной строки** страницу свойств. Дополнительные сведения см. в разделе [/Zl (опустить имя библиотеки по умолчанию)](../../build/reference/zl-omit-default-library-name.md) и [работа со свойствами проекта](../../ide/working-with-project-properties.md).  
  
-   Запрашиваемое кодом не существует (символ неверно указан или использует неправильного регистре, например).  
  
-   Код запрашивает неверный (используется смешанная версия библиотек — из разных версий продукта из другой версии).  
  
 **Конкретные причины**  
  
 **Проблемы кодирования**  
  
-   Если LNK2001 диагностическое сообщение о том, что `__check_commonlanguageruntime_version` имеет неразрешенный внешний символ в разделе [LNK2019](../../error-messages/tool-errors/linker-tools-error-lnk2019.md) сведения о способах устранения.  
  
-   Определение шаблона члена находится за пределами класса. Visual C++ имеет ограничение, в котором шаблоны членов должны быть полностью определены в включающего класса. В статье БАЗЫ знаний Q239436 Дополнительные сведения о шаблонах LNK2001 и членов.  
  
-   Несоответствующий регистр в коде или определения модуля (DEF) файла может вызвать ошибку LNK2001. Например, если имя переменной `var1` в C++ один исходный файл и обращении к ней как `VAR1` в другой.  
  
-   Проект, использующий [встраивания функции](../../error-messages/tool-errors/function-inlining-problems.md) еще, определяющий функции в CPP-файле, а не в заголовке файла может вызвать ошибку LNK2001.  
  
-   Вызов функции C из программы на C++ без использования `extern` «C» (который заставляет компилятор использовать соглашение об именовании C) может вызвать ошибку LNK2001. Параметры компилятора [/Tp](../../build/reference/tc-tp-tc-tp-specify-source-file-type.md) и [/Tc](../../build/reference/tc-tp-tc-tp-specify-source-file-type.md) компилятор компилировать файлы как C++ или C, соответственно, независимо от расширения имени файла. Эти параметры могут привести к имена функций, отличается от ожидаемого.  
  
-   Попытка сослаться на функции или данные, не имеющие внешних связей может вызвать ошибку LNK2001. В C++ встроенные функции и `const` данные имеют внутренние связи, если явно не указаны как `extern`.  
  
-   Объект [отсутствует тело функции или переменная](../../error-messages/tool-errors/missing-function-body-or-variable.md) может вызвать ошибку LNK2001. С прототипом функции или `extern` объявления компилятор может продолжать работу без ошибок, но компоновщик не может разрешить вызов по адресу или ссылку на переменную, поскольку отсутствует код функции или переменная интервала зарезервированы.  
  
-   Вызов функции с типами параметров, не соответствующими заданным в объявлении функции может вызвать ошибку LNK2001. [Декорирование имен](../../error-messages/tool-errors/name-decoration.md) включает параметры функции в окончательное дополненное имя функции.  
  
-   Некорректно включенный прототип, заставляющий компилятор ожидать текст функции, который не предоставляется может вызвать ошибку LNK2001. Если имеется класс и вне класса реализации функции `F`, помните о правилах разрешения области C++.  
  
-   При использовании C++, включение прототипа функции в определение класса и [включать реализацию](../../error-messages/tool-errors/missing-function-body-or-variable.md) функции для этого класса может вызвать ошибку LNK2001.  
  
-   Попытка вызова чистой виртуальной функции из конструктора или деструктора абстрактного базового класса может вызвать ошибку LNK2001. Чистой виртуальной функции не имеет базовый класс реализации.  
  
-   Попытка использовать переменную объявленная внутри функции ([локальной переменной](../../error-messages/tool-errors/automatic-function-scope-variables.md)) за пределами видимости данной функции может вызвать ошибку LNK2001.  
  
-   При построении окончательной версии проекта ATL, указывает, что в коде запуска CRT не требуется. Чтобы исправить это, выполните одно из следующих действий  
  
    -   Удалите `_ATL_MIN_CRT` из списка препроцессор определяет, чтобы разрешить включение кода запуска CRT. В разделе [странице свойств Общие параметры конфигурации](../../ide/general-property-page-project.md) подробнее.  
  
    -   Если это возможно удалите вызовы функций CRT, требующие код запуска CRT. Вместо этого используйте эквиваленты для Win32. Например, используйте `lstrcmp` вместо `strcmp`. Известные функции, требующие код запуска CRT приведены некоторые строки и функции с плавающей запятой.  
  
 **Компиляция и компоновка проблем**  
  
-   В проекте отсутствует ссылка на библиотеку (. LIB) или объекта (. Файл OBJ). В разделе [LIB-файлы в качестве входных данных компоновщика](../../build/reference/dot-lib-files-as-linker-input.md) подробнее.  
  
-   Если вы используете [/NODEFAULTLIB](../../build/reference/nodefaultlib-ignore-libraries.md) или [/Zl](../../build/reference/zl-omit-default-library-name.md), библиотеки, содержащие необходимый код, не будут скомпонованы в проект, если не включены явно. (При компиляции с параметром **/CLR** или **/CLR: pure**, вы увидите ссылку на .cctor; см. раздел [Инициализация смешанных сборок](../../dotnet/initialization-of-mixed-assemblies.md) подробнее.)  
  
-   Если вы используете Unicode и MFC, вы получите неразрешенный внешний `_WinMain@16` Если не создана точка входа для `wWinMainCRTStartup`; используйте [/Entry](../../build/reference/entry-entry-point-symbol.md). В разделе [Общие сведения о программировании Юникода](../../text/unicode-programming-summary.md).  
  
     В приведенных ниже статьях базы знаний, расположенного в библиотеке MSDN для получения дополнительной информации. В библиотеке MSDN щелкните **поиска** , вставьте номер или заголовок статьи в текстовое поле, а затем щелкните **разделы**. Если выполняется поиск по номеру статьи, убедитесь, что **поиска только в названиях** параметр.  
  
    -   Q125750 «PRB: ошибка LNK2001: "_WinMain@16": неразрешенного внешнего символа»  
  
    -   Q131204 «PRB: Выбор проектов неправильный вызывает ошибку LNK2001 в _WinMain@16»  
  
    -   Q100639 «поддержка Юникода в Microsoft Foundation Class библиотеки»  
  
    -   Q291952 «PRB: связывание ошибка LNK2001: неразрешенный внешний символ _main»  
  
-   Код, скомпилированный с /MT с библиотекой LIBC.lib компоновки, вызывает ошибку LNK2001 в `_beginthread`, `_beginthreadex`, `_endthread`, и `_endthreadex`.  
  
-   Код компоновки, требующий многопотоковые библиотеки (любой код MFC или код, скомпилированный с [/MT](../../build/reference/md-mt-ld-use-run-time-library.md)) вызывает ошибку LNK2001 в [_beginthread](../../c-runtime-library/reference/beginthread-beginthreadex.md), `_beginthreadex`, [_endthread](../../c-runtime-library/reference/endthread-endthreadex.md), и `_endthreadex`. См. Дополнительные сведения в следующей статье базы знаний:  
  
    -   Q126646 «PRB: сообщение об ошибке: LNK2001 на __beginthreadex и \__endthreadex»  
  
    -   Q128641 «INFO: параметры компилятора /Mx и LIBC, LIBCMT, MSVCRT библиотеки»  
  
    -   Q166504 «PRB: MFC и CRT должны совпадать в отладке или выпуску и статических и динамических»  
  
-   При компиляции с параметром **/MD**, ссылка на «func» в источнике превращается в ссылку «`__imp__func`» в объекте, поскольку все время выполнения содержится в библиотеке DLL. При попытке связать со статической библиотекой LIBC.lib или LIBCMT.lib возникнет ошибка LNK2001 `__imp__func`. При попытке компоновки с MSVCxx.lib при компилировании без /MD не всегда будет LNK2001, но вы, вероятно, возникают другие проблемы.  
  
-   Связывание с библиотеками в режиме выпуска при построении отладочной версии приложения может вызвать ошибку LNK2001. Аналогично, использование **/Mxd** параметр (**/MTd**, или **/MDd**) и/или определение `_DEBUG` и последующей компоновкой с выпущенными библиотеками предоставит возникновения неразрешенных внешних конфликтов (помимо прочих проблем). Компоновка построения в режиме выпуска с отладочными библиотеками также приведет к подобных проблем.  
  
-   Смешивание версий библиотек Microsoft или компиляторов может вызывать затруднения. Библиотеки новых версий компиляторов могут содержать новые символы, которые не удается найти в библиотеках предыдущих версий. Можно изменить порядок каталоги в пути поиска или изменить их, чтобы он указывал на текущую версию.  
  
     Инструменты | Параметры | Проекты | Диалоговое окно каталоги VC ++, при выборе файлов библиотек позволяет изменить порядок поиска. Папка "компоновщик" в диалоговом окне страницы свойств проекта может также содержать путей, которые могут быть устаревшими.  
  
     Эта проблема может возникнуть, если для установки нового SDK (возможно в другом месте), и порядок поиска не обновляется, чтобы он указывал на новое расположение. Как правило, необходимо указать путь для новых SDK директорий перед расположения Visual C++ по умолчанию. Кроме того проект, содержащий встроенные пути по-прежнему могут указывать на старые пути, которые допустимо, но истек срок для новых функций, встроенных в новой версии, установленной в другом месте.  
  
-   В настоящее время отсутствует стандарт для [именование C++](../../error-messages/tool-errors/name-decoration.md) между поставщиками компиляторов и даже между различными версиями одного компилятора. Таким образом при связывании объектных файлов, скомпилированных с помощью других компиляторов может не создавать различные схемы именования, таким образом вызовет ошибку LNK2001.  
  
-   [Смешивание встроенные и невстроенной параметров компиляции](../../error-messages/tool-errors/function-inlining-problems.md) в различных модулях может вызвать ошибку LNK2001. Если библиотека C++ создана с функциональная возможность встраивания включена (**/Ob1** или **/Ob2**), но в соответствующем файле заголовка с описанием функций отключена при встраивании (не `inline` ключевое слово), эта ошибка возникает. Чтобы избежать этой проблемы, встроенные функции определены с `inline` в файле заголовка, который требуется включить в другие файлы.  
  
-   Если вы используете `#pragma inline_depth` компилятора директив, убедитесь, что у вас есть [значение 2 или более](../../error-messages/tool-errors/function-inlining-problems.md)и убедитесь, что вы используете [/Ob1](../../build/reference/ob-inline-function-expansion.md) или [/Ob2](../../build/reference/ob-inline-function-expansion.md) параметр компилятора.  
  
-   Пропуск LINK-параметр/NOENTRY при создании ресурсной библиотеки DLL приведет к ошибке LNK2001.  
  
-   С помощью неправильные параметры SUBSYSTEM или/Entry может вызвать ошибку LNK2001. Например, если вы пишете символьный приложения (консольное приложение) и укажите /SUBSYSTEM:WINDOWS, вы получите неразрешенный внешний для `WinMain`. Дополнительные сведения об этих параметрах и точках входа см. в разделе [/SUBSYSTEM](../../build/reference/subsystem-specify-subsystem.md) и [/Entry](../../build/reference/entry-entry-point-symbol.md) параметры компоновщика.  
  
 **Проблемы при экспорте**  
  
-   При переносе приложения с 16 до 32- или 64-бит, может возникнуть ошибка LNK2001. Текущий синтаксис файла определения модуля (DEF) `__cdecl`, `__stdcall`, и `__fastcall` функции перечислены в разделе EXPORTS без подчеркивания (недекорированные). Это отличается от 16-разрядного синтаксиса, где они должны быть перечислены с подчеркивание. Дополнительные сведения см. в описании [ЭКСПОРТОВ](../../build/reference/exports.md) разделе файла определения модуля.  
  
-   Любой экспортируемый в DEF-файле и не найден, вызовет ошибку LNK2001. Возможно, не существует, неверно указан или использует внутреннее имя C++ (DEF-файлы не принимают внутренние имена)  
  
 **Интерпретация выходных данных**  
  
 Когда символ не разрешен, можно получить сведения о функции следующими способами:  
  
 На x86 платформ, вызывающий соглашение Декорирование имен, компилированных в C, или для внешних имен «C» в C++, является:  
  
 `__cdecl`  
 Функции имеют в префиксе символ подчеркивания (_).  
  
 `__stdcall`  
 Функции имеют в префиксе символ подчеркивания (_) и суффикс @ с последующим двойным словом, обозначающим выравниваются размер параметров в стеке.  
  
 `__fastcall`  
 Функция имеет префикс @ и суффикс @ с последующим двойным словом, обозначающим выравниваются размер параметров в стеке.  
  
 Используйте undname.exe для получения недекорированных декорированного имени.  
  
 Дополнительные сведения на некоторые из причин, перечисленных выше в разделе [имя оформление](../../error-messages/tool-errors/name-decoration.md).
