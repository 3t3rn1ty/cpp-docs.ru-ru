---
title: "Ошибка во время выполнения C R6035 | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "error-reference"
f1_keywords: 
  - "R6035"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "R6035"
ms.assetid: f8fb50b8-18bf-4258-b96a-b0a9de468d16
caps.latest.revision: 6
caps.handback.revision: 6
author: "corob-msft"
ms.author: "corob"
manager: "ghogen"
---
# Ошибка во время выполнения C R6035
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

Библиотека времени выполнения Microsoft Visual C\+\+, ошибка R6035 — Модуль в этом приложении инициализирует глобальный файл Cookie безопасности модуля, в то время как функция, использующая этот файл, активна.  Следует вызывать \_\_security\_init\_cookie ранее.  
  
 Необходимо вызывать [\_\_security\_init\_cookie](../../c-runtime-library/reference/security-init-cookie.md) до первого использования глобального файла Cookie безопасности.  
  
 Глобальный файл Cookie безопасности используется для защиты от переполнения буфера в коде, скомпилированном с помощью [Параметр \/GS \(проверка безопасности буфера\)](../Topic/-GS%20\(Buffer%20Security%20Check\).md), и в коде, в котором используется структурная обработка исключений.  По сути, на входе в защищенную от переполнения буфера функцию в стек помещается файл Cookie, а на выходе значение в стеке сравнивается с глобальным файлом Cookie.  Любое отличие между этими файлами означает, что произошло переполнение буфера, которое привело к мгновенному завершению программы.  
  
 Ошибка R6035 означает, что вызов `__security_init_cookie` был осуществлен после того, как был выполнен вход в защищенную функцию.  При дальнейшем выполнении программы было бы обнаружено ложное переполнение буфера, поскольку файл Cookie в стеке больше не соответствует глобальному файлу Cookie.  
  
 Рассмотрим следующий пример DLL.  Точка входа в библиотеку DLL установлена в DllEntryPoint в параметре компоновщика [\/ENTRY \(символ точки входа\)](../../build/reference/entry-entry-point-symbol.md).  Это позволяет обойти инициализацию CRT, в которой, как правило, инициализируется глобальный файл Cookie безопасности, поэтому сама библиотека должна вызвать `__security_init_cookie`.  
  
```  
// Wrong way to call __security_init_cookie  
DllEntryPoint(...) {  
   DllInitialize();  
   ...  
   __try {  
      ...  
   } __except()... {  
      ...  
   }  
}  
  
void DllInitialize() {  
   __security_init_cookie();  
}  
```  
  
 В данном примере возникнет ошибка R6035, поскольку параметр точки входа DllEntryPoint использует структурную обработку исключений, а значит, и файл Cookie безопасности для определения переполнения буфера.  К моменту вызова DllInitialize глобальный файл Cookie безопасности уже помещен в стек.  
  
 Правильный способ вызова показан в следующем примере.  
  
```  
// Correct way to call __security_init_cookie  
DllEntryPoint(...) {  
   __security_init_cookie();  
   DllEntryHelper();  
}  
  
void DllEntryHelper() {  
   ...  
   __try {  
      ...  
   } __except()... {  
      ...  
   }  
}  
```  
  
 В этом случае DllEntryPoint не защищена от переполнения буфера \(в ней нет буфера локальных строк и не используется структурная обработка исключений\). Это позволяет безопасно вызвать `__security_init_cookie`.  Затем DllEntryPoint вызывает вспомогательную функцию, которая является защищенной.  
  
> [!NOTE]
>  Сообщение об ошибке R6035 создается только библиотекой CRT отладки для платформы x86 и только для структурной обработки исключений, однако подобное состояние приводит к возникновению ошибки на всех платформах и для всех форм обработки исключений, включая обработку исключений для C\+\+.  
  
## См. также  
 [Проверки безопасности, более компилятора](http://go.microsoft.com/fwlink/?linkid=7260)