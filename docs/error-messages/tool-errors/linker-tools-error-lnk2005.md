---
title: Ошибка средств компоновщика LNK2005 | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-diagnostics
ms.topic: error-reference
f1_keywords:
- LNK2005
dev_langs:
- C++
helpviewer_keywords:
- LNK2005
ms.assetid: d9587adc-68be-425c-8a30-15dbc86717a4
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: f853bec220c7d46ed2a0c44ac1e1d45fbca8318f
ms.sourcegitcommit: 76b7653ae443a2b8eb1186b789f8503609d6453e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
---
# <a name="linker-tools-error-lnk2005"></a>Ошибка средств компоновщика LNK2005
*символ* уже определен в объекте  
  
Символ *символ* был определен более одного раза.   
  
Эта ошибка сопровождается неустранимой ошибки [LNK1169](../../error-messages/tool-errors/linker-tools-error-lnk1169.md).  
  
### <a name="possible-causes-and-solutions"></a>Возможные причины и решения  
  
Как правило, эта ошибка означает, что при разрыве *правило одного определения*, что позволяет только одно определение используется шаблон, функции, тип или объект в заданный объект файла и только одно определение через весь исполняемый файл для Видимый извне объекты или функции.  
  
Ниже приведены некоторые распространенные причины этой ошибки.  
  
-   Эта ошибка может возникать, если файл заголовка определяет переменную. Например если включить файл заголовка в более чем один исходный файл в проект, вызовет ошибку:  
  
    ```h  
    // LNK2005_global.h  
    int global_int;  // LNK2005
    ```  
  
    Ниже представлены возможные решения.  
  
    -   Объявите переменную `extern` в файле заголовка: `extern int global_int;`, затем определить и инициализировать его при необходимости в один и только один исходный файл: `int global_int = 17;`. Эта переменная теперь является глобальным, можно использовать в любой исходный файл, объявив ее `extern`, например, путем включения файла заголовка. Мы рекомендуем это решение для переменных, которые должны быть глобальными, но хороший программного обеспечения подход сводит к минимуму глобальные переменные.  
    
    -   Объявите переменную [статических](../../cpp/storage-classes-cpp.md#static): `static int static_int = 17;`. Это ограничивает область определения в текущем файле объекта и выбирать несколько файлов объекта имеет собственную копию переменной. Не рекомендуется определять статические переменные в файлах заголовков из-за избежание путаницы с глобальные переменные. Хотите перейти определения статических переменных установочные файлы, которые их используют.  
  
    -   Объявите переменную [selectany](../../cpp/selectany.md): `__declspec(selectany) int global_int = 17;`. Это заставляет компоновщик выбирает одно определение для использования с всех внешних ссылок и отказаться от остальных. Это решение, иногда бывает полезен при объединении библиотеки импорта. В противном случае не рекомендуется, чтобы избежать ошибок компоновщика.  
  
-   Эта ошибка может возникать, если файл заголовка определяет функцию, которая не `inline`. Если включить этот файл заголовка в более чем один исходный файл, вы получаете несколько определений функции в исполняемом файле.  
    
    ```h  
    // LNK2005_func.h  
    int sample_function(int k) { return 42 * (k % 167); }  // LNK2005
    ```  
  
    Ниже представлены возможные решения.  
  
    -   Добавить `inline` ключевое слово для функции: 

        ```h  
        // LNK2005_func_inline.h  
        inline int sample_function(int k) { return 42 * (k % 167); }  
        ```  
  
    -   Удалить тело функции из файла заголовка и оставьте только объявление, а затем реализовать функции в один и только один исходный файл:  
  
        ```h  
        // LNK2005_func_decl.h  
        int sample_function(int);  
        ```  
  
        ```cpp  
        // LNK2005_func_impl.cpp  
        int sample_function(int k) { return 42 * (k % 167); }  
        ```  
-   Эта ошибка также может возникнуть, если определение функции-члены вне объявления класса в файле заголовка:  
  
    ```h  
    // LNK2005_member_outside.h  
    class Sample {
    public:
        int sample_function(int);  
    };
    int Sample::sample_function(int k) { return 42 * (k % 167); }  // LNK2005
    ```  
  
    Чтобы устранить эту проблему, переместите определения функций члена внутри класса. Неявно встраиваются члена функции, определенные внутри объявления класса.  
  
    ```h  
    // LNK2005_member_inline.h  
    class Sample {
    public:
        int sample_function(int k) { return 42 * (k % 167); }  
    };
    ```  
  
-   Эта ошибка может возникать при связывании более чем одной версии стандартной библиотеки или CRT. Например при попытке связать исполняемый файл как розничной торговли и отладочные библиотеки CRT, а также статические и динамические версии библиотеки или две различные версии стандартной библиотеки, эта ошибка может сообщаться много раз. Чтобы устранить эту проблему, удалите все, кроме одного копию каждой библиотеки в команде link. Не рекомендуется смешивать розничной торговли и отладки библиотеки или различные версии библиотеки, в одном исполняемом объекте.  
  
    Чтобы указывают компоновщику, что для использования библиотеки, отличные от значений по умолчанию, в командной строке укажите библиотеки, а воспользуйтесь [/NODEFAULTLIB](../../build/reference/nodefaultlib-ignore-libraries.md) параметр для отключения библиотеки по умолчанию. В Интегрированной среде разработки, добавьте ссылки проекта, чтобы указать библиотек для использования, а затем откройте **страницы свойств** диалогового окна проекта, а в **компоновщика**, **ввода** свойство Задайте либо **игнорировать все стандартные библиотеки**, или **игнорировать определенной библиотеки по умолчанию** для отключения библиотеки по умолчанию.   
  
-   Эта ошибка может возникать, если смешивать использование статических и динамических библиотек при использовании [/CLR](../../build/reference/clr-common-language-runtime-compilation.md) параметр. Например Эта ошибка может возникать при сборке библиотеки DLL для использования в исполняемый файл со ссылкой в статической библиотеки CRT. Чтобы устранить эту проблему, используйте только статические библиотеки или только динамические библиотеки для всего исполняемый файл и все библиотеки, создаваемых в исполняемом файле.  
  
-   Эта ошибка может возникать, если символ является упакованной функцией (созданной компилированием с [/Gy](../../build/reference/gy-enable-function-level-linking.md)) и он был включен в несколько файлов, но изменен в промежутке между компиляциями. Чтобы устранить эту проблему, необходимо перекомпилируйте все файлы, включающие упакованной функцией.  
  
-   Эта ошибка может возникать, если этот символ определен по-разному в двух объектах-членах в различных библиотеках, и используются оба объекта-члена. Чтобы устранить эту проблему, когда статически связанные библиотеки можно использовать объект члена из библиотеки только один и включать эту библиотеку сначала в командной строке компоновщика. Чтобы использовать оба символа, необходимо создать способ их различать. Например при создании библиотеки из источника, можно заключить каждой библиотеки в уникальное пространство имен. Кроме того можно создать новый Библиотека оболочки, которая использует уникальные имена для переноса ссылок на библиотеки исходного, связать новую библиотеку исходной библиотеки, а затем ссылка на новый библиотеку вместо исходной библиотеки исполняемый файл.  
  
-   Эта ошибка может возникать, если `extern const` переменной значение определено дважды и имеет другое значение в каждом определении. Чтобы устранить эту проблему, определите константой только один раз или использовать пространства имен или `enum class` определения для различения константы.  
  
-   Эта ошибка может возникать, если вы используете uuid.lib в сочетании с другими файлами LIB, определяющими идентификаторы GUID (например oledb.lib и adsiid.lib). Пример:  
  
    ```Output  
    oledb.lib(oledb_i.obj) : error LNK2005: _IID_ITransactionObject  
    already defined in uuid.lib(go7.obj)  
    ```  
  
     Чтобы устранить эту проблему, добавьте [/FORCE: Multiple](../../build/reference/force-force-file-output.md) в параметры командной строки компоновщика и убедитесь в том, что uuid.lib является первой библиотекой в ссылках.
  
## <a name="additional-information"></a>Дополнительные сведения  
  
Если вы используете старую версию набора инструментов, см. Дополнительные сведения о конкретных причин этой ошибки статьи базы знаний:  
  
-   [Ошибка LNK2005 возникает, когда библиотеки CRT и библиотеки MFC связаны в неправильном порядке в Visual C++](https://support.microsoft.com/kb/148652)  
  
-   [Исправление: Delete глобальный перегруженный оператор причины LNK2005](https://support.microsoft.com/kb/140440)  
  
-   [При компиляции проекта ATL исполняемого файла (.exe) в Visual C++ ошибки LNK2005](https://support.microsoft.com/kb/184235).  
  
