---
title: "Ошибка средств компоновщика LNK2019 | Документы Microsoft"
ms.custom: 
ms.date: 05/17/2017
ms.reviewer: 
ms.suite: 
ms.technology: cpp-tools
ms.tgt_pltfrm: 
ms.topic: error-reference
f1_keywords: LNK2019
dev_langs: C++
helpviewer_keywords:
- nochkclr.obj
- LNK2019
- _check_commonlanguageruntime_version
ms.assetid: 4392be92-195c-4eb2-bd4d-49cfac3ca291
caps.latest.revision: "39"
author: corob-msft
ms.author: corob
manager: ghogen
ms.openlocfilehash: ce3fddc9977f0abda1d776fd66172dbb49e86d3a
ms.sourcegitcommit: ebec1d449f2bd98aa851667c2bfeb7e27ce657b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/24/2017
---
# <a name="linker-tools-error-lnk2019"></a>Ошибка средств компоновщика LNK2019
неразрешенный внешний символ "*символ*«ссылка на функцию»*функция*"  
  
Скомпилированный код для *функция* делает ссылку или вызов *символ*, однако этот символ не определен ни в одном из библиотеки или объектные файлы, указанные в компоновщик.  
  
Это сообщение об ошибке сопровождается неустранимой ошибки [LNK1120](../../error-messages/tool-errors/linker-tools-error-lnk1120.md). Необходимо исправить ошибки все LNK2001 и ошибки LNK2019 для устранения ошибки LNK1120.  
  
## <a name="possible-causes"></a>Возможные причины  
  
Существует множество способов, чтобы получить эту ошибку, но все они требуют ссылку на функцию или переменную, компоновщик не может *устранить*, или найти определение. Компилятор может указать, когда символ не *объявлен*, но не при не *определенные*, так как определение может находиться в другом файле исходного кода или библиотеки. Если символ имеется ссылка, но не определена, компоновщик создает ошибку неразрешенный внешний символ.  
  
Ниже приведены некоторые распространенные проблемы, вызывающие ошибку LNK2019.  
  
-   **Файл объекта или библиотеки, которая содержит определение символа не связан.** В Visual Studio убедитесь, что исходный файл, содержащий определение построения и связать как часть проекта. В командной строке убедитесь, что исходный файл, содержащий определение компилируется, и что полученный объектный файл включен в список файлов для связывания.  
  
-   **Написание объявления символа отличается от написания определения символа.** Проверьте правильность написания и регистр символов используется в объявлении и определении, а также везде, где символ использовать или вызывать.  
  
-   **Используется функция, но тип или количество параметров не соответствует определению функции.** Объявление функции должно соответствовать определению. Убедитесь в том, что вызов функции совпадает с объявлением, а объявление совпадает с определением. Код, который вызывает функции шаблона, также должен иметь совпадающие объявления функции шаблона, включающие те же параметры шаблона, что и определение. Пример несоответствия объявление шаблона см. Образец LNK2019e.cpp в подразделе «примеры».  
  
-   **Функция или переменная объявлена, но не определена.** Обычно это означает, что объявление существует в файле заголовка, но отсутствует соответствующее определение реализуется. Для функций-членов и статических элементов данных реализация должна содержать селектор области класса. Пример см. в разделе [Missing Function Body or Variable](../../error-messages/tool-errors/missing-function-body-or-variable.md).  
  
-   **Соглашение о вызовах в объявлении функции отличается от соглашения в определении функции.** Соглашения о вызовах ([__cdecl](../../cpp/cdecl.md), [__stdcall](../../cpp/stdcall.md), [__fastcall](../../cpp/fastcall.md)или [__vectorcall](../../cpp/vectorcall.md)) кодируются в составе декорированного имени. Убедитесь в том, что соглашение о вызовах одно и то же.  
  
-   **Символ определен в файле C, но объявлен без использования модификатора extern "C" в файле C++.** Декорированные имена символов, определенные в файле, который компилируется как C, будут отличаться от имен символов, объявленных в файле C++, до тех пор, пока не будет использоваться модификатор [extern "C"](../../cpp/using-extern-to-specify-linkage.md) . Убедитесь в том, что объявление соответствует компоновке компиляции для каждого символа. Аналогично, если символ определяется в файле C++, который будет использоваться программой C, в определении следует использовать `extern "C"` .  
  
-   **Символ определяется как статический, и позднее на него указывает ссылка за пределами файла.** В C++, в отличие от C, [глобальные константы](../../error-messages/tool-errors/global-constants-in-cpp.md) имеют компоновку `static` . Чтобы обойти это ограничение, можно включить инициализации `const` в заголовок файла и ввести этот заголовок в CPP-файлы или можно присвоить переменной неконстантное значение и использовать для доступа к ней константную ссылку.  
  
-   **Не определен статический член класса.** Статический член класса должен иметь уникальное определение. В противном случае он будет нарушать правило одного определения. Статический член класса, который не может быть определен как встроенный, должен быть определен в одном исходном файле с помощью его полного имени. Если он не определен вообще, компоновщик создает ошибку LNK2019.  
  
-   **Зависимость сборки определена только как зависимость проекта в решении.** В более ранних версиях Visual Studio этого уровня зависимости было достаточно. Тем не менее, начиная с Visual Studio 2010, Visual Studio требуется [ссылки проекта на проект](/visualstudio/ide/managing-references-in-a-project). Если в проекте отсутствует ссылка на другой проект, может возникнуть эта ошибка компоновщика. Чтобы устранить ошибку, добавьте ссылку одного проекта на другой.  
  
-   **Построение консольного приложения выполняется с использованием параметров для приложения Windows**. Если появилось сообщение об ошибке похожее на **unresolved external symbol WinMain referenced in function**`function_name`, выполните компоновку с помощью **/SUBSYSTEM:CONSOLE** вместо **/SUBSYSTEM:WINDOWS**. Дополнительные сведения об этом параметре и инструкции о том, как задать это свойство в Visual Studio, см. в статье [/SUBSYSTEM (Specify Subsystem)](../../build/reference/subsystem-specify-subsystem.md).  
  
-   **При попытке связать 64-разрядные библиотеки 32-разрядного кода или 32-разрядные библиотеки для 64-разрядного кода.** Библиотеки и объектных файлов, связанных с код должен быть скомпилирован для ту же архитектуру, что ваш код. Убедитесь, что ссылки проекта компилируются на ту же архитектуру, что и проект библиотеки. Убедитесь, что [/LIBPATH](../../build/reference/libpath-additional-libpath.md) или **Дополнительные каталоги библиотек** параметр пути, используемые точками компоновщика для библиотек, разработанных для обеспечения правильной архитектуры.

-   **Для встраивания функции в различные исходные файлы используются разные параметры компилятора.** Использование встроенных функций, определенных в CPP-файлах, и смешение в различных исходных файлах параметров компилятора для встраивания функций может привести к возникновению ошибки LNK2019. Для получения дополнительной информации см. [Function Inlining Problems](../../error-messages/tool-errors/function-inlining-problems.md).  
  
-   **Автоматические переменные используются за пределами их области видимости.** Автоматические переменные (области видимости функции) могут использоваться только в области видимости данной функции. Эти переменные не могут объявляться `extern` и использоваться в других исходных файлах. Пример см. в разделе [Automatic (Function Scope) Variables](../../error-messages/tool-errors/automatic-function-scope-variables.md).  
  
-   **Выполняется вызов встроенных функций или передача типов аргументов во встроенные функции, которые не поддерживаются в целевой архитектуре.** Например, если используется встроенная функция AVX2, но не указан параметр компилятора [/ARCH:AVX2](../../build/reference/arch-x86.md) , компилятор предполагает, что встроенная функция является внешней. Вместо создания встроенной инструкции компилятор создает вызов внешнего символа с тем же именем, что и у встроенного. Когда компоновщик пытается найти определение этой отсутствующей функции, он создает ошибку LNK2019. Убедитесь в том, что используются только встроенные функции и типы, поддерживаемые целевой архитектурой.  
  
-   **Код, который использует собственный тип данных wchar смешан\_t с кодом, который не.** Действия по согласованности языка C++, выполненные в Visual C++ 2005, привели к созданию собственного типа `wchar_t` по умолчанию. Для создания кода, совместимого с файлами библиотек и объектов, скомпилированными с помощью предыдущих версий Visual C++, необходимо использовать параметр компилятора [/Zc:wchar_t-](../../build/reference/zc-wchar-t-wchar-t-is-native-type.md) . Если не все файлы были скомпилированы с использованием тех же **/Zc:wchar\_t** параметров, тип ссылки не может быть выполнено в совместимые типы. Убедитесь в том, что типы `wchar_t` во всех файлах библиотек и объектов являются совместимыми. Для этого обновите используемые типы или используйте согласованные параметры **/Zc:wchar_t** при компиляции.  
  
## <a name="diagnosis-tools"></a>Средства диагностики    
  
Выяснение причин, по которым компоновщику не удается найти определение конкретного символа, может оказаться трудной задачей. Часто проблема заключается в том, что код, который содержит определение сборки, не включены или сборки параметры создали различные декорированные имена для внешних символов. Существует несколько средств и параметров, которые помогут диагностировать ошибку LNK2019.  
  
-   С помощью параметра компоновщика [/VERBOSE](../../build/reference/verbose-print-progress-messages.md) можно определить, на какие файлы ссылается компоновщик. Это поможет проверить, включен ли файл, содержащий определения символа, в сборку.  
  
-   Параметры [/EXPORTS](../../build/reference/dash-exports.md) и [/SYMBOLS](../../build/reference/symbols.md) служебной программы DUMPBIN помогут определить, какие символы определены в DLL-файлах и файлах объекта или библиотеки. Убедитесь в том, что экспортированные декорированные имена совпадают со ссылками, которые ищет компоновщик.  
  
-   Служебная программа UNDNAME может показывать эквивалентный недекорированный внешний символ для декорированного имени.  
## <a name="examples"></a>Примеры  
  
Далее приводится несколько примеров кода, вызывающего ошибку LNK2019, а также сведения о том, как устранить ошибку.  
  
### <a name="a-symbol-is-declared-but-not-defined"></a>Символ объявлен, но не определен  
  
В этом примере Внешняя переменная объявлена, но не определен:  
  
```cpp  
// LNK2019.cpp  
// Compile by using: cl /EHsc /W4 LNK2019.cpp  
// LNK2019 expected  
extern char B[100];   // B is not available to the linker  
int main() {  
   B[0] = ' ';   // LNK2019  
}  
```  
  
Вот другой пример, где переменных и функций объявляются как `extern` , но не определение содержится:  
  
```cpp  
// LNK2019c.cpp  
// Compile by using: cl /EHsc LNK2019c.cpp  
// LNK2019 expected  
extern int i;  
extern void g();  
void f() {  
   i++;  
   g();  
}  
int main() {}  
```  
  
Если не `i` и `g` определены в одном из файлов, включенных в сборке, компоновщик создает ошибку LNK2019. Чтобы исправить ошибки, включите файл исходного кода, который содержит определения, в процесс компиляции. Кроме того можно передать файлы OBJ или LIB-файлы, содержащие определения в компоновщик.  
  
### <a name="a-static-data-member-is-declared-but-not-defined"></a>Статические данные-член объявлены, но не определены  
  
Ошибка LNK2019 также может возникнуть в том случае, если статические данные-член объявлены, но не определены. В следующем примере показано возникновение ошибки LNK2019 и приводятся сведения по ее устранению.  
  
```cpp  
// LNK2019b.cpp  
// Compile by using: cl /EHsc LNK2019b.cpp  
// LNK2019 expected  
struct C {  
   static int s;  
};  
  
// Uncomment the following line to fix the error.  
// int C::s;  
  
int main() {  
   C c;  
   C::s = 1;  
}  
```  
  
### <a name="declaration-parameters-do-not-match-definition"></a>Параметры объявления не совпадают с определением  
  
Код, который вызывает функции шаблона, должен иметь совпадающие объявления функции шаблона. Объявления должны содержать те же параметры шаблона, что и определение. В следующем примере показано возникновение ошибки LNK2019 для определяемого пользователем оператора и приводятся сведения по ее устранению.  
  
```cpp  
// LNK2019e.cpp  
// compile by using: cl /EHsc LNK2019e.cpp  
// LNK2019 expected  
#include <iostream>  
using namespace std;  
  
template<class T> class   
Test {  
   // The operator<< declaration does not match the definition below:  
   friend ostream& operator<<(ostream&, Test&);  
   // To fix, replace the line above with the following:  
   // template<typename T> friend ostream& operator<<(ostream&, Test<T>&);  
};  
  
template<typename T>  
ostream& operator<<(ostream& os, Test<T>& tt) {  
   return os;  
}  
  
int main() {  
   Test<int> t;  
   cout << "Test: " << t << endl;   // LNK2019 unresolved external  
}  
```  
  
### <a name="inconsistent-wchart-type-definitions"></a>Несогласованные определения типа wchar_t  
  
Этот образец создает библиотеки DLL с экспортом, использующим `WCHAR`, который разрешается в `wchar_t`.  
  
```cpp  
// LNK2019g.cpp  
// compile with: cl /EHsc /LD LNK2019g.cpp  
#include "windows.h"  
// WCHAR resolves to wchar_t  
__declspec(dllexport) void func(WCHAR*) {}  
```  
  
Следующий пример использует библиотеку DLL в предыдущем примере и создает ошибку LNK2019, поскольку неподписанные типы short * и WCHAR\* не совпадают.  
  
```cpp  
// LNK2019h.cpp  
// compile by using: cl /EHsc LNK2019h LNK2019g.lib  
// LNK2019 expected  
__declspec(dllimport) void func(unsigned short*);  
  
int main() {  
   func(0);  
}  
```  
  
 Чтобы устранить эту ошибку, измените `unsigned short` для `wchar_t` или `WCHAR`, или выполните компиляцию с помощью LNK2019g.cpp **/Zc:wchar_t-**.  
  
## <a name="additional-resources"></a>Дополнительные ресурсы  
  
Дополнительные сведения о возможных причинах проблем и решений для LNK2001 см. в разделе вопросу переполнения стека [возможности ошибка неопределенной ссылки или неразрешенного внешнего символа и как ее исправить?](http://stackoverflow.com/q/12573816/2002113).  

