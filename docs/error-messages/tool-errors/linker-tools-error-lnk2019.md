---
title: "Ошибка средств компоновщика LNK2019 | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-cpp
ms.tgt_pltfrm: 
ms.topic: error-reference
f1_keywords:
- LNK2019
dev_langs:
- C++
helpviewer_keywords:
- nochkclr.obj
- LNK2019
- _check_commonlanguageruntime_version
ms.assetid: 4392be92-195c-4eb2-bd4d-49cfac3ca291
caps.latest.revision: 39
author: corob-msft
ms.author: corob
manager: ghogen
translation.priority.ht:
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- ru-ru
- zh-cn
- zh-tw
translation.priority.mt:
- cs-cz
- pl-pl
- pt-br
- tr-tr
translationtype: Machine Translation
ms.sourcegitcommit: 6cad5222fb0d97594d5b13b5cf8903eb2934ee88
ms.openlocfilehash: 86b43f2688b6e1dbfb39dfec681ca9adafd2c093
ms.lasthandoff: 02/24/2017

---
# <a name="linker-tools-error-lnk2019"></a>Ошибка средств компоновщика LNK2019
неразрешенный внешний символ "symbol", на который существует ссылка в функции "function"  
  
 Компоновщику не удалось найти определение внешнего символа "`symbol`", используемого в функции "`function`".  
  
 Существует множество проблем, которые могут вызвать эту ошибку. В данном разделе содержатся сведения, которые помогут определить причину возникновения ошибки и найти решение проблемы.  
  
 Объект *символ* имя, компилятор использует для функций или глобальных переменных. *Внешний символ* имя, используемое для ссылки на символ, который определен в другом файле источника или объекта. Компоновщик должен *устранить*, или определение для внешнего символа для каждой функции или глобальной переменной, используемых каждой скомпилированный файл когда связана с приложением или DLL. Если компоновщику не удается найти соответствующее определение для внешнего символа ни в одном связанном файле, он генерирует ошибку LNK2019.  
  
 Эта ошибка может возникать, если файл объекта или библиотеки, который содержит определение символа не включен в сборку. Также может возникнуть, если имя символа, ищет компоновщик не соответствует имени символа в файле библиотеки или объект, определяющий его. Это может произойти, если имя в вызывающем коде неправильно указано, использует прописной буквы, использует другой соглашение о вызовах или задает различные параметры.  
  
 Код, использующий компоновку C++ использует [Декорирование имен](../../error-messages/tool-errors/name-decoration.md), также известный как *декорированием имен*, для кодирования дополнительных сведений о типе и соглашение о вызовах в имени переменной или функции. *Декорированное имя* — это имя, которое ищет компоновщик для разрешения внешних символов. Поскольку сведения о типе становится частью декорированного имени символа, может привести LNK2019, если объявление внешний символ, где используется не соответствует объявлению символа, где он определен. Чтобы помочь определить причину ошибки, сообщение об ошибке показано, как «понятное имя, «имя, используемое в исходный код и декорированное имя (в скобках) неразрешенный внешний символ. Не нужно знать, как перевести декорированное имя, чтобы иметь возможность сравнить его с другим декорированные имена.  
  
 **Распространенные проблемы**  
  
 Ниже приведены некоторые распространенные проблемы, вызывающие ошибку LNK2019.  
  
-   **Объектный файл или библиотеку, которая содержит определение символа не связаны.** В Visual Studio убедитесь, что исходный файл, содержащий определение построения и связать как часть проекта. В командной строке убедитесь, что исходный файл, содержащий определение компилируется и включение в список файлов, чтобы связать файл результирующего объекта.  
  
-   **Объявления символа не написано таким же, как определение символа.** Проверьте правильность написания и регистр символов в объявление и определение, и везде, где используется символ или именем.  
  
-   **Используется функция, но тип или число параметров не соответствует определению функции.** Объявление функции должно соответствовать определению. Убедитесь в том, что вызов функции совпадает с объявлением, а объявление совпадает с определением. Код, который вызывает функции шаблона, также должен иметь совпадающие объявления функции шаблона, включающие те же параметры шаблона, что и определение. Пример несоответствия объявление шаблона см. Образец LNK2019e.cpp в разделе «примеры».  
  
-   **Функция или переменная объявлена, но не определен.** Это обычно означает объявление существует в файле заголовка, но отсутствует соответствующее определение реализуется. Для функций-членов и статических элементов данных реализация должна содержать селектор области класса. Например, в разделе [отсутствует тело функции или переменная](../../error-messages/tool-errors/missing-function-body-or-variable.md).  
  
-   **Соглашение о вызовах различается в объявлении и определении функции.** Соглашения о вызовах ([__cdecl](../../cpp/cdecl.md), [__stdcall](../../cpp/stdcall.md), [__fastcall](../../cpp/fastcall.md), или [__vectorcall](../../cpp/vectorcall.md)) кодируются в составе декорированного имени. Убедитесь в том, что соглашение о вызовах одно и то же.  
  
-   **Символ определен в файле C, но объявлен без использования extern «C» в файле C++.** Символы, определенные в файле, который компилируется как C имеют различные декорированные имена, чем символов, объявленных в файле C++ без использования [extern «C»](../../cpp/using-extern-to-specify-linkage.md) модификатор. Убедитесь в том, что объявление соответствует компоновке компиляции для каждого символа.  
  
     Аналогично, если символ определяется в файле C++, который будет использоваться программой C, в определении следует использовать `extern "C"` .  
  
-   **Символ определяется как статический и затем используется вне файла.** В C++, в отличие от C [глобальные константы](../../error-messages/tool-errors/global-constants-in-cpp.md) есть `static` компоновки. Чтобы обойти это ограничение, можно включить инициализации `const` в заголовок файла и ввести этот заголовок в CPP-файлы или можно присвоить переменной неконстантное значение и использовать для доступа к ней константную ссылку.  
  
-   **Не определен статический член класса.** Статический член класса должен иметь уникальное определение. В противном случае он будет нарушать правило одного определения. Статический член класса, который не может быть определен как встроенный, должен быть определен в одном исходном файле с помощью его полного имени. Если он не определен вообще, компоновщик создает ошибку LNK2019.  
  
-   **Зависимость сборки определена только как зависимость проекта в решении.** В более ранних версиях [!INCLUDE[vsprvs](../../assembler/masm/includes/vsprvs_md.md)] этого уровня зависимости было достаточно. Однако, начиная с Visual Studio 2010, [!INCLUDE[vsprvs](../../assembler/masm/includes/vsprvs_md.md)] требует [ссылку для проекта](/visualstudio/ide/managing-references-in-a-project). Если в проекте отсутствует ссылка на другой проект, может возникнуть эта ошибка компоновщика. Чтобы устранить ошибку, добавьте ссылку одного проекта на другой.  
  
-   **Построение консольного приложения выполняется с использованием параметров для приложения Windows**. Если появилось сообщение об ошибке похожее на **unresolved external symbol WinMain referenced in function**`function_name`, выполните компоновку с помощью **/SUBSYSTEM:CONSOLE** вместо **/SUBSYSTEM:WINDOWS**. Дополнительные сведения об этом параметре и инструкции о том, как задать это свойство в Visual Studio см. [/SUBSYSTEM (Укажите подсистему)](../../build/reference/subsystem-specify-subsystem.md).  
  
-   **Использовать разные параметры компилятора для встраивания функции в различных исходных файлах.** Использование встроенных функций, определенных в CPP-файлах, и смешение в различных исходных файлах параметров компилятора для встраивания функций может привести к возникновению ошибки LNK2019. Дополнительные сведения см. в разделе [проблемы при встраивании функций](../../error-messages/tool-errors/function-inlining-problems.md).  
  
-   **Автоматические переменные используются за пределами их области.** Автоматические переменные (области видимости функции) могут использоваться только в области видимости данной функции. Эти переменные не могут объявляться `extern` и использоваться в других исходных файлах. Например, в разделе [автоматические переменные (область видимости функции)](../../error-messages/tool-errors/automatic-function-scope-variables.md).  
  
-   **Вызов встроенных функций или передача типов аргументов во встроенные функции, которые не поддерживаются в целевой архитектуре.** Например, если используется встроенная функция AVX2, но не указывайте [/ARCH:AVX2](../../build/reference/arch-x86.md) параметр компилятора, компилятор предполагает, что встроенная функция является внешней. Вместо создания встроенной инструкции компилятор создает вызов внешнего символа с тем же именем, что и у встроенного. Когда компоновщик пытается найти определение этой отсутствующей функции, он создает ошибку LNK2019. Убедитесь в том, что используются только встроенные функции и типы, поддерживаемые целевой архитектурой.  
  
-   **Создайте код, который использует собственный тип wchar_t с кодом, который не.** Действия по согласованности языка C++, выполненные в Visual C++ 2005, привели к созданию собственного типа `wchar_t` по умолчанию. Необходимо использовать [/Zc:wchar_t-](../../build/reference/zc-wchar-t-wchar-t-is-native-type.md) параметр компилятора для создания кода, совместимого с файлами библиотек и объектов, скомпилированных с помощью предыдущих версий Visual C++. Если с использованием тех же параметров **/Zc:wchar_t** была скомпилирована только часть файлов, разрешение ссылок на тип в совместимые типы может не быть выполнено. Убедитесь в том, что типы `wchar_t` во всех файлах библиотек и объектов являются совместимыми. Для этого обновите используемые типы или используйте согласованные параметры **/Zc:wchar_t** при компиляции.  
  
 Дополнительные сведения о возможных причинах возникновения ошибки LNK2019 и способах ее устранения см. в информации по вопросу [Что представляет собой ошибка неопределенной ссылки или неразрешенного внешнего символа и как ее устранить?](http://stackoverflow.com/q/12573816/2002113)на StackOverflow.  
  
 **Средства диагностики**  
  
 Выяснение причин, по которым компоновщику не удается найти определение конкретного символа, может оказаться трудной задачей. Часто проблема заключается в том, что код не был включен в состав сборки или параметры сборки создали различные декорированные имена для внешних символов. Существует несколько средств и параметров, которые помогут диагностировать ошибку LNK2019.  
  
-   [/VERBOSE](../../build/reference/verbose-print-progress-messages.md) компоновщика может помочь определить, какие файлы ссылается компоновщик. Это поможет проверить, включен ли файл, содержащий определения символа, в сборку.  
  
-   [/EXPORTS](../../build/reference/dash-exports.md) и [и символов](../../build/reference/symbols.md) параметры служебной программы DUMPBIN помогут определить, какие символы определены в файлах DLL и объекта или библиотеки. Убедитесь в том, что экспортированные декорированные имена совпадают со ссылками, которые ищет компоновщик.  
  
-   Служебная программа UNDNAME может показывать эквивалентный недекорированный внешний символ для декорированного имени.  
  
 **Примеры**  
  
 Далее приводится несколько примеров кода, вызывающего ошибку LNK2019, а также сведения о том, как устранить ошибку.  
  
 **Символ объявлен, но не определен.**  
  
 В следующем примере показано возникновение ошибки LNK2019 вследствие того, что внешний символ объявлен, но не определен.  
  
```cpp  
// LNK2019.cpp  
// Compile by using: cl /EHsc LNK2019.cpp  
// LNK2019 expected  
extern char B[100];   // B is not available to the linker  
int main() {  
   B[0] = ' ';   // LNK2019  
}  
```  
  
 Вот другой пример.  
  
```cpp  
// LNK2019c.cpp  
// Compile by using: cl /EHsc LNK2019c.cpp  
// LNK2019 expected  
extern int i;  
extern void g();  
void f() {  
   i++;  
   g();  
}  
int main() {}  
```  
  
 Если `i` и `g` не определены в одном из файлов в сборке, компоновщик создает ошибку LNK2019. Чтобы исправить ошибки, включите файл исходного кода, который содержит определения, в процесс компиляции. Как вариант, можно передать в компоновщик OBJ- или LIB-файлы, которые содержат определение.  
  
 **Статические данные-член объявлены, но не определены**  
  
 Ошибка LNK2019 также может возникнуть в том случае, если статические данные-член объявлены, но не определены. В следующем примере показано возникновение ошибки LNK2019 и приводятся сведения по ее устранению.  
  
```cpp  
// LNK2019b.cpp  
// Compile by using: cl /EHsc LNK2019b.cpp  
// LNK2019 expected  
struct C {  
   static int s;  
};  
  
// Uncomment the following line to fix the error.  
// int C::s;  
  
int main() {  
   C c;  
   C::s = 1;  
}  
```  
  
 **Параметры объявления не соответствуют определению**  
  
 Код, который вызывает функции шаблона, должен иметь совпадающие объявления функции шаблона. Объявления должны содержать те же параметры шаблона, что и определение. В следующем примере показано возникновение ошибки LNK2019 для определяемого пользователем оператора и приводятся сведения по ее устранению.  
  
```cpp  
// LNK2019e.cpp  
// compile by using: cl /EHsc LNK2019e.cpp  
// LNK2019 expected  
#include <iostream>  
using namespace std;  
  
template<class T> class   
Test {  
   // The operator<< declaration does not match the definition below:  
   friend ostream& operator<<(ostream&, Test&);  
   // To fix, replace the line above with the following:  
   // template<typename T> friend ostream& operator<<(ostream&, Test<T>&);  
};  
  
template<typename T>  
ostream& operator<<(ostream& os, Test<T>& tt) {  
   return os;  
}  
  
int main() {  
   Test<int> t;  
   cout << "Test: " << t << endl;   // LNK2019 unresolved external  
}  
```  
  
 **Несогласованные определения типа wchar_t**  
  
 В следующем примере показано создание библиотеки DLL с экспортом, использующим `WCHAR`, который разрешается в `wchar_t`.  
  
```cpp  
// LNK2019g.cpp  
// compile with: cl /EHsc /LD LNK2019g.cpp  
#include "windows.h"  
// WCHAR resolves to wchar_t  
__declspec(dllexport) void func(WCHAR*) {}  
```  
  
 Следующий пример использует библиотеку DLL в предыдущем примере и создает ошибку LNK2019, поскольку неподписанные типы short * и WCHAR\* не совпадают.  
  
```cpp  
// LNK2019h.cpp  
// compile by using: cl /EHsc LNK2019h LNK2019g.lib  
// LNK2019 expected  
__declspec(dllimport) void func(unsigned short*);  
  
int main() {  
   func(0);  
}  
```  
  
 Чтобы устранить эту ошибку, измените `unsigned short` для `wchar_t` или `WCHAR`, или выполнить компиляцию с помощью LNK2019g.cpp **/Zc:wchar_t-**.
