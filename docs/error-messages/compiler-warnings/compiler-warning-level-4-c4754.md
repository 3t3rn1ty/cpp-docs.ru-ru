---
title: "Предупреждение компилятора (уровень 4) C4754 | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "error-reference"
f1_keywords: 
  - "C4754"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "C4754"
ms.assetid: e0e4606a-754a-4f42-a274-21a34978d21d
caps.latest.revision: 6
author: "corob-msft"
ms.author: "corob"
manager: "ghogen"
caps.handback.revision: 6
---
# Предупреждение компилятора (уровень 4) C4754
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

Правила преобразования для арифметических операций в середине сравнения, что одна ветвь не может быть выполнен.  
  
 C4754 выдается предупреждение, поскольку результат сравнения всегда одинаковы.  Это означает, что ветвей условия никогда не выполнен, произошло потому, что связанное выражение целые числа неправильно.  Это часто происходит кода в неправильных проверке переполнения целые числа на 64\-разрядных архитектуры.  
  
 Правила преобразования целого числа являются сложными и многие тонких опасностей.  В качестве альтернативы требует все предупреждения C4754, можно обновить код для использования [Библиотека SafeInt](../../windows/safeint-library.md).  
  
## Пример  
 В следующем примере появляется ошибка C4754:  
  
```cpp  
// C4754a.cpp  
// Compile with: /W4 /c  
#include "errno.h"  
  
int sum_overflow(unsigned long a, unsigned long b)   
{  
   unsigned long long x = a + b; // C4754  
  
   if (x > 0xFFFFFFFF)   
   {  
      // never executes!  
      return EOVERFLOW;  
   }  
   return 0;  
}  
```  
  
 Добавление `a + b` может вызвать арифметическое переполнение до результат upcast до 64\-разрядному значение и присвоен этой 64\-разрядному переменной `x`.  Это означает, что проверка на `x` является излишним и никогда не будет перехватить исключение переполнения.  В этом случае компилятор выводит данное предупреждение:  
  
  **Предупреждение C4754: Правила преобразования для арифметических операций в сравнении в середине C4754a.cpp \(7\), одна ветвь не может быть выполнен.  Приведение «\(a \+…\)» на «ULONG64» \(или подобному тип 8 байт\).**  Чтобы устранить предупреждение, можно изменить оператор присваивания для приведения операнды до 8 байтовых значений:  
  
```cpp  
// Casting one operand is sufficient to force all the operands in   
// the addition be upcast according to C/C++ conversion rules, but  
// casting both is clearer.  
unsigned long long x =   
   (unsigned long long)a + (unsigned long long)b;  
```  
  
## Пример  
 Следующий пример также демонстрирует C4754.  
  
```cpp  
// C4754b.cpp  
// Compile with: /W4 /c  
#include "errno.h"  
  
int wrap_overflow(unsigned long a)   
{  
   if (a + sizeof(unsigned long) < a) // C4754  
   {   
      // never executes!  
      return EOVERFLOW;  
   }  
   return 0;  
}  
```  
  
 Оператор `sizeof()` возвращает `size_t`, размер которого архитектура\- зависимого.  Пример кода работает на 32\-разрядных архитектурах, где `size_t` 32 — тип.  Однако на 64\-разрядных архитектурах, `size_t` 64 — тип.  Правила преобразования для целых чисел означают, что `a` upcast до 64\-разрядному значение в выражении `a + b < a`, если ему записана `(size_t)a + (size_t)b < (size_t)a`.  При `a` и `b` 32\-разрядные целые числа, 64\-разрядная операции сложения никогда не может переполниться, и никогда не содержит ограничение.  В результате код никогда не обнаруживает условия переполнения целые числа на 64\-разрядных архитектуры.  В этом примере указывает компилятору вывести это предупреждение:  
  
  **Предупреждение C4754: Правила преобразования для арифметических операций в сравнении в середине C4754b.cpp \(7\), одна ветвь не может быть выполнен.  Приведение «4» в «ULONG» \(или подобному тип 4 байт\).**  Обратите внимание, что предупреждение явно перечислены значения константы 4 вместо первоисточника строка\- временем предупреждения анализа обнаруживает проблемную код, `sizeof(unsigned long)` уже было преобразовано константным.  Поэтому может потребоваться отслеживать вниз, выражения в исходном коде связываются с постоянным значением в предупреждении.  Общедоступные источники кода разрешены на константы в предупреждениях C4754 выражения типа `sizeof(TYPE)` и `strlen(szConstantString)`.  
  
 В этом случае исправлен код напоминает следующий:  
  
```cpp  
// Casting the result of sizeof() to unsigned long ensures  
// that all the addition operands are 32-bit, so any overflow   
// is detected by the check.  
if (a + (unsigned long)sizeof(unsigned long) < a)  
  
```  
  
 **Заметка** Номер линии на нее в предупреждения компилятора последней линией выписки.  В предупреждении о сложных условном операторе, получение с помощью нескольких линиями, линию, которая имеет дефект кода может быть несколько линий перед линию, которая возникает.  Примеры.  
  
```cpp  
unsigned long a;  
  
if (a + sizeof(unsigned long) < a || // incorrect check  
    condition1() ||   
    a == 0) {    // C4754 warning reported on this line  
         // never executes!  
         return INVALID_PARAMETER;  
}  
  
```