---
title: "Предупреждение компилятора (уровни 1 и 3) C4793 | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "error-reference"
f1_keywords: 
  - "C4793"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "C4793"
  - "C6630"
  - "C6631"
  - "C6634"
  - "C6635"
  - "C6636"
  - "C6637"
  - "C6638"
  - "C6639"
  - "C6640"
ms.assetid: 819ada53-1d9c-49b8-a629-baf8c12314e6
caps.latest.revision: 28
caps.handback.revision: 26
author: "corob-msft"
ms.author: "corob"
manager: "ghogen"
---
# Предупреждение компилятора (уровни 1 и 3) C4793
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

"функция": функция скомпилирована как собственная: "причина"  
  
 Компилятор не может компилировать *function* в управляемый код, даже если параметр компилятора [\/clr](../../build/reference/clr-common-language-runtime-compilation.md) определен.  Вместо этого компилятор выдает предупреждение C4793 и сообщение, объясняющее продолжения и затем компилируется *function* в машинный код.  Сообщение продолжения содержит текст *reason*, объясняется, почему *function* невозможно компилировать в `MSIL`.  
  
 Если задан параметр компилятора `/clr:pure`, это предупреждение имеет уровень 1.  
  
 В следующей таблице приведены все возможные причины возникновения этого сообщения.  
  
|Сообщение с описанием причины|Примечания|  
|-----------------------------------|----------------|  
|Выровненные типы данных не поддерживаются в управляемом коде|В среде CLR при необходимости должно обеспечиваться выделение памяти для данных, что в некоторых случаях невозможно при использовании объявлений вида [\_\_m128](../Topic/__m128.md) или [align](../../cpp/align-cpp.md).|  
|Функции, в которых используется параметр \_\_ImageBase, не поддерживаются в управляемом коде|Специальный символ компоновщика `__ImageBase` обычно используется только в низкоуровневом неуправляемом коде для загрузки библиотек DLL.|  
|varargs не поддерживается параметром компилятора \/clr|Из\-за различных требований к размещению в стеке в неуправляемых функциях не поддерживается вызов управляемых функций, содержащих [списки аргументов переменных](../Topic/Variable%20Argument%20Lists.md) \(vararg\).  Поддержка списков аргументов переменных обеспечивается при заданном параметре `/clr:pure`, поскольку в этом случае в сборке содержатся только управляемые функции.  Для получения дополнительной информации см. [Чистый и проверяемый код](../../dotnet/pure-and-verifiable-code-cpp-cli.md).|  
|В 64\-разрядной среде CLR не поддерживаются данные, объявленные с помощью модификатора \_\_ptr32|Размер указателя должен соответствовать размеру неуправляемого указателя для текущей платформы.  Для получения дополнительной информации см. [\_\_ptr32, \_\_ptr64](../../cpp/ptr32-ptr64.md).|  
|В 32\-разрядной среде CLR не поддерживаются данные, объявленные с помощью модификатора \_\_ptr64|Размер указателя должен соответствовать размеру неуправляемого указателя для текущей платформы.  Для получения дополнительной информации см. [\_\_ptr32, \_\_ptr64](../../cpp/ptr32-ptr64.md).|  
|Одна или несколько встроенных функций не поддерживаются в управляемом коде|На момент отображения сообщения имя встроенной функции недоступно.  Связанная с этим сообщением встроенная функция обычно представляет собой низкоуровневую машинную инструкцию.|  
|Встроенные машинные сборки \(\_\_asm\) не поддерживаются в управляемом коде|[Встроенный код ассемблера](../../assembler/inline/asm.md) может содержать произвольный неуправляемый код, который не поддерживается в управляемом коде.|  
|Преобразователь виртуальной функции, не относящейся к вызову \_\_clrcall, необходимо компилировать как машинный код|Преобразователь виртуальной функции, не относящейся к вызову [\_\_clrcall](../../cpp/clrcall.md), должен использовать неуправляемый адрес.|  
|Функцию, в которой используется параметр \_setjmp, необходимо компилировать как машинный код|В среде CLR должно быть доступно управление выполнением программы.  При использовании функции [setjmp](../../cpp/using-setjmp-longjmp.md) выполняется обход стандартного выполнения программы за счет сохранения низкоуровневой информации, например регистров и состояния выполнения.|  
  
## Пример  
 В следующем примере возникает предупреждение C4793.  
  
```  
// C4793.cpp  
// compile with: /c /clr /W3   
// processor: x86  
int asmfunc(void) {   // C4793, compiled as unmanaged, native code  
   __asm {  
      mov eax, 0  
   }  
}  
```  
  
  **предупреждение C4793: "asmfunc": функция скомпилирована как машинный код:**  
 **Встроенные машинные сборки \(\_\_asm\) не поддерживаются в управляемом коде**   
## Пример  
 В следующем примере возникает предупреждение C4793.  
  
```  
// C4793_b.cpp  
// compile with: /c /clr /W3  
#include <setjmp.h>  
jmp_buf test_buf;  
  
void f() {  
   setjmp(test_buf);   // C4793 warning  
}  
```  
  
  **предупреждение C4793: "f": функция скомпилирована как машинный код:**  
 **Функцию, в которой используется параметр \_setjmp, необходимо компилировать как машинный код**