---
title: Предупреждения компилятора версии компилятора | Документы Microsoft
ms.custom: ''
ms.date: 01/31/2018
ms.technology:
- devlang-cpp
ms.topic: error-reference
dev_langs:
- C++
helpviewer_keywords:
- warnings, by compiler version
- cl.exe compiler, setting warning options
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 789121e3adb42cb74087339bb33bb82cb7604a10
ms.sourcegitcommit: 76b7653ae443a2b8eb1186b789f8503609d6453e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
---
# <a name="compiler-warnings-by-compiler-version"></a>Предупреждения компилятора версии компилятора

Компилятор можно подавить предупреждения, которые были введены после версии, заданной с помощью [/wv](../../build/reference/compiler-option-warning-level.md) параметр компилятора. Это полезно для управления процесс сборки, когда вводит новую версию набора инструментов и необходимо временно отключить новые предупреждения. Этот параметр отключает новое сообщение об ошибке. Мы не рекомендуем отключить все новые предупреждения без возможности восстановления. Мы рекомендуем всегда компиляции на высоком уровне предупреждение регулярного, __/W4__и удалите __/wv__ параметр сборки как можно быстрее. 

Эти версии компилятора появились новые предупреждения:

| Продукт | Номер версии компилятора |
|-|-|
| Visual C++ 2002 | 13.00.9466 |
| Visual C++ 2003 | 13.10.3077 |
| Visual C++ 2005 | 14.00.50727.762 |
| Visual C++ 2008 | 15.00.21022.08 |
| Visual C++ 2010 | 16.00.40219.01 |
| Visual C++ 2012 | 17.00.51106.1 |
| Visual C++ 2013 | 18.00.21005.1 |
| Visual C++ 2015 RTM | 19.00.23026.0 |
| Visual C++ 2015 с обновлением 1 | 19.00.23506.0 |
| Visual C++ 2015 с обновлением 2 | 19.00.23918.0 |
| Visual C++ 2015 с обновлением 3 | 19.00.24215.1 |
| Visual C++ 2017 г RTM | 19.10.24903.0 |
| Версии 15.1 2017 г. Visual C++ | 19.10.25017.0 |
| Версия 15,3 2017 г. Visual C++ | 19.11.25506.0 |
| Версия 15,5 2017 г. Visual C++ | 19.12.25827.0 |

Можно указать только основной номер, основной и дополнительный номера или основной и дополнительный номера, а номеров сборок для __/wv__ параметр. Компилятор выводит все предупреждения, соответствующих версий, которые начинаются с указанным номером и отключает все предупреждения для версий старше указанного числа. Например __/Wv:17__ выводит все предупреждения, появившиеся во время или до любой версии Visual Studio 2012 и отключает все предупреждения, появившиеся с любой компилятор из Visual Studio 2013 (версия 18) или более поздней версии. Чтобы подавить предупреждения, появившиеся в Visual Studio 2015 обновление 2 и более поздних версиях можно использовать __/Wv:19.00.23506__. Используйте __/Wv:19.11__ для отчетов все предупреждения, появившиеся в любой версии Visual Studio до версии 15,5 2017 г. Visual Studio, но подавляет предупреждения, появившиеся в Visual Studio 2017 г 15,5 и более поздних версий.

В следующих разделах перечислены предупреждения, появившиеся в каждой версии Visual C++, можно отключить с помощью __/wv__ параметр компилятора. __/Wv__ параметр нельзя было подавить предупреждения, которые отсутствуют в списке, которые предшествуют определенных версий компилятора.

## <a name="warnings-introduced-in-visual-c-2017-version-155-compiler-version-1912258270"></a>Предупреждения, появившиеся в версии (версия компилятора 19.12.25827.0) 15,5 2017 г. Visual C++

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:19.11__.

|||
|-|-|
C5044|Аргумент для параметра командной строки *параметр* путь "*путь*", которая не существует

## <a name="warnings-introduced-in-visual-c-2017-version-153-compiler-version-1911255060"></a>Предупреждения, появившиеся в версии (версия компилятора 19.11.25506.0) 15,3 2017 г. Visual C++

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:19.10__.

|||
|-|-|
C4843|"*тип1*": недоступен обработчика исключений ссылки на тип массива или функции, используйте "*тип2*" вместо
C4844|"модуль экспорта *имя_модуля*;" теперь синтаксис является предпочтительным для объявления интерфейса модуля
C5039|"*функция*": указатель или ссылка на потенциально создания функция extern C функции передан в группе - EHc. Если эта функция создает исключение, может возникнуть неопределенное поведение.
C5040|спецификации динамических исключений являются допустимыми только в C ++ 14 и более ранних версий. как noexcept(false)
C5041|"*определение*": статические данные-член constexpr определение вне строки не требуются и рекомендуется использовать в C ++ 17
C5042|"*объявление*": объявления функций в области видимости блока не может быть указанного «inline» в стандартном языке C++; удалите спецификатор «inline»
C5043|"*спецификации*": спецификация исключения не соответствует предыдущему объявлению

## <a name="warnings-introduced-in-visual-c-2017-version-151-compiler-version-1910250170"></a>Предупреждения, появившиеся в версии 15.1 (версия компилятора 19.10.25017.0) 2017 г. Visual C++

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:19.10.24903__.

|||
|-|-|
C4597|поведение не определено: *описание*
C4604|"*типа*": передача аргумента по значению через границы машинного и управляемого требуется конструктор действительной копии. В противном случае поведение среды выполнения не определено
C4749|условно поддерживается: *описание*
C4768|атрибуты __declspec перед спецификация компоновки учитываются.
C4834|Отмена возвращаемое значение функции с атрибутом «nodiscard»
C4841|использовано нестандартное расширение: *расширения*
C4842|результат offsetof применяется к типу, использование множественного наследования не обязательно быть согласованы между версиями компилятора
C4869|«nodiscard» может применяться только для классов, перечислений и функций с отличным от void тип возвращаемого значения
C5033|"*класс хранения*" больше не поддерживается в качестве хранилища класса
C5034|Использование встроенной функции "*встроенная функция*" функция *функция* будет компилироваться как Гость кода
C5035|Использование функции "*компонент*" вызывает функцию *функция* будет компилироваться как Гость кода
C5036|varargs преобразование указателя функции, при компиляции с /hybrid:x86arm64 "*тип1*«to»*тип2*"
C5037|"*функция член*": определение члена шаблона класса вне строки не могут иметь аргументы по умолчанию
C5038|элемент данных "*member1*«будет инициализирована после элемента данных»*member2*"

## <a name="warnings-introduced-in-visual-c-2017-rtm-compiler-version-191024903"></a>Предупреждения, появившиеся в Visual C++ 2017 г RTM (версия компилятора 19.10.24903)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:19.00__.

|||
|-|-|
C4468|«fallthrough»: атрибут должен следовать метки case или метка по умолчанию
C4698|"*функция*" для оценки только в целях и подлежит изменению или удаления в будущих обновлений.
C4839|Нестандартное использование класса*класс*"как аргумент для функции с переменным числом аргументов
C4840|Использование класса непереносимые*класс*"как аргумент для функции с переменным числом аргументов

## <a name="warnings-introduced-in-visual-c-2015-update-3-compiler-version-1900242151"></a>Предупреждения, появившиеся в Visual C++ 2015 с обновлением 3 (версия компилятора 19.00.24215.1)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:19.00.23918__.

|||
|-|-|
C4467|рекомендуется использование атрибутов библиотеки ATL
C4596|"*имя*": Недопустимое полное имя в объявлении члена
C4598|"#include \< *заголовок*\>": номер заголовка *номер* в *источника* не соответствует *источника* по этому положение
C4599|"*аргумент*": *источника* номер аргумента *номер* не соответствует *источника*

## <a name="warnings-introduced-in-visual-c-2015-update-2-compiler-version-1900239180"></a>Предупреждения, появившиеся в Visual C++ 2015 с обновлением 2 (версия компилятора 19.00.23918.0)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:19.00.23506__.

|||
|-|-|
C4466|Не удалось выполнить пропуск кучи соподпрограммы
C4595|"*класс*": не являющихся членами функций operator new или delete не могут объявляться встроенной
C4828|Файл содержит знак, начинающийся со смещением 0 x*значение* , является недопустимым в текущей исходной кодировке (кодовая страница *номер*).
C4868|компилятор не может принудительно применить порядок вычисления слева направо в списке инициализации в фигурных скобках

## <a name="warnings-introduced-in-visual-c-2015-update-1-compiler-version-1900235060"></a>Предупреждения, появившиеся в Visual C++ 2015 с обновлением 1 (версия компилятора 19.00.23506.0)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:19.00.23026__.

|||
|-|-|
C4426|Флаги оптимизации изменены после включения заголовка, может быть связано с #pragma optimize()
C4654|Код, помещенный перед включают предкомпилированного заголовка строки будут пропущены. Добавьте код для предкомпилированного заголовка.
C5031|#pragma warning(pop): возможное несоответствие, состояние всплывающего предупреждения передано в другой файл
C5032|Обнаружено #pragma warning(push) без соответствующего выражения #pragma warning(pop)

## <a name="warnings-introduced-in-visual-c-2015-rtm-compiler-version-1900230260"></a>Предупреждения, появившиеся в Visual C++ 2015 RTM (версия компилятора 19.00.23026.0)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/wv: 18__.

|||
|-|-|
C4427|"*ошибка*": переполнение при делении константы, неопределенное поведение
C4438|"*типа*": не удается вызвать безопасно / await: clrcompat режим. Если "*типа*" вызовы среду CLR, может произойти повреждение заголовка CLR
C4455|"оператор *имя*": идентификаторы литеральных суффиксов, которые не начинаются с символа подчеркивания, зарезервированы
C4456|объявление "*имя*" скрывает предыдущее локальное объявление
C4457|объявление "*имя*" скрывает параметр функции
C4458|объявление "*имя*" скрывает член класса
C4459|объявление "*имя*" скрывает глобальное объявление
C4462|"*типа*": не удается определить GUID типа. Программа может завершиться ошибкой во время выполнения.
C4463|переполнения; Назначение *значение* к битовому полю может содержать только значения из *значение* для *значение*
C4473|"*функция*": передано недостаточно аргументов для строки формата
C4474|"*функция*": передано слишком много аргументов для строки формата
C4475|"*функция*": модификатор длины "*модификатор*«не может использоваться с символом поля типа»*символ*" в описателе формата
C4476|"*функция*": неизвестный символ поля типа "*символ*" в описателе формата
C4477|"*функция*": строка формата "*строка*«требует аргумент типа»*тип*", но аргумента с переменным числом аргументов *номер* имеет тип "*типа*"
C4478|"*функция*": позиционные и непозиционные заполнители невозможно одновременно в одной строке формата
C4494|"*типа*": __declspec(allocator) пропускается, так как возвращаемый функцией тип не является указателем или ссылкой
C4495|нестандартное расширение «__super»: Замените на явное имя базового класса
C4496|используется нестандартное расширение «for each»: Замените на оператор ranged-for
C4497|нестандартное расширение «sealed»: замените «final»
C4498|использовано нестандартное расширение: "*расширения*"
C4499|"*специализации*": явная специализация не может иметь класс хранилища (пропускается)
C4576|в скобки тип, за которым следует список инициализаторов является стандартным явный тип синтаксисом преобразования
C4577|noexcept при использовании без указания; режима обработки исключений Прекращение по исключению не гарантируется. Задайте параметр/EHsc
C4578|«abs»: преобразование из "*тип*«to»*тип*", возможна потеря данных (предполагалось вызывать "*имя*" или к #include <cmath>?)
C4582|"*типа*": конструктор не вызывается неявно
C4583|"*типа*": деструктор не вызывается неявно
C4587|"*типа*": изменение поведения: конструктор имеет больше не вызывается неявно
C4588|"*типа*": изменение поведения: деструктор больше не вызывается неявно
C4589|Конструктор абстрактного класса*тип*«пропускает инициализатор для виртуального базового класса»*типа*"
C4591|ограничение глубина вызова «constexpr» *номер* превышено (/ constexpr: Depth<NUMBER>)
C4592|"*типа*": символ будет динамически инициализирован (ограничение реализации)
C4593|"*тип*": «constexpr» вызов evaluation шаг ограничение *значение* превышено; используйте /constexpr:steps<NUMBER> чтобы увеличить ограничение
C4647|Изменение поведения: __is_pod (*типа*) имеет другое значение в предыдущих версиях
C4648|стандартный атрибут «carries_dependency» игнорируется
C4649|атрибуты учитываются в этом контексте
C4753|Не удается найти границы для указателя; Встроенная функция MPX пропускается
C4771|Границы должны быть созданы с помощью простого указателя; Встроенная функция MPX пропускается
C4774|"*описание*": ожидаемая в аргументе строки формата *номер* не является строковым литералом
C4775|нестандартное расширение в строке формата "*строка*«функции»*функция*"
C4776|"%*символ*«не допускается в строке форматирования функции»*функция*"
C4777|"*описание*": строка формата "*строка*«требует аргумент типа»*тип*", но вариативный аргумент *номер* имеет тип "*типа*"
C4778|"*описание*": незавершенная строка форматирования "*строка*"
C4838|преобразование из "*тип*«to»*типа*" требует сужающего преобразования
C5022|"*типа*": указано несколько конструкторов перемещения
C5023|"*типа*": заданы несколько операторов присваивания перемещения
C5024|"*объявление*": переместите конструктор неявно определен как удаленный
C5025|"*объявление*": переместите оператор присваивания неявно определен как удаленный
C5026|"*типа*": переместите конструктор неявно определен как удаленный
C5027|"*типа*": переместите оператор присваивания неявно определен как удаленный
C5028|"*имя*": выравнивание указанное в предыдущем объявлении (*номер*) не указан в определении
C5029|использовано нестандартное расширение: атрибуты выравнивания в C++ применяются к переменным, элементам данных и только к типам тегов
C5030|атрибут "*атрибута*" не распознан

## <a name="warnings-introduced-in-visual-c-2013-compiler-version-1800210051"></a>Предупреждения, появившиеся в Visual C++ 2013 (версия компилятора 18.00.21005.1)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:17__.

|||
|-|-|
C4301|"*тип*": переопределение виртуальной функции отличается от "*объявление*" квалификаторами const или volatile
C4316|"*тип*": объект, размещенный в куче не быть выровнен *номер*
C4380|"*типа*": конструктор по умолчанию не может быть нерекомендуемым
C4388|"*маркера*": несоответствие со знаком и без
C4423|«std::bad_alloc»: будет перехвачен классом ("*тип*") в строке *номер*
C4424|catch для "*тип*«предшествует»*тип*" в строке *номер*; непредсказуемое поведение может привести к, если создается «std::bad_alloc»
C4425|Заметки SAL нельзя применить к «...»
C4464|относительный путь включения содержит ".."
C4575|соглашение «__vectorcall» несовместимо с "/ clr" параметр: преобразование к «__stdcall»
C4609|"*тип*«является производным от интерфейса по умолчанию»*тип*«в типе»*типа*". Используйте интерфейс по умолчанию для "*типа*", или к разрыву связи базовый/производный.
C4754|Правила преобразования арифметических операций в сравнении по *описание*(*номер*) означает, что одна ветвь не может быть выполнена. Приведение "*тип*«to»*тип*" (или к аналогичному типу из *номер* байт).
C4755|Правила преобразования арифметических операций в сравнении по *описание*(*номер*) означает, что одна ветвь не может быть выполнена в встроенной функции. Приведение "*тип*«to»*тип*" (или к аналогичному типу из *номер* байт).
C4767|Имя раздела '*имя*"длиннее, чем 8 символов и будет усечено компоновщиком
C4770|частично проверенное перечисление "*имя*" используется в качестве индекса
C4827|Открытый метод «ToString» с 0 параметров должен быть помечен как виртуальный и переопределение
C4882|передавать функции с операторами вызова непостоянных функций в concurrency::parallel_for_each устарел
C4973|"*типа*": помечен как устаревшие
C4974|"*типа*": помечен как устаревшие
C4981|Warbird: функция "*объявление*" помеченная как __forceinline не встроена, так как она содержит семантику исключения
C4990|Warbird: *сообщения*
C4991|Warbird: функция "*объявление*" помеченная как __forceinline, не является встроенной, так как уровень защиты встраиваемого объекта больше, чем родительский
C4992|Warbird: функция "*объявление*" помеченная как __forceinline, не является встроенной, так как она содержит встроенную сборку, которая не может быть защищен

## <a name="warnings-introduced-in-visual-c-2012-compiler-version-1700511061"></a>Предупреждения, появившиеся в Visual C++ 2012 (версия компилятора 17.00.51106.1)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:16__.

|||
|-|-|
C4330|атрибут "*атрибута*«для раздела»*раздел*" игнорируется
C4415|повторяющиеся __declspec (code_seg ("*имя*"))
C4416|атрибут "__declspec(code_seg(...))" содержит пустую строку: игнорируется
C4417|явное создание экземпляров шаблона не может иметь атрибут "__declspec(code_seg(...))": пропущен
C4418|атрибут "__declspec(code_seg(...))" игнорируется для перечисления
C4419|"*имя*«игнорируется при применении к закрытому классу ссылки»*типа*".
C4435|"*тип*": структура объекта в/vd2 изменится из-за виртуального базового "*типа*"
C4436|приведение dynamic_cast из виртуального базового "*тип*«to»*типа*" в конструктор или деструктор могут возникать ошибки с частично сконструированного объекта
C4437|приведение dynamic_cast из виртуального базового "*тип*«to»*типа*" может завершиться ошибкой в некоторых контекстах
C4443|требуется параметр директивы pragma "0", "1" или "2"
C4446|"*тип*": невозможно сопоставить член "*имя*" этому типу из-за конфликта с именем типа. Метод был переименован в "*имя*"
C4447|Обнаруженная без потоковой модели сигнатура метода «main». Рассмотрите возможность использования "int основной (Platform::Array\<Platform::String ^ > ^ args)".
C4448|"*типа*" не поддерживает интерфейс по умолчанию, указанные в метаданных. Комплектации: "*типа*", который может завершиться ошибкой во время выполнения.
C4449|"*типа*" незапечатанный тип должен быть помечен как «[WebHostHidden]»
C4450|"*тип*«должен быть помечен как «[WebHostHidden]», так как он является производным от»*типа*"
C4451|"*тип*": использование класса ref*типа*"внутри этого контекста может привести к неправильному маршалингу объекта между контекстами
C4452|"*типа*": открытый тип не может быть в глобальной области видимости. Он должен быть в пространстве имен, который является потомком имя выходного файла .winmd.
C4453|"*типа*": тип «[WebHostHidden]» не должен использоваться на опубликованной поверхности открытого типа, который не является «[WebHostHidden]»
C4454|"*типа*" перегружена превышает число входных параметров без необходимости [DefaultOverload] указан. Подбор "*объявление*" как перегрузка по умолчанию
C4471|"*имя*": у прямого объявления неограниченного перечисления должен иметь базовый тип (предполагается int.)
C4472|"*имя*" является собственным перечислением: добавьте спецификатор доступа (private/public), чтобы объявить перечисление managed WinRT
C4492|"*тип*": совпадений базовый метод класса ref "*типа*", но не помечен как «override»
C4493|выражение DELETE не делает ничего как деструктор класса "*тип*' Нет 'public' специальных возможностей
C4585|"*тип*': WinRT «открытый класс ссылки» должны быть запечатанными или производными от существующего незапечатанного класса
C4586|"*типа*": открытый тип не может объявляться в пространстве имен верхнего уровня, называемого «Windows»
C4695|#pragma кодировка_выполнения: "*аргумент*" не является поддерживаемой аргументом: поддерживается в настоящее время единственным «UTF-8"
C4703|потенциально неинициализированная локальная переменная-указатель "*имя*" используется
C4728|/ Параметр Yl-пропущено, так как требуется ссылка PCH
C4745|переменное обращение "*имя*" не может быть принят на обработку из-за его размера.
C4746|переменное обращение "*имя*" определяется параметром/volatile:\<iso\|ms >; попробуйте использовать встроенные функции __iso_volatile_load/store
C4872|с плавающей точкой деления на ноль, обнаруженных при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*описание*"
C4880|приведение из "*тип*«to»*типа*": приведение с потерей постоянства указателя или ссылки может привести к неопределенному поведению в функции, ограниченной amp
C4881|конструктор или деструктор не будет вызываться для переменной tile_static "*типа*"
C4966|"*описание*" содержит примечание __code_seg с неподдерживаемым именем сегмента; Примечание игнорируется
C4988|"*типа*": переменная объявлена вне области класса или функции
C4989|"*описание*": тип имеет конфликтующие определения.

## <a name="warnings-introduced-in-visual-c-2010-compiler-version-16004021901"></a>Предупреждения, появившиеся в Visual C++ 2010 (версия компилятора 16.00.40219.01)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:15__.

|||
|-|-|
C4352|"*имя*": подставляемая функция уже определена
C4573|Использование "*типа*" требует, чтобы записать «this» но компилятор не разрешается текущим режимом отслеживания по умолчанию
C4574|"*имя*«определяется как" 0": имелось в виду использование" #if *имя*"?
C4689|"*символ*": Неподдерживаемый знак в #pragma detect_mismatch; #pragma ignored
C4751|/ arch флаг AVX не применяется к расширениям Intel(R) Streaming SIMD, находящимся в пределах подставляемого ASM
C4752|найдены Intel(R) Advanced Vector Extensions; Рассмотрите возможность использования соответствующего/arch флаг AVX
C4837|Обнаруженный триграф: "?? *символ*«заменить»*символ*"
C4986|"*объявление*": спецификация исключения не соответствует предыдущему объявлению
C4987|используется нестандартное расширение: throw (...)

## <a name="warnings-introduced-in-visual-c-2008-compiler-version-15002102208"></a>Предупреждения, появившиеся в Visual C++ 2008 (версия компилятора 15.00.21022.08)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:14__.

|||
|-|-|
C4396|"*типа*": если дружественное объявление ссылается на специализацию шаблона функции нельзя использовать встроенный спецификатор
C4413|"*объявление*": ссылочный член инициализируется во временный, который не сохраняется после того как конструктор завершает работу
C4491|"*описание*": имеет недопустимый формат версии IDL
C4603|"*имя*": макрос не определен или определение изменилось после использования предкомпилированного заголовка
C4627|"*описание*": пропущен при поиске использования предкомпилированного заголовка
C4750|"*описание*": функция с _alloca() включена в цикл
C4910|"*типа*": «__declspec(dllexport)» и «extern» несовместимы при явном создании экземпляра
C4985|"*объявление*": атрибуты отсутствуют в предыдущем объявлении.

## <a name="warnings-introduced-in-visual-c-2005-compiler-version-140050727762"></a>Предупреждения, появившиеся в Visual C++ 2005 (версия компилятора 14.00.50727.762)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:13__.

|||
|-|-|
C4000|НЕИЗВЕСТНОЕ предупреждение выберите команду технической поддержки, в меню справки Visual C++ или откройте Справочный файл технической поддержки для получения дополнительной информации
C4272|"*типа*": помечается как __declspec(dllimport); при импорте функции необходимо указать собственное соглашение о вызовах.
C4333|"*выражение*": сдвиг вправо слишком большое значение, потери данных
C4334|"*выражение*": результат 32-разрядного смещения неявно преобразуется в 64 бита (предполагалось 64-разрядное смещение?)
C4335|Обнаружен файл в формате Mac: преобразуйте исходный файл в формат DOS или UNIX
C4342|Изменение поведения: "*типа*" вызван, но в предыдущих версиях был вызван оператор-член
C4350|Изменение поведения: "*объявление*«вызван вместо»*объявление*"
C4357|Аргумент array найден в списке формальных аргументов для делегата "*объявление*«игнорируется при создании»*типа*"
C4358|"*выражение*": тип возвращаемого значения объединенных делегатов не является «void», возвращаемое значение не определено
C4359|"*тип*": описатель выравнивания меньше, чем текущее выравнивание (*номер*) и будет игнорироваться.
C4362|"*типа*": выравнивание, превышающее 8 байт не поддерживается средой CLR
C4364|#using для сборки "*имя*" отображенного ранее в *описание*(*номер*) без атрибута as_friend; as_friend не применяется
C4365|"*выражение*": преобразование из "*тип*«to»*типа*", несоответствие со знаком и без
C4366|Результат операции унарного "*оператор*" оператор может быть невыровненным
C4367|Преобразование из "*тип*«to»*типа*" может вызвать исключение неверного выравнивания типа данных
C4368|не удается определить "*имя*«как член управляемого»*типа*": смешанные типы не поддерживаются.
C4369|"*тип*": значение перечислителя "*номер*«не может быть представлено как»*тип*, оно*номер*"
C4374|"*объявление*": метод интерфейса не будет реализован невиртуальным методом "*объявление*"
C4375|метод закрытые "*объявление*«не переопределяет»*объявление*"
C4376|спецификатор доступа "*описатель*:" больше не поддерживается: используйте "*описатель*:" вместо
C4377|собственные типы являются закрытыми по умолчанию; -d1PrivateNativeTypes запрещен
C4378|Необходимо получить указатели функций для запуска инициализаторов; Рассмотрите вариант System::ModuleHandle::
C4379|Версия *версии* общий язык среды выполнения не поддерживается на этом компьютере. Использование этой версии может привести к непредвиденным результатам
C4381|"*объявление*": метод интерфейса не будет реализован методом закрытые "*объявление*"
C4382|Создание "*типа*": тип с деструктором __clrcall или конструктором копии может быть перехвачен только в/CLR: pure модуля
C4383|"*тип*": значение разыменования дескриптора может измениться, если определяемый пользователем "*оператор*" оператор существует; запишите оператор как статическую функцию, чтобы сделать его явным по отношению к операнду
C4384|#pragma "*директивы*" можно использовать только в глобальной области видимости
C4393|"*тип*": const не оказывает влияния на *описание* данные-член; игнорируется
C4394|"*тип*": символ по доменам приложения не должны быть помечены __declspec (*значение*)
C4395|"*тип*": функция-член будет вызываться для копии данных initonly "*типа*"
C4397|DefaultCharSetAttribute игнорируется
C4398|"*типа*": глобальный объект для каждого процесса может работать неправильно с несколькими доменами приложений; рассмотрите возможность использования __declspec(appdomain)
C4399|"*тип*": символ для каждого процесса не следует помечать с __declspec (*значение*) при компиляции с параметром/clr: pure
C4400|"*типа*": квалификаторы const или volatile для этого типа не поддерживаются.
C4412|"*объявление*": подпись функции содержит тип "*тип*'; Объекты C++ небезопасно передавать между чистый код и смешанного или машинного.
C4429|Возможные неполные или неправильно сформированное универсальное имя символа
C4430|отсутствует спецификатор типа — предполагается int. Примечание: C++ не поддерживает int по умолчанию
C4431|отсутствует спецификатор типа — предполагается int. Примечание. C++ не поддерживает тип int по умолчанию
C4434|статический конструктор должен быть закрытым; закрытый доступ
C4439|"*типа*": определение функции с управляемым типом в сигнатуре должно иметь соглашение вызова __clrcall
C4441|соглашение вызова "*соглашение*" игнорируется; "*соглашение*" вместо этого использовать
C4445|"*объявление*": тип managed WinRT виртуальный метод не может быть закрытым
C4460|Оператор CLR или WinRT "*типа*", имеет параметр, передаваемый по ссылке. Оператор CLR или WinRT "*оператор*«имеют различную семантику из оператора C++ operator»*оператор*", вы хотели передать по значению?
C4461|"*тип*": этот класс содержит метод завершения "! *Тип*", но нет деструктора" ~*типа*"
C4470|директивы pragma контроля плавающей учитывается в/CLR
C4480|использовано нестандартное расширение: указание базового типа перечисления "*типа*"
C4481|использовано нестандартное расширение: спецификатор переопределения "*описатель*"
C4482|использовано нестандартное расширение: enum "*типа*" использован в полном имени
C4483|Синтаксическая ошибка: требуется ключевое слово C++
C4484|"*тип*": соответствует базовый метод класса ref "*типа*", но не помечен как «virtual», «new» или «override»; предполагается «new» (а не «virtual»)
C4485|"*тип*": соответствует базовый метод класса ref "*типа*", но не помеченные «new» или «override»; предполагается «new» (и «virtual»)
C4486|"*типа*": закрытый виртуальный метод класса ref или класса значений должен быть помечен как «sealed»
C4487|"*тип*": совпадений наследуется невиртуальному методу "*типа*", но не помечен явно «new»
C4488|"*тип*": требуется "*ключевое слово*«ключевое слово для реализации метода интерфейса»*типа*"
C4489|"*ключевое слово*": не разрешен в методе интерфейса "*имя*"; спецификаторы допустимы только для ссылочного класса и значение методов класса переопределения
C4490|"*ключевое слово*": Неправильное использование спецификатора переопределения; "*типа*" не соответствует методу базового класса
C4538|"*типа*": квалификаторы const или volatile для этого типа не поддерживаются.
C4559|"*тип*": переопределение; __declspec прибыли функция (*значение*)
C4565|"*тип*": переопределение; символ был объявлен ранее при помощи __declspec (*значение*)
C4566|символ, представленный универсальное имя символа "*символ*" невозможно представить в текущей кодовой странице (*номер*)
C4568|"*типа*": нет членов соответствует сигнатуре явного переопределения
C4569|"*типа*": нет членов соответствует сигнатуре явного переопределения
C4570|"*типа*": не объявлен явно как абстрактный, однако содержит абстрактные функции
C4571|Информация: семантика catch(...) изменилась, начиная с версии Visual C++ 7.1; структурированные исключения (SEH) более не перехватываются
C4572|Атрибут [ParamArray] рекомендуется использовать с параметром/CLR, используйте «...» вместо
C4580|[attribute] рекомендуется; Вместо этого укажите *указанного*атрибут в качестве базового класса
C4581|Рекомендуется использовать поведение: "»*имя*«" Заменить "*имя*" для обработки атрибута
C4606|#pragma warning: "*номер*" игнорируется; Предупреждения анализа кода не связаны с уровнями предупреждений
C4631|MSXML или XPath недоступны, комментарии XML-документа не будут обработаны. *description*
C4632|Комментарий XML-документа: *описание* -доступ запрещен: *описание*
C4633|Комментарий XML-документа*описание*: ошибка: *описание*
C4634|Комментарий XML-документа*описание*: невозможно применить: *описание*
C4635|Комментарий XML-документа*описание*: неправильно сформированный XML: *описание*
C4636|Комментарий XML-документа*описание*: тегу необходим непустой "*описание*" атрибута.
C4637|Комментарий XML-документа*описание*: <include> тега удаляется. *description*
C4638|Комментарий XML-документа*описание*: ссылка на неизвестный символ "*описание*".
C4639|Ошибка MSXML, не будут обрабатываться комментарии XML-документа. *description*
C4641|Документирующем комментарии XML присутствует неоднозначная перекрестная ссылка: 
C4678|базовый класс*объявление*«является менее доступным, чем»*имя*"
C4679|"*описание*": не удается импортировать член
C4687|"*тип*": Запечатанный абстрактный класс не может реализовывать интерфейс "*типа*"
C4688|"*имя*": список ограничений содержит частный тип сборки "*объявление*"
C4690|[ emitidl ( pop ) ]: стека превышает число занесений
C4691|"*тип*": ожидался адресуемый тип в неиспользуемых *модуль* "*описание*", тип, определенный в текущей записи преобразования, вместо этого использовать
C4692|"*имя*": подпись не частного члена содержит частный собственный тип сборки "*объявление*"
C4693|"*тип*": Запечатанный абстрактный класс не может быть членов экземпляра*имя*"
C4694|"*тип*": Запечатанный абстрактный класс не может иметь базового класса*типа*"
C4720|встроенный ассемблер отчетов: "*описание*"
C4721|"*описание*": недоступна в качестве встроенной функции
C4722|"*описание*": деструктор не возвращает ресурсы, возможна утечка памяти
C4726|ARM arch4/4T поддерживается только "< cpsr_f > или < spsr_f >" со значением интерпретации
C4727|PCH-ФАЙЛ с именем *имя* и одинаковой отметкой времени в *имя* и *имя*.  Используется первый PCH-ФАЙЛ.
C4729|слишком большая функция для предупреждений, основанных на оптимизации структуры кода
C4730|"*описание*": смешение _m64 и с плавающей запятой, выражения могут стать причиной неверного кода
C4731|"*описание*": регистр указателя фрейма "*зарегистрировать*" изменен с помощью встроенного кода ассемблера
C4732|Встроенная функция "*встроенная функция*" не поддерживается в этой архитектуре
C4733|Присваивание для «FS:0»: обработчик не зарегистрирован как безопасный
C4734|Более чем 64k номера строк в формате COFF отладки раздел с информацией о; остановить выдача номеров строк отладки COFF для модуля "*модуль*"
C4738|хранение результатов в памяти в 32-разрядном формате с плавающей запятой, возможно снижение производительности
C4739|ссылка на переменную "*переменной*" пределы ее области хранения
C4740|поток в или встроенного ассемблерного кода препятствуют глобальной оптимизации
C4742|"*переменной*«имеет различное выравнивание»*расположение*«и»*расположение*": *номер* и *номер*
C4743|"*имя*«имеет различные размеры»*расположение*«и»*расположение*": *номер* и *номер* байт
C4744|"*имя*«имеет другой тип»*расположение*«и»*расположение*": "*тип*«и»*типа*"
C4747|Вызов управляемого "*типа*": управляемый код может не выполняться во время блокировки загрузчика, включая точки входа DLL и поступившим из них вызовам
C4761|Несоответствие полного размера в аргументе; преобразование
C4764|Для перехваченных объектов выравнивание не может превышать 16 байт
C4788|"*идентификатор*": идентификатор усечен до "*номер*" знаков
C4789|буфер "*имя*" размера *номер* байт будет переполнен; *номер* байт будет записано начиная со смещения *номер*
C4801|Возврат по ссылке не поддается проверке: *описание*
C4819|Файл содержит символ, который невозможно представить в текущей кодовой странице (*номер*). Сохраните файл в формате Юникода для предотвращения потери данных
C4826|Преобразование из "*тип*«to»*типа*" выполняется с расширением знака. Это может вызвать непредвиденное поведение.
C4829|Возможно, неверные параметры для функции main. Рассмотрите возможность "int основной (Platform::Array\<Platform::String ^ > ^ argv)"
C4835|"*типа*": инициализатор экспортированных данных не будет выполнено до управляемого кода сначала в базовой сборке
C4867|"*типа*": нестандартный синтаксис; используйте «&» для создания указателя на член
C4936|Данный __declspec поддерживается только при компиляции с параметрами /clr или /clr:pure
C4937|"*имя*«и»*имя*«неразличимы в качестве аргументов»*параметр*"
C4938|"*типа*": переменная сокращения с плавающей точкой может привести к несогласованным результатам при использовании/fp: strict или #pragma fenv_access
C4939|не рекомендуется использовать директиву #pragma vtordisp, в следующих версиях Visual C++ ее не будет
C4947|"*типа*": помечен как устаревший
C4949|директивы pragma «managed» и «unmanaged» может применяться только при компиляции с параметром "/ clr [: параметр]"
C4950|"*типа*": помечен как устаревший
C4955|"*описание*": Импорт игнорируется; уже импортирован из "*источника*"
C4956|"*типа*": этот тип недоступен для проверки
C4957|"*выражение*": явное приведение "*тип*«to»*типа*" недоступен для проверки
C4958|"*выражение*": арифметика указателей не подлежит проверке.
C4959|не удается определить неуправляемый *класса* "*типа*" в/CLR: safe, поскольку доступ к ее членам выдает код, недоступный для проверки
C4960|"*описание*" слишком велик для профилирования
C4961|Данные профиля не были включены в "*расположение*", Профильная оптимизация отключена
C4962|"*описание*": Профильная оптимизация отключена, поскольку операции оптимизации приводят к несогласованности данных профиля
C4963|"*описание*": данные профилирования не найдены; в инструментированной сборке были использованы другие параметры компилятора
C4964|Параметры оптимизации не указаны; сведения о профиле не будут собраны.
C4965|неявная упаковка целого числа 0; используйте nullptr или явное приведение
C4970|конструктор делегата: целевой объект обрабатывается с "*объявление*" является статическим
C4971|Порядок аргументов: \<целевой объект >, \<Целевая функция > для конструктора делегата является устаревшим, используйте \<Целевая функция >, \<целевой объект >
C4972|Прямое изменение или обработка результатов операции распаковки в виде левостороннего значения недоступны для проверки

## <a name="warnings-introduced-in-visual-c-2003-compiler-version-13103077"></a>Предупреждения, появившиеся в Visual C++ 2003 (версия компилятора 13.10.3077)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:13.00.9466__.

|||
|-|-|
C4343|#pragma optimize (*описание*, выходить из системы) переопределяет параметр /Og
C4344|Изменение поведения: использование результатов явный шаблон аргументов в вызове "*объявление*"
C4346|"*типа*": зависимое имя не является типом
C4348|"*объявление*": переопределение параметра по умолчанию: параметр *номер*
C4356|"*типа*": не удается инициализировать статические данные-член в производном классе
C4408|анонимные *структуры* не объявляет никаких элементов данных
C4544|"*объявление*": аргумент шаблона, пропускается в этом объявлении шаблона по умолчанию
C4545|вычисление выражения перед запятой дает функцию, в которой отсутствует список аргументов
C4546|в вызове функции перед запятой отсутствует список аргументов
C4547|"*выражение*": оператор перед запятой не имеет результата; требуется оператор с побочным действием
C4548|выражение перед запятой не имеет результата; требуется выражение с побочным действием
C4549|"*выражение*": оператор перед запятой не имеет результата; возможно, планировалось "*выражение*"?
C4628|диграфы не поддерживаются при наличии параметра -Ze. Последовательность символов "*последовательности*«не преобразована в альтернативный маркер для»*маркера*"
C4629|использован диграф, последовательность знаков "*последовательности*«интерпретируется как токен»*маркера*" (если это необходимо, вставьте пробел между двумя знаками)
C4671|"*описание*": конструктор копии недоступен
C4676|"*описание*": деструктор недоступен
C4677|"*имя*": подпись не частного члена содержит частный тип сборки "*объявление*"
C4686|"*типа*": возможное изменение поведения, изменение возвращаемого значения UDT соглашение о вызовах
C4812|устаревший стиль объявления: используйте "*тип*::*имя*" вместо
C4813|"*типа*": дружественная функция локального класса должна быть предварительно объявлена
C4821|Не удалось определить тип кодировки Юникод; сохраните файл с сигнатурой (BOM)
C4822|"*типа*": функция-член локального класса не имеет тела
C4823|"*типа*": использует закрепленные указатели, но очистки семантику не включены. Рассмотрите возможность использования/EHa
C4913|пользовательский двоичный оператор "," существует, но ни одной перегрузке не удалось преобразовать все операнды, по умолчанию использован встроенный двоичный оператор ","
C4948|Тип возвращаемого значения "*объявление*" не соответствует последнему типу параметра задающей функции
C4951|"*описание*" была изменена после сбора данных профилирования. данные профиля функции не используются.
C4952|"*описание*": данные профилирования не найдены в базе данных программы "*описание*"
C4953|Встраиваемого метода "*описание*" была изменена после сбора данных профилирования. данные профилирования не используются
C4954|"*описание*": не профилирование (содержит выражение переключателя __int64)

## <a name="warnings-introduced-in-visual-c-2002-compiler-version-13009466"></a>Предупреждения, появившиеся в Visual C++ 2002 (версия компилятора 13.00.9466)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:12__.

|||
|-|-|
C4096|"*типа*": интерфейс не является COM-интерфейсом; он не будет передан в IDL
C4097|требуется параметр директивы pragma: "restore" или "off"
C4165|«HRESULT» преобразуется в «bool»; Вы уверены, что это желаемый?
C4183|"*имя*": отсутствие возвращаемого типа; предполагается функция-член, возвращающая «int»
C4199|*description*
C4255|"*имя*": не представлен прототип функции: преобразование «()» в «(void)»
C4256|"*объявление*": конструктор класса с виртуальными базами содержит «...»; вызовы могут оказаться несовместимыми с более ранними версиями Visual C++
C4258|"*имя*': определение из цикла for игнорируется; используется определение из внешней области видимости
C4263|"*объявление*": функция-член не переопределяет ни одной функции виртуальный член базового класса
C4264|"*объявление*": нет доступного переопределения для виртуальной функции-члена из базового "*класс*"; функция скрыта
C4265|"*типа*": класс имеет виртуальные функции, но деструктор не является виртуальным экземпляры этого класса не может быть корректно уничтожены
C4266|"*объявление*": нет доступного переопределения для виртуальной функции-члена из базового "*класс*"; функция скрыта
C4267|"*выражение*": преобразование из «size_t» в "*типа*", возможна потеря данных
C4274|#ident игнорируется; см. документацию для #pragma comment (exestr, "string")
C4277|импортированный элемент "*тип*::*имя*" существует как элемента данных и функции-члена; пропуск данных-члена
C4278|"*имя*": идентификатор в библиотеке типов "*описание*" уже является макроопределением; используйте квалификатор «rename»
C4279|"*имя*": идентификатор в библиотеке типов "*описание*" является зарезервированным словом; используйте квалификатор «rename»
C4287|"*выражение*": без учета знака несовпадение отрицательной константы и константы
C4288|использовано нестандартное расширение: "*имя*": переменная управления циклом, объявленная в цикле for, используется вне области цикла; это противоречит объявлению во внешней области
C4289|использовано нестандартное расширение: "*имя*": переменная управления циклом, объявленная в цикле for, используется вне области цикла for
C4293|"*выражение*": смещение отрицательное или слишком большое, поведение не определено
C4295|"*типа*": массив слишком мал, чтобы включить знак завершения null
C4296|"*выражение*": выражение всегда имеет *значение*
C4297|"*типа*": ожидается, что функция не будет выдавать исключения, но она это делает
C4298|"*имя*": идентификатор в библиотеке типов "*описание*" уже является макроопределением; переименование в "__*имя*"
C4299|"*имя*": идентификатор в библиотеке типов "*описание*" является зарезервированным словом; переименование в "__*имя*"
C4302|"*выражение*": усечение из "*тип*«to»*типа*"
C4303|*преобразование* из "*тип*«to»*типа*" является устаревшим, используйте static_cast, __try_cast или dynamic_cast
C4314|требуется параметр директивы pragma "32" или "64"
C4315|"*тип*": указатель «this» для элемента "*тип*" не может быть выровнен *номер* должным образом с помощью конструктора
C4318|Передача нулевой константы в качестве длины memset
C4319|"*выражение*": нулевое расширение "*тип*«to»*типа*" большего размера
C4321|Автоматическое создание IID для интерфейса "*типа*"
C4322|Автоматическое создание CLSID для класса*типа*"
C4323|повторное использование CLSID для класса*типа*"
C4324|"*типа*": структура была дополнена нулями из-за описателя выравнивания
C4325|атрибутов для стандартной секции "*описание*" игнорируется
C4326|Тип возвращаемого значения "*имя*«должен быть»*тип*«вместо of»*типа*"
C4327|"*выражение*": выравнивание косвенного обращения LHS (*номер*) больше, чем RHS (*номер*)
C4328|"*описание*": выравнивание косвенного обращения для формального параметра *номер* (*номер*) больше, чем выравнивание реального аргумента (*номер*)
C4329|Описатель выравнивания игнорируется для перечисления
C4336|Импорт библиотеки типов "*библиотеки*«перед импортом»*описание*"
C4337|Библиотека типов "*библиотеки*«in»*описание*" автоматически импортируется
C4338|#pragma *описание*: стандартного раздела "*раздел*" используется
C4339|"*типа*": обнаружено использование неопределенного типа в метаданных CLR или WinRT использование этого типа может привести к исключению среды выполнения
C4353|использовано нестандартное расширение: константа 0 в качестве выражения функции.  Вместо этого используйте функцию «__noop» встроенная функция
C4370|"*объявление*": размещение класса изменилось с предыдущей версии компилятора из-за улучшенной упаковки
C4371|"*объявление*": размещение класса могло измениться с предыдущей версии компилятора из-за улучшенной упаковки члена "*член*"
C4373|"*тип*": переопределение виртуальной функции*объявление*", предыдущие версии компилятора не выполняли переопределение, когда параметры отличались только квалификаторами const или volatile
C4387|"*описание*": считается
C4389|"*выражение*": несоответствие со знаком и без
C4391|"*объявление*": неправильный возвращаемый тип для подставляемой функции; требуется "*типа*"
C4392|"*объявление*": Неправильное число аргументов для подставляемой функции; требуется "*номер*" аргументов
C4407|приведение между различных представлениями указателя на член, компилятор может создать неправильный код
C4420|"*имя*": оператор недоступен, используется "*имя*" вместо; проверки во время выполнения могут выдать ошибку
C4440|переопределения соглашения о вызове "*описание*«to»*описание*" игнорируется
C4442|завершающий символ null, внедренных в аргументе __annotation аргумент.  Значение будет усечено.
C4444|"*имя*": верхнего уровня «__unaligned» не реализована в этом контексте
C4526|"*тип*": статическая функция-член не может переопределить виртуальную функцию "*объявление*" переопределение игнорируются, виртуальная функция будет скрыта.
C4531|Обработка исключений с ++ недоступно для Windows CE. Использование структурированной обработки исключений
C4532|"*описание*": выйти из *наконец* блок не определено поведение при обработке завершения
C4533|Инициализация "*объявление*" пропускается "goto *объявление*"
C4534|"*объявление*" не будет конструктором по умолчанию для *класса* "*типа*" из-за аргумента по умолчанию
C4535|вызывающий _set_se_translator() требует/EHa
C4536|"*описание*": имя типа превышает ограничение метаданных "*номер*" знаков
C4537|"*объявление*": "." применяется к типу не UDT
C4542|Пропуск автоматического создания объединенного файла подставляемого текста, не удается записать *тип* файла: "*filename*": *ошибки*
C4543|Введенный текст запрещен атрибутом "не\_injected_text"
C4555|выражение не имеет результата; требуется выражение с побочным действием
C4557|«__assume» содержит эффект "*эффект*"
C4558|значение операнда "*номер*«выходит за пределы диапазона»*номер* - *номер*"
C4561|соглашение «__fastcall» несовместимо с "/ clr" параметр: преобразование к «__stdcall»
C4562|требуются полные прототипы функций с "/ clr" параметр: преобразование «()» в «(void)»
C4564|метод "*имя*" из *класса* "*тип*«определяет неподдерживаемый параметр по умолчанию»*параметр*"
C4584|"*тип*": базовый класс*объявление*«уже является базовым классом для»*объявление*"
C4608|Инициализация нескольких элементов объединения: "*тип*«и»*типа*"
C4619|предупреждение #pragma: нет предупреждения с номером "*номер*"
C4623|"*типа*": конструктор по умолчанию неявно определен как удаленный
C4624|"*типа*": деструктор неявно определен как удаленный
C4625|"*типа*": конструктор копирования неявно определен как удаленный
C4626|"*типа*": оператор присваивания неявно определен как удаленный
C4645|функция, объявленная с атрибутом «noreturn» имеет оператор return
C4646|функция, объявленная с атрибутом «noreturn» имеет отличный от void тип возвращаемого значения
C4659|#pragma "*описание*": использовании зарезервированного сегмента "*имя*" поведение не определено; используйте #pragma comment (linker,...)
C4667|"*объявление*": функция шаблон не определен, соответствующий принудительному созданию экземпляра
C4668|"*имя*«не определен в качестве макроса препроцессора и будет заменен"0"в»*значение*"
C4669|"*выражение*": небезопасное преобразование: "*типа*" является объектом типа managed WinRT
C4674|"*имя*" должен быть объявлен как «static» и иметь ровно один параметр.
C4680|"*типа*": компонентный класс не указывает интерфейс по умолчанию
C4681|"*типа*": компонентный класс не указывает интерфейс по умолчанию, который является источником событий
C4682|"*типа*": не указан атрибут параметра направления, по умолчанию принимается [in]
C4683|"*объявление*": источник событий имеет «out»-параметра; соблюдайте осторожность при использовании нескольких обработчиков события
C4684|"*описание*": внимание! атрибут может привести к недопустимой генерации кода: используйте с осторожностью
C4685|требуется "> >", имеется ">>" в результате синтаксического разбора параметров шаблона
C4700|неинициализированная локальная переменная "*имя*" используется
C4701|потенциально неинициализированная локальная переменная "*имя*" используется
C4702|недостижимый код
C4711|функция "*имя*" выбрана для автоматического подстановки
C4714|функция "*объявление*" помеченная как __forceinline, не является встроенной
C4715|"*функция*": не все пути возвращают значение
C4716|"*функция*": должен возвращать значение
C4717|"*функция*": рекурсия на всех путях, функция вызовет переполнение стека времени выполнения
C4718|"*функция*": рекурсивный вызов не имеет побочных эффектов, удаление
C4719|Константа с двойной точностью найден при указанном параметре Qfast - используйте «f» виде суффикса задания одинарной точности
C4723|возможное деление на 0
C4724|возможный остаток от деления на 0
C4725|инструкция может оказаться неправильной на некоторых процессорах Pentium
C4757|Индекс является большим числом без знака, предполагалась отрицательная константа?
C4772|#import ссылается на тип из отсутствующей библиотеки типов; "*описание*" используется как заполнитель
C4792|функция "*функция*" объявлен с использованием sysimport и на которые имеются ссылки из машинного кода; импортируйте библиотеку, необходимую для связывания
C4794|Сегмент переменной из локальной памяти потока "*имя*«изменилось с»*сегмент*«to»*сегмент*"
C4798|машинный код, создаваемый для функции p-code "*имя*" с обработчиком исключений или семантикой уничтожения объектов
C4799|функция "*имя*" не имеет инструкции EMMS
C4803|"*объявление*": другим классом хранилища из того, что событие имеет метода raise "*объявление*"
C4810|значение pragma pack(show) == *номер*
C4811|значение pragma conform (forScope, show) == *значение*
C4820|"*тип*": "*номер*" байтовые поля добавлены после *тип* "*типа*"
C4905|приведение двухбайтового строкового литерала к "*типа*"
C4906|приведение строкового литерала к "*типа*"
C4912|"*атрибута*": атрибут не определено поведение во вложенных UDT
C4916|Чтобы получить идентификатор dispid, "*типа*": должны вводиться в интерфейсе
C4917|"*типа*": идентификатор GUID может быть связан только с классом, интерфейсом или пространством имен
C4918|"*символ*": недопустимый символ в списке оптимизации директивы pragma
C4920|Перечисление *имя* член *имя*=*номер* уже появлялся в перечислении *имя* как *имя* = *номер*
C4921|"*имя*": значение атрибута "*значение*" не следует указывать несколько раз
C4925|"*объявление*": метод disp-интерфейса нельзя вызвать из скрипта
C4926|"*объявление*": символ уже определен: атрибуты игнорируются
C4927|Недопустимое преобразование; неявно применены несколько пользовательских преобразований
C4928|недопустимая инициализация копии; неявно применено несколько пользовательских преобразований
C4929|"*описание*": библиотека типов содержит объединение; пропуск квалификатора «embedded_idl»
C4930|"*объявление*": функция с прототипом не вызвана (предполагалось определение переменной?)
C4931|предполагается библиотека типов была собрана для *номер*-разрядных указателей
C4932|__identifier (*описание*) и __identifier (*описание*), неразличимы
C4934|«__delegate(multicast)» устарел, используйте «__delegate». Вместо этого
C4935|спецификатор уровня доступа сборки изменен из "*описание*"
C4944|"*имя*": не удается импортировать символ из "*источника*": как*объявление*"уже существует в текущей области
C4945|"*имя*": не удается импортировать символ из "*источника*": как*объявление*«уже импортирован из другой сборки»*источника*"
C4946|reinterpret_cast между связанными классами: "*объявление*«и»*объявление*"
C4995|"*имя*": имя помечено как #pragma deprecated
C4996|"*проблема*": *описание*
C4997|"*типа*": компонентный класс не реализует COM-интерфейс или псевдоинтерфейс
C4998|Ошибка ОЖИДАНИЯ: *описание*(*номер*)

## <a name="see-also"></a>См. также
[Параметр компилятора/wv](../../build/reference/compiler-option-warning-level.md)
[предупреждения компилятора, отключенные по умолчанию](../../preprocessor/compiler-warnings-that-are-off-by-default.md)
[предупреждение](../../preprocessor/warning.md)
