---
title: "Ошибки компилятора C3500 до C3999 | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-tools
ms.tgt_pltfrm: 
ms.topic: error-reference
f1_keywords:
- C3502
- C3503
- C3504
- C3511
- C3512
- C3513
- C3514
- C3515
- C3516
- C3517
- C3518
- C3520
- C3521
- C3522
- C3523
- C3524
- C3525
- C3526
- C3527
- C3528
- C3529
- C3534
- C3542
- C3543
- C3544
- C3545
- C3546
- C3547
- C3548
- C3549
- C3557
- C3558
- C3559
- C3560
- C3561
- C3562
- C3563
- C3564
- C3565
- C3566
- C3567
- C3568
- C3569
- C3570
- C3571
- C3572
- C3573
- C3574
- C3575
- C3576
- C3577
- C3578
- C3579
- C3580
- C3581
- C3582
- C3583
- C3584
- C3585
- C3586
- C3587
- C3588
- C3589
- C3590
- C3591
- C3592
- C3593
- C3594
- C3595
- C3596
- C3597
- C3598
- C3599
- C3600
- C3601
- C3602
- C3604
- C3605
- C3613
- C3614
- C3615
- C3616
- C3620
- C3621
- C3635
- C3636
- C3649
- C3658
- C3659
- C3660
- C3663
- C3664
- C3667
- C3674
- C3676
- C3677
- C3678
- C3679
- C3680
- C3681
- C3682
- C3683
- C3684
- C3685
- C3686
- C3687
- C3688
- C3689
- C3690
- C3691
- C3696
- C3716
- C3720
- C3725
- C3726
- C3729
- C3730
- C3735
- C3742
- C3746
- C3750
- C3751
- C3756
- C3757
- C3758
- C3759
- C3760
- C3770
- C3773
- C3774
- C3775
- C3776
- C3777
- C3778
- C3779
- C3780
- C3781
- C3782
- C3783
- C3784
- C3785
- C3786
- C3787
- C3801
- C3802
- C3806
- C3811
- C3814
- C3819
- C3822
- C3823
- C3826
- C3827
- C3829
- C3837
- C3840
- C3841
- C3843
- C3844
- C3845
- C3863
- C3870
- C3871
- C3875
- C3879
- C3881
- C3882
- C3884
- C3885
- C3897
- C3905
- C3906
- C3916
- C3921
- C3924
- C3925
- C3926
- C3927
- C3928
- C3930
- C3931
- C3932
- C3933
- C3934
- C3935
- C3936
- C3937
- C3938
- C3939
- C3940
- C3941
- C3945
- C3946
- C3947
- C3948
- C3949
- C3950
- C3951
- C3952
- C3953
- C3954
- C3955
- C3956
- C3957
- C3958
- C3959
- C3960
- C3961
- C3962
- C3963
- C3964
- C3965
- C3966
- C3967
- C3968
- C3969
- C3970
- C3971
- C3972
- C3975
- C3976
- C3977
- C3978
- C3979
- C3980
- C3981
- C3982
- C3983
- C3984
- C3985
- C3986
- C3987
- C3988
- C3989
- C3990
- C3991
- C3992
- C3993
- C3994
- C3995
- C3996
- C3997
- C3998
- C3999
dev_langs:
- C++
ms.assetid: bd6f23ad-b300-4e07-8e35-9661cab1585f
caps.latest.revision: 12
author: corob-msft
ms.author: corob
manager: ghogen
translation.priority.ht:
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- ru-ru
- zh-cn
- zh-tw
translation.priority.mt:
- cs-cz
- pl-pl
- pt-br
- tr-tr
ms.translationtype: Machine Translation
ms.sourcegitcommit: 4bac7b2942f9d72674b8092dc7bf64174dd3c349
ms.openlocfilehash: 1c6e5e54541d5cdcb7e2cde7c12117266d45b514
ms.contentlocale: ru-ru
ms.lasthandoff: 04/24/2017

---
# <a name="compiler-errors-c3500-through-c3999"></a>Ошибки компилятора C3500 до C3999
Статьи из этой части документации содержат сведения о подразделе ошибок компилятора Visual C++. Информацию можно найти здесь, или можно выбрать номер ошибки в окне **Вывод** Visual Studio и нажать клавишу F1.  
  
> [!NOTE]
>  Не каждый [!INCLUDE[vcprvc](../../build/includes/vcprvc_md.md)] ошибки документируется в MSDN. Во многих случаях диагностическое сообщение предоставляет все информацию, которая доступна. Если вы считаете, что сообщение об ошибке требует дополнительного объяснения, сообщите нам об этом. Используйте форму обратной связи на этой странице или перейти к строке меню в Visual Studio и выберите **справки**, **сообщения об ошибке**, или вы можете отправить отчет предложений или ошибку на [Microsoft Connect](http://connect.microsoft.com/VisualStudio).  
  
 Может оказаться дополнительную помощь для ошибок и предупреждений на открытых форумах MSDN. [Языка Visual C++](http://go.microsoft.com/fwlink/?LinkId=158195) — форум для вопросов и обсуждения о [!INCLUDE[vcprvc](../../build/includes/vcprvc_md.md)] синтаксисом и компилятором языка. [Visual C++ Общие](http://go.microsoft.com/fwlink/?LinkId=158194) — форум для вопросов о [!INCLUDE[vcprvc](../../build/includes/vcprvc_md.md)] , которые не обсуждаются на других форумах. Кроме того, возможно справки об ошибках и предупреждения на [переполнения стека](http://stackoverflow.com/).  
  
|Ошибка|Сообщение|  
|-----------|-------------|  
|[Ошибка компилятора C3500](compiler-error-c3500.md)|Недопустимый атрибут ProgID "*progid*"|  
|[Ошибка компилятора C3501](compiler-error-c3501.md)|нет библиотеки типов, зарегистрированной для ProgID "*progid*"|  
|C3502 ошибки компилятора|Невозможно получить LIBID для ProgID "*progid*"|  
|C3503 ошибки компилятора|символ "0 x*значение*" не допускается в необработанный строковый литерал|  
|C3504 ошибки компилятора|не удается создать GUID из строки "*строка*"|  
|[Ошибка компилятора C3505](compiler-error-c3505.md)|не удается загрузить библиотеку типов "*библиотеки*"|  
|[Ошибка компилятора C3506](compiler-error-c3506.md)|нет библиотеки типов, зарегистрированной для LIBID "*библиотеки*"|  
|[Ошибка компилятора C3507](compiler-error-c3507.md)|Идентификатор ProgID не может иметь больше 39 знаков*progid*"; не содержать знаки пунктуации, кроме". "; и не может начинаться с цифры|  
|[Ошибка компилятора C3508](compiler-error-c3508.md)|"*типа*": не является допустимым типом автоматизации|  
|[Ошибка компилятора C3509](compiler-error-c3509.md)|"*типа*": недопустимый возвращаемый тип автоматизации; когда параметр помечен как «retval», тип возвращаемого значения должен быть «void», «HRESULT» или «SCODE»|  
|[Ошибка компилятора C3510](compiler-error-c3510.md)|не удается найти библиотеку зависимых типов *библиотеки*|  
|C3511 ошибки компилятора|"*идентификатор*": вызов делегирующего конструктора должен быть единственным инициализатором члена|  
|C3512 ошибки компилятора|последовательность символов-разделителей для необработанного строкового литерала не должна превышать 16 символов|  
|C3513 ошибки компилятора|"*строка*": неподдерживаемый символ-литерал разделитель необработанной строки|  
|C3514 ошибки компилятора|"*символ*" (*значение*): неподдерживаемый символ-литерал разделитель необработанной строки|  
|C3515 ошибки компилятора|если аргумент частичной специализации шаблона класса является раскрытием пакета, он должен быть последним аргументом|  
|C3516 ошибки компилятора|непредвиденный конец файла при обработке необработанного строкового литерала; найден последовательность разделителей "*строка*" не соответствует|  
|C3517 ошибки компилятора|"*идентификатор*" объявление псевдонима не может иметь тип, содержащий «auto»|  
|C3518 ошибки компилятора|"*идентификатор*": в контексте прямой инициализации списком Тип для "*типа*" можно вывести только из выражения с одним инициализатором|  
|[Ошибка компилятора C3519](compiler-error-c3519.md)|"*параметр*": недопустимый параметр атрибута embedded_idl|  
|C3520 ошибки компилятора|"*идентификатор*": пакет параметров должен раскрываться в этом контексте|  
|C3521 ошибки компилятора|"*идентификатор*" не является пакетом параметров|  
|C3522 ошибки компилятора|"*типа*": пакет параметров не могут быть развернуты в этом контексте|  
|C3523 ошибки компилятора|«sizeof...» требует в качестве аргумента нераскрытый пакет параметров|  
|C3524 ошибки компилятора|"*идентификатор*": «sizeof» нельзя применить к пакет параметров. Имелось в виду использование «sizeof»?|  
|C3525 ошибки компилятора|"*параметр*": Если в шаблоне класса имеется пакет параметров шаблона, он должен располагаться в конце списка параметров шаблона|  
|C3526 ошибки компилятора|'...' нельзя применить к «this»|  
|C3527 ошибки компилятора|"*идентификатор*" не является допустимым операндом для «sizeof...». Имелось в виду использование «sizeof»?|  
|C3528 ошибки компилятора|"*идентификатор1*": число элементов в раскрытии пакета не соответствует числу элементов в "*идентификатор2*"|  
|C3529 ошибки компилятора|"*параметр*": пакет параметров шаблона не может иметь аргумент по умолчанию|  
|[Ошибка компилятора C3530](compiler-error-c3530.md)|"*типа*" не может объединяться с любыми другими спецификаторами типа|  
|[Ошибка компилятора C3531](compiler-error-c3531.md)|"*идентификатор*": символ, тип которого содержит "*типа*" должно иметь инициализатор|  
|[Ошибка компилятора C3532](compiler-error-c3532.md)|Тип элемента массива не может быть типом, содержащим "*типа*"|  
|[Ошибка компилятора C3533](compiler-error-c3533.md)|параметр не может иметь тип, который содержит "*типа*"|  
|Ошибка компилятора C3534|Является устаревшей.|  
|[Ошибка компилятора C3535](compiler-error-c3535.md)|Невозможно вывести тип для "*тип1*«с»*тип2*"|  
|[Ошибка компилятора C3536](compiler-error-c3536.md)|"*идентификатор*": не может использоваться до инициализации.|  
|[Ошибка компилятора C3537](compiler-error-c3537.md)|не может быть приведен к типу, содержащему "*типа*"|  
|[Ошибка компилятора C3538](compiler-error-c3538.md)|в списке деклараторов "*типа*" должен всегда выводить тот же тип|  
|[Ошибка компилятора C3539](compiler-error-c3539.md)|аргумент шаблона не может быть типом, содержащим "*типа*"|  
|[Ошибка компилятора C3540](compiler-error-c3540.md)|Невозможно применить sizeof к типу, который содержит "*типа*"|  
|[Ошибка компилятора C3541](compiler-error-c3541.md)|typeid нельзя применять к типу, который содержит "*типа*"|  
|C3542 ошибки компилятора|"*идентификатор*": виртуальная функция-член не должен иметь тип возвращаемого значения, содержащий "*типа*"|  
|C3543 ошибки компилятора|"*типа*": не содержит пакет параметров|  
|C3544 ошибки компилятора|"*параметр*": пакет параметров ожидает аргумент типа шаблона|  
|C3545 ошибки компилятора|"*параметр*": пакет параметров ожидает аргумент шаблона не является типом|  
|C3546 ошибки компилятора|"...": нет доступных для раскрытия пакетов параметров|  
|C3547 ошибки компилятора|параметр шаблона "*параметр*«нельзя использовать, так как он находится пакет параметров шаблона и не может быть выведен из параметров функции»*функция*"|  
|C3548 ошибки компилятора|"*идентификатор*": пакет параметров не может использоваться в этом контексте|  
|C3549 ошибки компилятора|"*значение*": пакет параметров функции не могут иметь аргумент по умолчанию|  
|[Ошибка компилятора C3550](compiler-error-c3550.md)|только неструктурированный описатель "decltype(auto)" разрешен в этом контексте|  
|[Ошибка компилятора C3551](compiler-error-c3551.md)|Если используется завершающий возвращаемый тип, то начальный возвращаемый тип должен быть одним спецификатором типа «auto» (не "*типа*")|  
|[Ошибка компилятора C3552](compiler-error-c3552.md)|ожидается "decltype(auto)"|  
|[Ошибка компилятора C3553](compiler-error-c3553.md)|для "decltype" требуется выражение, а не тип|  
|[Ошибка компилятора C3554](compiler-error-c3554.md)|"*типа*" не может объединяться с любыми другими спецификаторами типа|  
|[Ошибка компилятора C3555](compiler-error-c3555.md)|неправильный аргумент для "decltype"|  
|[Ошибка компилятора C3556](compiler-error-c3556.md)|"*выражение*": неправильный аргумент для «decltype»|  
|Ошибка компилятора C3557|Является устаревшей.|  
|Ошибка компилятора C3558|Является устаревшей.|  
|C3559 ошибки компилятора|рекурсивный вызов "*функция*": рекурсия обнаруживается при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|  
|C3560 ошибки компилятора|"*функция*": Встраивание недоступно при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|  
|C3561 ошибки компилятора|Операция нарушения барьера групп в поток управления, который не является неравномерными, при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|  
|C3562 ошибки компилятора|Встроенная функция "*функция*" ограничена не имеют более *номер* параметров|  
|C3563 ошибки компилятора|Обнаружен бесконечный цикл при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|  
|C3564 ошибки компилятора|чтение неинициализированного значения при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|  
|C3565 ошибки компилятора|Общий объем памяти tile_static (*номер* байт) превышает ограничение *число* байтов при компиляции графа вызовов concurrency::parallel_for_each|  
|C3566 ошибки компилятора|блоки с побочными эффектами вложены слишком глубоко при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|  
|C3567 ошибки компилятора|деление на ноль или остаток от деления на ноль, обнаруженных при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|  
|C3568 ошибки компилятора|Сумма регистров превышает лимит *номер* при компиляции графа вызовов concurrency::parallel_for_each. Упростите программы|  
|C3569 ошибки компилятора|гонки, обнаруженных при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|  
|C3570 ошибки компилятора|недопустимое использование ограниченной для AMP области при компиляции с параметром /clr|  
|C3571 ошибки компилятора|"*типа*": недопустимый аргумент домена вычислений; не является типом класса|  
|C3572 ошибки компилятора|"*типа*": недопустимый аргумент домена вычислений; отсутствует открытый член: «static const int rank» или значение ранга неположительно|  
|C3573 ошибки компилятора|Количество экземпляров Concurrency::Graphics:: sampler, передаваемых в concurrency::parallel_for_each, не может превышать *номер*|  
|C3574 ошибки компилятора|"*тип*": недопустимые размеры плитки: должны быть положительными и (1) Z < = *номер*; (2) Z*Y*X <= *number*|  
|C3575 ошибки компилятора|"*тип*": недопустимый аргумент домена вычислений; отсутствует открытый член: "concurrency::index <*номер*> _map_index (const concurrency::index <*номер*> &) restrict(amp)"|  
|C3576 ошибки компилятора|"*тип*": аргумента Concurrency::Details:: #*номер* имеет неподдерживаемый тип|  
|C3577 ошибки компилятора|Недопустимый аргумент ядра Concurrency::parallel_for_each: не удалось разрешить вызов члена "void operator() (*типа*) restrict(amp)"|  
|C3578 ошибки компилятора|Размер объекта функции, передаваемых в concurrency::parallel_for_each, не может превышать *номер* байт|  
|C3579 ошибки компилятора|Не может превышать число только для чтения экземпляров concurrency::array и Concurrency::Graphics:: Texture, передаваемых в concurrency::parallel_for_each *номер*|  
|C3580 ошибки компилятора|Не может превышать количество доступных для записи экземпляров concurrency::array и Concurrency::Graphics:: Texture, передаваемых в concurrency::parallel_for_each *номер*|  
|C3581 ошибки компилятора|"*типа*": неподдерживаемый тип в amp коде, ограниченном|  
|C3582 ошибки компилятора|Является устаревшей.|  
|C3583 ошибки компилятора|"*идентификатор*": размер переменной (*номер* байт) больше, чем максимальный размер (*номер* байтов) поддерживается в коде, ограниченном amp|  
|C3584 ошибки компилятора|не поддерживается использование tile_static в "*идентификатор*"|  
|C3585 ошибки компилятора|"*идентификатор*" класс хранения не поддерживается в amp ограничил кода|  
|C3586 ошибки компилятора|"*идентификатор*": Использование глобальных или статических переменных не поддерживается в коде, ограниченном amp|  
|C3587 ошибки компилятора|dynamic_cast не поддерживается в коде, ограниченном AMP|  
|C3588 ошибки компилятора|приведение из "*тип1*«to»*тип2*" не поддерживается в коде, ограниченном amp|  
|C3589 ошибки компилятора|"*строка*": неподдерживаемое использование строковых литералов в amp коде, ограниченном|  
|C3590 ошибки компилятора|"*маркера*": по ссылке или с «this» записи не поддерживается, если лямбда-выражение ограничено amp|  
|C3591 ошибки компилятора|оператор typeid не поддерживается в коде, ограниченном AMP|  
|C3592 ошибки компилятора|встраиваемая машинная сборка (__asm) не поддерживается в коде, ограниченном AMP|  
|C3593 ошибки компилятора|оператор goto не поддерживается в коде, ограниченном AMP|  
|C3594 ошибки компилятора|обработка исключений (try, catch, throw и т. д.) не поддерживается в коде, ограниченном AMP|  
|C3595 ошибки компилятора|постоянное значение выходит за пределы поддерживаемого диапазона в коде, ограниченном AMP|  
|C3596 ошибки компилятора|"*параметр*" ("*типа*"): переменная, записанная лямбда-выражение имеет неподдерживаемый тип в коде, ограниченном amp|  
|C3597 ошибки компилятора|"*параметр*": "*идентификатор*" не может быть захвачено значение, если лямбда-выражение ограничено amp|  
|C3598 ошибки компилятора|выражения меток не поддерживаются в коде, ограниченном AMP|  
|C3599 ошибки компилятора|"*оператор*": невозможно выполнять арифметические операции с указателем на тип bool в коде, ограниченном amp|  
|C3600 ошибки компилятора|"*функция*": использовать плитку\_статической памяти, обнаруженных при компиляции графа вызовов негруппируемого concurrency::parallel\_for_each на: '*функция*"|  
|C3601 ошибки компилятора|"*тип*": недопустимый тип аргумента для диагностической функции amp "*функция*"|  
|C3602 ошибки компилятора|Неподдерживаемая операция управления потоком, обнаруженных при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|  
|[Ошибка компилятора C3603](compiler-error-c3603.md)|"*символ*": тип "*типа*" не поддерживается|  
|C3604 ошибки компилятора|"*идентификатор*": управляемый объект можно создать только в куче gc|  
|C3605 ошибки компилятора|Общее количество образцов (*номер* захвачен и *номер* предопределенных) превышает *номер* при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|  
|C3606 ошибки компилятора|Является устаревшей.|  
|Ошибка компилятора C3607|Является устаревшей.|  
|C3608 ошибки компилятора|Является устаревшей.|  
|[Ошибка компилятора C3609](compiler-error-c3609.md)|"*идентификатор*": функция «запечатан и final» должна быть виртуальной|  
|[Ошибка компилятора C3610](compiler-error-c3610.md)|"*идентификатор*": тип значения должен быть «упакован» перед методом "*метод*" может быть вызван|  
|[Ошибка компилятора C3611](compiler-error-c3611.md)|"*идентификатор*": запечатанная функция не может иметь чистый спецификатор|  
|[Ошибка компилятора C3612](compiler-error-c3612.md)|"*идентификатор*": у запечатанного класса не может быть чистые виртуальные методы|  
|C3613 ошибки компилятора|отсутствует тип возвращаемого значения после "->" (предполагается int)|  
|C3614 ошибки компилятора|Разные значения для размера пакета, в том же классе; предыдущим значением было "*значение*, новое значение —*значение*"|  
|C3615 ошибки компилятора|функция constexpr "*функция*" не может быть выражение константы|  
|Ошибка компилятора C3616|Является устаревшей.|  
|C3617 ошибки компилятора|Является устаревшей.|  
|[Ошибка компилятора C3618](compiler-error-c3618.md)|"*объявление*": метод, помеченный как DllImport не может быть определен|  
|[Ошибка компилятора C3619](compiler-error-c3619.md)|шаблон не может объявляться внутри типа managed WinRT|  
|C3620 ошибки компилятора|"*типа*": Задание выравнивания не разрешен в типах WinRT|  
|C3621 ошибки компилятора|"*тип*": только значение упаковки по умолчанию (*номер*) допускается в типах WinRT|  
|[Ошибка компилятора C3622] (компилятор ошибка c3622.md*тип*": класс, объявленный как"*ключевое слово*"не может быть создан|  
|[Ошибка компилятора C3623](compiler-error-c3623.md)|"*идентификатор*": битовые поля не поддерживаются в типах managed WinRT|  
|[Ошибка компилятора C3624](compiler-error-c3624.md)|"*тип*": использование этого типа необходима ссылка на сборку или модуль "*идентификатор*"|  
|[Ошибка компилятора C3625](compiler-error-c3625.md)|"*класса*": собственный тип не может быть производным от типа managed WinRT "*типа*"|  
|[Ошибка компилятора C3626](compiler-error-c3626.md)|"*идентификатор*": "*ключевое слово*" ключевое слово может использоваться только на интерфейсы COM, функции-члены и члены данных, которые являются указателями на делегаты|  
|[Ошибка компилятора C3627](compiler-error-c3627.md)|Неявное преобразование возможно только для типа значения|  
|[Ошибка компилятора C3628](compiler-error-c3628.md)|"*класс*": классы managed WinRT поддерживают только открытое наследование|  
|C3629 ошибки компилятора|"*маркера*": передаваемый параметр по умолчанию может использоваться только в начале списка захвата лямбда-выражения|  
|[Ошибка компилятора C3630](compiler-error-c3630.md)|Ошибка при обработке лексемы "*токена*"|  
|[Ошибка компилятора C3631](compiler-error-c3631.md)|"*событие*": нельзя перегрузить события managed WinRT|  
|[Ошибка компилятора C3632](compiler-error-c3632.md)|"*событий*": недопустимый тип события для *построения*|  
|[Ошибка компилятора C3633](compiler-error-c3633.md)|не удается определить "*идентификатор*«как управляемый является членом»*класс*"|  
|[Ошибка компилятора C3634](compiler-error-c3634.md)|"*член*": невозможно определить абстрактный метод класса managed WinRT|  
|C3635 ошибки компилятора|"*идентификатор*": не может применяться к классу managed WinRT (используйте "*идентификатор*" вместо)|  
|C3636 ошибки компилятора|"*идентификатор*": не может применяться к этому типу|  
|[Ошибка компилятора C3637](compiler-error-c3637.md)|"*функция*": определение дружественной функции не может быть специализацией функции шаблона или универсального класса|  
|[Ошибка компилятора C3638](compiler-error-c3638.md)|"*оператор*": стандартные упаковка-преобразование и распаковка-преобразование операторы преобразования не может быть переопределен|  
|C3639 ошибки компилятора|Является устаревшей.|  
|[Ошибка компилятора C3640](compiler-error-c3640.md)|"*член*": член адресуемая или виртуальная функция локального класса должна быть определена|  
|[Ошибка компилятора C3641](compiler-error-c3641.md)|"*функция*": недопустимое соглашение о вызовах "*соглашение*" для функции, скомпилированные с параметром/clr: pure или/CLR: safe|  
|[Ошибка компилятора C3642](compiler-error-c3642.md)|"*функция*": невозможно вызвать функцию с соглашением вызова из машинного кода __clrcall|  
|C3643 ошибки компилятора|Является устаревшей.|  
|[Ошибка компилятора C3644](compiler-error-c3644.md)|"*функция*": не удается скомпилировать функцию для создания управляемого кода|  
|[Ошибка компилятора C3645](compiler-error-c3645.md)|"*функция*": __clrcall невозможно использовать с функциями, скомпилированными в машинный код|  
|[Ошибка компилятора C3646](compiler-error-c3646.md)|"*идентификатор*": Неизвестный спецификатор переопределения|  
|C3647 ошибки компилятора|Является устаревшей.|  
|[Ошибка компилятора C3648](compiler-error-c3648.md)|этот синтаксис явного переопределения не поддерживается для управляемых типов|  
|C3649 ошибки компилятора|такой синтаксис явного переопределения невозможно использовать с параметром /ZW|  
|[Ошибка компилятора C3650](compiler-error-c3650.md)|"*член*": не может использоваться как явное переопределение, должен быть виртуальная функция-член базового класса|  
|[Ошибка компилятора C3651](compiler-error-c3651.md)|"*член*": не может использоваться как явное переопределение, должен быть членом базового класса|  
|[Ошибка компилятора C3652](compiler-error-c3652.md)|"*член*": явно переопределяющая функция должна быть виртуальной|  
|[Ошибка компилятора C3653](compiler-error-c3653.md)|"*идентификатор*": не может использоваться как именованное переопределение: переопределяемая функция не найдена; возможно, вы забыли имя функции явно, с помощью ответ: оператор?|  
|[Ошибка компилятора C3654](compiler-error-c3654.md)|"*маркера*": синтаксическая ошибка в явном переопределении|  
|[Ошибка компилятора C3655](compiler-error-c3655.md)|"*член*": функция уже явно переопределена|  
|[Ошибка компилятора C3656](compiler-error-c3656.md)|"*ключевое слово*": переопределение спецификатора не может повторяться|  
|[Ошибка компилятора C3657](compiler-error-c3657.md)|метод завершения или деструктор не может явно переопределять или явно переопределяться|  
|Ошибка компилятора C3658|Является устаревшей.|  
|C3659 ошибки компилятора|"*член*": спецификатор переопределения "*ключевое слово*" не поддерживается|  
|C3660 ошибки компилятора|"*член1*": скрывает наследуемый член "*member2*"|  
|[Ошибка компилятора C3661](compiler-error-c3661.md)|в списке явных переопределений не найден ни один из переопределяемых методов|  
|[Ошибка компилятора C3662](compiler-error-c3662.md)|"*член*": спецификатор переопределения "*ключевое слово*" допускается только для функций-членов классов managed WinRT|  
|C3663 ошибки компилятора|Является устаревшей.|  
|C3664 ошибки компилятора|"*член*": не может использоваться как явное переопределение, должен иметь 'public' или 'защищенными»|  
|[Ошибка компилятора C3665](compiler-error-c3665.md)|"*член*": спецификатор переопределения "*ключевое слово*" не допускается в деструкторе или методе завершения|  
|[Ошибка компилятора C3666](compiler-error-c3666.md)|"*конструктор*": спецификатор переопределения "*ключевое слово*" не допускается в конструкторе|  
|C3667 ошибки компилятора|"*атрибута*": атрибут не поддерживает расширение пакета|  
|[Ошибка компилятора C3668](compiler-error-c3668.md)|"*член*": метод со спецификатором переопределения «override» не переопределяет все методы базового класса|  
|[Ошибка компилятора C3669](compiler-error-c3669.md)|"*член*": спецификатор переопределения «override» не допускаются статические функции-члены или конструкторы|  
|[Ошибка компилятора C3670](compiler-error-c3670.md)|"*член*": невозможно переопределить недоступный метод базового класса "*член*"|  
|[Ошибка компилятора C3671](compiler-error-c3671.md)|"*член*": функция не переопределяет "*член*"|  
|[Ошибка компилятора C3672](compiler-error-c3672.md)|выражение псевдо-деструктора можно использовать только как часть вызова функции|  
|[Ошибка компилятора C3673](compiler-error-c3673.md)|"*класс*": класс не имеет конструктор копии|  
|C3674 ошибки компилятора|не удалось найти стандартную библиотеку модуль "*модуль*"|  
|[Ошибка компилятора C3675](compiler-error-c3675.md)|"*функция*": зарезервировано, поскольку "*свойство*" определен|  
|C3676 ошибки компилятора|"*класса*": класс ссылки и базовый класс имеют несовместимые атрибуты "[*атрибута*]"|  
|C3677 ошибки компилятора|строковый литерал после "operator" не может иметь кодирующий префикс|  
|C3678 ошибки компилятора|строковый литерал после «operator» должен быть пустая строка "»»»"|  
|C3679 ошибки компилятора|Ожидается идентификатор литерального суффикса после "operator «»»"|  
|C3680 ошибки компилятора|невозможно объединить определенные пользователем строковые литералы с несоответствующими идентификаторами литеральных суффиксов|  
|C3681 ошибки компилятора|«fallthrough»: атрибут может использоваться только в внешнего оператора switch|  
|C3682 ошибки компилятора|"оператор *идентификатор*": шаблон литерального оператора/literal оператора не может объявляться как «компоновку C»|  
|C3683 ошибки компилятора|невозможно определить необработанный литеральный оператор и шаблон литерального оператора с одинаковым идентификатором литерального суффикса|  
|C3684 ошибки компилятора|"оператор *идентификатор*": объявление литерального оператора имеет недопустимый список параметров|  
|C3685 ошибки компилятора|"оператор *идентификатор*": шаблон литерального оператора не может иметь параметры функции|  
|C3686 ошибки компилятора|"оператор *идентификатор*": шаблон литерального оператора должен иметь ровно один параметр шаблона, который означает пакет параметров|  
|C3687 ошибки компилятора|"оператор *идентификатор*": шаблон литерального оператора должен иметь не являющийся типом параметр типа «char»|  
|C3688 ошибки компилятора|Недопустимый литеральный суффикс "*суффикс*"; литерала оператор или шаблон литерального оператора "оператор *идентификатор*" не найден|  
|C3689 ошибки компилятора|"оператор *идентификатор*": шаблон литерального оператора/literal оператора должна находиться в области глобальной или пространство имен|  
|C3690 ошибки компилятора|ожидается строковый литерал, но вместо этого обнаружен определенный пользователем строковый литерал|  
|C3691 ошибки компилятора|Недопустимый литеральный префикс "*префикс*"|  
|C3692 ошибки компилятора|Является устаревшей.|  
|C3693 ошибки компилятора|Является устаревшей.|  
|C3694 ошибки компилятора|Является устаревшей.|  
|C3695 ошибки компилятора|Является устаревшей.|  
|C3696 ошибки компилятора|"*ключевое слово*": этот квалификатор невозможно использовать для «%»|  
|[Ошибка компилятора C3697](compiler-error-c3697.md)|"*ключевое слово*": этот квалификатор невозможно использовать для "^"|  
|[Ошибка компилятора C3698](compiler-error-c3698.md)|"*тип*": этот тип нельзя использовать в качестве аргумента "*оператор*"|  
|[Ошибка компилятора C3699](compiler-error-c3699.md)|"*оператор*": невозможно использовать это косвенное обращение в типе "*типа*"|  
|C3700 ошибки компилятора|Является устаревшей.|  
|[Ошибка компилятора C3701](compiler-error-c3701.md)|"*функция*": источник событий не имеет событий|  
|[Ошибка компилятора C3702](compiler-error-c3702.md)|для событий COM требуется ATL|  
|[Ошибка компилятора C3703](compiler-error-c3703.md)|"*event_handler*": метод обработчика событий должен иметь такой же класс хранения, как источник "*событие*"|  
|[Ошибка компилятора C3704](compiler-error-c3704.md)|"*член*": метод vararg не может порождать события|  
|[Ошибка компилятора C3705](compiler-error-c3705.md)|"*функция*": невозможно найти интерфейс событий|  
|[Ошибка компилятора C3706](compiler-error-c3706.md)|"*функция*": должен быть COM-интерфейса для порождения COM-событий|  
|[Ошибка компилятора C3707](compiler-error-c3707.md)|"*член*": метод disp-интерфейса должен иметь dispid|  
|[Ошибка компилятора C3708](compiler-error-c3708.md)|"*функция*": Неправильное использование "*ключевое слово*"; требуется член совместимого источника событий|  
|[Ошибка компилятора C3709](compiler-error-c3709.md)|"*функция*": неправильный синтаксис для задания события в __hook или __unhook|  
|[Ошибка компилятора C3710](compiler-error-c3710.md)|"*функция*": неправильный синтаксис для задания обработчика событий в __hook или __unhook|  
|[Ошибка компилятора C3711](compiler-error-c3711.md)|"*событие*": исходный метод неуправляемого события должен возвращать тип void или целый тип|  
|[Ошибка компилятора C3712](compiler-error-c3712.md)|"*event_handler*": метод обработчика событий должен возвращать тип, совпадающий с именем источника "*событие*"|  
|[Ошибка компилятора C3713](compiler-error-c3713.md)|"*event_handler*": метод обработчика событий должен иметь такие же параметры функции как источник "*событие*"|  
|[Ошибка компилятора C3714](compiler-error-c3714.md)|"*event_handler*": метод обработчика событий должен иметь соглашение о вызове в качестве источника "*событие*"|  
|[Ошибка компилятора C3715](compiler-error-c3715.md)|"*указатель*": должен быть указателем на "*типа*"|  
|C3716 ошибки компилятора|Является устаревшей.|  
|[Ошибка компилятора C3717](compiler-error-c3717.md)|"*член*": метод, порождающий события не может быть определен|  
|[Ошибка компилятора C3718](compiler-error-c3718.md)|можно только вызов "__*ключевое слово*" в контексте функции-члена принимающего класса|  
|[Ошибка компилятора C3719](compiler-error-c3719.md)|"*член*": источник событий на основе интерфейса может использоваться только для событий COM|  
|C3720 ошибки компилятора|"*типа*": реализация IDispatch допускается только на двух или disp-интерфейс|  
|[Ошибка компилятора C3721](compiler-error-c3721.md)|"*подписи*": несовместимая сигнатура для события|  
|[Ошибка компилятора C3722](compiler-error-c3722.md)|универсальное событие не допускается|  
|[Ошибка компилятора C3723](compiler-error-c3723.md)|"*функция*": не удается разрешить событие|  
|[Ошибка компилятора C3724](compiler-error-c3724.md)|для использования многопоточности в событиях требуется #include <windows.h>|  
|Ошибка компилятора C3725|Является устаревшей.|  
|C3726 ошибки компилятора|Является устаревшей.|  
|[Ошибка компилятора C3727](compiler-error-c3727.md)|"*событие*": управляемое событие должно быть функция-член или член данных, является указателем на делегата|  
|[Ошибка компилятора C3728](compiler-error-c3728.md)|"*событие*": событие не имеет метода raise|  
|C3729 ошибки компилятора|Является устаревшей.|  
|Ошибка компилятора C3730|Является устаревшей.|  
|[Ошибка компилятора C3731](compiler-error-c3731.md)|несовместимые событие "*событий*«и обработчик»*event_handler*"; источник события и обработчик событий должен иметь одинаковый тип события|  
|[Ошибка компилятора C3732](compiler-error-c3732.md)|"*интерфейс*": настраиваемый интерфейс, порождающий COM-события не может наследовать от IDispatch|  
|[Ошибка компилятора C3733](compiler-error-c3733.md)|"*событие*": неверный синтаксис для указания события модели COM; возможно, отсутствует «__interface»?|  
|[Ошибка компилятора C3734](compiler-error-c3734.md)|"*класс*": класс managed WinRT не может быть компонентным классом|  
|C3735 ошибки компилятора|Является устаревшей.|  
|[Ошибка компилятора C3736](compiler-error-c3736.md)|"*член*": должен быть методом или, в случае управляемых событий, при необходимости данные-член|  
|[Ошибка компилятора C3737](compiler-error-c3737.md)|"*идентификатор*": делегат не может иметь явное соглашение о вызовах|  
|[Ошибка компилятора C3738](compiler-error-c3738.md)|"*соглашение*": соглашение о вызовах явное создание экземпляра должно совпадать с количеством шаблона создаваемых экземпляров|  
|[Ошибка компилятора C3739](compiler-error-c3739.md)|"*класса*": синтаксис является только после "макета\_зависимых" параметр для event_receiver имеет значение true|  
|[Ошибка компилятора C3740](compiler-error-c3740.md)|"*шаблона*": шаблоны не источниками или приемниками событий|  
|[Ошибка компилятора C3741](compiler-error-c3741.md)|"*класса*": должен быть компонентным классом при "макет\_зависимых" параметр для event_receiver имеет значение true|  
|C3742 ошибки компилятора|"*токен1*": Несбалансированная последовательность токенов в аргументе атрибута "*атрибута*«, ожидалось»*токен2*"|  
|[Ошибка компилятора C3743](compiler-error-c3743.md)|когда параметр "layout_dependent" для event_receiver имеет значение true, установка и удаление обработчика допускаются только для всего интерфейса|  
|[Ошибка компилятора C3744](compiler-error-c3744.md)|для __unhook требуется по крайней мере 3 аргумента в случае управляемых событий|  
|[Ошибка компилятора C3745](compiler-error-c3745.md)|"*функция*": только событие может быть «raised»|  
|C3746 ошибки компилятора|стандартный атрибут "*идентификатор*" могут отображаться не более одного раза в списке атрибутов|  
|[Ошибка компилятора C3747](compiler-error-c3747.md)|отсутствует шаблон или универсальный параметр по умолчанию: параметр *номер*|  
|[Ошибка компилятора C3748](compiler-error-c3748.md)|"*интерфейс*": неуправляемые интерфейсы не могут порождать события|  
|[Ошибка компилятора C3749](compiler-error-c3749.md)|"*атрибута*": настраиваемый атрибут не может использоваться внутри функции|  
|C3750 ошибки компилятора|"*маркера*": непредвиденная лексема в списке атрибутов|  
|C3751 ошибки компилятора|"*идентификатор*": непредвиденный идентификатор в списке атрибутов|  
|[Ошибка компилятора C3752](compiler-error-c3752.md)|"*атрибута*": не удается классифицировать атрибут; "*ключевое слово*" не должны использоваться в этом контексте|  
|[Ошибка компилятора C3753](compiler-error-c3753.md)|универсальное свойство не допускается|  
|[Ошибка компилятора C3754](compiler-error-c3754.md)|конструктор делегата: функцию-член "*член*«не может вызываться для экземпляра типа»*типа*"|  
|[Ошибка компилятора C3755](compiler-error-c3755.md)|"*идентификатор*": делегат не могут быть определены|  
|Ошибка компилятора C3756|Является устаревшей.|  
|C3757 ошибки компилятора|"*типа*": тип не допускается для функции «constexpr»|  
|C3758 ошибки компилятора|"*член*": виртуальная функция не может объявляться как «constexpr»|  
|C3759 ошибки компилятора|"*член*": функция-член нелитерального типа не может объявляться как «constexpr»|  
|C3760 ошибки компилятора|Используйте ключевое слово __property для объявления свойства в managed WinRT "*класс*"|  
|[Ошибка компилятора C3761](compiler-error-c3761.md)|"*функция*": «retval» может использоваться только в последнем аргументе функции|  
|[Ошибка компилятора C3762](compiler-error-c3762.md)|не удается обработать атрибут "*атрибута*"|  
|[Ошибка компилятора C3763](compiler-error-c3763.md)|"*типа*": «retval» и «out» могут использоваться только в тип данных указателя|  
|[Ошибка компилятора C3764](compiler-error-c3764.md)|"*член*": невозможно переопределить метод базового класса "*член*"|  
|[Ошибка компилятора C3765](compiler-error-c3765.md)|"*событий*": не удается определить событие в классе или структуре "*типа*" с пометкой event_receiver|  
|[Ошибка компилятора C3766](compiler-error-c3766.md)|"*тип*«должны предоставлять реализацию метода интерфейса»*функция*"|  
|[Ошибка компилятора C3767](compiler-error-c3767.md)|"*функция*": нет доступа к функции-кандидаты|  
|[Ошибка компилятора C3768](compiler-error-c3768.md)|не удалось получить адрес виртуальной функции vararg в чистом управляемом коде|  
|[Ошибка компилятора C3769](compiler-error-c3769.md)|"*идентификатор*": вложенный класс не может иметь имя, совпадающее с именем немедленно включающего класса|  
|C3770 ошибки компилятора|"*типа*": не является допустимым базовым классом|  
|[Ошибка компилятора C3771](compiler-error-c3771.md)|"*идентификатор*": в ближайшей области пространства имен не может найти дружественное объявление|  
|[Ошибка компилятора C3772](compiler-error-c3772.md)|"*идентификатор*": Недопустимое объявление дружественного шаблона|  
|C3773 ошибки компилятора|следует использовать параметр компилятора / await, чтобы включить соподпрограммы|  
|C3774 ошибки компилятора|не удается найти "*область*::*идентификатор*": включите *заголовок* заголовок|  
|C3775 ошибки компилятора|Тип возвращаемого значения "*функция*«не должно быть»*типа*"|  
|C3776 ошибки компилятора|Невозможно вернуть выражение типа void в соподпрограмме с отличным от void типом возвращаемого значения|  
|C3777 ошибки компилятора|"*функция*": соподпрограмма не может принимать переменное число аргументов|  
|C3778 ошибки компилятора|alloca: невозможно использовать в соподпрограмме|  
|C3779 ошибки компилятора|"*функция*": функция, возвращающая "*типа*" не может использоваться, пока она определена|  
|C3780 ошибки компилятора|"*функция*": преобразование функции, которая возвращает*типа*"не может использоваться, пока она определена|  
|C3781 ошибки компилятора|"*ключевое слово*": нельзя использовать в соподпрограмме типа "*типа*". Либо *ключевое слово* или *ключевое слово* должен присутствовать в связанных типе обещания promise_type|  
|C3782 ошибки компилятора|*Тип*: обещание соподпрограммы не может одновременно содержать *ключевое слово* и *ключевое слово*|  
|C3783 ошибки компилятора|"*идентификатор*": не может быть соподпрограммой|  
|C3784 ошибки компилятора|*Ключевое слово* выражение не может содержаться в этом контексте|  
|C3785 ошибки компилятора|Первый аргумент шаблона для «std::integer_sequence» должен быть типом целого числа|  
|C3786 ошибки компилятора|Второй аргумент шаблона для «std::make_integer_sequence» должен быть целочисленной константой больше или равно нулю|  
|C3787 ошибки компилятора|не удается вывести тип возвращаемого значения этой сопрограммы|  
|C3788 ошибки компилятора|Является устаревшей.|  
|C3789 ошибки компилятора|Является устаревшей.|  
|C3790 ошибки компилятора|Является устаревшей.|  
|C3791 ошибки компилятора|Является устаревшей.|  
|C3792 ошибки компилятора|Является устаревшей.|  
|C3793 ошибки компилятора|Является устаревшей.|  
|C3794 ошибки компилятора|Является устаревшей.|  
|C3795 ошибки компилятора|Является устаревшей.|  
|C3796 ошибки компилятора|Является устаревшей.|  
|[Ошибка компилятора C3797](compiler-error-c3797.md)|"*ключевое слово*": объявление события не может содержать спецификатор переопределения (должен быть размещен в методах добавления/remove/raise события вместо)|  
|[Ошибка компилятора C3798](compiler-error-c3798.md)|"*ключевое слово*": объявление свойства не может содержать спецификатор переопределения (должен быть размещен в свойстве методы get/set вместо)|  
|[Ошибка компилятора C3799](compiler-error-c3799.md)|список параметров индексированного свойства не может быть пустым|  
|[Ошибка компилятора C3800](compiler-error-c3800.md)|"*объявление*": нельзя смешивать свойства и события|  
|C3801 ошибки компилятора|"*атрибута*": атрибут не может иметь предложение аргумента|  
|Ошибка компилятора C3802|Является устаревшей.|  
|[Ошибка компилятора C3803](compiler-error-c3803.md)|"*свойство*": свойство имеет тип, который несовместим с одной из его методов доступа*доступа*"|  
|[Ошибка компилятора C3804](compiler-error-c3804.md)|"*член*": методы доступа для свойства должны либо быть статическими, либо не статическими|  
|[Ошибка компилятора C3805](compiler-error-c3805.md)|"*маркера*": непредвиденная лексема, требуется либо "} «или»,"|  
|C3806 ошибки компилятора|"*маркера*": непредвиденная лексема, требуется либо "{" или инициализатор члена|  
|[Ошибка компилятора C3807](compiler-error-c3807.md)|"*тип*": класс с атрибутом ComImport не может наследовать от "*типа*", допускается только реализация интерфейса|  
|[Ошибка компилятора C3808](compiler-error-c3808.md)|"*тип*": класс с атрибутом ComImport не может определить член "*член*", только абстрактного или функции dllimport разрешены|  
|[Ошибка компилятора C3809](compiler-error-c3809.md)|"*типа*": тип managed WinRT не может иметь любой дружественные функции, классы и интерфейсы|  
|C3810 ошибки компилятора|Является устаревшей.|  
|Ошибка компилятора C3811|Является устаревшей.|  
|[Ошибка компилятора C3812](compiler-error-c3812.md)|"__property" должна быть первой лексемой в объявлении свойства|  
|[Ошибка компилятора C3813](compiler-error-c3813.md)|объявление свойства может присутствовать только в определении типа управляемых WinRT|  
|Ошибка компилятора C3814|Является устаревшей.|  
|[Ошибка компилятора C3815](compiler-error-c3815.md)|Тип возвращаемого значения метода "*член*" должен соответствовать типу последнего параметра метода set|  
|[Ошибка компилятора C3816](compiler-error-c3816.md)|"классе или структуре *член*" был ранее объявлен или определен с другим модификатором managed WinRT|  
|[Ошибка компилятора C3817](compiler-error-c3817.md)|"*объявление*": свойство может применяться только к функции|  
|[Ошибка компилятора C3818](compiler-error-c3818.md)|объявление свойства массива "*свойство*«не будет перегружать свойство индекса»*свойство*"|  
|Ошибка компилятора C3819|Является устаревшей.|  
|[Ошибка компилятора C3820](compiler-error-c3820.md)|"*идентификатор*": инициализаторы должны быть управляемыми|  
|[Ошибка компилятора C3821](compiler-error-c3821.md)|"*функция*": управляемый тип или функция не может использоваться в неуправляемую функцию|  
|Ошибка компилятора C3822|Является устаревшей.|  
|Ошибка компилятора C3823|Является устаревшей.|  
|[Ошибка компилятора C3824](compiler-error-c3824.md)|"*типа*": этот тип не может использоваться в данном контексте (параметр функции, тип возвращаемого значения или статический член)|  
|[Ошибка компилятора C3825](compiler-error-c3825.md)|"*типа*": класс managed WinRT может поддерживать только события managed WinRT|  
|Ошибка компилятора C3826|Является устаревшей.|  
|C3827 ошибки компилятора|стандартный атрибут «deprecated» может иметь без аргументов или один строковый литерал, описывающий причину|  
|[Ошибка компилятора C3828](compiler-error-c3828.md)|аргументы размещения не может быть указан для "*ключевое слово*«выражение для типа»*типа*"|  
|C3829 ошибки компилятора|стандартный атрибут «noreturn» может применяться только к функциям|  
|[Ошибка компилятора C3830](compiler-error-c3830.md)|"*тип1*": не может наследовать от "*тип2*", типы значений могут наследовать только от классов интерфейсов|  
|[Ошибка компилятора C3831](compiler-error-c3831.md)|"*идентификатор*": "*типа*" не может иметь закрепленные данные-член или функция-член, возвращающую закрепляющий указатель|  
|[Ошибка компилятора C3832](compiler-error-c3832.md)|"*typelib*": тип библиотеки выглядит как если бы он был построен для 32-разрядных указателей; измените квалификатор «ptrsize»|  
|[Ошибка компилятора C3833](compiler-error-c3833.md)|"*тип*": недопустимый тип целевого объекта для *идентификатор*|  
|[Ошибка компилятора C3834](compiler-error-c3834.md)|недопустимое явное приведение к закрепляющему указателю; вместо этого используйте закрепленную локальную переменную|  
|C3835 ошибки компилятора|Является устаревшей.|  
|[Ошибка компилятора C3836](compiler-error-c3836.md)|статический конструктор не может иметь список инициализации членов|  
|C3837 ошибки компилятора|атрибуты не допускаются в этом контексте|  
|[Ошибка компилятора C3838](compiler-error-c3838.md)|не может наследовать от "*типа*"|  
|[Ошибка компилятора C3839](compiler-error-c3839.md)|Нельзя изменять выравнивание в типе managed WinRT|  
|Ошибка компилятора C3840|Является устаревшей.|  
|Ошибка компилятора C3841|Является устаревшей.|  
|[Ошибка компилятора C3842](compiler-error-c3842.md)|"*идентификатор*": квалификаторы «const» и «volatile» для функций-членов управляемых WinRT типов не поддерживаются.|  
|C3843 ошибки компилятора|"*идентификатор*": квалификаторы ref в функциях-членах типов управляемых WinRT не поддерживаются.|  
|C3844 ошибки компилятора|"*идентификатор*": не удается импортировать символ из "*источника*": как*идентификатор*"уже существует в текущей области|  
|Ошибка компилятора C3845|Является устаревшей.|  
|[Ошибка компилятора C3846](compiler-error-c3846.md)|"*идентификатор*": не удается импортировать символ из "*источника*": как*идентификатор*«уже импортирован из другой сборки»*сборки*"|  
|C3847 ошибки компилятора|Является устаревшей.|  
|[Ошибка компилятора C3848](compiler-error-c3848.md)|выражение, имеющее тип "*тип*«потеряет некоторые квалификаторы const и volatile для вызова»*идентификатор*"|  
|[Ошибка компилятора C3849](compiler-error-c3849.md)|вызов в стиле функции выражения типа "*тип*" будут потеряны квалификаторы const и volatile для всех *номер* доступных перегрузок операторов|  
|[Ошибка компилятора C3850](compiler-error-c3850.md)|"*маркера*": универсальное имя символа определяет недопустимый символ.|  
|[Ошибка компилятора C3851](compiler-error-c3851.md)|"*токена*": универсальное имя символа не может обозначать символ из базового набора|  
|[Ошибка компилятора C3852](compiler-error-c3852.md)|"*член*«с типом»*типа*": агрегатной инициализации не удалось инициализировать этот член|  
|[Ошибка компилятора C3853](compiler-error-c3853.md)|=: повторная инициализация ссылки или присвоение через ссылку на функцию не допускается|  
|[Ошибка компилятора C3854](compiler-error-c3854.md)|выражение слева от «=» сводится к функции. Не удается назначить функцию (функция не является l значение)|  
|[Ошибка компилятора C3855](compiler-error-c3855.md)|"*функция*": параметр шаблона или универсальный "*идентификатор*" несовместим с объявлением|  
|[Ошибка компилятора C3856](compiler-error-c3856.md)|"*класс*": класс не является шаблон класса или универсальный|  
|[Ошибка компилятора C3857](compiler-error-c3857.md)|"*шаблона*": не допускаются несколько списков вложенных или универсальных параметров|  
|[Ошибка компилятора C3858](compiler-error-c3858.md)|"*идентификатор*": не может быть повторно объявлен в текущей области видимости|  
|[Ошибка компилятора C3859](compiler-error-c3859.md)|диапазон виртуальной памяти для PCH превысил; Повторите компиляцию с параметром командной строки "-Zm*номер*" или выше|  
|[Ошибка компилятора C3860](compiler-error-c3860.md)|список аргументов шаблона или универсальный после имени шаблона или универсальный класс должен перечислять параметры в том порядке, в списке или универсальных параметров|  
|[Ошибка компилятора C3861](compiler-error-c3861.md)|"*идентификатор*": идентификатор не найден|  
|[Ошибка компилятора C3862](compiler-error-c3862.md)|"*функция*": не удается скомпилировать неуправляемую функцию с параметром/clr: pure или/CLR: safe|  
|C3863 ошибки компилятора|тип массива "*типа*" не может быть назначен|  
|C3864 ошибки компилятора|Является устаревшей.|  
|[Ошибка компилятора C3865](compiler-error-c3865.md)|"*ключевое слово*": может использоваться только в собственных функциях-членах|  
|[Ошибка компилятора C3866](compiler-error-c3866.md)|отсутствует список аргументов вызова деструктора или метода завершения|  
|[Ошибка компилятора C3867](compiler-error-c3867.md)|"*функция*": нестандартный синтаксис; используйте «&» для создания указателя на член|  
|[Ошибка компилятора C3868](compiler-error-c3868.md)|"*тип*": ограничения на универсальный параметр "*параметр*" отличаются от ограничений на объявление|  
|[Ошибка компилятора C3869](compiler-error-c3869.md)|в ограничении gcnew отсутствует пустой список параметров "()"|  
|C3870 ошибки компилятора|"*параметр*': ' __declspec (*описатель*)" может применяться только к параметрам целочисленных типов|  
|C3871 ошибки компилятора|"*параметр*": «__declspec(guard(overflow))» поддерживается только для первых 64 параметров функции|  
|[Ошибка компилятора C3872](compiler-error-c3872.md)|"0 x*значение*": этот символ не допускается в идентификаторе|  
|[Ошибка компилятора C3873](compiler-error-c3873.md)|"0 x*значение*": этот символ недопустим как первый символ идентификатора|  
|[Ошибка компилятора C3874](compiler-error-c3874.md)|Тип возвращаемого значения "*идентификатор*«должен быть»*тип1*«вместо of»*тип2*"|  
|C3875 ошибки компилятора|в вызове нестатической функции члена отсутствует список аргументов|  
|C3876 ошибки компилятора|Является устаревшей.|  
|C3877 ошибки компилятора|Является устаревшей.|  
|C3878 ошибки компилятора|Является устаревшей.|  
|C3879 ошибки компилятора|"*член*": не может быть данными-членом initonly|  
|[Ошибка компилятора C3880](compiler-error-c3880.md)|"*член*": не может быть член данных литерала|  
|C3881 ошибки компилятора|конструктор можно наследовать только от прямого базового класса|  
|C3882 ошибки компилятора|"*класса*": конструктор уже унаследован от "*класс*"|  
|Ошибка компилятора C3883|"*член*": статические элементы данных initonly должен инициализироваться|  
|C3884 ошибки компилятора|"*типа*": массив неизвестного размера не может инициализироваться значением|  
|C3885 ошибки компилятора|"*типа*": массив неизвестного размера нельзя инициализировать с помощью пустого списка инициализаторов|  
|[Ошибка компилятора C3886](compiler-error-c3886.md)|"*член*": член данных литерала должен быть инициализирован|  
|[Ошибка компилятора C3887](compiler-error-c3887.md)|"*член*": инициализатор для члена данных литерала должно быть константным выражением|  
|[Ошибка компилятора C3888](compiler-error-c3888.md)|"*член*": выражение константы, связанное с этим членом данных литерала не поддерживается в C + +/ CLI|  
|C3889 ошибки компилятора|Является устаревшей.|  
|[Ошибка компилятора C3890](compiler-error-c3890.md)|"*член*": невозможно получить адрес данных-члена литерала|  
|[Ошибка компилятора C3891](compiler-error-c3891.md)|"*член*": член данных литерала не может использоваться как l значение|  
|[Ошибка компилятора C3892](compiler-error-c3892.md)|"*переменной*": Невозможно присвоить переменной, которая является константным выражением|  
|[Ошибка компилятора C3893](compiler-error-c3893.md)|"*член*": l значения можно использовать элементы данных initonly допускается только в конструкторе экземпляра класса*класс*"|  
|[Ошибка компилятора C3894](compiler-error-c3894.md)|"*член*": l значения можно использовать статические данные-член initonly допускается только в конструкторе класса для класса*класс*"|  
|[Ошибка компилятора C3895](compiler-error-c3895.md)|"*член*": *тип* элементы данных не может быть «volatile»|  
|[Ошибка компилятора C3896](compiler-error-c3896.md)|"*член*": недопустимый инициализатор: этот член данных литерала можно инициализировать только с «nullptr»|  
|Ошибка компилятора C3897|Является устаревшей.|  
|[Ошибка компилятора C3898](compiler-error-c3898.md)|"*член*": *тип* элементы данных могут быть только членами управляемых типов|  
|[Ошибка компилятора C3899](compiler-error-c3899.md)|"*член*": l значения можно использовать элементы данных initonly не разрешается напрямую в параллельной области класса*класс*"|  
|[Ошибка компилятора C3900](compiler-error-c3900.md)|"*член*": не допускается в текущей области видимости|  
|[Ошибка компилятора C3901](compiler-error-c3901.md)|"*функция*": должен иметь тип возвращаемого значения "*типа*"|  
|[Ошибка компилятора C3902](compiler-error-c3902.md)|"*функция*": тип последнего параметра должен быть "*типа*"|  
|[Ошибка компилятора C3903](compiler-error-c3903.md)|"*свойство*": does не установлен или get-метод|  
|[Ошибка компилятора C3904](compiler-error-c3904.md)|"*свойство*": необходимо указать *номер* параметров|  
|C3905 ошибки компилятора|Невыровненные обращения не поддерживаются для подставляемого типа "*типа*"|  
|C3906 ошибки компилятора|Встроенная функция типа "*типа*" не является поддерживаемым типом возврата или аргументов для функций с переменным количеством аргументов или без прототипа|  
|C3907 ошибки компилятора|Является устаревшей.|  
|[Ошибка компилятора C3908](compiler-error-c3908.md)|уровень доступа менее строгий, чем "*идентификатор*"|  
|[Ошибка компилятора C3909](compiler-error-c3909.md)|объявление события WinRT или управляемого должно находиться в типе managed WinRT|  
|[Ошибка компилятора C3910](compiler-error-c3910.md)|"*событий*": должен определять член "*член*"|  
|[Ошибка компилятора C3911](compiler-error-c3911.md)|"*член*": функция должна иметь тип "*типа*"|  
|[Ошибка компилятора C3912](compiler-error-c3912.md)|"*событие*": тип события должен быть типом делегата|  
|[Ошибка компилятора C3913](compiler-error-c3913.md)|свойство по умолчанию должно быть индексировано|  
|[Ошибка компилятора C3914](compiler-error-c3914.md)|свойство по умолчанию не может быть статическим|  
|[Ошибка компилятора C3915](compiler-error-c3915.md)|"*идентификатор*" имеет по умолчанию индексированное свойство (индексатора класса)|  
|C3916 ошибки компилятора|Является устаревшей.|  
|[Ошибка компилятора C3917](compiler-error-c3917.md)|"*маркера*": устаревший *создания* стиль объявления (вы хотели использовать "[" "]" вместо этого?)|  
|[Ошибка компилятора C3918](compiler-error-c3918.md)|требует использования "*идентификатор*" для элемента данных|  
|[Ошибка компилятора C3919](compiler-error-c3919.md)|"*функция*": функция должна иметь тип "*тип_возврата* (*типа*)"|  
|[Ошибка компилятора C3920](compiler-error-c3920.md)|"*оператор*": не удается определить постфиксный увеличения и уменьшения значения оператор CLR или WinRT при вызове постфиксного оператора CLR или WinRT будет вызывать соответствующий префикс CLR или WinRT оператор (op_Increment/op_Decrement), но с постфиксной семантикой|  
|Ошибка компилятора C3921|Является устаревшей.|  
|C3922 ошибки компилятора|Является устаревшей.|  
|[Ошибка компилятора C3923](compiler-error-c3923.md)|"*член*": определения локальных классов, структуры или объединения не допускается в функции-члене класса managed WinRT|  
|C3924 ошибки компилятора|Ошибка в аргументе #*номер* вызова конструктора делегата "*конструктор*":|  
|C3925 ошибки компилятора|ожидается цикл (for, while или выполните) следующие "*директивы*" директивы|  
|C3926 ошибки компилятора|недопустимая константа в директиве parallel|  
|C3927 ошибки компилятора|"->": использование завершающего возвращаемого типа не допускается после декларатора, который не является функцией|  
|C3928 ошибки компилятора|"->": использование завершающего возвращаемого типа не допускается после декларатора в скобках|  
|C3929 ошибки компилятора|Является устаревшей.|  
|C3930 ошибки компилятора|"*функция*": ни одна из перегруженных функций нет спецификаторов ограничений, совместимых с внешним контекстом "*контекста*"|  
|C3931 ошибки компилятора|"*типа*": невозможно вызвать функцию, имеющую спецификаторы ограничений, несовместимые с внешним контекстом|  
|C3932 ошибки компилятора|Является устаревшей.|  
|C3933 ошибки компилятора|"*класс*": спецификаторы ограничения деструктора должны покрывать объединение ограничений для всех конструкторов|  
|C3934 ошибки компилятора|у функции, которая находится в какой-либо из форм функции main, не может быть спецификаторов ограничений, отличных от restrict(cpu)|  
|C3935 ошибки компилятора|"*идентификатор*": переопределение; перекрывающиеся спецификаторы ограничений|  
|C3936 ошибки компилятора|"*идентификатор*": нераспознаваемый спецификатор ограничений|  
|C3937 ошибки компилятора|не допускается использовать пустой спецификатор ограничений|  
|C3938 ошибки компилятора|"*идентификатор*": \042C\042 внешних функций не поддерживаются несколько спецификаторов ограничений|  
|C3939 ошибки компилятора|"*идентификатор*": указатель функции-члены, указатели на функции нельзя использовать ссылки на функции со спецификатором ограничения «amp»|  
|C3940 ошибки компилятора|"*идентификатор*": идентификатор не найден - возможное несоответствие между компилятором и версии библиотек. Убедитесь, соответствие vccorlib.h/.lib, vccorlib120.dll и c1xx.dll|  
|C3941 ошибки компилятора|"*условие*": требуется "/ clr" параметр командной строки|  
|C3942 ошибки компилятора|Является устаревшей.|  
|C3943 ошибки компилятора|Является устаревшей.|  
|C3944 ошибки компилятора|Является устаревшей.|  
|C3945 ошибки компилятора|"*типа*": невозможно выдать или перехватить объект winrt, не являющийся производным от Platform::Exception|  
|C3946 ошибки компилятора|"*типа*": typeid нельзя применять к этому типу|  
|C3947 ошибки компилятора|"*typeid*": typeid нельзя применить к раскрытием пакета|  
|C3948 ошибки компилятора|"*ключевое слово*": раскрытие пакета не может использоваться в этом контексте|  
|C3949 ошибки компилятора|раскрытие пакета, ..., не может отображаться в заключенном в скобки операторе объявления|  
|C3950 ошибки компилятора|Является устаревшей.|  
|C3951 ошибки компилятора|Нельзя использовать указатель на член в проектируемом типе WinRT "*типа*". Вместо этого используйте делегат.|  
|C3952 ошибки компилятора|"*тип*': WinRT не поддерживает массивы «in/out». Используйте "const Array<T>^" для «in» и "WriteOnlyArray<T>" или "Array<T>^ *" для «out» в открытых API|  
|C3953 ошибки компилятора|Нельзя использовать управляемый класс*типа*"в модуле WinRT.|  
|C3954 ошибки компилятора|"*тип*": массив, возвращаемый опубликованным методом в типе WinRT не может использовать форму "Array<T>^"|  
|C3955 ошибки компилятора|"*тип*": открытый конструктор не может содержать параметр «out» или "WriteOnlyArray<T>"|  
|C3956 ошибки компилятора|"*тип*": тип помечен как эксклюзивный для "*тип*и не может использоваться в качестве базового*производный_тип*"|  
|C3957 ошибки компилятора|"*типа*": невозможно использовать «new» WinRT тип; вместо этого используйте «ref new»|  
|C3958 ошибки компилятора|"*типа*": невозможно использовать «gcnew» на WinRT тип; вместо этого используйте «ref new»|  
|C3959 ошибки компилятора|"ref new" можно использовать только для создания объекта типа WinRT|  
|C3960 ошибки компилятора|Является устаревшей.|  
|C3961 ошибки компилятора|статический конструктор не поддерживается|  
|C3962 ошибки компилятора|универсальные классы не поддерживаются|  
|C3963 ошибки компилятора|многомерный массив не поддерживается|  
|C3964 ошибки компилятора|массивы массивов с различным числом членов не поддерживаются|  
|C3965 ошибки компилятора|массивы параметров не поддерживаются|  
|C3966 ошибки компилятора|"*функция*": универсальная функция не поддерживается.|  
|C3967 ошибки компилятора|Ошибка при импорте "*идентификатор*«из модуля»*модуль*"|  
|C3968 ошибки компилятора|токен "*маркера*" является недопустимым разделителем имени модуля; использовать точку (".") вместо|  
|C3969 ошибки компилятора|имена модулей несогласованные: "*module1*«и»*module1*"|  
|C3970 ошибки компилятора|"*идентификатор*": "*ключевое слово*" может применяться только к «ref class» или «ref struct» в глобальной области видимости или области видимости пространства имен|  
|C3971 ошибки компилятора|"*типа*": разделяемое определение не может располагаться после полного определения|  
|C3972 ошибки компилятора|"*типа*": «partial» может применяться только к объявлениям или определениям классов|  
|C3973 ошибки компилятора|Является устаревшей.|  
|C3974 ошибки компилятора|Является устаревшей.|  
|C3975 ошибки компилятора|"классе или структуре *идентификатор*" был ранее объявлен или определен с другим модификатором|  
|C3976 ошибки компилятора|"*идентификатор1*«должен быть объявлен как 'public' для использования»*идентификатор2*"|  
|C3977 ошибки компилятора|Использование требуется ссылка на сборку, определяющую "*идентификатор*"|  
|C3978 ошибки компилятора|"*идентификатор*": статические свойства не допускается в качестве члена типа значения или интерфейса WinRT|  
|C3979 ошибки компилятора|"*тип*": используйте атрибут "*атрибута*«вместо of»*значение*"|  
|C3980 ошибки компилятора|"*типа*" не попадает в метаданные|  
|C3981 ошибки компилятора|"*тип*": тип значения не может иметь любой элементы статических данных*идентификатор*"|  
|C3982 ошибки компилятора|"*тип*": тип значения не может иметь все данные, не являющиеся открытыми члены*идентификатор*"|  
|C3983 ошибки компилятора|"*тип*": тип значения не может иметь любой открытых членов данных не*идентификатор*"|  
|C3984 ошибки компилятора|"*тип*": тип не значения не может иметь открытых элементов данных*идентификатор*"|  
|C3985 ошибки компилятора|"*идентификатор*": сигнатура открытого члена содержит частный тип "*член*"|  
|C3986 ошибки компилятора|"*идентификатор*": сигнатура открытого члена содержит собственный тип "*член*"|  
|C3987 ошибки компилятора|"*идентификатор*": сигнатура открытого члена содержит собственный тип "*типа*"|  
|C3988 ошибки компилятора|"*типа*": собственный тип не может быть открытым|  
|C3989 ошибки компилятора|"*типа*": вложенный тип не может быть открытым|  
|C3990 ошибки компилятора|"*тип*": атрибут "*атрибута*" не может быть закрытым или вложенным|  
|C3991 ошибки компилятора|"*тип*": невозможно реализовать неоткрытый или вложенный интерфейс "*интерфейс*"|  
|C3992 ошибки компилятора|"*идентификатор*": сигнатура открытого члена содержит недопустимый тип "*типа*"|  
|C3993 ошибки компилятора|"*типа*": тип значения должен содержать по крайней мере одно открытое поле|  
|C3994 ошибки компилятора|"*типа*": тип значения не может реализовывать интерфейсы или иметь виртуальные функции|  
|C3995 ошибки компилятора|"*тип*": тип значения не может иметь любое событие члены*идентификатор*"|  
|Ошибка компилятора C3996|Является устаревшей.|  
|C3998 ошибки компилятора|"c ++*версии*": неподдерживаемая версия C++; по умолчанию принимается "c ++*версии*"|  
|C3999 ошибки компилятора|НЕИЗВЕСТНАЯ ошибка выберите команду технической поддержки, в меню справки Visual C++ или откройте Справочный файл технической поддержки для получения дополнительной информации|  

