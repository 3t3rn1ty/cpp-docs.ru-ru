---
title: "CString Operations Relating to C-Style Strings | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "reference"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "casting CString objects"
  - "CString objects, основные операции"
  - "C-style strings"
  - "MFC [C++], string handling class"
  - "значения null, Null-terminated string conversion"
  - "standard run-time library string functions"
  - "string arguments"
  - "преобразование строк [C++], C-style strings"
  - "строковые функции"
  - "строки [C++], class CString"
  - "строки [C++], in C"
  - "строки [C++], string operations"
ms.assetid: 5048de8a-5298-4891-b8a0-c554b5a3ac1b
caps.latest.revision: 17
caps.handback.revision: 13
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# CString Operations Relating to C-Style Strings
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Объект [CString](../atl-mfc-shared/using-cstring.md) содержит данные строки символов.  `CString` наследует набор [методов и операторов](../atl-mfc-shared/reference/cstringt-class.md), определенных в шаблоне класса [CStringT](../atl-mfc-shared/reference/cstringt-class.md) для работы со строковыми данными.  \(`CString` представляет собой `typedef`, который специализирует`CStringT` для работы с тем видом символьных данных, который поддерживается `CString`.\)  
  
 `CString` не обеспечивает внутреннее хранение символьных данных как строка с завершающим нулевым байтом в стиле C.  Вместо этого `CString` отслеживает длину символьных данных, чтобы безопаснее контролировать эти данные и требуемое им место.  
  
 `CString` принимает строки в стиле C и предоставляет способы для доступа к символьным данным как строке в стиле C.  В этом разделе содержатся следующие подразделы, в которых описано использование объекта `CString`, как если бы он являлся строкой с завершающим нулевым байтом в стиле C.  
  
-   [Преобразование в строки с завершающим нулевым байтом в стиле C](#_core_using_cstring_as_a_c.2d.style_null.2d.terminated_string)  
  
-   [Работа со стандартными строковыми функциями библиотеки времени выполнения](#_core_working_with_standard_run.2d.time_library_string_functions)  
  
-   [Непосредственное изменение содержимого CString](#_core_modifying_cstring_contents_directly)  
  
-   [Использование объектов CString с функциями, имеющими переменные аргументы](#_core_using_cstring_objects_with_variable_argument_functions)  
  
-   [Указание формальных параметров CString](#_core_specifying_cstring_formal_parameters)  
  
##  <a name="_core_using_cstring_as_a_c.2d.style_null.2d.terminated_string"></a> Использование CString в качестве строки с завершающим нулевым байтом в стиле C  
 Чтобы использовать объект `CString` в качестве строки в стиле C, выполните приведение этого объекта к `LPCTSTR`.  В следующем примере `CString` возвращает указатель на строку с завершающим нулевым байтом в стиле C, доступную только для чтения.  Функция `strcpy` помещает копию строки в стиле C в переменную `myString`.  
  
```  
CString aCString = "A string";  
char myString[256];  
strcpy(myString, (LPCTSTR)aCString);  
  
```  
  
 Вы можете использовать методы `CString`, например `SetAt`, для изменения отдельных символов в объекте строки.  Однако указатель `LPCTSTR` является временным и становится недействительным при любом изменении `CString`.  `CString` также может выйти за пределы области, после чего выполняется его автоматическое удаление.  Мы рекомендуем получать новый указатель `LPCTSTR` объекта `CString` каждый раз, когда он используется.  
  
 Иногда вам может потребоваться копия данных `CString` для непосредственного внесения изменений.  Используйте более защищенную функцию `strcpy_s` \(или переносимую между Юникодом и многобайтовой кодировкой `_tcscpy_s`\) для копирования объекта `CString` в отдельный буфер.  Именно здесь можно безопасно изменить символы, как показано в следующем примере.  
  
 [!code-cpp[NVC_ATLMFC_Utilities#189](../atl-mfc-shared/codesnippet/CPP/cstring-operations-relating-to-c-style-strings_1.cpp)]  
  
> [!NOTE]
>  Третьим аргументом для `strcpy_s` \(или переносимой между Юникодом и многобайтовой кодировкой `_tcscpy_s`\) является `const``wchar_t*` \(Юникод\) или `const``char*` \(ANSI\).  Приведенный выше пример передает `CString` для этого аргумента.  Компилятор C\+\+ автоматически применяет функцию преобразования, определенную для класса `CString`, который преобразует `CString` в `LPCTSTR`.  Возможность определения операций приведения от одного типа к другому — это одна из самых полезных особенностей C\+\+.  
  
##  <a name="_core_working_with_standard_run.2d.time_library_string_functions"></a> Работа со стандартными строковыми функциями библиотеки времени выполнения  
 Вы должны иметь возможность найти метод `CString` для выполнения строковой операции, для которой может потребоваться использование стандартных строковых функций библиотеки времени выполнения, таких как `strcmp` \(или переносимой между Юникодом и многобайтовой кодировкой `_tcscmp`\).  
  
 Если вам необходимо использовать строковые функции времени выполнения C, можно использовать методики, описанные в разделе \_core\_using\_cstring\_as\_a\_c.2d.style\_null.2d.terminated\_string.  Вы можете скопировать объект `CString` в эквивалентный строковый буфер в стиле C, выполнить операции в этом буфере, а затем снова назначить полученную строку в стиле C объекту `CString`.  
  
##  <a name="_core_modifying_cstring_contents_directly"></a> Непосредственное изменение содержимого CString  
 В большинстве ситуаций для изменения содержимого объекта `CString` или для преобразования `CString` в символьную строку в стиле C следует использовать функции\-члены `CString`.  
  
 В некоторых ситуациях имеет смысл напрямую изменить содержимое `CString`, например, при работе с функциями операционной системы, требующими символьный буфер.  
  
 Методы `GetBuffer` и `ReleaseBuffer` предоставляют доступ к внутреннему символьному буферу объекта `CString` и позволяют изменять его напрямую.  Приведенные ниже действия показывают, как использовать такие функции в этих целях.  
  
#### Использование GetBuffer и ReleaseBuffer для доступа к внутреннему символьному буферу объекта CString  
  
1.  Вызовите `GetBuffer` для объекта `CString` и укажите требуемую длину буфера.  
  
2.  Используйте указатель, возвращенный `GetBuffer`, для записи символов напрямую в объект `CString`.  
  
3.  Вызовите `ReleaseBuffer` для объекта `CString`, чтобы обновить все внутренние сведения о состоянии `CString`, например длину строки.  После непосредственного изменения содержимого объекта `CString` необходимо вызвать `ReleaseBuffer` до вызова любых других функций\-членов `CString`.  
  
##  <a name="_core_using_cstring_objects_with_variable_argument_functions"></a> Использование объектов CString с функциями, имеющими переменные аргументы  
 Некоторые функции C принимают переменное число аргументов.  Ярким примером этого является `printf_s`.  Из\-за способа объявления этого вида функции компилятор не может быть уверен в типе аргументов и не может определить, какую операцию преобразования требуется выполнить для каждого аргумента.  Таким образом, вам важно использовать явное приведение типа при передаче объекта `CString` в функцию, которая принимает переменное число аргументов.  
  
 Чтобы использовать объект `CString` в функции с переменным числом аргументов, выполните явное приведение `CString` к строке `LPCTSTR`, как показано в следующем примере.  
  
 [!code-cpp[NVC_ATLMFC_Utilities#190](../atl-mfc-shared/codesnippet/CPP/cstring-operations-relating-to-c-style-strings_2.cpp)]  
  
##  <a name="_core_specifying_cstring_formal_parameters"></a> Указание формальных параметров CString  
 Для большинства функций, которым требуется строковый аргумент, в прототипе функции в качестве указателя `const` на символ \(`LPCTSTR`\) вместо `CString` лучше всего указать формальный параметр.  При задании формального параметра в качестве указателя `const` на символ вы можете передать указатель в массив `TCHAR`, строковый литерал \[`"hi there"`\] либо объект `CString`.  Объект `CString` автоматически преобразуется в `LPCTSTR`.  В любом месте, где можно использовать `LPCTSTR`, также можно воспользоваться и объектом `CString`.  
  
 Кроме того, вы можете указать формальный параметр в качестве ссылки на константную строку \(то есть, `const``CString&`\), если аргумент не будет изменен.  Удалите модификатор `const`, если строка будет изменена функцией.  Если требуется использовать по умолчанию значение NULL, инициализируйте его с нулевой строкой \[`""`\], как показано ниже:  
  
 [!code-cpp[NVC_ATLMFC_Utilities#191](../atl-mfc-shared/codesnippet/CPP/cstring-operations-relating-to-c-style-strings_3.cpp)]  
  
 Для большинства результатов функции вы можете просто возвратить объект `CString` по значению.  
  
## См. также  
 [Строки](../atl-mfc-shared/strings-atl-mfc.md)   
 [CString Argument Passing](../atl-mfc-shared/cstring-argument-passing.md)