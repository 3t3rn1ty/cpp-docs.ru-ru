---
title: Предотвращение конфликтов кучи | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-mfc
ms.topic: reference
dev_langs:
- C++
helpviewer_keywords:
- heap contention
ms.assetid: 797129d7-5f8c-4b0e-8974-bb93217e9ab5
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 731fcb2328f789e5c487dc56510bbd6f7ec049ea
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
ms.locfileid: "32358089"
---
# <a name="avoidance-of-heap-contention"></a>Предотвращение конфликтов кучи
Диспетчеры строки по умолчанию, предоставляемых MFC и ATL являются простыми оболочками поверх глобальной кучи. Этот глобальный кучи потокобезопасен полностью, это означает, что несколько потоков можно выделить и освободить память из него одновременно без повреждения кучи. Для обеспечения потокобезопасности кучи имеет сериализации доступа к самому себе. Обычно это выполняется с критической секции или похожий механизм блокировки. Каждый раз, когда два потока пытаются одновременно получить доступ к куче, один поток будет заблокирован до завершения другого потока запроса. Для многих приложений такая ситуация возникает редко, и механизм блокировки кучи влияние на производительность незначительно. Однако для приложений, которые часто обращаются к куче из нескольких потоков за блокировки кучи может привести к приложение будет работать медленнее, чем если бы они были одним потоком (даже на компьютерах с несколькими ЦП).  
  
 Приложения, использующие [CStringT](../atl-mfc-shared/reference/cstringt-class.md) особенно чувствительны к куче конфликтов из-за операции с `CStringT` объекты часто требуют повторного выделения буфера строки.  
  
 Один из способов смягчению кучи конфликтов между потоками является иметь каждый поток выделить строки из кучи частного, локальных для потока. До тех пор, пока строк, выделенных с помощью распределителя определенного потока используются только в том же потоке, распределителя не обязательно должен быть потокобезопасным.  
  
## <a name="example"></a>Пример  
 В приведенном ниже примере показано поток процедуру, которая выделяет собственный закрытый кучи не многопоточное следует использовать для строк в этом потоке.  
  
 [!code-cpp[NVC_ATLMFC_Utilities#182](../atl-mfc-shared/codesnippet/cpp/avoidance-of-heap-contention_1.cpp)]  
  
## <a name="comments"></a>Комментарии  
 Несколько потоков могут выполняться с помощью этой же процедуры потока, но так как каждый поток имеет свою собственную кучу является отсутствие конкуренции между потоками. Кроме того тот факт, что каждой кучи не является потокобезопасной дает заметного увеличение производительности, даже если выполняется только одна копия потока. Это является результатом кучи, не используется для защиты от одновременный доступ дорогих Блокируемые операции.  
  
 Для более сложной процедуре потока может оказаться удобнее хранения указателя на диспетчере потока в слоте (TLS) с локального хранилища потока. Это позволяет другие функции, вызывается процедура потока для доступа к диспетчеру строка потока.  
  
## <a name="see-also"></a>См. также  
 [Управление памятью с помощью CStringT](../atl-mfc-shared/memory-management-with-cstringt.md)

