---
title: Реализация пользовательских строка Manager (Дополнительно метод) | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-mfc
ms.topic: reference
dev_langs:
- C++
helpviewer_keywords:
- IAtlStringMgr class, using
ms.assetid: 64ab7da9-47c1-4c4a-9cd7-4cc37e7f3f57
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 23798a4e3c1a5d3c46ea28dec39b37697aae640f
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
---
# <a name="implementation-of-a-custom-string-manager-advanced-method"></a>Реализация пользовательских строка Manager (расширенный метод)
В специальных ситуациях может потребоваться реализовать пользовательскую строку диспетчер, который больше, чем просто изменить какие-либо кучи используется для выделения памяти. В этом случае необходимо вручную реализовать [IAtlStringMgr](../atl-mfc-shared/reference/iatlstringmgr-class.md) интерфейс как руководитель настраиваемой строки.  
  
 Чтобы сделать это, важно понимать как [CStringT](../atl-mfc-shared/reference/cstringt-class.md) использует этот интерфейс для управления его строковых данных. Каждый экземпляр `CStringT` содержит указатель [CStringData](../atl-mfc-shared/reference/cstringdata-class.md) структуры. Эта структура переменной длины содержит важные сведения о строку (например, длина), а также данные Фактический символ для строки. Каждый диспетчер пользовательскую строку отвечает за выделение и освобождение этих структур по запросу `CStringT`.  
  
 `CStringData` Структура состоит из четырех полей:  
  
-   [pStringMgr](../atl-mfc-shared/reference/cstringdata-class.md#pstringmgr) это поле указывает на `IAtlStringMgr` интерфейс, используемый для управления этими данными строки. Когда `CStringT` необходимо повторно выделить или освободить буфер строки, он вызывает перераспределения или произвольным методы этого интерфейса, передавая `CStringData` структуры в качестве параметра. При выделении `CStringData` структуры в ваш руководитель строки необходимо установить это поле для указания настраиваемой строки руководителю.  
  
-   [nDataLength](../atl-mfc-shared/reference/cstringdata-class.md#ndatalength) в этом поле содержится текущего логического длину строки, сохраненного в буфере, за исключением конечное значение null. `CStringT` Это поле обновляется при изменении длину строки. При выделении `CStringData` структуры, руководителю строки необходимо задать это поле в ноль. При перераспределении `CStringData` структуры руководителю настраиваемой строки, оставьте это поле без изменений.  
  
-   [nAllocLength](../atl-mfc-shared/reference/cstringdata-class.md#nalloclength) это поле содержит максимальное число символов (не считая завершающий нуль-символ), которые могут храниться в этом буфере строки без ее перераспределения. Всякий раз, когда `CStringT` необходимости увеличения логический длина строки, он сначала проверяет это поле, чтобы убедиться, что имеется достаточно места в буфере. Если проверка завершается неудачно, `CStringT` вызовы руководителю пользовательской строки в перераспределении буфера. При выделении или перераспределения `CStringData` структуры, необходимо установить это поле по крайней мере число символов, запрашиваемый в **nChars** параметр [IAtlStringMgr::Allocate](../atl-mfc-shared/reference/iatlstringmgr-class.md#allocate) или [IAtlStringMgr::Reallocate](../atl-mfc-shared/reference/iatlstringmgr-class.md#reallocate). Если имеется больше места в буфере, чем запрошено, можно задать это значение, чтобы отразить фактический объем доступного места. Это позволяет `CStringT` расти строку на все выделенное место до того, как его обратный вызов диспетчер строки в перераспределении буфера.  
  
-   [nRefs](../atl-mfc-shared/reference/cstringdata-class.md#nrefs) в этом поле содержится текущее количество ссылок строкового буфера. Если значение равно одно, а затем один экземпляр `CStringT` использует буфера. Кроме того экземпляр может читать и изменять содержимое буфера. Если значение больше одной, нескольких экземпляров `CStringT` можно использовать буфер. Поскольку буфер символов является общим, `CStringT` экземпляры могут только считывать содержимое буфера. Чтобы изменить содержимое, `CStringT` сначала создается копия буфера. Если значение является отрицательным, только один экземпляр `CStringT` использует буфера. В этом случае считается буфера заблокирован. Когда `CStringT` экземпляр использует заблокированные буфера другие экземпляры `CStringT` могут совместно использовать буфер. Эти экземпляры создайте копию буфера перед началом работы содержимое. Кроме того `CStringT` совместное использование буфера какого-либо другого экземпляра, используя заблокированный буфер не пытается `CStringT` назначенного ей экземпляр. В этом случае `CStringT` экземпляр копирует другая строка в заблокированный буфер.  
  
     При выделении `CStringData` структуры, необходимо задать для этого поля зависит от типа общего доступа, разрешенный для буфера. Для большинства реализаций это значение в один. Это позволяет обычным поведением копирования при записи управления доступом. Тем не менее если ваш руководитель строки не поддерживает совместное использование буфера строки, задайте его в заблокированном состоянии. Это заставляет `CStringT` только использовать этот буфер для экземпляра `CStringT` , которые выделены его.  
  
## <a name="see-also"></a>См. также  
 [Управление памятью с помощью CStringT](../atl-mfc-shared/memory-management-with-cstringt.md)

