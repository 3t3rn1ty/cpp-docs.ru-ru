---
title: "String Data Management | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "reference"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "Юникод, string objects"
ms.assetid: 0b53a542-eeb1-4108-9ada-6700645b6f8f
caps.latest.revision: 15
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 11
---
# String Data Management
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Visual C\+\+ предоставляет несколько способов управления строковые данные:  
  
-   [Управление строками](../c-runtime-library/string-manipulation-crt.md) для работы со строками null\- завершенными C учетом  
  
-   Функция Win32 API для управления строками  
  
-   Класс [CStringT Class](../atl-mfc-shared/reference/cstringt-class.md) MFC, который обеспечивает гибкие, изменяемого размера строкового объекта  
  
-   Класс [CStringT Class](../atl-mfc-shared/reference/cstringt-class.md), который предоставляет MFC\- независимое строкового объекта с одной и той же функциональностью, как `CString`  
  
 Практически всю работу программы с данными строки.  Класс MFC `CString` часто лучшее решение, гибкий обработке строки.  Начиная с версии 7.0, `CString` можно использовать в MFC или MFC\- независимых программах.  И библиотека времени выполнения и `CString` поддерживают строки, содержащие символы multibyte \(широкие\), как в Юникоде или программирования многобайтовой кодировки.  
  
 В этой статье описывается, что библиотека классов предоставляет общего назначения службы, связанные в манипуляции строки.  Разделы покрытые в этой статье.  
  
-   [Многобайтовая кодировка Юникод и обеспечивает переносимости](#_core_unicode_and_mbcs_provide_portability)  
  
-   [CStrings и const сгорают указатели](#_core_cstrings_and_const_char_pointers)  
  
-   [Подсчет ссылок CString](#_core_cstring_reference_counting)  
  
 Класс [CStringT Class](../atl-mfc-shared/reference/cstringt-class.md) обеспечивает поддержку обработка строк.  Он предназначен для замены и расширять функциональные возможности, как правило, обеспечиваемая пакетом строки библиотеки времени выполнения c.  Предоставляет функции\-члены и операторы класса `CString` для упрощенной обработки строк, подобные тем, найденных в основном.  Класс также предоставляет конструкторы и операторы для конструирования, присвоить его и сравнить **CStrings** и стандартные строковых типов данных C\+\+.  Поскольку `CString` не является производным от `CObject`, можно использовать объекты `CString` независимо от большинства библиотеки Microsoft Foundation Class \(MFC\).  
  
 Объекты `CString` следовать семантике "значения". Объект `CString` представляющая уникальное значение.  Подумайте, как `CString` фактическая строка, а не как указатель на строку.  
  
 Объект `CString` представляет последовательность переменного числа символов.  Объекты `CString` можно представить в виде массива символов.  
  
##  <a name="_core_unicode_and_mbcs_provide_portability"></a> Многобайтовая кодировка Юникод и обеспечивает переносимости  
 С версией MFC 3,0 и более новой версии MFC, в том числе `CString`, включен как в юникоде, так и для многобайтовых кодировок \(mbcs\).  Эта поддержка позволяет более удобным для записи переносимых приложений, которые можно создать для символов или в юникоде или ANSI.  Чтобы включить эту переносимость каждый символ в объекте `CString` типа **TCHAR**, который определен как `wchar_t` если указан символ **\_UNICODE** при построении приложения или как `char` если нет.  Символ `wchar_t` 16 бит.  Mbcs включена при построении с символом **\_MBCS** указан.  Сам построен с MFC или символ **\_MBCS** \(для библиотек NAFX\) или указанный символ **\_UNICODE** \(для библиотек UAFX\).  
  
> [!NOTE]
>  Примеры в этом `CString` и соответствующие статьи на строках отображаются правильно отформатированные для переносимости строковые литералы в юникоде, используя макрос **\_T**, которые преобразует литеральную строку в формате:  
  
 `L"literal string"`  
  
> [!NOTE]
>  компилятор считает, что в виде строки в юникоде.  Например, следующий код:  
  
 [!code-cpp[NVC_ATLMFC_Utilities#187](../atl-mfc-shared/codesnippet/CPP/string-data-management_1.cpp)]  
  
> [!NOTE]
>  преобразует в виде строки в юникоде, если **\_UNICODE** указано или в виде строки ANSI, если нет.  Дополнительные сведения см. в статье [Поддержка Юникода и многобайтовой кодировки](../atl-mfc-shared/unicode-and-multibyte-character-set-mbcs-support.md).  
  
 Объект `CString` может храниться до **INT\_MAX** \(2.147.483.647\) символов.  Тип данных **TCHAR** используется для получения или установки отдельных символов в `CString` объект.  В отличие от массив знаков, класс `CString` имеет встроенные возможности выделения памяти.  Это позволяет объектам `CString` автоматически увеличиваться по мере необходимости \(иными словами, не следует беспокоиться о увеличение объект `CString` с подходящим более длинным строкам\).  
  
##  <a name="_core_cstrings_and_const_char_pointers"></a> CStrings и const сгорают указатели  
 Объект `CString` также может действовать как символьная строка в стиле языка C \( `PCXSTR`, совпадает с **const char\*** если не в юникод\).  Оператор преобразования [CSimpleStringT::operator PCXSTR](../Topic/CSimpleStringT::operator%20PCXSTR.md) позволяет объектам `CString` свободно, заменяемый указателей символов при вызове функции.  Конструктор **CString\( LPCWSTR**`pszSrc`**\)** позволяет указателей символов, заменяемый объектов `CString`.  
  
 Не производится попыток сложить объекты `CString`.  При внесении 2 объекта `CString`, содержащий `Chicago`, например, символы в `Chicago` хранятся в 2 местах.  \(Это не может выполняться будущих версий MFC, поэтому зависит от нее\).  
  
> [!NOTE]
>  Использование функций\-членов [CSimpleStringT::GetBuffer](../Topic/CSimpleStringT::GetBuffer.md) и [CSimpleStringT::ReleaseBuffer](../Topic/CSimpleStringT::ReleaseBuffer.md), когда требуется непосредственно обратиться к `CString` как nonconstant указатель на символ.  
  
> [!NOTE]
>  Использование функций\-членов [CStringT::AllocSysString](../Topic/CStringT::AllocSysString.md) и [CStringT::SetSysString](../Topic/CStringT::SetSysString.md) для выбора и установить объекты `BSTR` используемый в автоматизации \(ранее называемой ole\-автоматизацией\).  
  
> [!NOTE]
>  Где возможно, выберите объекты `CString` во фрейме, а не в куче.  Это сохраняет память и упрощает передачу параметров.  
  
 Класс `CString` не реализуется как класс коллекции библиотеки Microsoft Foundation Class, хотя объекты `CString` определенно могут храниться как элементы в коллекциях.  
  
##  <a name="_core_cstring_reference_counting"></a> Подсчет ссылок CString  
 От версии MFC 4.0, если объекты [CStringT Class](../atl-mfc-shared/reference/cstringt-class.md) копируются, MFC увеличивает счетчик ссылок вместо репликация данных.  Это делает их передаче объектов `CString` значений и возврата значения более эффективным.  Эти операции вызывают конструктор копии, иногда вызываться несколько раз.  Выполнить приращение счетчика ссылок уменьшается, что издержки для этих общих операций и делает использование `CString` более привлекательный параметр.  
  
 По мере того как каждая копия разрушена, уменьшается число ссылок в исходном объекте.  Объект `CString` оригинального не уничтожается, пока его значение счетчика ссылок не уменьшен до нуля.  
  
 Можно использовать функции\-члены [CSimpleStringT::LockBuffer](../Topic/CSimpleStringT::LockBuffer.md) и [CSimpleStringT::UnlockBuffer](../Topic/CSimpleStringT::UnlockBuffer.md)`CString` чтобы отключить или включить подсчет ссылок.  
  
## См. также  
 [Общие разделы по MFC](../mfc/general-mfc-topics.md)