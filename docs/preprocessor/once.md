---
title: Когда | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-tools
ms.topic: reference
f1_keywords:
- vc-pragma.once
- once_CPP
dev_langs:
- C++
helpviewer_keywords:
- once pragma
- pragmas, once
ms.assetid: c7517556-6403-4b16-8898-f2aa0a6f685f
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 9b0e0b2b3667d4a33709caa643e4d26ed70b2990
ms.sourcegitcommit: d55ac596ba8f908f5d91d228dc070dad31cb8360
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/08/2018
ms.locfileid: "33912931"
---
# <a name="once"></a>once
Указывает, что при компилировании компилятором файла исходного кода данный файл будет включен (открыт) только один раз.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
#pragma once  
  
```  
  
## <a name="remarks"></a>Примечания  
 Использование `#pragma once` может сократить время сборки, так как компилятор не будет открывать и считывать файл после первой директивы #include для файла в записи преобразования. Это называется *оптимизации множественного включения*. Он действует аналогично *#include guard* версии, которая использует определения макросов препроцессора для предотвращения множественных включений содержимого файла. Это также помогает предотвратить нарушение *правило одного определения*— требование, которому все шаблоны, типы, функции и объекты должны иметь не более одного определения в коде.  
  
 Пример:  
  
```  
// header.h  
#pragma once  
// Code placed here is included only once per translation unit  
  
```  
  
 Мы рекомендуем директиву `#pragma once` для нового кода, так как она не засоряет глобальное пространство имен символами препроцессора. Она требует меньше ввода кода, меньше отвлекает и не вызывает конфликтов символов — ошибок, возникающих, когда разные заголовочные файлы используют один и тот же символ препроцессора в качестве значения защиты. Она не входит в стандарт C++, но она переносимо реализована в нескольких популярных компиляторах.  
  
 Использование обеих директив, идиомы #include guard и `#pragma once`, в одном и том же файле не дает никаких преимуществ. Компилятор распознает идиому #include guard и выполняет оптимизацию множественного включения точно так же как и директива `#pragma once`, если исполняемый код или директива препроцессора располагаются до или после стандартной формы идиомы:  
  
```  
// header.h  
// Demonstration of the #include guard idiom.  
// Note that the defined symbol can be arbitrary.  
#ifndef HEADER_H_     // equivalently, #if !defined HEADER_H_  
#define HEADER_H_  
// Code placed here is included only once per translation unit  
#endif // HEADER_H_  
  
```  
  
 Мы рекомендуем использовать идиому #include guard в тех случаях, когда код должен быть переносимым для компиляторов, которые не реализуют директиву `#pragma once`, для поддержания согласованности с существующим кодом или когда оптимизация множественного включения невозможна. Это может произойти в сложных проектах, когда использование псевдонимов в файловой системе или в путях включения не позволяет компилятору обнаруживать идентичные включаемые файлы с помощью канонического пути.  
  
 Старайтесь не использовать `#pragma once` или идиому #include guard в файлах заголовков, предназначенных для многократного включения с использованием символов препроцессора для контроля за результатами их применения. Пример этой конструкции см. в разделе \<assert.h > файла заголовка. Также соблюдайте осторожность, задавая пути включения, чтобы избежать создания нескольких путей к включаемым файлам, что позволит отказаться от использования оптимизации множественного включения как для #include guard, так и для `#pragma once`.  
  
## <a name="see-also"></a>См. также  
 [Директивы Pragma и ключевое слово __Pragma](../preprocessor/pragma-directives-and-the-pragma-keyword.md)