---
title: "once | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "vc-pragma.once"
  - "once_CPP"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "once - прагма"
  - "прагмы, once"
ms.assetid: c7517556-6403-4b16-8898-f2aa0a6f685f
caps.latest.revision: 8
author: "corob-msft"
ms.author: "corob"
manager: "ghogen"
caps.handback.revision: 8
---
# once
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Указывает, что при компилировании компилятором файла исходного кода данный файл будет включен \(открыт\) только один раз.  
  
## Синтаксис  
  
```  
  
#pragma once  
  
```  
  
## Заметки  
 Использование `#pragma once` может сократить время сборки, так как компилятор не будет открывать и считывать файл после первой директивы \#include для файла в записи преобразования.  Это называется *оптимизация множественного включения*.  Результат ее применения аналогичен применению идиомы *\#include guard*, которая использует определения макросов препроцессора для предотвращения множественных включений содержимого файла.  Это также помогает предотвратить нарушение *правила одного определения* — требования, согласно которому все шаблоны, типы, функции и объекты не должны иметь более одного определения в коде.  
  
 Пример:  
  
```  
// header.h  
#pragma once  
// Code placed here is included only once per translation unit  
  
```  
  
 Мы рекомендуем директиву `#pragma once` для нового кода, так как она не засоряет глобальное пространство имен символами препроцессора.  Она требует меньше ввода кода, меньше отвлекает и не вызывает конфликтов символов — ошибок, возникающих, когда разные заголовочные файлы используют один и тот же символ препроцессора в качестве значения защиты.  Она не входит в стандарт C\+\+, но она переносимо реализована в нескольких популярных компиляторах.  
  
 Использование обеих директив, идиомы \#include guard и `#pragma once`, в одном и том же файле не дает никаких преимуществ.  Компилятор распознает идиому \#include guard и выполняет оптимизацию множественного включения точно так же как и директива `#pragma once`, если исполняемый код или директива препроцессора располагаются до или после стандартной формы идиомы:  
  
```  
// header.h  
// Demonstration of the #include guard idiom.  
// Note that the defined symbol can be arbitrary.  
#ifndef HEADER_H_     // equivalently, #if !defined HEADER_H_  
#define HEADER_H_  
// Code placed here is included only once per translation unit  
#endif // HEADER_H_  
  
```  
  
 Мы рекомендуем использовать идиому \#include guard в тех случаях, когда код должен быть переносимым для компиляторов, которые не реализуют директиву `#pragma once`, для поддержания согласованности с существующим кодом или когда оптимизация множественного включения невозможна.  Это может произойти в сложных проектах, когда использование псевдонимов в файловой системе или в путях включения не позволяет компилятору обнаруживать идентичные включаемые файлы с помощью канонического пути.  
  
 Старайтесь не использовать `#pragma once` или идиому \#include guard в файлах заголовков, предназначенных для многократного включения с использованием символов препроцессора для контроля за результатами их применения.  Пример такой структуры см. в файле заголовка \<assert.h\>.  Также соблюдайте осторожность, задавая пути включения, чтобы избежать создания нескольких путей к включаемым файлам, что позволит отказаться от использования оптимизации множественного включения как для \#include guard, так и для `#pragma once`.  
  
## См. также  
 [Директивы Pragma и ключевое слово \_\_Pragma](../preprocessor/pragma-directives-and-the-pragma-keyword.md)