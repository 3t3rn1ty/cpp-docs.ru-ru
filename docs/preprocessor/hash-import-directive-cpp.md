---
title: '#Импортировать директивы (C++) | Документы Microsoft'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-tools
ms.topic: reference
f1_keywords:
- '#import'
dev_langs:
- C++
helpviewer_keywords:
- .tlh files
- '#import directive'
- import directive (#import)
- tlh files
- tlbid switch
- preprocessor, directives
- COM, type library header file
ms.assetid: 787d1112-e543-40d7-ab15-a63d43f4030a
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 4e649e458a6275ea369031416c379721c3f9af0e
ms.sourcegitcommit: d55ac596ba8f908f5d91d228dc070dad31cb8360
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/07/2018
---
# <a name="import-directive-c"></a>Директива #import (C++)
**Конкретных C++**  
  
 Используется для включения сведений из библиотеки типов. Содержимое библиотеки типов преобразовано в классы C++, в основном описывающие интерфейсы модели COM.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
#import "filename" [attributes]  
#import <filename> [attributes]  
```  
  
#### <a name="parameters"></a>Параметры  
 *filename*  
 Задает тип библиотеки для импорта. `filename` может принимать следующие значения:  
  
-   Имя файла, содержащего библиотеку типов, например OLB-, TLB- или DLL-файла. Ключевое слово **файла:**, может предшествовать имени каждого файла.  
  
-   ИД программы элемента управления в библиотеке типов. Ключевое слово **progid:**, может предшествовать каждому идентификатору программы. Пример:  
  
    ```  
    #import "progid:my.prog.id.1.5"  
    ```  
  
     Дополнительные сведения об идентификаторах ProgID см [Указание идентификатора локализации и номер версии](#_predir_the_23import_directive_specifyingthelocalizationidandversionnumber).  
  
     Обратите внимание, что при компилировании с использованием межкомпилятора в 64-разрядной операционной системе компилятор сможет прочитать только куст 32-разрядного реестра. Может потребоваться использовать собственный 64-разрядный компилятор для создания и регистрации 64-разрядной библиотеки типов.  
  
-   Идентификатор библиотеки типов. Ключевое слово **libid:**, может предшествовать каждому идентификатору библиотеки. Пример:  
  
    ```  
    #import "libid:12341234-1234-1234-1234-123412341234" version("4.0") lcid("9")  
    ```  
  
     Если не указать версию или код языка, [правила](#_predir_the_23import_directive_specifyingthelocalizationidandversionnumber) , которые применяются к **progid:** также применяются к **libid:**.  
  
-   Исполняемый файл (.exe).  
  
-   Файл библиотеки (DLL), содержащий ресурс библиотеки типов (например, OCX).  
  
-   Составной документ, содержащую библиотеку типов.  
  
-   Любой другой формат файла, который может быть понятным **LoadTypeLib** API.  
  
 `attributes`  
 Один или несколько [атрибуты #import](#_predir_the_23import_directive_import_attributes). Используйте в качестве разделителя атрибутов пробел или запятую. Пример:  
  
```  
#import "..\drawctl\drawctl.tlb" no_namespace, raw_interfaces_only  
```  
  
 - или -  
  
```  
#import "..\drawctl\drawctl.tlb" no_namespace raw_interfaces_only  
```  
  
## <a name="remarks"></a>Примечания  
  
##  <a name="_predir_the_23import_directive_searchorderforfilename"></a> Порядок поиска имени файла  
 *Имя файла* при необходимости предваряется спецификацией каталога. Имя файла должно указывать на существующий файл. Различие между двумя синтаксисами — это порядок, в котором препроцессор ищет файлы библиотеки типов, когда путь определен не полностью.  
  
|Форма синтаксиса|Действие|  
|-----------------|------------|  
|Форма в кавычках|Указывает препроцессору искать файлы библиотеки типов сначала в каталоге файла, содержащего оператор `#import`, а затем в каталогах любых файлов, которые включают (`#include`) этого файла. Затем препроцессор выполняет поиск по путям, показанным ниже.|  
|Форма с угловыми скобками|Указывает препроцессору искать файлы библиотеки типов по следующим путям.<br /><br /> 1.  **Путь** список путей переменной среды<br />2.  **LIB** список путей переменной среды<br />3.  Путь, указанный /I (Дополнительные каталоги включения) параметр компилятора, за исключением его компилятор выполняет поиск библиотеки типов, на который была ссылка из другой библиотеки типов с [no_registry](../preprocessor/no-registry.md) атрибута.|  
  
##  <a name="_predir_the_23import_directive_specifyingthelocalizationidandversionnumber"></a> Указание идентификатора локализации и номер версии  
 При определении идентификатора программы можно также указать идентификатор программы локализации и номер версии. Пример:  
  
```  
#import "progid:my.prog.id" lcid("0") version("4.0)  
```  
  
 Если не указать идентификатор локализации, идентификатор программы выбирается по следующим правилам.  
  
-   Если имеется только один ИД локализации, используется он.  
  
-   Если имеется несколько идентификаторов локализации, используется первый из них с номером версии 0, 9 или 409.  
  
-   Если имеется несколько идентификаторов локализации и ни один из них не равен 0, 9 или 409, используется последний.  
  
-   Если не указать номер версии, используется последняя версия.  
  
##  <a name="_predir_the_23import_directive_header_files_created_by_import"></a> Заголовочные файлы, созданные импортом  
 `#import` создает два файла заголовка, которые реконструируют содержимое библиотеки типов в исходном коде на языке C++. Основной файл заголовка аналогичен файлу, создаваемому компилятором MIDL, но с дополнительными создаваемыми компилятором кодом и данными. [Основной файл заголовка](#_predir_the_primary_type_library_header_file) имеет такое же базовое имя, что библиотека типов, а также. TLH расширение. Вторичный файл заголовка имеет такое же базовое имя, что и библиотека типов, с расширением .TLI. Он содержит реализации созданных компилятором функций-членов и включен (`#include`) в соответствующий файл заголовка.  
  
 Если импортировать свойство dispinterface, использующее параметры byref, #import не создает __declspec ([свойство](../cpp/property-cpp.md)) инструкции для функции.  
  
 Оба файла заголовка помещаются в выходной каталог, заданный параметром /Fo (имя объектного файла). Затем они считываются и компилируются компилятором, как если бы основной файл заголовка назывался директивой `#include`.  
  
 Следующие оптимизации компилятора выполняется с помощью директивы `#import`.  
  
-   Файл заголовка, когда создан, получает ту же отметку времени, что и библиотека типов.  
  
-   При обработке `#import` компилятор проверяет, существует ли заголовок и находится ли он в актуальном состоянии. Если да, повторно создавать его не требуется.  
  
 Директива `#import` также участвует в минимальном перестроении и может быть помещена в предкомпилированный файл заголовка. В разделе [Создание файлов предкомпилированных заголовков](../build/reference/creating-precompiled-header-files.md) для получения дополнительной информации.  
  
###  <a name="_predir_the_primary_type_library_header_file"></a> Основной файл библиотеки типов заголовка  
 Основной файл заголовка библиотеки типов состоит из 7 разделов:  
  
-   Наименование заголовка: состоит из комментариев, оператора `#include` для COMDEF.H (определяющего некоторые стандартные макросы, используемые в заголовке), и других разнообразных сведений о настройке.  
  
-   Прямые ссылки и объекты typedef. Состоит из двух структур, таких как `struct IMyInterface` и typedef.  
  
-   Смарт-указатель объявления: класс шаблона `_com_ptr_t` — реализация интеллектуального указателя, которая инкапсулирует указатели на интерфейс и избавляет от необходимости вызывать `AddRef`, **выпуска**, `QueryInterface` функции. Кроме того, он скрывает вызов `CoCreateInstance` при создании нового COM-объекта. В этом разделе используется оператор макрос **_COM_SMARTPTR_TYPEDEF** для установления определения типов COM-интерфейсов для специализации шаблона [_com_ptr_t](../cpp/com-ptr-t-class.md) класса шаблона. Например, для интерфейса **IMyInterface**,. TLH-файл содержит:  
  
    ```  
    _COM_SMARTPTR_TYPEDEF(IMyInterface, __uuidof(IMyInterface));  
    ```  
  
     который будет развернут компилятором следующим образом.  
  
    ```  
    typedef _com_ptr_t<_com_IIID<IMyInterface, __uuidof(IMyInterface)> > IMyInterfacePtr;  
    ```  
  
     Тип `IMyInterfacePtr` можно затем использовать вместо начального указателя интерфейса `IMyInterface*`. Следовательно, нет необходимости вызывать различные **IUnknown** функции-члены  
  
-   Объявления typeInfo: в основном состоит из определений классов и других элементов, предоставляющих отдельные элементы typeinfo возвращенных **ITypeLib: GetTypeInfo**. В этом разделе каждый объект typeinfo из библиотеки типов отражается в заголовке в форме, которая определяется информацией `TYPEKIND`.  
  
-   Необязательное прежнее определение GUID: содержит инициализации именованных констант GUID. Имена в формате **CLSID_CoClass** и **IID_Interface**, схожие с создаваемыми создаваемого компилятором MIDL.  
  
-   Оператор `#include` для заголовка второстепенной библиотеки типов.  
  
-   Стандартный нижний колонтитул: в настоящее время содержит `#pragma pack(pop)`.  
  
 Все разделы, за исключением стандартного и нижний колонтитулы стандартный раздел заголовка, заключенные в пространстве имен, имя которого задается путем **библиотеки** инструкции в исходном файле IDL. Можно использовать имена из заголовков библиотек типов путем явной квалификации с именем пространства имен или путем включения следующего оператора:  
  
```  
using namespace MyLib;  
```  
  
 сразу после оператора `#import` в исходном коде.  
  
 Пространство имен можно подавить с помощью [no_namespace](#_predir_no_namespace) атрибут `#import` директивы. Однако подавление пространства имен может привести к конфликтам имен. Пространство имен может быть переименована [rename_namespace](#_predir_rename_namespace) атрибута.  
  
 Компилятор предоставляет полный путь к любой зависимости библиотеки типов, необходимой библиотеке типов, которая его в данный момент обрабатывает. Путь записывается в форме комментариев в заголовке библиотеки типов (.TLH), который компилятор создает для каждой обрабатываемой библиотеки типов.  
  
 Если библиотека типов содержит ссылки на типы, определенные в других библиотеках типов, TLH-файл включает комментарии следующей сортировки:  
  
```  
//  
// Cross-referenced type libraries:  
//  
//  #import "c:\path\typelib0.tlb"  
//  
```  
  
 Фактическое имя файла в комментарии `#import` — это полный путь к библиотеке типов, на которые имеются перекрестные ссылки, в том виде, в котором они сохранены в реестре. При возникновении ошибок, которые вызваны отсутствующими определения типа, проверьте комментарии в элементе .TLH, чтобы узнать, какие зависимые библиотеки типов может потребоваться импортировать в первую очередь. Самыми вероятными ошибками являются синтаксические (например, C2143, C2146, C2321), C2501 (отсутствуют спецификаторы decl) и C2433 ("inline" не разрешается использовать в объявлении данных) при компиляции TLI-файла.  
  
 Необходимо определить, какие из комментариев зависимости в противном случае не предоставляются для заголовков системы, и затем предоставить директиву `#import` в некоторый момент перед директивой `#import` зависимой библиотеки типов для разрешения ошибки.  
  
 Дополнительные сведения см. в статье базы знаний "Методы программы-оболочки #import могут вызвать нарушение прав доступа" (Q242527) или "Ошибки компилятора при использовании #import с XML" (Q269194). Статьи базы знаний можно найти на диске библиотеки MSDN или на [поддержки Майкрософт](https://support.microsoft.com/).  
  
##  <a name="_predir_the_23import_directive_import_attributes"></a> атрибуты #import  
 `#import` также может включать один или несколько атрибутов. Эти атрибуты указывают, что компилятор изменяет содержимое заголовка библиотеки типов. Обратная косая черта (**\\**) символ можно использовать для включения дополнительных строк в одном `#import` инструкции. Пример:  
  
```  
#import "test.lib" no_namespace \  
   rename("OldName", "NewName")  
```  
  
 Дополнительные сведения см. в разделе [атрибуты #import](../preprocessor/hash-import-attributes-cpp.md).  
  
 **КОНЕЦ определенного C++**  
  
## <a name="see-also"></a>См. также  
 [Директивы препроцессора](../preprocessor/preprocessor-directives.md)   
 [Поддержка COM компилятора](../cpp/compiler-com-support.md)
