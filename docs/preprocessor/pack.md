---
title: "pack | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "pack_CPP"
  - "vc-pragma.pack"
dev_langs: 
  - "C++"
  - "C"
helpviewer_keywords: 
  - "pack - прагма"
  - "прагмы, pack"
ms.assetid: e4209cbb-5437-4b53-b3fe-ac264501d404
caps.latest.revision: 18
caps.handback.revision: 18
author: "corob-msft"
ms.author: "corob"
manager: "ghogen"
---
# pack
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Задает выравнивание упаковки для членов структуры, объединения и класса.  
  
## Синтаксис  
  
```  
  
#pragma pack( [ show ] | [ push | pop ] [, identifier ] , n  )  
```  
  
## Заметки  
 Упаковать класс значит разместить его члены непосредственно друг за другом в памяти, что может привести к тому, что некоторые или все члены могут быть выровнены по границе меньшей, чем выравнивание целевой архитектуры, заданное по умолчанию.  Директива `pack` обеспечивает контроль на уровне объявления данных.  В этом состоит отличие от параметра компилятора [\/Zp](../Topic/-Zp%20\(Struct%20Member%20Alignment\).md), который предоставляет контроль только на уровне модуля.  Директива `pack` действует на первое объявление `struct`, `union` или `class` после этой директивы \#pragma.  Директива `pack` не действует на определения.  При вызове директивы `pack` без аргументов для параметра `n` задается значение, указанное в параметре компилятора **\/Zp**.  Если этот параметр компилятора не указан, по умолчанию используется значение 8.  
  
 При изменении выравнивания структуры она может занимать меньше места в памяти, но возможно снижение производительности или даже возникновение аппаратного исключения для невыровненного доступа.  Поведение этого исключения можно изменить с помощью директивы [SetErrorMode](http://msdn.microsoft.com/library/windows/desktop/ms680621).  
  
 **show** \(необязательно\)  
 Отображает текущее байтовое значение выравнивания упаковки.  Значение отображается в предупреждении.  
  
 **push** \(необязательно\)  
 Помещает текущее значение выравнивания упаковки во внутренний стек компилятора и задает для текущего выравнивания упаковки значение `n`.  Если значение `n` не указано, текущее значение выравнивания упаковки не помещается в стек.  
  
 **pop** \(необязательно\)  
 Удаляет запись из вершины внутреннего стека компилятора.  Если значение `n` не указано вместе с **pop**, то новым значением выравнивания упаковки становится значение упаковки, связанное с результирующей записью в вершине стека.  Если значение `n` указано \(например, `#pragma pack(pop, 16)`\), `n` становится новым значением выравнивания упаковки.  Если извлечение из стека производится вместе с идентификатором `identifier` \(например, `#pragma pack(pop, r1)`\), из стека извлекаются все записи, пока не будет найдена запись `identifier`.  Эта запись извлекается из стека, и новым значением выравнивания упаковки становится значение упаковки, связанное с результирующей записью в вершине стека.  Если при извлечении из стека с идентификатором `identifier` этот идентификатор не найден ни в одной из записей стека, директива **pop** игнорируется.  
  
 `identifier` \(необязательно\)  
 При использовании с директивой **push** присваивает имя записи во внутреннем стеке компилятора.  При использовании с директивой **pop** записи из внутреннего стека извлекаются до тех пор, пока не будет удален идентификатор `identifier`; если идентификатор `identifier` во внутреннем стеке не найден, ничего не извлекается.  
  
 `n` \(необязательно\)  
 Указывает значение \(в байтах\), используемое для упаковки.  Если для модуля не задан параметр компилятора [\/Zp](../Topic/-Zp%20\(Struct%20Member%20Alignment\).md), по умолчанию для `n` используется значение 8.  Допустимые значения: 1, 2, 4, 8 и 16.  Выравнивание члена будет производиться по границе, кратной значению `n` или кратной размеру члена, в зависимости от того, какое из значений меньше.  
  
 Значение `#pragma pack(pop,` `identifier``,` `n``)` не определено.  
  
 Дополнительные сведения об изменении выравнивания см. в следующих разделах:  
  
-   [\_\_alignof](../cpp/alignof-operator.md)  
  
-   [align](../cpp/align-cpp.md)  
  
-   [\_\_unaligned](../cpp/unaligned.md)  
  
-   [Примеры выравнивания структуры](../build/examples-of-structure-alignment.md) \(для x64\)  
  
    > [!WARNING]
    >  Обратите внимание, что в Visual Studio 2015 и более поздних версиях можно использовать стандартные операторы alignas и alignof, которые в отличие от `__alignof` и `declspec( align )` могут переноситься между компиляторами.  Стандарт C\+\+ не предусматривает упаковки, поэтому необходимо использовать `pack` \(или соответствующие расширения для других компиляторов\), чтобы указать выравнивания меньшие, чем размер слова целевой архитектуры.  
  
## Пример  
 В следующем примере показано, как использовать директиву \#pragma `pack` для изменения выравнивания структуры.  
  
```  
// pragma_directives_pack.cpp  
#include <stddef.h>  
#include <stdio.h>  
  
struct S {  
   int i;   // size 4  
   short j;   // size 2  
   double k;   // size 8  
};  
  
#pragma pack(2)  
struct T {  
   int i;  
   short j;  
   double k;  
};  
  
int main() {  
   printf("%zu ", offsetof(S, i));  
   printf("%zu ", offsetof(S, j));  
   printf("%zu\n", offsetof(S, k));  
  
   printf("%zu ", offsetof(T, i));  
   printf("%zu ", offsetof(T, j));  
   printf("%zu\n", offsetof(T, k));  
}  
```  
  
```  
0 4 8  
0 4 6  
```  
  
## Пример  
 В следующем образце кода показано использование синтаксиса **push**, **pop** и **show**.  
  
```  
// pragma_directives_pack_2.cpp  
// compile with: /W1 /c  
#pragma pack()   // n defaults to 8; equivalent to /Zp8  
#pragma pack(show)   // C4810  
#pragma pack(4)   // n = 4  
#pragma pack(show)   // C4810  
#pragma pack(push, r1, 16)   // n = 16, pushed to stack  
#pragma pack(show)   // C4810  
#pragma pack(pop, r1, 2)   // n = 2 , stack popped  
#pragma pack(show)   // C4810  
```  
  
## См. также  
 [Директивы Pragma и ключевое слово \_\_Pragma](../preprocessor/pragma-directives-and-the-pragma-keyword.md)