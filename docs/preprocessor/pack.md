---
title: пакет | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-tools
ms.topic: reference
f1_keywords:
- pack_CPP
- vc-pragma.pack
dev_langs:
- C++
helpviewer_keywords:
- pragmas, pack
- pack pragma
ms.assetid: e4209cbb-5437-4b53-b3fe-ac264501d404
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 6c29c31cae2b7de59d4db5ed6546ad4eda6baecf
ms.sourcegitcommit: d55ac596ba8f908f5d91d228dc070dad31cb8360
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/07/2018
---
# <a name="pack"></a>pack
Задает выравнивание упаковки для членов структуры, объединения и класса.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
#pragma pack( [ show ] | [ push | pop ] [, identifier ] , n  )  
```  
  
## <a name="remarks"></a>Примечания  
 Упаковать класс значит разместить его члены непосредственно друг за другом в памяти, что может привести к тому, что некоторые или все члены могут быть выровнены по границе меньшей, чем выравнивание целевой архитектуры, заданное по умолчанию. Директива `pack` обеспечивает контроль на уровне объявления данных. В этом состоит отличие от параметра компилятора [/Zp](../build/reference/zp-struct-member-alignment.md), который предоставляет контроль только на уровне модуля. Директива `pack` действует на первое объявление `struct`, `union` или `class` после этой директивы #pragma. Директива `pack` не действует на определения. Вызов `pack` с нет наборов аргументов `n` до значения, заданного в параметре компилятора **/Zp**. Если этот параметр компилятора не указан, по умолчанию используется значение 8.  
  
 При изменении выравнивания структуры она может занимать меньше места в памяти, но возможно снижение производительности или даже возникновение аппаратного исключения для невыровненного доступа.  Поведение этого исключения можно изменить с помощью [SetErrorMode](http://msdn.microsoft.com/library/windows/desktop/ms680621).  
  
 **Показать** (необязательно)  
 Отображает текущее байтовое значение выравнивания упаковки. Значение отображается в предупреждении.  
  
 **Принудительная** (необязательно)  
 Помещает текущее значение выравнивания упаковки во внутренний стек компилятора и задает для текущего выравнивания упаковки значение `n`. Если значение `n` не указано, текущее значение выравнивания упаковки не помещается в стек.  
  
 **POP** (необязательно)  
 Удаляет запись из вершины внутреннего стека компилятора. Если `n` не указан с **pop**, то значение упаковки, связанное с результирующей записью в вершине стека — новый значение выравнивания упаковки. Если значение `n` указано (например, `#pragma pack(pop, 16)`), `n` становится новым значением выравнивания упаковки. Если извлечение из стека производится вместе с идентификатором `identifier` (например, `#pragma pack(pop, r1)`), из стека извлекаются все записи, пока не будет найдена запись `identifier`. Эта запись извлекается из стека, и новым значением выравнивания упаковки становится значение упаковки, связанное с результирующей записью в вершине стека. Если извлечение с `identifier` , не найден в любой записи в стеке, а затем **pop** игнорируется.  
  
 `identifier` (необязательно)  
 При использовании с **принудительной**, присваивает имя записи во внутреннем стеке компилятора. При использовании с **pop**, извлекает записи из внутреннего стека до `identifier` удаляется; Если `identifier` не найден во внутреннем стеке, ничего не извлекается.  
  
 `n` (необязательно)  
 Указывает значение (в байтах), используемое для упаковки. Если параметр компилятора [/Zp](../build/reference/zp-struct-member-alignment.md) не задано для модуля, значение по умолчанию для `n` равно 8. Допустимые значения: 1, 2, 4, 8 и 16. Выравнивание члена будет производиться по границе, кратной значению `n` или кратной размеру члена, в зависимости от того, какое из значений меньше.  
  
 `#pragma pack(pop, identifier, n)` не определено.  
  
 Дополнительные сведения об изменении выравнивания см. в следующих разделах:  
  
-   [__alignof](../cpp/alignof-operator.md)  
  
-   [align](../cpp/align-cpp.md)  
  
-   [__unaligned](../cpp/unaligned.md)  
  
-   [Примеры выравнивания структуры](../build/examples-of-structure-alignment.md) (x64 64)  
  
    > [!WARNING]
    >  Обратите внимание, что в Visual Studio 2015 и более поздних версиях можно использовать стандартные операторы alignas и alignof, которые в отличие от `__alignof` и `declspec( align )` могут переноситься между компиляторами. Стандарт C++ не предусматривает упаковки, поэтому необходимо использовать `pack` (или соответствующие расширения для других компиляторов), чтобы указать выравнивания меньшие, чем размер слова целевой архитектуры.  
  
## <a name="example"></a>Пример  
 В следующем примере показано, как использовать директиву #pragma `pack` для изменения выравнивания структуры.  
  
```  
// pragma_directives_pack.cpp  
#include <stddef.h>  
#include <stdio.h>  
  
struct S {  
   int i;   // size 4  
   short j;   // size 2  
   double k;   // size 8  
};  
  
#pragma pack(2)  
struct T {  
   int i;  
   short j;  
   double k;  
};  
  
int main() {  
   printf("%zu ", offsetof(S, i));  
   printf("%zu ", offsetof(S, j));  
   printf("%zu\n", offsetof(S, k));  
  
   printf("%zu ", offsetof(T, i));  
   printf("%zu ", offsetof(T, j));  
   printf("%zu\n", offsetof(T, k));  
}  
```  
  
```  
0 4 8  
0 4 6  
```  
  
## <a name="example"></a>Пример  
 Следующий пример показывает, как использовать **принудительной**, **pop**, и **Показать** синтаксиса.  
  
```  
// pragma_directives_pack_2.cpp  
// compile with: /W1 /c  
#pragma pack()   // n defaults to 8; equivalent to /Zp8  
#pragma pack(show)   // C4810  
#pragma pack(4)   // n = 4  
#pragma pack(show)   // C4810  
#pragma pack(push, r1, 16)   // n = 16, pushed to stack  
#pragma pack(show)   // C4810  
#pragma pack(pop, r1, 2)   // n = 2 , stack popped  
#pragma pack(show)   // C4810  
```  
  
## <a name="see-also"></a>См. также  
 [Директивы Pragma и ключевое слово __Pragma](../preprocessor/pragma-directives-and-the-pragma-keyword.md)