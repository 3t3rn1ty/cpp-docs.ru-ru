---
title: '#Директива using (C + +/ CLR) | Документы Microsoft'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-tools
ms.topic: reference
f1_keywords:
- friend_as_cpp
- '#using'
- friend_as
- '#using_cpp'
dev_langs:
- C++
helpviewer_keywords:
- using directive (#using)
- '#using directive'
- LIBPATH environment variable
- preprocessor, directives
ms.assetid: 870b15e5-f361-40a8-ba1c-c57d75c8809a
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 053c425a6bb8dcab0dc5cb94db1537f0fff3d9f8
ms.sourcegitcommit: d55ac596ba8f908f5d91d228dc070dad31cb8360
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/07/2018
---
# <a name="using-directive-cclr"></a># Директива using (C + +/ CLR)
Импортирует метаданные в программе, которая скомпилирована с [/CLR](../build/reference/clr-common-language-runtime-compilation.md).  
  
## <a name="syntax"></a>Синтаксис  
  
```  
#using file [as_friend]  
```  
  
#### <a name="parameters"></a>Параметры  
 `file`  
 Файл MSIL .dll, .exe, .netmodule или .obj. Например, примененная к объекту директива  
  
 `#using <MyComponent.dll>`  
  
 as_friend  
 Указывает, что все типы, заданные в параметре `file`, доступны.  Дополнительные сведения см. в разделе [дружественные сборки (C++)](../dotnet/friend-assemblies-cpp.md).  
  
## <a name="remarks"></a>Примечания  
 Значением параметра `file` может быть файл MSIL, который импортируется ради хранящихся в нем управляемых данных и управляемых конструкций. Если DLL-файла, содержащего манифест сборки, то всех библиотек, на которые ссылается манифест, импортируются и построение сборки будут отображаться *файл* в метаданных как ссылку на сборку.  
  
 Если `file` не содержит сборку (если `file` — это модуль) и если вы не собираетесь использовать информацию о типе из модуля в текущем приложении (сборка), вы можете просто указать, что этот модуль является частью сборки; используйте [/ASSEMBLYMODULE](../build/reference/assemblymodule-add-a-msil-module-to-the-assembly.md). После этого типы из этого модуля будут доступны любому приложению, ссылки на которые содержатся в этой сборке.  
  
 Альтернатива использованию `#using` — [/FU](../build/reference/fu-name-forced-hash-using-file.md) параметр компилятора.  
  
 сборки .exe, передаваемые директиве `#using` должны компилироваться с помощью одного из компиляторов .NET Visual Studio (Visual Basic или Visual C#, например).  При попытке импортировать метаданные из сборки .exe, скомпилированной с **/CLR** вызовет исключение загрузки файла.  
  
> [!NOTE]
>  Компонент, на который ссылается директива `#using`, может запускаться с другой версией файла, импортируемого во время компиляции. В результате клиентское приложение может выдавать непрогнозируемый результат.  
  
 Для того чтобы компилятор мог распознавать тип в сборке (не в модуле), необходимо принудительно включить для него разрешение типа. К примеру, для этого можно определить экземпляр этого типа. Добиться того, чтобы компилятор разрешал имена типов в сборке, можно и другими способами. Например, если используется наследование от типа в сборке, то имя типа будет известно компилятору.  
  
 При импорте метаданных, созданных из исходного кода, который используется [__declspec(thread)](../cpp/thread.md), семантика потока не сохраняется в метаданных. Например, переменная, объявленная с **__declspec(thread)**, компилируется в программе, которая собирается для CLR .NET Framework, а затем импортируется через `#using`, больше не будет **__declspec () поток)** семантики для переменной.  
  
 Все импортируемые типы (как управляемые, так и собственные) в файле, на который ссылается директива `#using`, доступны, однако компилятор обрабатывает собственные типы как объявления, а не определения.  
  
 При компиляции с параметром автоматически ссылается mscorlib.dll **/CLR**.  
  
 Переменная среды LIBPATH указывает каталоги, в которых компилятор будет выполнять поиск при попытке разрешить имена файлов, передаваемые директиве `#using`.  
  
 Компилятор будет искать ссылки по следующим путям:  
  
-   Путь, заданный в директиве `#using`.  
  
-   Текущий каталог.  
  
-   Системный каталог .NET Framework.  
  
-   Каталоги, добавленные с [/AI](../build/reference/ai-specify-metadata-directories.md) параметр компилятора.  
  
-   Каталоги, указанные в переменной среды LIBPATH.  
  
## <a name="example"></a>Пример  
 Если вы создаете сборку (C) и используете ссылку на сборку (B), которая сама содержит ссылки на другую сборку (A), то вам не придется создавать явную ссылку на сборку A, кроме случаев, когда вы явным образом используете один из типов сборки A в сборке C.  
  
```  
// using_assembly_A.cpp  
// compile with: /clr /LD  
public ref class A {};  
```  
  
## <a name="example"></a>Пример  
  
```  
// using_assembly_B.cpp  
// compile with: /clr /LD  
#using "using_assembly_A.dll"  
public ref class B {  
public:  
   void Test(A a) {}  
   void Test() {}  
};  
  
```  
  
## <a name="example"></a>Пример  
 В следующем примере не создается ошибка компилятора, связанная с отсутствием ссылки "using_assembly_A.dll", поскольку в программе не используются типы, заданные в файле using_assembly_A.cpp.  
  
```  
// using_assembly_C.cpp  
// compile with: /clr  
#using "using_assembly_B.dll"  
int main() {  
   B b;  
   b.Test();  
}  
```  
  
## <a name="see-also"></a>См. также  
 [Директивы препроцессора](../preprocessor/preprocessor-directives.md)