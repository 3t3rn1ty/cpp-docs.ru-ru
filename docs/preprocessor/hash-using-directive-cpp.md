---
title: '#Директива using (C + +/ CLI) | Документация Майкрософт'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-tools
ms.topic: reference
f1_keywords:
- friend_as_cpp
- '#using'
- friend_as
- '#using_cpp'
dev_langs:
- C++
helpviewer_keywords:
- using directive (#using)
- '#using directive'
- LIBPATH environment variable
- preprocessor, directives
ms.assetid: 870b15e5-f361-40a8-ba1c-c57d75c8809a
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: c2255f5de9cc26505bb07110da6368a039009c6c
ms.sourcegitcommit: b8b1cba85ff423142d73c888be26baa8c33f3cdc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/17/2018
ms.locfileid: "39093037"
---
# <a name="using-directive-ccli"></a># Директива using (C + +/ CLI)
Импортирует метаданные в программы, скомпилированной с [/CLR](../build/reference/clr-common-language-runtime-compilation.md).  
  
## <a name="syntax"></a>Синтаксис  
  
```  
#using file [as_friend]  
```  
  
#### <a name="parameters"></a>Параметры  
 `file`  
 Файл MSIL .dll, .exe, .netmodule или .obj. Например, примененная к объекту директива  
  
 `#using <MyComponent.dll>`  
  
 as_friend  
 Указывает, что все типы, заданные в параметре `file`, доступны.  Дополнительные сведения см. в разделе [дружественные сборки (C++)](../dotnet/friend-assemblies-cpp.md).  
  
## <a name="remarks"></a>Примечания  
 Значением параметра `file` может быть файл MSIL, который импортируется ради хранящихся в нем управляемых данных и управляемых конструкций. Если DLL-файл содержит манифест сборки, то все библиотеки DLL, на которые ссылается манифест, импортируются и будут перечислены сборки, вы создаете *файл* в метаданных как ссылку на сборку.  
  
 Если `file` не содержит сборку (если `file` — это модуль) и если не планируется использовать сведения о типе из модуля в текущем приложении (сборке), вы можете просто указать, что этот модуль является частью сборки; используйте [Добавившей](../build/reference/assemblymodule-add-a-msil-module-to-the-assembly.md). После этого типы из этого модуля будут доступны любому приложению, ссылки на которые содержатся в этой сборке.  
  
 Альтернатива использованию `#using` — [/FU](../build/reference/fu-name-forced-hash-using-file.md) параметр компилятора.  
  
 передаваемый сборок .exe `#using` должны быть скомпилированы с помощью одного из компиляторов .NET Visual Studio (Visual Basic или Visual C#, например).  Попытки импорта метаданных из сборки .exe, скомпилированной с **/CLR** приведет к исключение загрузки файла.  
  
> [!NOTE]
>  Компонент, на который ссылается директива `#using`, может запускаться с другой версией файла, импортируемого во время компиляции. В результате клиентское приложение может выдавать непрогнозируемый результат.  
  
 Для того чтобы компилятор мог распознавать тип в сборке (не в модуле), необходимо принудительно включить для него разрешение типа. К примеру, для этого можно определить экземпляр этого типа. Добиться того, чтобы компилятор разрешал имена типов в сборке, можно и другими способами. Например, если используется наследование от типа в сборке, то имя типа будет известно компилятору.  
  
 При импорте метаданных, созданных из исходного кода, который использован [__declspec(thread)](../cpp/thread.md), семантика потока не сохраняются в метаданных. Например, переменная, объявленная с **__declspec(thread)**, компилируется в программе, которая собирается для CLR .NET Framework, а затем импортируется через `#using`, больше не будет иметь **__declspec () поток)** семантики для переменной.  
  
 Все импортируемые типы (как управляемые, так и собственные) в файле, на который ссылается директива `#using`, доступны, однако компилятор обрабатывает собственные типы как объявления, а не определения.  
  
 При компиляции с параметром mscorlib.dll автоматически ссылается **/CLR**.  
  
 Переменная среды LIBPATH указывает каталоги, в которых компилятор будет выполнять поиск при попытке разрешить имена файлов, передаваемые директиве `#using`.  
  
 Компилятор будет искать ссылки по следующим путям:  
  
-   Путь, заданный в директиве `#using`.  
  
-   Текущий каталог.  
  
-   Системный каталог .NET Framework.  
  
-   Каталоги, добавленные с помощью [/AI](../build/reference/ai-specify-metadata-directories.md) параметр компилятора.  
  
-   Каталоги, указанные в переменной среды LIBPATH.  
  
## <a name="example"></a>Пример  
 Если вы создаете сборку (C) и используете ссылку на сборку (B), которая сама содержит ссылки на другую сборку (A), то вам не придется создавать явную ссылку на сборку A, кроме случаев, когда вы явным образом используете один из типов сборки A в сборке C.  
  
```  
// using_assembly_A.cpp  
// compile with: /clr /LD  
public ref class A {};  
```  
  
## <a name="example"></a>Пример  
  
```  
// using_assembly_B.cpp  
// compile with: /clr /LD  
#using "using_assembly_A.dll"  
public ref class B {  
public:  
   void Test(A a) {}  
   void Test() {}  
};  
  
```  
  
## <a name="example"></a>Пример  
 В следующем примере не создается ошибка компилятора, связанная с отсутствием ссылки "using_assembly_A.dll", поскольку в программе не используются типы, заданные в файле using_assembly_A.cpp.  
  
```  
// using_assembly_C.cpp  
// compile with: /clr  
#using "using_assembly_B.dll"  
int main() {  
   B b;  
   b.Test();  
}  
```  
  
## <a name="see-also"></a>См. также  
 [Директивы препроцессора](../preprocessor/preprocessor-directives.md)
