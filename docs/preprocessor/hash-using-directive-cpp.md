---
title: "Директива #using (C++) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "friend_as_cpp"
  - "#using"
  - "friend_as"
  - "#using_cpp"
dev_langs: 
  - "C++"
  - "C"
helpviewer_keywords: 
  - "#using - директива"
  - "LIBPATH - переменная среды"
  - "препроцессор, директивы"
  - "using - директива (#using)"
ms.assetid: 870b15e5-f361-40a8-ba1c-c57d75c8809a
caps.latest.revision: 17
caps.handback.revision: 17
author: "corob-msft"
ms.author: "corob"
manager: "ghogen"
---
# Директива #using (C++)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Импортирует метаданные в программу, скомпилированную с параметром [\/clr](../build/reference/clr-common-language-runtime-compilation.md).  
  
## Синтаксис  
  
```  
#using file [as_friend]  
```  
  
#### Параметры  
 `file`  
 Файл MSIL .dll, .exe, .netmodule или .obj.  Например:  
  
 `#using <MyComponent.dll>`  
  
 as\_friend  
 Указывает, что все типы, заданные в параметре `file`, доступны.  Дополнительные сведения см. в разделе [Дружественные сборки \(C\+\+\)](../dotnet/friend-assemblies-cpp.md).  
  
## Заметки  
 Значением параметра `file` может быть файл MSIL, который импортируется ради хранящихся в нем управляемых данных и управляемых конструкций.  Если .dll\-файл содержит манифест сборки, то все .dll\-файлы, на которые ссылается этот манифест, импортируются, а в метаданных создаваемой сборки будет указан *файл* в качестве ссылки сборки.  
  
 Если в файле, заданном параметром `file`, не содержится сборки \(т. е. `file` задает модуль\) и вы не планируете использовать информацию о типе из этого модуля в текущем приложении \(сборке\), то можно просто указать, что этот модуль является частью сборки. Это делается при помощи параметра [\/ASSEMBLYMODULE](../build/reference/assemblymodule-add-a-msil-module-to-the-assembly.md).  После этого типы из этого модуля будут доступны любому приложению, ссылки на которые содержатся в этой сборке.  
  
 Альтернатива использованию директивы `#using` является параметр компилятора [\/FU](../build/reference/fu-name-forced-hash-using-file.md).  
  
 Сборки файлов .exe, передаваемые директиве `#using`, должны компилироваться либо с параметром **\/clr:safe** или **\/clr:pure**, либо при помощи любого из других компиляторов Visual Studio \(например, Visual Basic или Visual C\#\).  При попытке импортировать метаданные из сборки файла .exe, скомпилированной с параметром **\/clr**, возникнет исключение загрузки файла.  
  
> [!NOTE]
>  Компонент, на который ссылается директива `#using`, может запускаться с другой версией файла, импортируемого во время компиляции. В результате клиентское приложение может выдавать непрогнозируемый результат.  
  
 Для того чтобы компилятор мог распознавать тип в сборке \(не в модуле\), необходимо принудительно включить для него разрешение типа. К примеру, для этого можно определить экземпляр этого типа.  Добиться того, чтобы компилятор разрешал имена типов в сборке, можно и другими способами. Например, если используется наследование от типа в сборке, то имя типа будет известно компилятору.  
  
 Во время импорта метаданных, созданных из исходного кода, в котором используется атрибут [\_\_declspec\(thread\)](../cpp/thread.md), семантика потока не сохраняется в метаданных.  Например, если переменная, объявленная с атрибутом **\_\_declspec\(thread\)**, компилируется в программе, которая собирается для CLR .NET Framework, а затем импортируется через директиву `#using`, то семантика **\_\_declspec\(thread\)** в такой переменной не сохранится.  
  
 Все импортируемые типы \(как управляемые, так и собственные\) в файле, на который ссылается директива `#using`, доступны, однако компилятор обрабатывает собственные типы как объявления, а не определения.  
  
 При компиляции с параметром **\/clr** ссылка на файл mscorlib.dll создается автоматически.  
  
 Переменная среды LIBPATH указывает каталоги, в которых компилятор будет выполнять поиск при попытке разрешить имена файлов, передаваемые директиве `#using`.  
  
 Компилятор будет искать ссылки по следующим путям:  
  
-   Путь, заданный в директиве `#using`.  
  
-   Текущий каталог.  
  
-   Системный каталог .NET Framework.  
  
-   Каталоги, добавленные при помощи параметра компилятора [\/AI](../build/reference/ai-specify-metadata-directories.md).  
  
-   Каталоги, указанные в переменной среды LIBPATH.  
  
## Пример  
 Если вы создаете сборку \(C\) и используете ссылку на сборку \(B\), которая сама содержит ссылки на другую сборку \(A\), то вам не придется создавать явную ссылку на сборку A, кроме случаев, когда вы явным образом используете один из типов сборки A в сборке C.  
  
```  
// using_assembly_A.cpp  
// compile with: /clr /LD  
public ref class A {};  
```  
  
## Пример  
  
```  
// using_assembly_B.cpp  
// compile with: /clr /LD  
#using "using_assembly_A.dll"  
public ref class B {  
public:  
   void Test(A a) {}  
   void Test() {}  
};  
  
```  
  
## Пример  
 В следующем примере не создается ошибка компилятора, связанная с отсутствием ссылки "using\_assembly\_A.dll", поскольку в программе не используются типы, заданные в файле using\_assembly\_A.cpp.  
  
```  
// using_assembly_C.cpp  
// compile with: /clr  
#using "using_assembly_B.dll"  
int main() {  
   B b;  
   b.Test();  
}  
```  
  
## См. также  
 [Директивы препроцессора](../preprocessor/preprocessor-directives.md)