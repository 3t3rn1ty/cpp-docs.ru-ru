---
title: "Многопоточность. Использование классов синхронизации | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "доступ к контролируемому ресурсу [C++]"
  - "многопоточность [C++], классы синхронизации"
  - "ресурсы [C++], многопоточность"
  - "синхронизация [C++], многопоточность"
  - "классы синхронного доступа [C++]"
  - "классы синхронизации [C++]"
  - "работа с потоками [C++], синхронизация"
  - "работа с потоками [MFC], классы синхронизации"
ms.assetid: 4914f54e-68ac-438f-93c9-c013455a657e
caps.latest.revision: 9
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 9
---
# Многопоточность. Использование классов синхронизации
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Классы в многопоточных приложениях, предоставляемые в MFC, бывают двух видов: объекты синхронизации \([CSyncObject](../mfc/reference/csyncobject-class.md), [CSemaphore](../mfc/reference/csemaphore-class.md), [CMutex](../mfc/reference/cmutex-class.md), [CCriticalSection](../Topic/CCriticalSection%20Class.md) и [CEvent](../mfc/reference/cevent-class.md)\) и объекты доступа синхронизации \([CMultiLock](../mfc/reference/cmultilock-class.md) и [CSingleLock](../mfc/reference/csinglelock-class.md)\).  
  
 Классы синхронизации используются в случае, если необходимо управлять доступом к ресурсу для обеспечения его целостности.  Классы доступа к синхронизации используются для получения доступа к контролируемым ресурсам.  В данном разделе описываются случаи использования каждого из этих классов.  
  
 Чтобы определить, какой класс синхронизации следует использовать, необходимо ответить на следующие вопросы:  
  
1.  Ожидает ли приложение чего\-либо перед обращением к ресурсу \(например, получения данных с COM\-порта перед записью их в файл\)?  
  
     Если ответ "да", то следует использовать класс `CEvent`.  
  
2.  Могут ли несколько потоков обращаться к этому ресурсу одновременно \(например, если приложение поддерживает возможность открытия одного и того же документа в нескольких окнах одновременно\)?  
  
     Если ответ "да", то следует использовать класс `CSemaphore`.  
  
3.  Могут ли несколько приложений использовать этот ресурс \(например, если ресурс содержится в библиотеке DLL\)?  
  
     Если ответ "да", то следует использовать класс `CMutex`.  
  
     Если ответ "нет", то следует использовать класс `CCriticalSection`.  
  
 Класс **CSyncObject** не используется непосредственно.  Он является базовым классом для четырех других классов синхронизации.  
  
## Пример 1. Использование трех классов синхронизации  
 В качестве примера следует взять приложение, поддерживающее связанный список учетных записей.  Это приложение позволяет проверять в отдельных окнах до трех учетных записей, но в определенный момент времени может обновляться только одна учетная запись.  При обновлении учетной записи обновленные данные отправляются по сети в архив данных.  
  
 В этом примере приложения используются все три типа классов синхронизации.  Класс `CSemaphore` позволяет ограничить количество объектов представления, к которым можно одновременно получить доступ, до трех.  При попытке просмотра четвертой учетной записи приложение находится в ожидании закрытия одного из первых трех окон или завершается с ошибкой.  При обновлении учетной записи приложение использует класс `CCriticalSection`, чтобы убедиться, что одновременно выполняется обновление только одной учетной записи.  После успешного завершения обновления подается сигнал классу `CEvent`, который освобождает поток, ожидающий завершения этого события.  Этот поток направляет новые данные в архив данных.  
  
## Пример 2. Использование классов доступа синхронизации  
 Выбор используемого класса доступа синхронизации является еще более простым.  Если в приложении выполняется доступ только к отдельному управляемому ресурсу, то следует использовать класс `CSingleLock`.  Если необходимо осуществить доступ к одному из нескольких управляемых ресурсов, то следует использовать класс `CMultiLock`.  В примере 1 для этого использовался бы класс `CSingleLock`, поскольку в определенный момент времени требуется использовать только один ресурс.  
  
 Сведения об использовании классов синхронизации см. в разделе [Многопоточность. Способы использования классов синхронизации](../parallel/multithreading-how-to-use-the-synchronization-classes.md).  Сведения о синхронизации см. в разделе [Синхронизация](http://msdn.microsoft.com/library/windows/desktop/ms686353) \([!INCLUDE[winsdkshort](../atl/reference/includes/winsdkshort_md.md)]\).  Сведения о поддержке многопоточности в MFC см. в разделе [Использование многопоточности с C\+\+ и MFC](../parallel/multithreading-with-cpp-and-mfc.md).  
  
## См. также  
 [Реализация многопоточности на языке C\+\+ с помощью классов MFC](../parallel/multithreading-with-cpp-and-mfc.md)