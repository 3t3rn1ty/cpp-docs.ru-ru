---
title: ': Многопоточность использование классов синхронизации | Документы Microsoft'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-parallel
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- MFC [C++], multithreading
- threading [MFC], synchronization classes
- resources [C++], multithreading
- thread-safe classes [C++]
- synchronization classes [C++]
- synchronization [C++], multithreading
- threading [MFC], thread-safe class design
- threading [C++], synchronization
- multithreading [C++], synchronization classes
- threading [C++], thread-safe class design
ms.assetid: f266d4c6-0454-4bda-9758-26157ef74cc5
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 49b0737a794216c4899b280bc049a1cdc0fe0948
ms.sourcegitcommit: 7019081488f68abdd5b2935a3b36e2a5e8c571f8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/07/2018
---
# <a name="multithreading-how-to-use-the-synchronization-classes"></a>Многопоточность. Использование классов синхронизации
Синхронизация доступа к ресурсам между потоками является распространенной проблемой при записи многопоточных приложений. Наличие двух или более потоков, одновременно доступ, и тех же данных может привести к нежелательных и неожиданных результатов. Например один поток может обновлять содержимое структуры, пока другой поток считывает содержимое той же структуры. Неизвестно, какие данные будут получены считывающим потоком: старые данные, вновь записанные или возможно их сочетании. MFC предоставляет номер синхронизации и классы синхронного доступа для помощи в решении этой проблемы. В этом разделе объясняется доступные классы и способ их использования для создания потокобезопасных классов в типичном многопоточном приложении.  
  
 Типичное многопоточное приложение содержит класс, представляющий ресурс для совместного использования потоками. Спроектированные надлежащим образом полностью потокобезопасного класса не требуется вызывать любые функции синхронизации. Все содержимое обрабатывается внутри класса, позволяя сосредоточиться на том, как лучше использовать класс, а не о том, как он может быть поврежден. Метод для создания полностью потокобезопасного класса является объединение класса синхронизации в классе ресурса. Объединение классов синхронизации в общедоступный класс представляет собой простой процесс.  
  
 Например рассмотрим приложение, поддерживающее связанный список учетных записей. Это приложение позволяет проверять в отдельных окнах до трех учетных записей, но можно обновить в любой конкретный момент времени только один. При обновлении учетной записи обновленные данные отправляются по сети в архив данных.  
  
 В этом примере приложения используются все три типа классов синхронизации. Так как до трех учетных записей за один раз, используется [CSemaphore](../mfc/reference/csemaphore-class.md) для ограничения доступа к трем объектам просмотра. При попытке просмотра четвертой учетной записи приложение находится в ожидании закрытия одного из первых трех окон или завершается с ошибкой. При обновлении учетной записи приложение использует [CCriticalSection](../mfc/reference/ccriticalsection-class.md) чтобы убедиться, что только одна учетная запись обновляется одновременно. После успешного обновления сообщает [CEvent](../mfc/reference/cevent-class.md), который освобождает поток, ожидающий отслеживаемого события. Этот поток отправляет новые данные в архив данных.  
  
##  <a name="_mfc_designing_a_thread.2d.safe_class"></a> Разработка потокобезопасного класса  
 Чтобы сделать класс полностью потокобезопасным, сначала добавьте соответствующий класс синхронизации к общедоступным классам как элемента данных. В предыдущем примере управления учетными записями **CSemaphore** класс представления, следует добавить элемент данных `CCriticalSection` член данных следует добавить в класс связанного списка и `CEvent` данные-член будет добавлено к данным класс хранения.  
  
 Затем добавьте вызовы синхронизации ко всем функциям элемента, которые изменяют данные в классе или доступ к контролируемому ресурсу. В каждой функции, следует создать [класс CSingleLock](../mfc/reference/csinglelock-class.md) или [CMultiLock](../mfc/reference/cmultilock-class.md) объекта и вызвать этот объект `Lock` функции. Когда объект блокировки выходит за пределы области и разрушается, деструктор объекта вызывает `Unlock` освобождая ресурс. Конечно, вы можете вызвать `Unlock` непосредственно при необходимости.  
  
 Проектирование поточно ориентированного класса таким способом позволяет использовать в многопоточном приложении так же легко, как не потокобезопасного класса, но с более высоким уровнем безопасности. Инкапсуляция в классе ресурса объекта синхронизации и объекта синхронизации доступа предоставляет все преимущества полностью поточно ориентированного программирования без недостатка в виде поддержания кода синхронизации.  
  
 В следующем примере кода демонстрируется этот метод с помощью элемента данных `m_CritSection` (типа `CCriticalSection`), объявленный в классе общего ресурса и `CSingleLock` объекта. Общий ресурс синхронизации (производный от `CWinThread`) выполняется путем создания `CSingleLock` объекта с использованием адреса `m_CritSection` объекта. Предпринята попытка блокировки ресурса и получения общего объекта выполняется работа. По окончании работы ресурс разблокируется с помощью вызова `Unlock`.  
  
```  
CSingleLock singleLock(&m_CritSection);  
singleLock.Lock();  
// resource locked  
//.usage of shared resource...  
  
singleLock.Unlock();  
```  
  
> [!NOTE]
>  `CCriticalSection`, в отличие от других классов синхронизации MFC, не имеет параметра запроса на блокировку по времени. Период ожидания для освобождения потока является бесконечным.  
  
 Недостатком этого подхода является то, что класс будет немного медленнее, чем тот же класс без добавления объектов синхронизации. Кроме того Если есть подозрение, что более чем один поток может удалить объект, объединенный подход может не всегда работать. В этом случае лучше поддерживать отдельные объекты синхронизации.  
  
 Сведения о какой класс синхронизации для использования в различных ситуациях, в разделе [Многопоточность: использование классов синхронизации](../parallel/multithreading-when-to-use-the-synchronization-classes.md). Дополнительные сведения о синхронизации см. в разделе [синхронизации](http://msdn.microsoft.com/library/windows/desktop/ms686353) в [!INCLUDE[winsdkshort](../atl-mfc-shared/reference/includes/winsdkshort_md.md)]. Дополнительные сведения о поддержке многопоточности в MFC см. в разделе [многопоточность с помощью C++ и MFC](../parallel/multithreading-with-cpp-and-mfc.md).  
  
## <a name="see-also"></a>См. также  
 [Реализация многопоточности на языке C++ с помощью классов MFC](../parallel/multithreading-with-cpp-and-mfc.md)