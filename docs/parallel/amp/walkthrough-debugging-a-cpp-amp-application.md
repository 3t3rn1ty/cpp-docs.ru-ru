---
title: 'Пошаговое руководство: Отладка приложения C++ AMP | Документы Microsoft'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-amp
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- debugging, C++ Accelerated Massive Parallelism
- C++ AMP, debugging
- C++ Accelerated Massive Parallelism, debugging
- debugging, C++ AMP
ms.assetid: 40e92ecc-f6ba-411c-960c-b3047b854fb5
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 2f1308462133c11c8f945416a13fb5542c1d2da8
ms.sourcegitcommit: 7019081488f68abdd5b2935a3b36e2a5e8c571f8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/07/2018
---
# <a name="walkthrough-debugging-a-c-amp-application"></a>Пошаговое руководство. Отладка приложения C++ AMP
В этом разделе показано, как выполнить отладку приложения, использующего C++ Accelerated Massive Parallelism (C++ AMP), чтобы воспользоваться преимуществами графический процессор (GPU). Она использует параллельной редукции программу, которая суммирует большой массив целых чисел. В данном пошаговом руководстве рассмотрены следующие задачи:  
  
-   Запуск отладчика GPU.  
  
-   Проверка потоков GPU в окно "потоки GPU".  
  
-   Использование окна параллельных стеков одновременно контролирующая стеки вызовов нескольких потоков GPU.  
  
-   Использование окна параллельных контрольных значений для проверки значений из одного выражения в нескольких потоках одновременно.  
  
-   Пометка, закрепление, размораживание и группирование потоки GPU.  
  
-   Выполнение всех потоков плитки в определенное расположение в коде.  
  
## <a name="prerequisites"></a>Предварительные требования  
 Перед выполнением этого пошагового руководства:  
  
-   Чтение [Обзор C++ AMP](../../parallel/amp/cpp-amp-overview.md).  
  
-   Убедитесь в том, что строка чисел в текстовом редакторе. Дополнительные сведения см. в разделе [как: отображение номеров строк в редакторе](/visualstudio/ide/reference/how-to-display-line-numbers-in-the-editor).  
  
-   Убедитесь, что вы используете [!INCLUDE[win8](../../build/reference/includes/win8_md.md)] или [!INCLUDE[winserver8](../../build/reference/includes/winserver8_md.md)] для поддержки отладки в эмуляторе программного обеспечения.  
  
 [!INCLUDE[note_settings_general](../../mfc/includes/note_settings_general_md.md)]  
  
### <a name="to-create-the-sample-project"></a>Создание примера проекта  
  
1.  Запустите Visual Studio.  
  
2.  В строке меню выберите **Файл**, **Создать**, **Проект**.  
  
3.  В разделе **установленные** в области шаблонов выберите **Visual C++**.  
  
4.  Выберите **консольное приложение Win32**, тип `AMPMapReduce` в **имя** , а затем нажмите **ОК** кнопки.  
  
5.  Нажмите кнопку **Далее**.  
  
6.  Очистить **предкомпилированный заголовок** флажок и нажмите кнопку **Готово** кнопки.  
  
7.  В **обозревателе решений**, удалите файл stdafx.h, targetver.h, а stdafx.cpp из проекта.  
  
8.  Откройте AMPMapReduce.cpp и замените его содержимое следующим кодом.  
  
 ```cpp  
    // AMPMapReduce.cpp defines the entry point for the program.  
    // The program performs a parallel-sum reduction that computes the sum of an array of integers.   
  
    #include <stdio.h>  
    #include <tchar.h>  
    #include <amp.h>  
  
    const int BLOCK_DIM = 32;  
  
    using namespace concurrency;  
  
    void sum_kernel_tiled(tiled_index<BLOCK_DIM> t_idx, array<int, 1> &A, int stride_size) restrict(amp)  
    {  
        tile_static int localA[BLOCK_DIM];  
  
        index<1> globalIdx = t_idx.global * stride_size;  
        index<1> localIdx = t_idx.local;  
  
        localA[localIdx[0]] =  A[globalIdx];  
  
        t_idx.barrier.wait();  
  
        // Aggregate all elements in one tile into the first element.  
        for (int i = BLOCK_DIM / 2; i > 0; i /= 2)   
        {  
            if (localIdx[0] < i)   
            {  
  
                localA[localIdx[0]] += localA[localIdx[0] + i];  
            }  
  
            t_idx.barrier.wait();  
        }  
  
        if (localIdx[0] == 0)  
        {  
            A[globalIdx] = localA[0];  
        }  
    }  
  
    int size_after_padding(int n)  
    {  
        // The extent might have to be slightly bigger than num_stride to   
        // be evenly divisible by BLOCK_DIM. You can do this by padding with zeros.  
        // The calculation to do this is BLOCK_DIM * ceil(n / BLOCK_DIM)  
        return ((n - 1) / BLOCK_DIM + 1) * BLOCK_DIM;  
    }  
  
    int reduction_sum_gpu_kernel(array<int, 1> input)   
    {  
        int len = input.extent[0];  
  
        //Tree-based reduction control that uses the CPU.  
        for (int stride_size = 1; stride_size < len; stride_size *= BLOCK_DIM)   
        {  
            // Number of useful values in the array, given the current  
            // stride size.  
            int num_strides = len / stride_size;    
  
            extent<1> e(size_after_padding(num_strides));  
  
            // The sum kernel that uses the GPU.  
            parallel_for_each(extent<1>(e).tile<BLOCK_DIM>(), [&input, stride_size] (tiled_index<BLOCK_DIM> idx) restrict(amp)  
            {  
                sum_kernel_tiled(idx, input, stride_size);  
            });  
        }  
  
        array_view<int, 1> output = input.section(extent<1>(1));  
        return output[0];  
    }  
  
    int cpu_sum(const std::vector<int> &arr) {  
        int sum = 0;  
        for (size_t i = 0; i < arr.size(); i++) {  
            sum += arr[i];  
        }  
        return sum;  
    }  
  
    std::vector<int> rand_vector(unsigned int size) {  
        srand(2011);  
  
        std::vector<int> vec(size);  
        for (size_t i = 0; i < size; i++) {  
            vec[i] = rand();  
        }  
        return vec;  
    }  
  
    array<int, 1> vector_to_array(const std::vector<int> &vec) {  
        array<int, 1> arr(vec.size());  
        copy(vec.begin(), vec.end(), arr);  
        return arr;  
    }  
  
    int _tmain(int argc, _TCHAR* argv[])  
    {  
        std::vector<int> vec = rand_vector(10000);  
        array<int, 1> arr = vector_to_array(vec);  
  
        int expected = cpu_sum(vec);  
        int actual = reduction_sum_gpu_kernel(arr);  
  
        bool passed = (expected == actual);  
        if (!passed) {  
            printf("Actual (GPU): %d, Expected (CPU): %d", actual, expected);  
        }  
        printf("sum: %s\n", passed  "Passed!" : "Failed!");   
  
        getchar();  
  
        return 0;  
    }  
  
 ```  
  
9. В строке меню выберите **Файл**, **Сохранить все**.  
  
10. В **обозревателе решений**, откройте контекстное меню для **AMPMapReduce**, а затем выберите **свойства**.  
  
11. В **страницы свойств** диалогового **свойства конфигурации**, выберите **C/C++**, **предварительно скомпилированные заголовки**.  
  
12. Для **предкомпилированный заголовок** выберите **не использовать предкомпилированные заголовки**и нажмите кнопку **ОК** кнопки.  
  
13. В строке меню последовательно выберите **Сборка**и **Собрать решение**.  
  
## <a name="debugging-the-cpu-code"></a>Отладка кода ЦП  
 В этой процедуре будет использовать локальный отладчик Windows, чтобы убедиться в правильности кода ЦП в этом приложении. Сегмент кода ЦП в приложении, которое особенно интересны `for` цикл в `reduction_sum_gpu_kernel` функции. Он управляет, на основе дерева параллельной редукции, выполняемый в GPU.  
  
### <a name="to-debug-the-cpu-code"></a>Для отладки кода ЦП  
  
1.  В **обозревателе решений**, откройте контекстное меню для **AMPMapReduce**, а затем выберите **свойства**.  
  
2.  В **страницы свойств** диалогового **свойства конфигурации**, выберите **Отладка**. Убедитесь, что **локальный отладчик Windows** выбран в **отладчик для запуска** списка.  
  
3.  Вернуться в редактор кода.  
  
4.  Установите точки останова в строках кода показано на следующем рисунке (около строки 67 строки 70).  
  
     ![Точки останова ЦП](../../parallel/amp/media/campcpubreakpoints.png "campcpubreakpoints")  
Точки останова ЦП  
  
5.  В строке меню выберите **Отладка**, **Начать отладку**.  
  
6.  В **локальные** окна, определите значение для `stride_size` до достижения точки останова в строке 70.  
  
7.  В строке меню выберите **Отладка**, **Остановить отладку**.  
  
## <a name="debugging-the-gpu-code"></a>Отладка кода GPU  
 В этом разделе показано, как для отладки кода GPU, который является код, содержащийся в `sum_kernel_tiled` функции. Кода GPU параллельно вычисляет сумму целых чисел для каждой «блок».  
  
### <a name="to-debug-the-gpu-code"></a>Для отладки кода GPU  
  
1.  В **обозревателе решений**, откройте контекстное меню для **AMPMapReduce**, а затем выберите **свойства**.  
  
2.  В **страницы свойств** диалогового **свойства конфигурации**, выберите **Отладка**.  
  
3.  В **отладчик для запуска** выберите **локальный отладчик Windows**.  
  
4.  В **тип отладчика** выберите **только графический Процессор**.  
  
5.  Нажмите кнопку **ОК** .  
  
6.  Установите точку останова в строке 30, как показано на следующем рисунке.  
  
     ![Точки останова GPU](../../parallel/amp/media/campgpubreakpoints.png "campgpubreakpoints")  
Точки останова GPU  
  
7.  В строке меню выберите **Отладка**, **Начать отладку**. Точки останова в коде ЦП на линии 67 и 70 не выполняются во время отладки, поскольку эти строки кода, выполняются на ЦП GPU.  
  
### <a name="to-use-the-gpu-threads-window"></a>Использование окна потоков GPU  
  
1.  Чтобы открыть окно потоков GPU в строке меню выберите **отладки**, **Windows**, **потоки GPU**.  
  
     Можно проверять состояние потоки GPU в появившемся окне потоков GPU.  
  
2.  Закрепите окно потоков GPU в нижней части Visual Studio. Выберите **разверните переключение потоков** кнопку, чтобы открыть плитку и поток текстовые поля. Окно "потоки GPU" отображается общее число активных и заблокированных потоков GPU, как показано на следующем рисунке.  
  
     ![Окно "потоки GPU" с 4 активными потоками](../../parallel/amp/media/campc.png "campc")  
Окно "Потоки GPU"  
  
     Имеются 313 плитки, выделенных для этого вычисления. Каждая плитка содержит 32 потока. Поскольку локальной отладки GPU в программном эмуляторе происходит, существует четыре активные потоки GPU. Четыре потока одновременно выполнить инструкции и затем перемещаются следующую инструкцию.  
  
     В окне потоков GPU наличии четырех потоков GPU активных и 28 заблокированных потоков GPU в [tile_barrier::wait](reference/tile-barrier-class.md#wait) инструкции, определенном около строки 21 (`t_idx.barrier.wait();`). Все 32 потоки GPU принадлежат первый фрагмент `tile[0]`. Стрелка указывает на строку, которая включает в себя текущего потока. Чтобы переключиться на другой поток, используйте один из следующих методов:  

  
    -   В строке для потока, переключитесь в окно "потоки GPU", откройте контекстное меню и выберите **переключиться на поток**. Если строка представляет более одного потока, будут переключаться на первый поток согласно координаты потока.  
  
    -   Введите значения плитки и поток потока в соответствующие текстовые поля и нажмите кнопку **поток коммутатора** кнопки.  
  
     Окно стека вызовов отображается стек вызовов текущего потока в GPU.  
  
### <a name="to-use-the-parallel-stacks-window"></a>В окне параллельных стеков  
  
1.  Открытие окна "Параллельные стеки", в строке меню выберите **отладки**, **Windows**, **Параллельные стеки**.  
  
     Окно параллельных стеков одновременно проверки кадров стека, нескольких потоков GPU.  
  
2.  Закрепите окно "Параллельные стеки" в нижней части Visual Studio.  
  
3.  Убедитесь, что **потоков** выбран в списке в левом верхнем углу. На следующем рисунке в окне параллельных стеков показано представление в фокусе стека вызовов потоков GPU, которые отображались в окне потоков GPU.  
  
     ![Окно параллельных стеков с 4 активными потоками](../../parallel/amp/media/campd.png "campd")  
Окно "Параллельные стеки"  
  
     32 потоков изменился с `_kernel_stub` в инструкцию лямбда-выражения в `parallel_for_each` вызов функции и затем `sum_kernel_tiled` функции, где происходит параллельной редукции. 28 из 32 потока создали для [tile_barrier::wait](reference/tile-barrier-class.md#wait) инструкции и остаются заблокированными строки 22, тогда как другие потоки 4 остаются активными в `sum_kernel_tiled` функции в строке 30.  

  
     Можно просмотреть свойства поток GPU, доступные в окне потоков GPU в подсказке по данным форматированного окна параллельных стеков. Для этого наведите указатель мыши на кадр стека **sum_kernel_tiled**. На следующем рисунке подсказка.  
  
     ![DataTip для окна "Параллельные стеки"](../../parallel/amp/media/campe.png "campe")  
Поток GPU подсказки данных  
  
     Дополнительные сведения об окне "Параллельные стеки" см. в разделе [с помощью окна "Параллельные стеки"](/visualstudio/debugger/using-the-parallel-stacks-window).  
  
### <a name="to-use-the-parallel-watch-window"></a>Использование окна параллельных контрольных значений  
  
1.  Чтобы открыть окно "контроль параллельных данных" в строке меню выберите **отладки**, **Windows**, **контроль параллельных данных**, **контроль параллельных данных 1**.  
  
     Окно параллельных контрольных значений можно использовать для проверки значений выражения в нескольких потоках.  
  
2.  Закрепите окно «контроль параллельных данных 1» в нижней части Visual Studio. Имеется 32 строк в таблице окна параллельных контрольных значений. Каждая соответствует поток GPU, указанную в окне параллельных стеков и окно "потоки GPU". Теперь можно ввести выражения, значения которого требуется проверить во всех потоках 32 GPU.  
  
3.  Выберите **Добавить контрольное значение** заголовок столбца введите `localIdx`, а затем нажмите клавишу ВВОД.  
  
4.  Выберите **Добавить контрольное значение** заголовок столбца еще раз, введите `globalIdx`, а затем нажмите клавишу ВВОД.  
  
5.  Выберите **Добавить контрольное значение** заголовок столбца еще раз, введите `localA[localIdx[0]]`, а затем нажмите клавишу ВВОД.  
  
     Можно сортировать указанным выражением, выбрав заголовок соответствующего столбца.  
  
     Выберите **localA [localIdx [0]]** заголовок столбца для сортировки столбца. На следующем рисунке показан результаты сортировки **localA [localIdx [0]]**.  
  
     ![Окно параллельных контрольных значений с отсортированными результатами](../../parallel/amp/media/campf.png "campf")  
 Результаты сортировки  
  
     Содержимое окна параллельных контрольных значений можно экспортировать в Excel, нажмите кнопку «Excel» и выбрав **открыть в Excel**. Если у вас есть Excel, установленную на компьютере разработчика, открывается лист Excel, содержащий содержимое.  
  
6.  В правом верхнем углу окна параллельных контрольных значений имеется элемент управления фильтром, который можно использовать для фильтрации содержимого с помощью логических выражений. Ввод `localA[localIdx[0]] > 20000` в тексте элемента управления фильтра поле и нажмите клавишу ВВОД.  
  
     Это окно теперь содержит только потоки, на котором `localA[localIdx[0]]` значение больше 20000. Содержимое по-прежнему сортируется по `localA[localIdx[0]]` столбец, который является действие сортировки, вы осуществили ранее.  
  
## <a name="flagging-gpu-threads"></a>Пометка потоков GPU  
 Можно пометить определенные потоки GPU, отмечая их в окно "потоки GPU" окна параллельных контрольных значений и подсказка в окне параллельных стеков. Если строка в окно "потоки GPU" содержит более одного потока, Пометка этой строки помечает все потоки, которые содержатся в строке.  
  
### <a name="to-flag-gpu-threads"></a>Пометка потоков GPU  
  
1.  Выберите **[поток]** заголовок столбца в окне «контроль параллельных данных 1» для сортировки по индексу плитки и индекс потока.  
  
2.  В строке меню выберите **отладки**, **Продолжить**, которое вызывает четыре потока были активны для хода выполнения работ по Далее барьер (определенное в строке AMPMapReduce.cpp 32).  
  
3.  Выберите флаг символ слева от строки, содержащей четырех потоков, которые теперь активны.  
  
     Ниже показан четыре active отмеченные потоки в окне потоков GPU.  
  
     ![Окно "потоки GPU" с помеченными потоками](../../parallel/amp/media/campg.png "campg")  
Активные потоки в окне "Потоки GPU"  
  
     Окно параллельных контрольных значений и подсказку окна параллельных стеков оба указывают отмеченные потоки.  
  
4.  Если необходимо сосредоточиться на четырех потоков, которые вы отмечены, можно показать только отмеченные потоки в потоки GPU, контроль параллельных данных и windows Параллельные стеки.  
  
     Нажмите кнопку «Показать только помеченные» на любом windows или на **место отладки** инструментов. На следующем рисунке показана кнопка Показать только помеченные на **место отладки** инструментов.  
  
     ![Панель инструментов расположение Показать только помеченные значком отладки](../../parallel/amp/media/camph.png "camph")  
Кнопка "Показать только помеченные"  
  
     Теперь окно потоки GPU "," контроль параллельных данных "и" Параллельные стеки Показывать только отмеченные потоки.  
  
## <a name="freezing-and-thawing-gpu-threads"></a>Замораживание и размораживание потоков GPU  
 Можно закрепить (приостанавливать) и размораживать (возобновлять) потоки GPU из окна потоков GPU или окна параллельных контрольных значений. Можно заморозить или Разморозить потоки ЦП одинаково. сведения см. в разделе [как: использование окна потоков](/visualstudio/debugger/how-to-use-the-threads-window).  
  
### <a name="to-freeze-and-thaw-gpu-threads"></a>Чтобы заморозить и Разморозить потоки GPU  
  
1.  Выберите **Показать только помеченные** кнопку, чтобы отобразить все потоки.  
  
2.  В строке меню выберите **отладки**, **Продолжить**.  
  
3.  Откройте контекстное меню для активной строки, а затем выберите **закрепить**.  
  
     На следующем рисунке окна потоков GPU показано, что все четыре потока, зафиксированы.  
  
     ![Windows потоки GPU, в котором показаны замороженные потоки](../../parallel/amp/media/campk.png "campk")  
Замороженные потоки в окне "Потоки GPU"  
  
     Аналогичным образом окна параллельных контрольных значений показывает, что фиксируются все четыре потока.  
  
4.  В строке меню выберите **отладки**, **Продолжить** следующие четыре потоков GPU в ходе выполнения прошедшими барьер строки 22 и достигнет точки останова в строке 30. Окно потоков GPU показывает, что четыре ранее замороженные потоки остаются Замороженные и в активном состоянии.  
  
5.  В строке меню выберите **отладки**, **Продолжить**.  
  
6.  Из окна параллельных контрольных значений можно также Разморозить одного или нескольких потоков GPU.  
  
### <a name="to-group-gpu-threads"></a>Группирование потоков GPU  
  
1.  В контекстном меню для одного из потоков в **потоки GPU** окно, выберите **Group By**, **адрес**.  
  
     Потоки в окне потоков GPU группируются по адресу. Адрес соответствует инструкции в дизассемблированном коде, где расположена каждая группа потоков. 24 потоков, в строке 22 где [метод tile_barrier::wait](reference/tile-barrier-class.md#wait) выполняется. 12 потоки — на этой инструкции для строки 32 барьера. Четыре из этих потоков, отмечаются флагами. В точке останова на строке 30 — восемь потоков. Четыре эти потоки заморожены. Ниже показаны сгруппированные потоки в окне потоков GPU.  

  
     ![Окно "потоки GPU" с потоками, сгруппированными по адресам](../../parallel/amp/media/campl.png "campl")  
Сгруппированные потоки в окне потоков GPU  
  
2.  Можно также выполнять **Group By** операции, открыв контекстное меню для сетки данных окна параллельных контрольных значений, выбрав **Group By**и выбрав элемент меню, соответствующий способ группировать потоки.  
  
## <a name="running-all-threads-to-a-specific-location-in-code"></a>Выполнение всех потоков в определенное расположение в коде  
 Запускать все потоки в заданной плитки для строки, содержащей курсор с помощью **выполнить текущей плитки до курсора**.  
  
### <a name="to-run-all-threads-to-the-location-marked-by-the-cursor"></a>Для выполнения всех потоков в расположение, помеченного курсора  
  
1.  В контекстном меню замороженные потоки выберите **Разморозить**.  
  
2.  В редакторе кода, поместите курсор в строке 30.  
  
3.  В контекстном меню редактора кода, выберите **выполнить текущий Tile до курсора**.  
  
     24 потока, которые ранее были заблокированы в барьера строки 21 создали строку 32. Это показано в **потоки GPU** окна.  
  
## <a name="see-also"></a>См. также  
 [Обзор C++ AMP](../../parallel/amp/cpp-amp-overview.md)   
 [Отладка кода GPU](/visualstudio/debugger/debugging-gpu-code)   
 [Как: использование окна потоков GPU](/visualstudio/debugger/how-to-use-the-gpu-threads-window)   
 [Как: использование окна параллельных контрольных значений](/visualstudio/debugger/how-to-use-the-parallel-watch-window)   
 [Анализ кода C++ AMP с помощью визуализатора параллелизма](http://go.microsoft.com/fwlink/p/?linkid=253987&clcid=0x409)

