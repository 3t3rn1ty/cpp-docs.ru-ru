---
title: "Отмена в библиотеке параллельных шаблонов | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "отмена параллельных алгоритмов [среда выполнения с параллелизмом]"
  - "отмена параллельных задач [среда выполнения с параллелизмом]"
  - "отмена в библиотеке параллельных шаблонов"
  - "параллельные алгоритмы, отмена [среда выполнения с параллелизмом]"
  - "параллельные задачи, отмена [среда выполнения с параллелизмом]"
  - "деревья параллельной работы [среда выполнения с параллелизмом]"
ms.assetid: baaef417-b2f9-470e-b8bd-9ed890725b35
caps.latest.revision: 31
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 28
---
# Отмена в библиотеке параллельных шаблонов
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

В этом документе рассматривается роль отмены в библиотеке параллельных шаблонов \(PPL\), а также объясняется, как отменить параллельную работу и как определить, что параллельная работа отменена.  
  
> [!NOTE]
>  Среда выполнения использует обработку исключений для реализации отмены.  Не следует перехватывать или обрабатывать эти исключения в своем коде.  Кроме того, рекомендуется писать безопасный в отношении исключений код в функциях для ваших задач.  Например, можно использовать шаблон *Получение ресурса есть инициализация* \(RAII\) для обеспечения корректной обработки ресурсов при возникновении исключения в теле задачи.  Полный пример, использующий шаблон RAII для очистки ресурса в задаче с возможностью отмены, см. в разделе [Пошаговое руководство. Удаление задач из потоков пользовательского интерфейса](../../parallel/concrt/walkthrough-removing-work-from-a-user-interface-thread.md).  
  
## Ключевые моменты  
  
-   Отмена выполняется совместно и обеспечивает координацию между кодом, запрашивающим отмену запросов, и задачей, которая отвечает за отмену.  
  
-   Если возможно, используйте токены отмены, чтобы отменить работу.  Класс [concurrency::cancellation\_token](../../parallel/concrt/reference/cancellation-token-class.md) определяет токен отмены.  
  
-   При использовании токенов отмены применяйте метод [concurrency::cancellation\_token\_source::cancel](../Topic/cancellation_token_source::cancel%20Method.md), чтобы инициировать отмену, и функцию [concurrency::cancel\_current\_task](../Topic/cancel_current_task%20Function.md), чтобы реагировать на отмену.  
  
-   Отмена не происходит немедленно.  Хотя новая работа не запускается, если задача или группа задач отменяются, выполняющаяся работа должна выполнить проверку и отреагировать на отмену.  
  
-   Продолжение, основанное на значении, наследует токен отмены своей предшествующей задачи.  Продолжение на основе задачи никогда не наследует токен своей предшествующей задачи.  
  
-   Используйте метод [concurrency::cancellation\_token::none](../Topic/cancellation_token::none%20Method.md) при вызове конструктора или функции, которая принимает объект `cancellation_token`, но необходимо, чтобы операция поддерживала отмену.  Кроме того, если вы не передаете токен отмены конструктору [concurrency::task](../../parallel/concrt/reference/task-class-concurrency-runtime.md) или функции [concurrency::create\_task](../Topic/create_task%20Function.md), эта задача не будет поддерживать отмену.  
  
##  <a name="top"></a> В этом документе  
  
-   [Деревья параллельной работы](#trees)  
  
-   [Отмена параллельных задач](#tasks)  
  
    -   [Использование токена отмены для отмены параллельной работы](#tokens)  
  
    -   [Использование метода cancel для отмены параллельной работы](#cancel)  
  
    -   [Использование исключений для отмены параллельной работы](#exceptions)  
  
-   [Отмена параллельных алгоритмов](#algorithms)  
  
-   [Когда не следует использовать отмену](#when)  
  
##  <a name="trees"></a> Деревья параллельной работы  
 В PPL для управления детализированными задачами и вычислениями используются задачи и группы задач.  Вы можете вкладывать группы задач для формирования *деревьев* параллельной работы.  На следующем рисунке показано дерево параллельной работы.  На этом рисунке `tg1` и `tg2` представляют группы задач; `t1`, `t2`, `t3`, `t4` и `t5` представляют работы, которые выполняют группы задач.  
  
 ![Дерево параллельной работы](../Image/ParallelWork_Trees.png "ParallelWork\_Trees")  
  
 В следующем примере показан код, который необходим для создания дерева на рисунке.  В этом примере `tg1` и `tg2` являются объектами [concurrency::structured\_task\_group](../../parallel/concrt/reference/structured-task-group-class.md), а `t1`, `t2`, `t3`, `t4` и `t5` — объектами [concurrency::task\_handle](../../parallel/concrt/reference/task-handle-class.md).  
  
 [!code-cpp[concrt-task-tree#1](../../parallel/concrt/codesnippet/CPP/cancellation-in-the-ppl_1.cpp)]  
  
 Можно также использовать класс [concurrency::task\_group](../Topic/task_group%20Class.md) для создания подобного дерева работы.  Класс [concurrency::task](../../parallel/concrt/reference/task-class-concurrency-runtime.md) также поддерживает понятие дерева работы.  Однако дерево `task` является деревом зависимостей.  В дереве `task` следующие задания выполняются после текущих.  В дереве группы задач внутренняя работа завершается до внешней работы.  Дополнительные сведения о различиях между задачами и группами задач см. в разделе [Параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md).  
  
 \[[В начало](#top)\]  
  
##  <a name="tasks"></a> Отмена параллельных задач  
 Существует несколько способов отмены параллельной работы.  Предпочтительный способ — использование токена отмены.  Группы задач также поддерживают метод [concurrency::task\_group::cancel](../Topic/task_group::cancel%20Method.md) и метод [concurrency::structured\_task\_group::cancel](../Topic/structured_task_group::cancel%20Method.md).  Еще один способ — создать исключение в теле рабочей функции задачи.  Какой бы метод вы ни выбрали, нужно понимать, что отмена не происходит немедленно.  Хотя новая работа не запускается, если задача или группа задач отменяются, выполняющаяся работа должна выполнить проверку и отреагировать на отмену.  
  
 Дополнительные примеры отмены параллельных задач см. в разделах [Пошаговое руководство. Подключение с использованием задач и HTTP\-запросов XML](../../parallel/concrt/walkthrough-connecting-using-tasks-and-xml-http-requests.md), [Практическое руководство. Использование отмены для выхода из параллельного цикла](../../parallel/concrt/how-to-use-cancellation-to-break-from-a-parallel-loop.md) и [Практическое руководство. Использование обработки исключений для выхода из параллельного цикла](../Topic/How%20to:%20Use%20Exception%20Handling%20to%20Break%20from%20a%20Parallel%20Loop.md).  
  
###  <a name="tokens"></a> Использование токена отмены для отмены параллельной работы  
 Классы `task`, `task_group` и `structured_task_group` поддерживают отмену посредством использования токенов отмены.  PPL определяет классы [concurrency::cancellation\_token\_source](../../parallel/concrt/reference/cancellation-token-source-class.md) и [concurrency::cancellation\_token](../../parallel/concrt/reference/cancellation-token-class.md) для этой цели.  При использовании токена отмены, чтобы отменить работу, среда выполнения не запускает новую работу, которая подписывается на этот токен.  Уже выполняющаяся работа может отслеживать свой токен отмены и останавливаться, когда имеет такую возможность.  
  
 Чтобы инициировать отмену, вызовите метод [concurrency::cancellation\_token\_source::cancel](../Topic/cancellation_token_source::cancel%20Method.md).  Можно реагировать на отмену следующими способами.  
  
-   Для объектов `task` используется функция [concurrency::cancel\_current\_task](../Topic/cancel_current_task%20Function.md).  `cancel_current_task` отменяет текущую задачу и любое ее продолжение, основанное на значении.  \(Он не отменяет *токен* отмены, связанный с задачей или ее продолжениями.\)  
  
-   Для групп задач и параллельных алгоритмов используйте функцию [concurrency::is\_current\_task\_group\_canceling](../Topic/is_current_task_group_canceling%20Function.md), чтобы отследить отмену и как можно скорее вернуться из тела задачи, когда эта функция возвращает `true`.  \(Не вызывайте `cancel_current_task` из группы задач.\)  
  
 В следующем примере показан первый базовый шаблон для отмены задачи.  Тело задачи время от времени проверяет, нет ли отмены внутри цикла.  
  
 [!code-cpp[concrt-task-basic-cancellation#1](../../parallel/concrt/codesnippet/CPP/cancellation-in-the-ppl_2.cpp)]  
  
 Функция `cancel_current_task` создает исключение, поэтому нет необходимости явно возвращаться из текущего цикла или функции.  
  
> [!TIP]
>  Кроме того, можно вызвать функцию [concurrency::interruption\_point](../Topic/interruption_point%20Function.md) вместо `cancel_current_task`.  
  
 Необходимо вызвать `cancel_current_task` при реагировании на отмену, поскольку она переводит задачу в отмененное состояние.  Если вы вернулись раньше вместо вызова `cancel_current_task`, операция переходит в состояние завершения, и все продолжения, основанные на значении, выполняются.  
  
> [!CAUTION]
>  Никогда не вызывайте исключение `task_canceled` из своего кода.  Вместо него вызовите метод `cancel_current_task`.  
  
 Когда задача завершается в отмененном состоянии, метод [concurrency::task::get](../Topic/task::get%20Method.md) создает [concurrency::task\_canceled](../../parallel/concrt/reference/task-canceled-class.md).  \(И наоборот, [concurrency::task::wait](../Topic/task::wait%20Method.md) возвращает [task\_status::canceled](../Topic/task_group_status%20Enumeration.md) и не создает исключение.\) В следующем примере показано такое поведение для продолжения на основе задачи.  Продолжение на основе задачи вызывается всегда, даже если предшествующая задача отменяется.  
  
 [!code-cpp[concrt-task-canceled#1](../../parallel/concrt/codesnippet/CPP/cancellation-in-the-ppl_3.cpp)]  
  
 Поскольку продолжения, основанные на значении, наследуют токен их предшествующей задачи, если они не были созданы с явным токеном, продолжения немедленно входят в отмененное состояние, даже если предшествующая задача по\-прежнему выполняется.  Поэтому любое исключение, создаваемое предшествующей задачей после отмены, не распространяется задачам продолжения.  Отмена всегда переопределяет состояние предшествующей задачи.  Следующий пример похож на предыдущий, но показывает поведение продолжения, основанного на значении.  
  
 [!code-cpp[concrt-task-canceled#2](../../parallel/concrt/codesnippet/CPP/cancellation-in-the-ppl_4.cpp)]  
  
> [!CAUTION]
>  Если вы не передаете токен отмены конструктору `task` или функции [concurrency::create\_task](../Topic/create_task%20Function.md), эта задача не будет поддерживать отмену.  Кроме того необходимо передать один и тот же токен отмены конструктору всех вложенных задач \(т. е. задач, которые создаются в теле другой задачи\), чтобы отменить все задачи одновременно.  
  
 Может понадобиться выполнить собственный код, когда токен отмены отменен.  Например, если пользователь выбирает в интерфейсе пользователя кнопку **Отмена**, чтобы отменить операцию, можно отключить эту кнопку до тех пор, пока пользователь не начнет другую операцию.  В следующем примере показано, как использовать метод [concurrency::cancellation\_token::register\_callback](../Topic/cancellation_token::register_callback%20Method.md) для регистрации функции обратного вызова, которая выполняется, когда токен отмены отменяется.  
  
 [!CODE [concrt-task-cancellation-callback#1](../CodeSnippet/VS_Snippets_ConcRT/concrt-task-cancellation-callback#1)]  
  
 В документе [Параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md) объясняется разница между продолжениями на основе задач и продолжениями на основе значений.  Если не предоставить объект `cancellation_token` задаче продолжения, продолжение наследует токен отмены из предшествующей задачи следующими способами.  
  
-   Продолжение, основанное на значении, всегда наследует токен отмены предшествующей задачи.  
  
-   Продолжение на основе задач никогда не наследует токен отмены предшествующей задачи.  Единственный способ сделать продолжение на основе задач отменяемым — явно передать токен отмены.  
  
 Эти поведения не изменяются из\-за сбоя задачи \(той, которая создает исключение\).  В этом случае продолжение на основе значения отменяется, а продолжение на основе задачи не отменяется.  
  
> [!CAUTION]
>  Задача, которая создается внутри другой задачи \(вложенная задача\), не наследует токен отмены от родительской задачи.  Только продолжение, основанное на значении, наследует токен отмены своей предшествующей задачи.  
  
> [!TIP]
>  Используйте метод [concurrency::cancellation\_token::none](../Topic/cancellation_token::none%20Method.md) при вызове конструктора или функции, которая принимает объект `cancellation_token`, если необходимо, чтобы операция поддерживала отмену.  
  
 Также можно предоставить токен отмены конструктору объекта `task_group` или `structured_task_group`.  Важным аспектом является то, что дочерние группы задач наследуют этот токен отмены.  Пример, демонстрирующий эту концепцию с помощью использования функции [concurrency::run\_with\_cancellation\_token](../Topic/run_with_cancellation_token%20Function.md) для вызова `parallel_for`, см. в разделе [Отмена параллельных алгоритмов](#algorithms) далее в этом документе.  
  
 \[[В начало](#top)\]  
  
#### Токены отмены и композиция задач  
 Функции [concurrency::when\_all](../Topic/when_all%20Function.md) и [concurrency::when\_any](../Topic/when_all%20Function.md) помогают объединять несколько задач для реализации общих шаблонов.  В этом разделе описывается, как эти функции работают с токенами отмены.  
  
 Если предоставляется токен отмены для любой из функций `when_all` и `when_any`, эта функция отменяется, только если отменяется этот токен отмены, или одна из участвующих задач заканчивается в отмененном состоянии или создает исключение.  
  
 Функция `when_all` наследует токен отмены от каждой задачи, формирующей общую операцию, если ей не предоставляется токен отмены.  Задача, возвращаемая из `when_all`, отменяется, если отменяется любой из этих токенов и хотя бы одна из участвующих задач еще не началась или выполняется.  Такое же поведение наблюдается, когда одна из задач создает исключение: задача, возвращаемая из `when_all`, немедленно отменяется с этим исключением.  
  
 Среда выполнения выбирает токен отмены для задачи, которая возвращается из функции `when_any`, когда эта задача завершается.  Если ни одна из участвующих задач не заканчивается в завершенном состоянии или одна или более задач создают исключение, одна из создавших исключение задач выбирается для выполнения `when_any`, а ее токен выбирается как токен для окончательной задачи.  Если более чем одна задача заканчивается в завершенном состоянии, задача, возвращаемая `when_any`, заканчивается в завершенном состоянии.  Среда выполнения пытается выбрать завершенную задачу, токен которой не отменяется во время завершения, чтобы задача, которая возвращается из `when_any`, не отменялась сразу же, даже если остальные выполняющиеся задачи могут завершиться позднее.  
  
 \[[В начало](#top)\]  
  
###  <a name="cancel"></a> Использование метода cancel для отмены параллельной работы  
 Методы [concurrency::task\_group::cancel](../Topic/task_group::cancel%20Method.md) и [concurrency::structured\_task\_group::cancel](../Topic/structured_task_group::cancel%20Method.md) задают для группы задач отмененное состояние.  После вызова метода `cancel` группа задач не начинает выполнение следующих задач.  Методы `cancel` могут вызываться несколькими дочерними задачами.  Отмененная задача заставляет методы [concurrency::task\_group::wait](../Topic/task_group::wait%20Method.md) и [concurrency::structured\_task\_group::wait](../Topic/structured_task_group::wait%20Method.md) возвращать [concurrency::canceled](../Topic/task_group_status%20Enumeration.md).  
  
 Если группа задач отменяется, вызовы из каждой дочерней задачи, направленные в среду выполнения, могут инициировать *точку прерывания*, которая заставляет среду выполнения создавать и перехватывать тип внутреннего исключения для отмены активных задач.  Среда выполнения с параллелизмом не определяет конкретные точки прерывания; они могут возникать в любом вызове среды выполнения.  Среда выполнения должна обрабатывать исключения, которые она вызывает, чтобы выполнить отмену.  Таким образом, не следует обрабатывать неизвестные исключения в теле задачи.  
  
 Если дочерняя задача выполняет длительную операцию и не выполняет вызовы, направленные в среду выполнения, необходимо периодически проверять ее для своевременной отмены и выхода.  В следующем примере показывается один из способов определения, когда работа отменяется.  Задача `t4` отменяет родительскую группу задач при обнаружении ошибки.  Задача `t5` периодически вызывает метод `structured_task_group::is_canceling` для проверки отмены.  Если родительская группа задач отменяется, задача `t5` выводит сообщение и завершает работу.  
  
 [!code-cpp[concrt-task-tree#6](../../parallel/concrt/codesnippet/CPP/cancellation-in-the-ppl_5.cpp)]  
  
 В этом примере выполняется проверка отмены при каждой сотой итерации цикла задач.  Частота, с которой выполняется проверка отмены, зависит от объема работы, выполняемой задачей, и того, как быстро задачи должны реагировать на отмену.  
  
 Если отсутствует доступ к объекту родительской группы задач, следует вызвать функцию [concurrency::is\_current\_task\_group\_canceling](../Topic/is_current_task_group_canceling%20Function.md), чтобы определить, отменена ли родительская группа задач.  
  
 Метод `cancel` влияет только на дочерние задачи.  Например, если отменить группу задач `tg1`, показанную на рисунке дерева параллельной работы, будут затронуты все задачи в дереве \(`t1`, `t2`, `t3`, `t4` и `t5`\).  Если отменить вложенную группу задач `tg2`, будут затронуты только задачи `t4` и `t5`.  
  
 При вызове метода `cancel` будут также отменены все дочерние группы задач.  Однако отмена не повлияет ни на какие родительские объекты группы задач в дереве параллельной работы.  В следующих примерах это демонстрируется с опорой на иллюстрацию дерева параллельной работы.  
  
 В первом из этих примеров создается рабочая функция для задачи `t4`, которая является дочерним элементом группы задач `tg2`.  Эта рабочая функция вызывает функцию `work` в цикле.  Если какой\-либо вызов `work` завершается неудачно, задача отменяет свою родительскую группу задач.  В результате группа задач `tg2` переходит в отмененное состояние, но группа задач `tg1` не отменяется.  
  
 [!code-cpp[concrt-task-tree#2](../../parallel/concrt/codesnippet/CPP/cancellation-in-the-ppl_6.cpp)]  
  
 Второй пример аналогичен первому, но за тем исключением, что задача отменяет группу задач `tg1`.  Это влияет на все задачи в дереве \(`t1`, `t2`, `t3`, `t4` и `t5`\).  
  
 [!code-cpp[concrt-task-tree#3](../../parallel/concrt/codesnippet/CPP/cancellation-in-the-ppl_7.cpp)]  
  
 Класс `structured_task_group` не является потокобезопасным.  Таким образом, дочерняя задача, которая вызывает метод своего родительского объекта `structured_task_group`, приводит к непредсказуемому поведению.  Методы `structured_task_group::cancel` и [concurrency::structured\_task\_group::is\_canceling](../Topic/structured_task_group::is_canceling%20Method.md) — исключения из этого правила.  Дочерняя задача может вызывать эти методы для отмены родительской группы задач и проверки на предмет отмены.  
  
> [!CAUTION]
>  Хотя можно использовать токен отмены, чтобы отменить работу, выполняемую группой задач, которая выполняется как дочерний элемент объекта `task`, невозможно использовать методы `task_group::cancel` или `structured_task_group::cancel`, чтобы отменить объекты `task`, выполняемые в группе задач.  
  
 \[[В начало](#top)\]  
  
###  <a name="exceptions"></a> Использование исключений для отмены параллельной работы  
 Использование токенов отмены и метода `cancel` более эффективно, чем обработка исключений при отмене дерева параллельной работы.  Токены отмены и метод `cancel` отменяют задачу и все дочерние задачи сверху вниз.  И наоборот, обработка исключений работает в режиме «снизу вверх» и необходимо отменять каждую дочернюю группу задач независимо, поскольку исключение распространяется вверх.  В разделе [Обработка исключений](../Topic/Exception%20Handling%20in%20the%20Concurrency%20Runtime.md) объясняется, как среда выполнения с параллелизмом использует исключения для сообщения об ошибках.  Однако не все исключения указывают на ошибку.  Например, алгоритм поиска может отменить связанную задачу при нахождении результата.  Тем не менее, как упоминалось ранее, обработка исключений менее эффективна, чем использование метода `cancel` для отмены параллельной работы.  
  
> [!CAUTION]
>  Рекомендуется использовать исключения для отмены параллельной работы только при необходимости.  Токены отмены и методы `cancel` группы задач более эффективны и менее подвержены возникновению ошибок.  
  
 При создании исключения в теле рабочей функции, передаваемой в группу задач, среда выполнения сохраняет это исключение и маршалирует его в контекст, ожидающий завершения этой группы задач.  Как и в случае использования метода `cancel`, среда выполнения удаляет любые задачи, которые еще не были запущены, и не принимает новые задачи.  
  
 Третий пример напоминает второй, за исключением того, что задача `t4` создает исключение для отмены группы задач `tg2`.  В этом примере используется блок `try`\-`catch` для проверки отмены, когда группа задач `tg2` ожидает завершения своих дочерних задач.  Как и в первом примере, в результате группа задач `tg2` переходит в отмененное состояние, но группа задач `tg1` не отменяется.  
  
 [!code-cpp[concrt-task-tree#4](../../parallel/concrt/codesnippet/CPP/cancellation-in-the-ppl_8.cpp)]  
  
 В четвертом примере используется обработка исключений для отмены всего дерева работы.  В этом примере перехватывается исключение, когда группа задач `tg1` ожидает завершения своих дочерних задач вместо группы задач `tg2`, ожидающей своих дочерних задач.  Как и во втором примере, это приводит к переходу в отмененное состояние обеих групп задач в дереве, `tg1` и `tg2`.  
  
 [!code-cpp[concrt-task-tree#5](../../parallel/concrt/codesnippet/CPP/cancellation-in-the-ppl_9.cpp)]  
  
 Так как методы `task_group::wait` и `structured_task_group::wait` вызываются, когда дочерняя задача создает исключение, вы не получите от них возвращаемое значение.  
  
 \[[В начало](#top)\]  
  
##  <a name="algorithms"></a> Отмена параллельных алгоритмов  
 Параллельные алгоритмы в PPL \(например, `parallel_for`\) основаны на группах задач.  Таким образом, многие из тех же способов можно использовать для для отмены параллельного алгоритма.  
  
 Следующие примеры иллюстрируют несколько способов отмены параллельного алгоритма.  
  
 В следующем примере функция `run_with_cancellation_token` используется для вызова алгоритма `parallel_for`.  Функция `run_with_cancellation_token` принимает в качестве аргумента токен отмены и одновременно вызывает предоставленную рабочую функцию.  Поскольку параллельные алгоритмы строятся на задачах, они наследуют токен отмены родительской задачи.  Поэтому `parallel_for` может реагировать на отмену.  
  
 [!CODE [concrt-cancel-parallel-for#1](../CodeSnippet/VS_Snippets_ConcRT/concrt-cancel-parallel-for#1)]  
  
 В следующем примере метод [concurrency::structured\_task\_group::run\_and\_wait](../Topic/structured_task_group::run_and_wait%20Method.md) используется для вызова алгоритма `parallel_for`.  Метод `structured_task_group::run_and_wait` ожидает завершения предоставленной задачи.  Объект `structured_task_group` позволяет рабочей функции отменить задачу.  
  
 [!code-cpp[concrt-task-tree#7](../../parallel/concrt/codesnippet/CPP/cancellation-in-the-ppl_10.cpp)]  
  
 В этом примере формируются следующие данные:  
  
  **Состояние группы задач: отменено.** В следующем примере используется обработка исключений для отмены цикла `parallel_for`.  Среда выполнения маршалирует исключение в вызывающий контекст.  
  
 [!code-cpp[concrt-task-tree#9](../../parallel/concrt/codesnippet/CPP/cancellation-in-the-ppl_11.cpp)]  
  
 В этом примере формируются следующие данные:  
  
  **Перехвачено 50** В следующем примере используется логический флаг для координации отмены в цикле `parallel_for` Каждая задача выполняется, поскольку в этом примере не используется метод `cancel` или обработка исключений, чтобы отменить весь набор задач.  Таким образом, этот метод может использовать больше вычислительных ресурсов, чем механизм отмены.  
  
 [!code-cpp[concrt-task-tree#8](../../parallel/concrt/codesnippet/CPP/cancellation-in-the-ppl_12.cpp)]  
  
 Каждый метод отмены имеет свои преимущества по сравнению с другими.  Выбирайте метод, который соответствует вашим конкретным требованиям.  
  
 \[[В начало](#top)\]  
  
##  <a name="when"></a> Когда не следует использовать отмену  
 Использование отмены подходит в тех случаях, когда каждый член группы связанных задач может выполнить выход своевременно.  Однако существуют некоторые сценарии, в которых отмена может не подойти для вашего приложения.  Например, поскольку отмена задач осуществляется совместно, весь набор задач не будет отменен, если одна из задач заблокирована.  Например, если одна задача еще не запущена, но разблокирует другую активную задачу, эта задача не запустится, если отменяется группа задач.  Это может вызвать взаимоблокировку в приложении.  Второй пример, когда использование отмены может не подойти: задача отменяется, но ее дочерняя задача выполняет важную операцию, например высвобождение ресурса.  Так как при отмене родительской задачи отменяется весь набор задач, эта операция не будет выполнена.  Пример, иллюстрирующий этот аспект, см. в разделе [Узнайте, как отмена и обработка исключений влияет на уничтожение объектов](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md#object-destruction) документа "Лучшие практические примеры библиотеки шаблонов параллельного программирования".  
  
 \[[В начало](#top)\]  
  
## См. также  
  
|Заголовок|Описание|  
|---------------|--------------|  
|[Практическое руководство. Использование отмены для выхода из параллельного цикла](../../parallel/concrt/how-to-use-cancellation-to-break-from-a-parallel-loop.md)|Показывается, как использовать отмену для реализации алгоритма параллельного поиска.|  
|[Практическое руководство. Использование обработки исключений для выхода из параллельного цикла](../Topic/How%20to:%20Use%20Exception%20Handling%20to%20Break%20from%20a%20Parallel%20Loop.md)|Здесь приводятся способы использования класса `task_group` для записи алгоритма поиска для базовой структуры дерева.|  
|[Обработка исключений](../Topic/Exception%20Handling%20in%20the%20Concurrency%20Runtime.md)|В этом разделе описывается обработка в среде выполнения исключений, созданных группами задач, упрощенными задачами и асинхронными агентами, а также способы реагирования на исключения в приложениях.|  
|[Параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md)|В этом разделе описывается, как задачи связаны с группами задач и как можно использовать структурированные и неструктурированные задачи в приложениях.|  
|[Параллельные алгоритмы](../Topic/Parallel%20Algorithms.md)|В этом разделе описываются параллельные алгоритмы, одновременно выполняющие работу с коллекциями данных.|  
|[Библиотека параллельных шаблонов](../../parallel/concrt/parallel-patterns-library-ppl.md)|Общие сведения о библиотеке параллельных задач.|  
  
## Ссылка  
 [Класс task \(среда выполнения с параллелизмом\)](../../parallel/concrt/reference/task-class-concurrency-runtime.md)  
  
 [Класс cancellation\_token\_source](../../parallel/concrt/reference/cancellation-token-source-class.md)  
  
 [Класс cancellation\_token](../../parallel/concrt/reference/cancellation-token-class.md)  
  
 [Класс task\_group](../Topic/task_group%20Class.md)  
  
 [Класс structured\_task\_group](../../parallel/concrt/reference/structured-task-group-class.md)  
  
 [Функция parallel\_for](../Topic/parallel_for%20Function.md)