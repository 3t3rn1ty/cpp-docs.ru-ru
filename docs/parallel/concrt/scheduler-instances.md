---
title: "Экземпляры планировщика | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "экземпляры планировщика"
ms.assetid: 4819365f-ef99-49cc-963e-50a2a35a8d6b
caps.latest.revision: 7
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 6
---
# Экземпляры планировщика
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

В этом документе описывается роль экземпляров планировщика в среде выполнения с параллелизмом, а также описано, как использовать классы [concurrency::Scheduler](../../parallel/concrt/reference/scheduler-class.md) и [concurrency::CurrentScheduler](../Topic/CurrentScheduler%20Class.md), чтобы создавать экземпляры планировщиков и управлять ими.  Экземпляры планировщика позволяют связывать явные политики планирования с определенными типами рабочих нагрузок.  Например, можно создать один экземпляр планировщика для выполнения некоторых задач с повышенным приоритетом потока, а планировщик по умолчанию — для выполнения задач с обычным приоритетом потока.  
  
> [!TIP]
>  Среда выполнения с параллелизмом предоставляет планировщик по умолчанию, поэтому вам не обязательно создавать собственный.  Так как планировщик заданий помогает оптимизировать производительность приложений, рекомендуется начать с раздела [Библиотека параллельных шаблонов](../../parallel/concrt/parallel-patterns-library-ppl.md) или [Библиотека асинхронных агентов](../../parallel/concrt/asynchronous-agents-library.md), если вы не знакомы со средой выполнения с параллелизмом.  
  
##  <a name="top"></a> Подразделы  
  
-   [Планировщик и классы CurrentScheduler](#classes)  
  
-   [Создание экземпляра планировщика](#creating)  
  
-   [Управление временем существования экземпляра планировщика](#managing)  
  
-   [Методы и свойства](#features)  
  
-   [Пример](#example)  
  
##  <a name="classes"></a> Планировщик и классы CurrentScheduler  
 Планировщик заданий позволяет приложениям использовать один или несколько *экземпляров планировщика* для планирования работы.  Класс [concurrency::Scheduler](../../parallel/concrt/reference/scheduler-class.md) представляет экземпляр планировщика и содержит функциональные возможности, связанные с планированием задач.  
  
 Поток, прикрепленный к планировщику, известен как *контекст выполнения* или просто *контекст*.  В любой момент времени в текущем контексте может быть активен только один планировщик.  Активный планировщик также известен как *текущий планировщик*.  Среда выполнения с параллелизмом использует класс [concurrency::CurrentScheduler](../Topic/CurrentScheduler%20Class.md) для предоставления доступа к текущему планировщику.  Текущий планировщик для одного контекста может отличаться от текущего планировщика для другого контекста.  Среда выполнения не предоставляет представление текущего планировщика на уровне процесса.  
  
 Как правило, класс `CurrentScheduler` используется для осуществления доступа к текущему планировщику.  Класс `Scheduler` удобен при необходимости управлять планировщиком, не являющимся текущим.  
  
 В следующих разделах описано создание экземпляра планировщика и управление им.  Полный пример, в котором показаны эти задачи, см. в разделе [Практическое руководство. Управление экземпляром планировщика](../../parallel/concrt/how-to-manage-a-scheduler-instance.md).  
  
 \[[Наверх](#top)\]  
  
##  <a name="creating"></a> Создание экземпляра планировщика  
 Существует три способа создания объекта `Scheduler`.  
  
-   Если планировщика не существует, среда выполнения создает планировщик по умолчанию, когда пользователь использует для выполнения работы функции среды выполнения, например параллельный алгоритм.  Планировщик по умолчанию становится текущим планировщиком для контекста, инициирующего параллельную работу.  
  
-   Метод [concurrency::CurrentScheduler::Create](../Topic/CurrentScheduler::Create%20Method.md) создает объект `Scheduler`, использующий конкретную политику и связывающий этот планировщик с текущим контекстом.  
  
-   Метод [concurrency::Scheduler::Create](../Topic/Scheduler::Create%20Method.md) создает объект `Scheduler`, использующий конкретную политику, но не связывает его с текущим контекстом.  
  
 Если среде выполнения разрешается создавать планировщик по умолчанию, все параллельные задачи могут совместно использовать один и тот же планировщик.  Обычно функции [библиотеки параллельных шаблонов](../../parallel/concrt/parallel-patterns-library-ppl.md) \(PPL\) или [библиотеки асинхронных агентов](../../parallel/concrt/asynchronous-agents-library.md) используются для выполнения параллельной работы.  Следовательно, чтобы контролировать политику или время существования планировщика, не обязательно работать с ним напрямую.  При использовании библиотеки параллельных шаблонов или библиотеки агентов среда выполнения создает планировщик по умолчанию, если его не существует, и делает его текущим планировщиком для каждого контекста.  Если создается планировщик и задается в качестве текущего, среда выполнения использует этот планировщик для планирования заданий.  Создавать дополнительные экземпляры планировщика следует только тогда, когда требуется определенная политика планирования.  Дополнительные сведения о политиках, выключенных в планировщик, см. в разделе [Политики планировщика](../../parallel/concrt/scheduler-policies.md).  
  
 \[[Наверх](#top)\]  
  
##  <a name="managing"></a> Управление временем существования экземпляра планировщика  
 Среда выполнения использует механизм подсчета ссылок для управления временем существования объектов `Scheduler`.  
  
 При использовании метода `CurrentScheduler::Create` или `Scheduler::Create` для создания объекта `Scheduler` среда выполнения задает начальное число ссылок этого планировщика, равное 1.  Среда выполнения увеличивает число ссылок при каждом вызове метода [concurrency::Scheduler::Attach](../Topic/Scheduler::Attach%20Method.md).  Метод `Scheduler::Attach` связывает объект `Scheduler` с текущим контекстом.  После этого он становится текущим планировщиком.  При вызове метода `CurrentScheduler::Create` среда выполнения создает объект `Scheduler` и прикрепляет его к текущему контексту \(и задает число ссылок, равное 1\).  Кроме того, для увеличения числа ссылок объекта `Scheduler` можно использовать метод [concurrency::Scheduler::Reference](../Topic/Scheduler::Reference%20Method.md).  
  
 Среда выполнения уменьшает число ссылок при вызове метода [concurrency::CurrentScheduler::Detach](../Topic/CurrentScheduler::Detach%20Method.md) для отсоединения текущего планировщика или вызове метода [concurrency::Scheduler::Release](../Topic/Scheduler::Release%20Method.md).  Когда число ссылок достигает нуля, среда выполнения уничтожает объект `Scheduler` после завершения всех запланированных задач.  Выполняемая задача может увеличивать число ссылок текущего планировщика.  Следовательно, если число ссылок достигает нуля и задача увеличивает это число ссылок, среда выполнения не уничтожает объект `Scheduler` до тех пор, пока число ссылок снова не станет равным нулю и не завершатся все задачи.  
  
 Среда выполнения поддерживает внутренний стек объектов `Scheduler` для каждого контекста.  При вызове метода `Scheduler::Attach` или `CurrentScheduler::Create` среда выполнения помещает объект `Scheduler` в стек текущего контекста.  После этого он становится текущим планировщиком.  При вызове метода `CurrentScheduler::Detach` среда выполнения извлекает текущий планировщик из стека текущего контекста и задает в качестве текущего предыдущий планировщик.  
  
 Среда выполнения предоставляет несколько способов управления временем существования экземпляра планировщика.  В следующей таблице показан соответствующий метод, освобождающий или отсоединяющий планировщик от текущего контекста, для каждого метода, создающего или присоединяющего планировщик к текущему контексту.  
  
|Метод создания или присоединения|Метод освобождения или отсоединения|  
|--------------------------------------|-----------------------------------------|  
|`CurrentScheduler::Create`|`CurrentScheduler::Detach`|  
|`Scheduler::Create`|`Scheduler::Release`|  
|`Scheduler::Attach`|`CurrentScheduler::Detach`|  
|`Scheduler::Reference`|`Scheduler::Release`|  
  
 Вызов неподходящего метода освобождения или отсоединения создает незаданное поведение в среде выполнения.  
  
 При использовании определенных функциональных возможностей \(например, библиотеки параллельных шаблонов\), заставляющих среду выполнения создавать планировщик по умолчанию, этот планировщик не нужно освобождать или отсоединять.  Среда выполнения управляет временем существования любого создаваемого ею планировщика.  
  
 Так как среда выполнения не уничтожает объект `Scheduler` до завершения всех задач, можно использовать метод [concurrency::Scheduler::RegisterShutdownEvent](../Topic/Scheduler::RegisterShutdownEvent%20Method.md) или [concurrency::CurrentScheduler::RegisterShutdownEvent](../Topic/CurrentScheduler::RegisterShutdownEvent%20Method.md) для получения уведомления об уничтожении объекта `Scheduler`.  Это полезно, если приходится ожидать завершения каждой задачи, запланированной объектом `Scheduler`.  
  
 \[[Наверх](#top)\]  
  
##  <a name="features"></a> Методы и свойства  
 В этом подразделе обобщаются важные методы классов `CurrentScheduler` и `Scheduler`.  
  
 Класс `CurrentScheduler` можно назвать вспомогательным средством создания планировщика для использования в текущем контексте.  Класс `Scheduler` позволяет контролировать планировщик, принадлежащий к другому контексту.  
  
 В следующей таблице указаны важные методы, определяемые классом `CurrentScheduler`.  
  
|Метод|Описание|  
|-----------|--------------|  
|[Create](../Topic/CurrentScheduler::Create%20Method.md)|Создает объект `Scheduler`, который использует заданную политику и связывает ее с текущим контекстом.|  
|[Get](../Topic/CurrentScheduler::Get%20Method.md)|Извлекает указатель на объект `Scheduler`, связанный с текущим контекстом.  Этот метод не увеличивает число ссылок объекта `Scheduler`.|  
|[Отсоединить](../Topic/CurrentScheduler::Detach%20Method.md)|Отсоединяет текущий планировщик из текущего контекста и задает в качестве текущего планировщика предыдущий.|  
|[RegisterShutdownEvent](../Topic/CurrentScheduler::RegisterShutdownEvent%20Method.md)|Регистрирует событие, которое среда выполнения задает при уничтожении текущего планировщика.|  
|[CreateScheduleGroup](../Topic/CurrentScheduler::CreateScheduleGroup%20Method.md)|Создает объект [concurrency::ScheduleGroup](../Topic/ScheduleGroup%20Class.md) в текущем планировщике.|  
|[ScheduleTask](../Topic/CurrentScheduler::ScheduleTask%20Method.md)|Добавляет упрощенную задачу в очередь планирования текущего планировщика.|  
|[GetPolicy](../Topic/CurrentScheduler::GetPolicy%20Method.md)|Извлекает копию политики, связанной с текущим планировщиком.|  
  
 В следующей таблице указаны важные методы, определяемые классом `Scheduler`.  
  
|Метод|Описание|  
|-----------|--------------|  
|[Create](../Topic/Scheduler::Create%20Method.md)|Создает объект `Scheduler`, использующий заданную политику.|  
|[Присоединиться](../Topic/Scheduler::Attach%20Method.md)|Связывает объект `Scheduler` с текущим контекстом.|  
|[Справочные сведения](../Topic/Scheduler::Reference%20Method.md)|Увеличивает число ссылок объекта `Scheduler`.|  
|[Release](../Topic/Scheduler::Release%20Method.md)|Уменьшает число ссылок объекта `Scheduler`.|  
|[RegisterShutdownEvent](../Topic/Scheduler::RegisterShutdownEvent%20Method.md)|Регистрирует событие, которое среда выполнения задает при уничтожении объекта `Scheduler`.|  
|[CreateScheduleGroup](../Topic/Scheduler::CreateScheduleGroup%20Method.md)|Создает объект [concurrency::ScheduleGroup](../Topic/ScheduleGroup%20Class.md) в объекте `Scheduler`.|  
|[ScheduleTask](../Topic/Scheduler::ScheduleTask%20Method.md)|Планирует упрощенную задачу из объекта `Scheduler`.|  
|[GetPolicy](../Topic/Scheduler::GetPolicy%20Method.md)|Извлекает копию политики, связанную с объектом `Scheduler`.|  
|[SetDefaultSchedulerPolicy](../Topic/Scheduler::SetDefaultSchedulerPolicy%20Method.md)|Задает политику для использования средой выполнения при создании планировщика по умолчанию.|  
|[ResetDefaultSchedulerPolicy](../Topic/Scheduler::ResetDefaultSchedulerPolicy%20Method.md)|Восстанавливает в качестве политики по умолчанию ту, которая была активной до вызова метода `SetDefaultSchedulerPolicy`.  Если планировщик по умолчанию создается после этого вызова, среда выполнения использует для создания планировщика настройки политики по умолчанию.|  
  
 \[[Наверх](#top)\]  
  
##  <a name="example"></a> Пример  
 Общие примеры создания экземпляра планировщика и управления им см. в разделе [Практическое руководство. Управление экземпляром планировщика](../../parallel/concrt/how-to-manage-a-scheduler-instance.md).  
  
## См. также  
 [Планировщик задач](../../parallel/concrt/task-scheduler-concurrency-runtime.md)   
 [Практическое руководство. Управление экземпляром планировщика](../../parallel/concrt/how-to-manage-a-scheduler-instance.md)   
 [Политики планировщика](../../parallel/concrt/scheduler-policies.md)   
 [Группы расписаний](../../parallel/concrt/schedule-groups.md)