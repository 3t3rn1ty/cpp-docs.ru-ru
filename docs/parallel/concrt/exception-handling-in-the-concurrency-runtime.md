---
title: "Обработка исключений в среде выполнения с параллелизмом | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
helpviewer_keywords:
- lightweight tasks, exception handling [Concurrency Runtime]
- exception handling [Concurrency Runtime]
- structured task groups, exception handling [Concurrency Runtime]
- agents, exception handling [Concurrency Runtime]
- task groups, exception handling [Concurrency Runtime]
ms.assetid: 4d1494fb-3089-4f4b-8cfb-712aa67d7a7a
caps.latest.revision: "29"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: 72cde17c0bcb6a3582305167e6358f761c16f248
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="exception-handling-in-the-concurrency-runtime"></a>Обработка исключений в среде выполнения с параллелизмом
Среда выполнения с параллелизмом использует для обмена данными в различных видах ошибок обработки исключений C++. В число этих ошибок включено недопустимое использование исполняющей среды, такие ошибки исполняющей среды, как сбой в получении ресурса, а также ошибки в рабочих функциях, предоставляемых задачам и группам задач. Когда задача или группа задач создает исключение, исполняющая среда хранит это исключение и маршалирует его в контекст, ожидающий завершения задачи или группы задач. Для компонентов, таких как упрощенных задач и агентов среда выполнения не управляет исключениями для вас. В этих случаях необходимо реализовать собственный механизм обработки исключений. В этом разделе описывается обработка в среде выполнения исключений, созданных задачами, группами задач, упрощенными задачами и асинхронными агентами, а также способы реагирования на исключения в приложениях.  
  
## <a name="key-points"></a>Ключевые моменты  
  
-   Когда задача или группа задач создает исключение, исполняющая среда хранит это исключение и маршалирует его в контекст, ожидающий завершения задачи или группы задач.  
  
-   Если это возможно, окружите каждый вызов [Concurrency::Task:: Get](reference/task-class.md#get) и [Concurrency::Task:: wait](reference/task-class.md#wait) с `try` / `catch` блок для обработки ошибок, которые можно восстановить От. Среда выполнения завершает приложение, если задача создает исключение и это исключение не перехватывается задачей, одним из ее продолжений или основным приложением.  
  
-   Основанное на задаче продолжение выполняется всегда вне зависимости от того, завершилась ли предыдущая задача успешно, создала исключение или была отменена. Основанное на значении продолжение не выполняется, если предыдущая задача была отменена или создала исключение.  
  
-   Поскольку основанное на задаче продолжение задачи выполняется всегда, рассмотрите возможность добавления продолжения, основанного на задаче, в конец цепочки продолжения. Это позволяет гарантировать, что код проверяет все исключения.  
  
-   Среда выполнения создает [concurrency::task_canceled](../../parallel/concrt/reference/task-canceled-class.md) при вызове [Concurrency::Task:: Get](reference/task-class.md#get) и эта задача отменена.  

  
-   Среда выполнения не управляет исключениями для легковесных задач и агентов.  
  
##  <a name="top"></a>В этом документе  
  
- [Задачи и продолжения](#tasks)  
  
- [Группы задач и параллельных алгоритмов](#task_groups)  
  
- [Исключения, создаваемые средой выполнения](#runtime)  
  
- [Несколько исключений](#multiple)  
  
- [Отмена](#cancellation)  
  
- [Упрощенные задачи](#lwts)  
  
- [Асинхронные агенты](#agents)  
  
##  <a name="tasks"></a>Задачи и продолжения  
 В этом разделе описывается, как среда выполнения обрабатывает исключения, вызываемые [concurrency::task](../../parallel/concrt/reference/task-class.md) и их продолжениями. Дополнительные сведения о модели задачи и продолжения см. в разделе [параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md).  
  
 При создании исключения в теле рабочей функции, передаваемой `task` объекта, среда выполнения хранит это исключение и маршалирует его в контекст, вызывающий [Concurrency::Task:: Get](reference/task-class.md#get) или [параллелизма:: Task::wait](reference/task-class.md#wait). Документ [параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md) описывается на основе задач и продолжения на основе значения, но чтобы итоги, основанное на значении продолжение принимает параметр типа `T` и продолжение на основе задачи с параметром типа `task<T>`. Если задача, которая создает исключение, имеет одно или несколько продолжений, основанных на значении, эти продолжения не ставятся в очередь для запуска. Это демонстрируется в приведенном ниже примере.  

  
 [!code-cpp[concrt-eh-task#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_1.cpp)]  
  
 Продолжение на основе задачи позволяет обрабатывать любое исключение, созданное предшествующей задачей. Основанное на задаче продолжение выполняется всегда вне зависимости от того, завершилась ли задача успешно, создала исключение или была отменена. Если задача создает исключение, ее продолжения на основе задач вносятся в план для выполнения. В следующем примере показана задача, которая всегда создает исключение. У задачи два продолжения: одно основано на значении, а другое — на задаче. Продолжение на основе задачи выполняется всегда и, таким образом, может перехватить исключение, созданное предшествующей задачей. Если в примере ожидается завершение обоих продолжений, исключение создается повторно, поскольку исключение задачи всегда создается при вызове `task::get` или `task::wait`.  
  
 [!code-cpp[concrt-eh-continuations#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_2.cpp)]  
  
 Рекомендуется использовать продолжения на основе задачи, чтобы перехватывать исключения, которые вы можете обработать. Поскольку основанное на задаче продолжение задачи выполняется всегда, рассмотрите возможность добавления продолжения, основанного на задаче, в конец цепочки продолжения. Это позволяет гарантировать, что код проверяет все исключения. В следующем примере показана простая цепочка продолжений на основе значений. Третья задача в цепочке создает исключение, и поэтому все последующие продолжения на основе значений не выполняются. Однако последнее продолжение основано на задаче, и поэтому всегда выполняется. Последнее продолжение обрабатывает исключение, которое создается третьей задачей.  
  
 Рекомендуется перехватывать максимально конкретные исключения. Можно опустить это последнее продолжение на основе задачи, если у вас нет определенных исключений, которые необходимо перехватывать. Любое исключение останется необработанным и может завершить приложение.  
  
 [!code-cpp[concrt-eh-task-chain#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_3.cpp)]  
  
> [!TIP]
>  Можно использовать [Concurrency::task_completion_event:: set_exception](../../parallel/concrt/reference/task-completion-event-class.md) метода можно связать исключение с событием завершения задачи. Документ [параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md) описывает [concurrency::task_completion_event](../../parallel/concrt/reference/task-completion-event-class.md) класс более подробно.  
  

 [Concurrency::task_canceled](../../parallel/concrt/reference/task-canceled-class.md) является важным типом среды выполнения исключения, связанного с `task`. Среда выполнения создает `task_canceled` при вызове `task::get`, если эта задача отменена. (И наоборот, `task::wait` возвращает [task_status::canceled](reference/concurrency-namespace-enums.md#task_group_status) и не создает исключение.) Можно перехватить и обработать данное исключение в продолжении на основе задачи или при вызове `task::get`. Дополнительные сведения об отмене задачи см. в разделе [Отмена в PPL](cancellation-in-the-ppl.md).  

  
> [!CAUTION]
>  Никогда не вызывайте исключение `task_canceled` из своего кода. Вызовите [concurrency::cancel_current_task](reference/concurrency-namespace-functions.md#cancel_current_task) вместо него.  
  
 Среда выполнения завершает приложение, если задача создает исключение и это исключение не перехватывается задачей, одним из ее продолжений или основным приложением. Если приложение аварийно завершается, можно настроить Visual Studio, чтобы прерывать выполнение при создании исключений C++. После выяснения расположения необработанного исключения используйте продолжение на основе задачи, чтобы обработать его.  
  
 Раздел [исключения средой выполнения](#runtime) в этом документе описывается работа с исключениями среды выполнения более подробно.  
  
 [[В начало](#top)]  
  
##  <a name="task_groups"></a>Группы задач и параллельных алгоритмов  

 В этом разделе описывается, как среда выполнения обрабатывает исключения, возникающие с группами задач. Этот раздел также относится к параллельным алгоритмам, таких как [concurrency::parallel_for](reference/concurrency-namespace-functions.md#parallel_for), так как эти алгоритмы используют группы задач.  
  
> [!CAUTION]
>  Убедитесь, что вы понимаете влияние исключений на зависимые задачи. Рекомендации о способах использования обработки исключений с задачами или параллельными алгоритмами см. в разделе [понимание как отмена и обработка исключений влияет на уничтожение объектов](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md#object-destruction) раздела рекомендации параллельно Раздел библиотеки шаблонов.  
  
 Дополнительные сведения о группах задач см. в разделе [параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md). Дополнительные сведения о параллельных алгоритмах см. в разделе [параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md).  

 При создании исключения в теле рабочей функции, передаваемой [concurrency::task_group](reference/task-group-class.md) или [concurrency::structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) объекта, среда выполнения хранит это исключение и маршалирует его контекст, который вызывает [Concurrency::task_group:: wait](reference/task-group-class.md#wait), [Concurrency::structured_task_group:: wait](reference/structured-task-group-class.md#wait), [Concurrency::task_group:: run_and_wait](reference/task-group-class.md#run_and_wait), или [Concurrency::structured_task_group::](reference/structured-task-group-class.md#run_and_wait). Среда выполнения также останавливает все активные задачи, которые находятся в группе задач (включая задачи дочерних групп) и удаляет любые задачи, которые еще не запущен.  

  
 Следующий пример показывает базовую структуру рабочую функцию, которая создает исключение. В этом примере `task_group` объекта для печати значения двух `point` объектов в параллельном режиме. `print_point` Рабочая функция печатает значения `point` на консоль. Рабочая функция вызывает исключение, если входное значение `NULL`. Среда выполнения хранит это исключение и маршалирует его в контекст, вызывающий `task_group::wait`.  
  
 [!code-cpp[concrt-eh-task-group#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_4.cpp)]  
  
 В этом примере формируются следующие данные:  
  
```Output  
X = 15, Y = 30Caught exception: point is NULL.  
```  
  
 Полный пример, в котором используется обработка исключений в группе задач, в разделе [как: использование обработки исключений для выхода из параллельного цикла](../../parallel/concrt/how-to-use-exception-handling-to-break-from-a-parallel-loop.md).  
  
 [[В начало](#top)]  
  
##  <a name="runtime"></a>Исключения, создаваемые средой выполнения  
 Исключение может быть результатом вызова среды выполнения. Большинство типов исключений, за исключением [concurrency::task_canceled](../../parallel/concrt/reference/task-canceled-class.md) и [concurrency::operation_timed_out](../../parallel/concrt/reference/operation-timed-out-class.md), указывают на ошибку программирования. Эти ошибки обычно устранить нельзя и таким образом не должно перехвачено и обработано в коде приложения. Мы советуем использовать только перехватывать или обрабатывать неустранимые ошибки в коде приложения, при необходимости диагностировать ошибки программирования. Однако понимание типов исключений, определенных средой выполнения может помочь диагностировать ошибки программирования.  
  
 Механизм обработки исключений для исключений, создаваемых средой выполнения как исключения, вызываемые рабочие функции одинаково. Например [concurrency::receive](reference/concurrency-namespace-functions.md#receive) создает исключение `operation_timed_out` если он не получает сообщение в заданный период времени. Если `receive` вызывает исключение в рабочую функцию, передайте в группу задач, среда выполнения хранит это исключение и маршалирует его в контекст, вызывающий `task_group::wait`, `structured_task_group::wait`, `task_group::run_and_wait`, или `structured_task_group::run_and_wait`.  
  
 В следующем примере используется [concurrency::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) алгоритм для параллельного выполнения двух задач. Первая задача ожидает в течение пяти секунд и затем отправляет сообщение в буфер сообщений. Вторая задача использует `receive` функции в течение трех секунд для получения сообщения из того же буфера сообщений. `receive` Создает исключение `operation_timed_out` , если не получает сообщение в период времени.  
  
 [!code-cpp[concrt-eh-time-out#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_5.cpp)]  
  
 В этом примере формируются следующие данные:  
  
```Output  
The operation timed out.  
```  
  
 Чтобы предотвратить ошибочное завершение работы приложения, убедитесь в том, что код обрабатывает исключения, когда вызывает среду выполнения. Также обрабатывать исключения при вызове внешнего кода, использующего среду выполнения с параллелизмом, например, библиотеки сторонних разработчиков.  
  
 [[В начало](#top)]  
  
##  <a name="multiple"></a>Несколько исключений  
 Если задача или параллельный алгоритм получает несколько исключений, среда выполнения маршалирует только один из этих исключений в вызывающий контекст. Среда выполнения не гарантирует какое исключение будет маршалировано.  
  
 В следующем примере используется `parallel_for` алгоритм для вывода чисел на консоль. Он вызывает исключение, если входное значение меньше некоторых минимальное значение или больше, чем максимальное значение. В этом примере несколькими рабочими функциями может создавать исключения.  
  
 [!code-cpp[concrt-eh-multiple#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_6.cpp)]  
  
 Ниже приведен пример выходных данных в этом примере.  
  
```Output  
8293104567Caught exception: -5: the value is less than the minimum.  
```  
  
 [[В начало](#top)]  
  
##  <a name="cancellation"></a>Отмена  
 Не все исключения указывают на ошибку. Например алгоритм поиска может использовать обработку исключений для остановки связанной задачи при нахождении результата. Дополнительные сведения об использовании механизмов отмены в коде см. в разделе [Отмена в PPL](../../parallel/concrt/cancellation-in-the-ppl.md).  
  
 [[В начало](#top)]  
  
##  <a name="lwts"></a>Упрощенные задачи  
 Упрощенная задача — это задача, планируемая непосредственно из [concurrency::Scheduler](../../parallel/concrt/reference/scheduler-class.md) объекта. Упрощенные задачи дают меньше ресурсов, чем обычные задачи. Однако среда выполнения не перехватывает исключения, вызываемые упрощенных задач. Вместо этого исключение перехватывается обработчиком необработанных исключений, который по умолчанию завершает процесс. Таким образом используйте соответствующий механизм обработки ошибок в приложении. Дополнительные сведения об упрощенных задачах см. в разделе [планировщик](../../parallel/concrt/task-scheduler-concurrency-runtime.md).  
  
 [[В начало](#top)]  
  
##  <a name="agents"></a>Асинхронные агенты  
 Как и упрощенных задач среда выполнения не управляет исключения, вызванные асинхронными агентами.  
  
 В примере показан один из способов обработки исключений в классе, который является производным от [concurrency::agent](../../parallel/concrt/reference/agent-class.md). В этом примере определяется `points_agent` класса. `points_agent::run` Метод считывает `point` объектов из буфера сообщений и выводит их на консоль. `run` Метод вызывает исключение, если он получает `NULL` указателя.  
  
 `run` Метод помещает всю работу в `try` - `catch` блока. `catch` Блок хранит исключение в буфере сообщений. Приложение проверяет ли агент обнаружил ошибку при чтении из этого буфера после завершения агента.  
  
 [!code-cpp[concrt-eh-agents#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_7.cpp)]  
  
 В этом примере формируются следующие данные:  
  
```Output  
X: 10 Y: 20  
X: 20 Y: 30  
error occurred in agent: point must not be NULL  
the status of the agent is: done  
```  
  
 Поскольку `try` - `catch` существует блок за пределами `while` цикла, агент завершает обработку при обнаружении первой ошибки. Если `try` - `catch` блок был внутри `while` цикл, агент будет продолжен после возникновения ошибки.  
  
 В этом примере исключения хранятся в буфере сообщений, чтобы другой компонент мог проверять агент на наличие ошибок во время их выполнения. В этом примере используется [concurrency::single_assignment](../../parallel/concrt/reference/single-assignment-class.md) объект для хранения ошибки. В случае, если агент обрабатывает несколько исключений `single_assignment` класс хранит только первое сообщение, передаваемое к нему. Чтобы сохранить только последнее исключение, используйте [concurrency::overwrite_buffer](../../parallel/concrt/reference/overwrite-buffer-class.md) класса. Чтобы сохранить все исключения, используйте [concurrency::unbounded_buffer](reference/unbounded-buffer-class.md) класса. Дополнительные сведения об этих блоках сообщений см. в разделе [асинхронные блоки сообщений](../../parallel/concrt/asynchronous-message-blocks.md).  
  
 Дополнительные сведения об асинхронных агентов см. в разделе [асинхронных агентов](../../parallel/concrt/asynchronous-agents.md).  
  
 [[В начало](#top)]  
  
##  <a name="summary"></a> Сводка  
 [[В начало](#top)]  
  
## <a name="see-also"></a>См. также  
 [Среда выполнения с параллелизмом](../../parallel/concrt/concurrency-runtime.md)   
 [Параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md)   
 [Параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md)   
 [Отмена в библиотеке параллельных Шаблонов](cancellation-in-the-ppl.md)   
 [Планировщик задач](../../parallel/concrt/task-scheduler-concurrency-runtime.md)   
 [Асинхронные агенты](../../parallel/concrt/asynchronous-agents.md)

