---
title: "Класс structured_task_group | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-cpp
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords:
- structured_task_group
- PPL/concurrency::structured_task_group
- PPL/concurrency::structured_task_group::structured_task_group
- PPL/concurrency::structured_task_group::cancel
- PPL/concurrency::structured_task_group::is_canceling
- PPL/concurrency::structured_task_group::run
- PPL/concurrency::structured_task_group::run_and_wait
- PPL/concurrency::structured_task_group::wait
dev_langs:
- C++
helpviewer_keywords:
- structured_task_group class
ms.assetid: 742afa8c-c7b6-482c-b0ba-04c809927b22
caps.latest.revision: 21
author: mikeblome
ms.author: mblome
manager: ghogen
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
translationtype: Machine Translation
ms.sourcegitcommit: 5faef5bd1be6cc02d6614a6f6193c74167a8ff23
ms.openlocfilehash: a1817080506150a8a25918988e18b76dd7a04def
ms.lasthandoff: 03/17/2017

---
# <a name="structuredtaskgroup-class"></a>Класс structured_task_group
Класс `structured_task_group` представляет коллекцию параллельной работы со сложной структурой. Можно поместить в очередь `structured_task_group` отдельные параллельные задачи с помощью объектов `task_handle` и ожидать их выполнения или отменить группу задач до завершения выполнения, что приведет к отмене всех задач, которые не начали выполнение.  
  
## <a name="syntax"></a>Синтаксис  
  
```
class structured_task_group;
```  
  
## <a name="members"></a>Члены  
  
### <a name="public-constructors"></a>Открытые конструкторы  
  
|Имя|Описание|  
|----------|-----------------|  
|[structured_task_group](#ctor)|Перегружен. Создает новый `structured_task_group` объекта.|  
|[~ structured_task_group деструктор](#dtor)|Уничтожает объект `structured_task_group`. Вы должны вызвать `wait` или `run_and_wait` метод на объекте до выполнения деструктора, если деструктор не выполняется в результате использования стека из-за исключения.|  
  
### <a name="public-methods"></a>Открытые методы  
  
|Имя|Описание|  
|----------|-----------------|  
|[Отмена](#cancel)|Делает все возможное пытается отменить поддерево работ, имеющее корень в данной группе задач. Все задачи, запланированные в группе задач отменяются транзитивно, если это возможно.|  
|[is_canceling](#is_canceling)|Сообщает вызывающей стороне, находится ли группа задач состоянии отмены. Это не обязательно означает, что `cancel` метод был вызван для `structured_task_group` объекта (хотя это определенно позволяет этот метод для возврата `true`). Часто бывает так, `structured_task_group` объекта выполняется встроено и одной группы задач вверх в дереве рабочих была отменена. В случаях, таких как where эти среда выполнения может определить заранее, что отмена будет передаваться через этот `structured_task_group` объекта, `true` также будут возвращены.|  
|[run](#run)|Перегружен. Планирует задачу на `structured_task_group` объект. Вызывающий объект управляет временем существования `task_handle` объект, передаваемый в `_Task_handle` параметр. Версия, которая принимает параметр `_Placement`, заставляет задачу стремиться к выполнению в расположении, указанном этим параметром.|  
|[run_and_wait](#run_and_wait)|Перегружен. Планирует задачу для выполнения встроено в вызывающий контекст с помощью `structured_task_group` объекта для поддержки полной отмены. Если `task_handle` объект передается в качестве параметра `run_and_wait`, вызывающий объект отвечает за управление временем жизни `task_handle` объекта. Функция затем ожидает, пока не будет работать на `structured_task_group` объекта будет завершена или отменена.|  
|[Ожидание](#wait)|Ожидает, пока вся работа на `structured_task_group` завершена или отменена.|  
  
## <a name="remarks"></a>Примечания  
 Существует ряд серьезные ограничения, налагаемые на использование `structured_task_group` объекта с целью повышения производительности:  
  
-   Один `structured_task_group` объект не может использоваться несколькими потоками. Все операции с `structured_task_group` должен выполнить объект потока, который создал объект. Два исключения из этого правила являются функциями-членами `cancel` и `is_canceling`. Объект не может быть в списке захвата лямбда-выражения и использоваться внутри задачи, если задача не использует одну из операций отмены.  
  
-   Все задания, запланированные для `structured_task_group` объекта планируются использования `task_handle` которого необходимо явно управлять временем жизни объектов.  
  
-   Несколько групп могут использоваться только в порядке абсолютно вложенных. Если два `structured_task_group` объектов объявляются, должен уничтожения второй объявляемого (один внутренний) перед вызовом любого метода, за исключением `cancel` или `is_canceling` вызывается в первый из них (один внешний). Это условие истинно как в случае простого объявления нескольких `structured_task_group` объектов внутри того же или функционально вложенных областей, а также в случае задачу, которая поставлено в очередь `structured_task_group` через `run` или `run_and_wait` методы.  
  
-   В отличие от общих `task_group` класса всех состояний в `structured_task_group` класса являются окончательными. После помещения задач в очередь группы и ожидания их завершения невозможно использовать ту же группу снова.  
  
 Дополнительные сведения см. в разделе [параллелизм задач](../../../parallel/concrt/task-parallelism-concurrency-runtime.md).  
  
## <a name="inheritance-hierarchy"></a>Иерархия наследования  
 `structured_task_group`  
  
## <a name="requirements"></a>Требования  
 **Заголовок:** ppl.h  
  
 **Пространство имен:** concurrency  
  
##  <a name="cancel"></a>Отмена 

 Делает все возможное пытается отменить поддерево работ, имеющее корень в данной группе задач. Все задачи, запланированные в группе задач отменяются транзитивно, если это возможно.  
  
```
void cancel();
```  
  
### <a name="remarks"></a>Примечания  
 Дополнительные сведения см. в разделе [отмены](../../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md#cancellation).  
  
##  <a name="is_canceling"></a>is_canceling 

 Сообщает вызывающей стороне, находится ли группа задач состоянии отмены. Это не обязательно означает, что `cancel` метод был вызван для `structured_task_group` объекта (хотя это определенно позволяет этот метод для возврата `true`). Часто бывает так, `structured_task_group` объекта выполняется встроено и одной группы задач вверх в дереве рабочих была отменена. В случаях, таких как where эти среда выполнения может определить заранее, что отмена будет передаваться через этот `structured_task_group` объекта, `true` также будут возвращены.  
  
```
bool is_canceling();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Указание, следует ли `structured_task_group` объекта, в процессе отмены (или гарантированно будет вскоре).  
  
### <a name="remarks"></a>Примечания  
 Дополнительные сведения см. в разделе [отмены](../../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md#cancellation).  
  
##  <a name="run"></a>Запуск 

 Планирует задачу на `structured_task_group` объект. Вызывающий объект управляет временем существования `task_handle` объект, передаваемый в `_Task_handle` параметр. Версия, которая принимает параметр `_Placement`, заставляет задачу стремиться к выполнению в расположении, указанном этим параметром.  
  
```
template<class _Function>
void run(
    task_handle<_Function>& _Task_handle);

template<class _Function>
void run(
    task_handle<_Function>& _Task_handle,
    location& _Placement);
```  
  
### <a name="parameters"></a>Параметры  
 `_Function`  
 Тип объекта функции, который будет вызываться для выполнения основной части дескриптора задачи.  
  
 `_Task_handle`  
 Дескриптор запланированных работ. Обратите внимание, что вызывающий объект отвечает за время существования этого объекта. Среда выполнения будет продолжать ожидать live пока не `wait` или `run_and_wait` на это был вызван метод `structured_task_group` объекта.  
  
 `_Placement`  
 Ссылка на расположение, в котором должна выполняться задача, представленная параметром `_Task_handle`.  
  
### <a name="remarks"></a>Примечания  
 Среда выполнения создает копию рабочей функции, передаваемый данному методу. Изменения состояния, возникающие в объект функции, который передается этому методу не появятся в копии этого объекта функции.  
  
 Если `structured_task_group` destructs в результате очистки стека из исключения, не нужно гарантировать, что вызов либо `wait` или `run_and_wait` метод. В этом случае деструктор будет соответствующим образом отменить и ожидания для задачи, представленной `_Task_handle` параметра для выполнения.  
  
 Создает [invalid_multiple_scheduling](invalid-multiple-scheduling-class.md) исключение, если задача обработки заданного `_Task_handle` параметр уже было запланировано на объект группы задач через `run` метод и без промежуточных вызовов любого `wait` или `run_and_wait` метод в этой группе задач.  
  
##  <a name="run_and_wait"></a>run_and_wait 

 Планирует задачу для выполнения встроено в вызывающий контекст с помощью `structured_task_group` объекта для поддержки полной отмены. Если `task_handle` объект передается в качестве параметра `run_and_wait`, вызывающий объект отвечает за управление временем жизни `task_handle` объекта. Функция затем ожидает, пока не будет работать на `structured_task_group` объекта будет завершена или отменена.  
  
```
template<class _Function>
task_group_status run_and_wait(task_handle<_Function>& _Task_handle);

template<class _Function>
task_group_status run_and_wait(const _Function& _Func);
```  
  
### <a name="parameters"></a>Параметры  
 `_Function`  
 Тип объекта функции, который будет вызываться для выполнения задачи.  
  
 `_Task_handle`  
 Дескриптор задачу, которая будет выполняться в контексте вызова встроенной. Обратите внимание, что вызывающий объект отвечает за время существования этого объекта. Среда выполнения будет продолжать ожидать, что он будет жить до `run_and_wait` метод завершает выполнение.  
  
 `_Func`  
 Функция, которая будет вызываться для вызова основного текста работы. Это может быть лямбда-выражение или другой объект, который поддерживает версию оператора вызова функции с сигнатурой `void operator()()`.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Индикация того, было ли выполнено ожидания или группа задач была отменена в связи с явной операцией отмены или исключение из одной из задач. Дополнительные сведения см. в разделе [task_group_status](concurrency-namespace-enums.md)  
  
### <a name="remarks"></a>Примечания  
 Обратите внимание, что один или несколько задач, запланированных на этот `structured_task_group` объекта может выполняться встроено в контекст вызова.  
  
 Если один или несколько задач, запланированных на этот `structured_task_group` объекта возникает исключение, среда выполнения будет выбрать одно такое исключение и распространить из вызова `run_and_wait` метод.  
  
 После возврата этой функции объект `structured_task_group` находится в конечном состоянии и не должен использоваться. Обратите внимание, что использование после `run_and_wait` метод возвращает приведет к неопределенному поведению.  
  
 В неисключительном пути выполнения имеется поручение вызывать этот метод или `wait` метод до деструктора `structured_task_group` выполняет.  
  
##  <a name="ctor"></a>structured_task_group 

 Создает новый `structured_task_group` объекта.  
  
```
structured_task_group();

structured_task_group(cancellation_token _CancellationToken);
```  
  
### <a name="parameters"></a>Параметры  
 `_CancellationToken`  
 Токен отмены, чтобы связать с этой группы структурированных задач. Группы структурированных задач будет отменена, когда токен отменяется.  
  
### <a name="remarks"></a>Примечания  
 Конструктор, который принимает токен отмены, создает `structured_task_group`, которая будет отменена, когда будет отменен источник, связанный с этим токеном. Предоставление явного токена отмены также изолирует эту группу структурированных задач от участия в неявной отмене из родительской группы с другим токеном или без токена.  
  
##  <a name="dtor"></a>~ structured_task_group 

 Уничтожает объект `structured_task_group`. Вы должны вызвать `wait` или `run_and_wait` метод на объекте до выполнения деструктора, если деструктор не выполняется в результате использования стека из-за исключения.  
  
```
~structured_task_group();
```  
  
### <a name="remarks"></a>Примечания  
 Если деструктор выполняется как результат обычного выполнения (например, не освобождения стека из-за исключения) и ни `wait` , ни `run_and_wait` были вызваны, деструктор может вызвать [missing_wait](missing-wait-class.md) исключение.  
  
##  <a name="wait"></a>Ожидание 

 Ожидает, пока вся работа на `structured_task_group` завершена или отменена.  
  
```
task_group_status wait();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Индикация того, было ли выполнено ожидания или группа задач была отменена в связи с явной операцией отмены или исключение из одной из задач. Дополнительные сведения см. в разделе [task_group_status](concurrency-namespace-enums.md)  
  
### <a name="remarks"></a>Примечания  
 Обратите внимание, что один или несколько задач, запланированных на этот `structured_task_group` объекта может выполняться встроено в контекст вызова.  
  
 Если один или несколько задач, запланированных на этот `structured_task_group` объекта возникает исключение, среда выполнения будет выбрать одно такое исключение и распространить из вызова `wait` метод.  
  
 После возврата этой функции объект `structured_task_group` находится в конечном состоянии и не должен использоваться. Обратите внимание, что использование после `wait` метод возвращает приведет к неопределенному поведению.  
  
 В неисключительном пути выполнения имеется поручение вызывать этот метод или `run_and_wait` метод до деструктора `structured_task_group` выполняет.  
  
## <a name="see-also"></a>См. также  
 [пространство имен Concurrency](concurrency-namespace.md)   
 [Класс task_group](task-group-class.md)   
 [Класс task_handle](task-handle-class.md)

