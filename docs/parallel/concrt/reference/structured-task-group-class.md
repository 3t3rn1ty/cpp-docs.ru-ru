---
title: "Класс structured_task_group | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-windows
ms.tgt_pltfrm: 
ms.topic: reference
f1_keywords:
- structured_task_group
- PPL/concurrency::structured_task_group
- PPL/concurrency::structured_task_group::structured_task_group
- PPL/concurrency::structured_task_group::cancel
- PPL/concurrency::structured_task_group::is_canceling
- PPL/concurrency::structured_task_group::run
- PPL/concurrency::structured_task_group::run_and_wait
- PPL/concurrency::structured_task_group::wait
dev_langs:
- C++
helpviewer_keywords:
- structured_task_group class
ms.assetid: 742afa8c-c7b6-482c-b0ba-04c809927b22
caps.latest.revision: 
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: 1f8d2b9cdc71b6e8a7a0fe9e3bf3d3d3306af1da
ms.sourcegitcommit: d51ed21ab2b434535f5c1d553b22e432073e1478
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/23/2018
---
# <a name="structuredtaskgroup-class"></a>Класс structured_task_group
Класс `structured_task_group` представляет коллекцию параллельной работы со сложной структурой. Можно поместить в очередь `structured_task_group` отдельные параллельные задачи с помощью объектов `task_handle` и ожидать их выполнения или отменить группу задач до завершения выполнения, что приведет к отмене всех задач, которые не начали выполнение.  
  
## <a name="syntax"></a>Синтаксис  
  
```
class structured_task_group;
```  
  
## <a name="members"></a>Участники  
  
### <a name="public-constructors"></a>Открытые конструкторы  
  
|Имя|Описание:|  
|----------|-----------------|  
|[structured_task_group](#ctor)|Перегружен. Создает новое `structured_task_group` объекта.|  
|[~structured_task_group Destructor](#dtor)|Уничтожает объект `structured_task_group`. Вы должны вызвать либо метод `wait` или `run_and_wait` метод на объект до выполнения деструктора, если деструктор не выполняется в результате использования стека из-за исключения.|  
  
### <a name="public-methods"></a>Открытые методы  
  
|Имя|Описание:|  
|----------|-----------------|  
|[cancel](#cancel)|Делает все возможное при попытке отменить поддерева, корнем в эту группу задач работы. Все задачи, запланированные в группе задач отменяются транзитивно, если это возможно.|  
|[is_canceling](#is_canceling)|Сообщает вызывающей стороне, находится ли группа задач состоянии отмены. Это не обязательно, `cancel` метод был вызван для `structured_task_group` объекта (хотя это определенно позволяет этот метод для возврата `true`). Он может иметь место, `structured_task_group` объекта выполняется встроено и дальнейшей группы задач вверх в дереве работы была отменена. В случаях, таких как where эти среда выполнения может определить заранее, что отмена будет передаваться через этот `structured_task_group` объекта, `true` будут также возвращены.|  
|[run](#run)|Перегружен. Планирует задачу на `structured_task_group` объекта. Вызывающий объект управляет временем существования `task_handle` переданный объект `_Task_handle` параметра. Версия, которая принимает параметр `_Placement`, заставляет задачу стремиться к выполнению в расположении, указанном этим параметром.|  
|[run_and_wait](#run_and_wait)|Перегружен. Планирует задачу для выполнения встроено в вызывающий контекст с помощью `structured_task_group` объекта для поддержки полной отмены. Если `task_handle` объект передается как параметр `run_and_wait`, вызывающий объект отвечает за управление жизненным циклом `task_handle` объекта. Функция затем ожидает, пока не работают на `structured_task_group` объекта завершена или отменена.|  
|[Ожидание](#wait)|Ожидает, пока не работают на `structured_task_group` завершена или отменена.|  
  
## <a name="remarks"></a>Примечания  
 Существует ряд серьезных ограничений на использование `structured_task_group` объекта с целью повышения производительности:  
  
-   Один `structured_task_group` объект не может использоваться несколькими потоками. Все операции в `structured_task_group` объекта должна быть выполнена пользователем потока, в котором был создан объект. Два исключения из этого правила являются функции-члены `cancel` и `is_canceling`. Объект не может быть в список передаваемых параметров лямбда-выражения и использоваться внутри задачи, если задача не использует одну из операций отмены.  
  
-   Все задания, запланированные для `structured_task_group` объекта запланированы помощью `task_handle` которого необходимо явным образом управления временем жизни объектов.  
  
-   Несколько групп могут использоваться только в порядке абсолютно вложенной. Если два `structured_task_group` объявляются объекты, второй объявляемого (внутреннее один) должны неопределенному до любого метода, за исключением `cancel` или `is_canceling` вызывается в первый (внешнее один). Это условие справедливо и в случае простого объявления нескольких `structured_task_group` объектов внутри того же или функционально вложенных областей, а также в случае задачу, которая была поставлена в очередь `structured_task_group` через `run` или `run_and_wait` методы.  
  
-   В отличие от общих `task_group` класса все состояния в `structured_task_group` класса являются окончательными. После помещения задач в очередь группы и ожидания их завершения невозможно использовать ту же группу снова.  
  
 Дополнительные сведения см. в разделе [параллелизм задач](../../../parallel/concrt/task-parallelism-concurrency-runtime.md).  
  
## <a name="inheritance-hierarchy"></a>Иерархия наследования  
 `structured_task_group`  
  
## <a name="requirements"></a>Требования  
 **Заголовок:** ppl.h  
  
 **Пространство имен:** concurrency  
  
##  <a name="cancel"></a> Отмена 

 Делает все возможное при попытке отменить поддерева, корнем в эту группу задач работы. Все задачи, запланированные в группе задач отменяются транзитивно, если это возможно.  
  
```
void cancel();
```  
  
### <a name="remarks"></a>Примечания  
 Дополнительные сведения см. в разделе [отмены](../../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md#cancellation).  
  
##  <a name="is_canceling"></a> is_canceling 

 Сообщает вызывающей стороне, находится ли группа задач состоянии отмены. Это не обязательно, `cancel` метод был вызван для `structured_task_group` объекта (хотя это определенно позволяет этот метод для возврата `true`). Он может иметь место, `structured_task_group` объекта выполняется встроено и дальнейшей группы задач вверх в дереве работы была отменена. В случаях, таких как where эти среда выполнения может определить заранее, что отмена будет передаваться через этот `structured_task_group` объекта, `true` будут также возвращены.  
  
```
bool is_canceling();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Указание, следует ли `structured_task_group` объекта, в процессе отмены (или гарантированно будет вскоре).  
  
### <a name="remarks"></a>Примечания  
 Дополнительные сведения см. в разделе [отмены](../../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md#cancellation).  
  
##  <a name="run"></a> run 

 Планирует задачу на `structured_task_group` объекта. Вызывающий объект управляет временем существования `task_handle` переданный объект `_Task_handle` параметра. Версия, которая принимает параметр `_Placement`, заставляет задачу стремиться к выполнению в расположении, указанном этим параметром.  
  
```
template<class _Function>
void run(
    task_handle<_Function>& _Task_handle);

template<class _Function>
void run(
    task_handle<_Function>& _Task_handle,
    location& _Placement);
```  
  
### <a name="parameters"></a>Параметры  
 `_Function`  
 Тип объекта функции, который будет вызываться для выполнения основной части дескриптора задачи.  
  
 `_Task_handle`  
 Дескриптор запланированных работ. Обратите внимание, что вызывающий объект несет ответственность за, в течение времени существования этого объекта. Среда выполнения будет продолжать ожидать live, пока не будет `wait` или `run_and_wait` метод был вызван в данном `structured_task_group` объекта.  
  
 `_Placement`  
 Ссылка на расположение, в котором должна выполняться задача, представленная параметром `_Task_handle`.  
  
### <a name="remarks"></a>Примечания  
 Среда выполнения создает копию рабочей функции, передаваемой в этот метод. Любые изменения состояния, которые происходят в объект функции, которая передается в этот метод не появятся в установленную копию этого объекта функции.  
  
 Если `structured_task_group` destructs в результате очистки стека из исключения, вы не обязательно должны гарантировать, что вызов был сделан с либо `wait` или `run_and_wait` метод. В этом случае деструктор будет соответствующим образом отменить и ожидания для задачи, представленной `_Task_handle` параметра для выполнения.  
  
 Создает [invalid_multiple_scheduling](invalid-multiple-scheduling-class.md) исключение, если задача обрабатывать предоставленные `_Task_handle` параметр уже было запланировано на объектом группы задач через `run` метод и без промежуточных вызовов либо `wait` или `run_and_wait` метод в этой группе задач.  
  
##  <a name="run_and_wait"></a> run_and_wait 

 Планирует задачу для выполнения встроено в вызывающий контекст с помощью `structured_task_group` объекта для поддержки полной отмены. Если `task_handle` объект передается как параметр `run_and_wait`, вызывающий объект отвечает за управление жизненным циклом `task_handle` объекта. Функция затем ожидает, пока не работают на `structured_task_group` объекта завершена или отменена.  
  
```
template<class _Function>
task_group_status run_and_wait(task_handle<_Function>& _Task_handle);

template<class _Function>
task_group_status run_and_wait(const _Function& _Func);
```  
  
### <a name="parameters"></a>Параметры  
 `_Function`  
 Тип объекта функции, который будет вызываться для выполнения задачи.  
  
 `_Task_handle`  
 Дескриптор задачу, которая будет выполняться встроенный в вызывающем контексте. Обратите внимание, что вызывающий объект несет ответственность за, в течение времени существования этого объекта. Среда выполнения будет продолжать ожидать доживают до `run_and_wait` метод завершает выполнение.  
  
 `_Func`  
 Функция, которая будет вызываться для вызова тела работу. Это может быть лямбда-выражение или другой объект, который поддерживает версию оператора вызова функции с сигнатурой `void operator()()`.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Значение, указывающее, было ли выполнено ожидания или группа задач была отменена в связи с явной операцией отмены или исключение из одного из своих задач. Дополнительные сведения см. в разделе [task_group_status](concurrency-namespace-enums.md)  
  
### <a name="remarks"></a>Примечания  
 Обратите внимание на один или несколько задач, назначенных этому `structured_task_group` объекта может выполняться встроено в вызывающий контекст.  
  
 Если один или несколько задач, назначенных этому `structured_task_group` объекта вызывает исключение, среда выполнения выбирает одно такое исключение и распространить из вызова `run_and_wait` метод.  
  
 После возврата этой функции объект `structured_task_group` находится в конечном состоянии и не должен использоваться. Обратите внимание, что использование после `run_and_wait` метод возвращает приведет к неопределенному поведению.  
  
 В пути выполнения, без поддержки исключений, у вас есть обязательные для вызова этого метода либо или `wait` метод до деструктора `structured_task_group` выполняет.  
  
##  <a name="ctor"></a> structured_task_group 

 Создает новое `structured_task_group` объекта.  
  
```
structured_task_group();

structured_task_group(cancellation_token _CancellationToken);
```  
  
### <a name="parameters"></a>Параметры  
 `_CancellationToken`  
 Токен отмены, чтобы связать с этой группы структурированных задач. Группы структурированных задач будет отменена, когда токен отменяется.  
  
### <a name="remarks"></a>Примечания  
 Конструктор, который принимает токен отмены, создает `structured_task_group`, которая будет отменена, когда будет отменен источник, связанный с этим токеном. Предоставление явного токена отмены также изолирует эту группу структурированных задач от участия в неявной отмене из родительской группы с другим токеном или без токена.  
  
##  <a name="dtor"></a> ~structured_task_group 

 Уничтожает объект `structured_task_group`. Вы должны вызвать либо метод `wait` или `run_and_wait` метод на объект до выполнения деструктора, если деструктор не выполняется в результате использования стека из-за исключения.  
  
```
~structured_task_group();
```  
  
### <a name="remarks"></a>Примечания  
 Если деструктор выполняется как результат обычного выполнения (например, не освобождения стека из-за исключения) и ни `wait` , ни `run_and_wait` методы вызываются, деструктор может вызвать [missing_wait](missing-wait-class.md) исключение.  
  
##  <a name="wait">Ожидание</a> 

 Ожидает, пока не работают на `structured_task_group` завершена или отменена.  
  
```
task_group_status wait();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Значение, указывающее, было ли выполнено ожидания или группа задач была отменена в связи с явной операцией отмены или исключение из одного из своих задач. Дополнительные сведения см. в разделе [task_group_status](concurrency-namespace-enums.md)  
  
### <a name="remarks"></a>Примечания  
 Обратите внимание на один или несколько задач, назначенных этому `structured_task_group` объекта может выполняться встроено в вызывающий контекст.  
  
 Если один или несколько задач, назначенных этому `structured_task_group` объекта вызывает исключение, среда выполнения выбирает одно такое исключение и распространить из вызова `wait` метод.  
  
 После возврата этой функции объект `structured_task_group` находится в конечном состоянии и не должен использоваться. Обратите внимание, что использование после `wait` метод возвращает приведет к неопределенному поведению.  
  
 В пути выполнения, без поддержки исключений, у вас есть обязательные для вызова этого метода либо или `run_and_wait` метод до деструктора `structured_task_group` выполняет.  
  
## <a name="see-also"></a>См. также  
 [пространство имен Concurrency](concurrency-namespace.md)   
 [Класс task_group](task-group-class.md)   
 [Класс task_handle](task-handle-class.md)
