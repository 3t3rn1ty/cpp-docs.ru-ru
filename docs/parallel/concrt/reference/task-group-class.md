Класс `task_group` представляет коллекцию параллельной работы, для которой возможно ожидание или отмена.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
class task_group;  
```  
  
## <a name="members"></a>Участники  
  
### <a name="public-constructors"></a>Открытые конструкторы  
  
|Имя|Описание|  
|----------|-----------------|  
|[task_group](#ctor)|Перегружен. Создает новое `task_group` объекта.|  
|[~ task_group деструктор](#dtor)|Уничтожает объект `task_group`. Вы должны вызвать либо метод `wait` или `run_and_wait` метод на объект до выполнения деструктора, если деструктор не выполняется в результате из-за исключения очистки стека.|  
  
### <a name="public-methods"></a>Открытые методы  
  
|Имя|Описание|  
|----------|-----------------|  
|[Отмена](#cancel)|Делает все возможное при попытке отменить поддерева, корнем в эту группу задач работы. Все задачи, запланированные в группе задач отменяются транзитивно, если это возможно.|  
|[is_canceling](#is_canceling)|Сообщает вызывающей стороне, находится ли группа задач состоянии отмены. Это не обязательно, `cancel` метод был вызван для `task_group` объекта (хотя это определенно позволяет этот метод для возврата `true`). Он может иметь место, `task_group` объекта выполняется встроено и дальнейшей группы задач вверх в дереве работы была отменена. В случаях, таких как where эти среда выполнения может определить заранее, что отмена будет передаваться через этот `task_group` объекта, `true` будут также возвращены.|  
|[run](#run)|Перегружен. Планирует задачу на `task_group` объекта. Если `task_handle` объект передается как параметр `run`, вызывающий объект отвечает за управление жизненным циклом `task_handle` объекта. Версию метода, который принимает ссылку на объект функции как параметр, включает выделение кучи внутри среды выполнения, который может быть выполнения хуже, чем версия, которая принимает ссылку с помощью `task_handle` объекта. Версия, принимающая параметр `_Placement`, заставляет задачу стремиться к выполнению в расположении, указанном этим параметром.|  
|[run_and_wait](#run_and_wait)|Перегружен. Планирует задачу для выполнения встроено в вызывающий контекст с помощью `task_group` объекта для поддержки полной отмены. Функция затем ожидает, пока не работают на `task_group` объекта завершена или отменена. Если `task_handle` объект передается как параметр `run_and_wait`, вызывающий объект отвечает за управление жизненным циклом `task_handle` объекта.|  
|[wait](#wait)|Ожидает, пока не работают на `task_group` объекта завершена или отменена.|  
  
## <a name="remarks"></a>Примечания  
 В отличие от сильно ограниченными `structured_task_group` класса `task_group` класс является намного более общие конструкции. Не имеет ограничения, описываемого [structured_task_group](structured-task-group-class.md). `task_group` объекты могут безопасно использоваться между потоками и загруженные способами произвольной формы. Недостатком `task_group` конструкция — что он не может выполнять и `structured_task_group` построения для задач, выполняющих небольшие объемы работы.  
  
 Дополнительные сведения см. в разделе [параллелизм задач](../task-parallelism-concurrency-runtime.md).  
  
## <a name="inheritance-hierarchy"></a>Иерархия наследования  
 `task_group`  
  
## <a name="requirements"></a>Требования  
 **Заголовок:** ppl.h  
  
 **Пространство имен:** concurrency  
  
##  <a name="cancel"></a> Отмена 

 Делает все возможное при попытке отменить поддерева, корнем в эту группу задач работы. Все задачи, запланированные в группе задач отменяются транзитивно, если это возможно.  
  
```  
void cancel();  
```  
  
### <a name="remarks"></a>Примечания  
 Дополнительные сведения см. в разделе [отмены](../cancellation-in-the-ppl.md).  
  
##  <a name="is_canceling"></a> is_canceling 

 Сообщает вызывающей стороне, находится ли группа задач состоянии отмены. Это не обязательно, `cancel` метод был вызван для `task_group` объекта (хотя это определенно позволяет этот метод для возврата `true`). Он может иметь место, `task_group` объекта выполняется встроено и дальнейшей группы задач вверх в дереве работы была отменена. В случаях, таких как where эти среда выполнения может определить заранее, что отмена будет передаваться через этот `task_group` объекта, `true` будут также возвращены.  
  
```  
bool is_canceling();  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Указание, следует ли `task_group` объекта, в процессе отмены (или гарантированно будет вскоре).  
  
### <a name="remarks"></a>Примечания  
 Дополнительные сведения см. в разделе [отмены](../cancellation-in-the-ppl.md).  
  
##  <a name="run"></a> Запустите 

 Планирует задачу на `task_group` объекта. Если `task_handle` объект передается как параметр `run`, вызывающий объект отвечает за управление жизненным циклом `task_handle` объекта. Версию метода, который принимает ссылку на объект функции как параметр, включает выделение кучи внутри среды выполнения, который может быть выполнения хуже, чем версия, которая принимает ссылку с помощью `task_handle` объекта. Версия, принимающая параметр `_Placement`, заставляет задачу стремиться к выполнению в расположении, указанном этим параметром.  
  
```  
template<  
   typename _Function  
>  
void run(  
   const _Function& _Func  
);  
  
template<  
   typename _Function  
>  
void run(  
   const _Function& _Func,  
   location& _Placement  
);  
  
template<  
   typename _Function  
>  
void run(  
   task_handle<_Function>& _Task_handle  
);  
  
template<  
   typename _Function  
>  
void run(  
   task_handle<_Function>& _Task_handle,  
   location& _Placement  
);  
```  
  
### <a name="parameters"></a>Параметры  
 `_Function`  
 Тип объекта функции, который будет вызываться для выполнения основной части дескриптора задачи.  
  
 `_Func`  
 Функция, которая будет вызываться для вызова тела задачи. Это может быть лямбда-выражение или другой объект, который поддерживает версию оператора вызова функции с сигнатурой `void operator()()`.  
  
 `_Placement`  
 Ссылка на расположение, в котором должна выполняться задача, представленная параметром `_Func`.  
  
 `_Task_handle`  
 Дескриптор запланированных работ. Обратите внимание, что вызывающий объект несет ответственность за, в течение времени существования этого объекта. Среда выполнения будет продолжать ожидать live, пока не будет `wait` или `run_and_wait` метод был вызван в данном `task_group` объекта.  
  
### <a name="remarks"></a>Примечания  
 Среда выполнения назначает предоставленную рабочую функцию для запуска позднее, который может быть после возврата вызывающей функции. Этот метод использует [task_handle](task-handle-class.md) объект для хранения копии предоставленную рабочую функцию. Таким образом любые изменения состояния, которые происходят в объект функции, которая передается в этот метод не появятся в установленную копию этого объекта функции. Кроме того убедитесь в том, что временем существования объектов, которые передают указатель или ссылка на функцию рабочего остаются действительными до возврата функции рабочих.  
  
 Если `task_group` destructs в результате очистки стека из исключения, вы не обязательно должны гарантировать, что вызов был сделан с либо `wait` или `run_and_wait` метод. В этом случае деструктор будет соответствующим образом отменить и ожидания для задачи, представленной `_Task_handle` параметра для выполнения.  
  
 Метод создает [invalid_multiple_scheduling](invalid-multiple-scheduling-class.md) исключение, если задача обрабатывать предоставленные `_Task_handle` параметр уже было запланировано на объектом группы задач через `run` метод и было не промежуточные вызове `wait` или `run_and_wait` метод в этой группе задач.  
  
##  <a name="run_and_wait"></a> run_and_wait 

 Планирует задачу для выполнения встроено в вызывающий контекст с помощью `task_group` объекта для поддержки полной отмены. Функция затем ожидает, пока не работают на `task_group` объекта завершена или отменена. Если `task_handle` объект передается как параметр `run_and_wait`, вызывающий объект отвечает за управление жизненным циклом `task_handle` объекта.  
  
```  
template<  
   class _Function  
>  
task_group_status run_and_wait(  
   task_handle<_Function>& _Task_handle  
);  
  
template<  
   class _Function  
>  
task_group_status run_and_wait(  
   const _Function& _Func  
);  
```  
  
### <a name="parameters"></a>Параметры  
 `_Function`  
 Тип объекта функции, который будет вызван для выполнения основной части задачи.  
  
 `_Task_handle`  
 Дескриптор задачу, которая будет выполняться встроенный в вызывающем контексте. Обратите внимание, что вызывающий объект несет ответственность за, в течение времени существования этого объекта. Среда выполнения будет продолжать ожидать доживают до `run_and_wait` метод завершает выполнение.  
  
 `_Func`  
 Функция, которая будет вызываться для вызова тела работу. Это может быть лямбда-выражение или другой объект, который поддерживает версию оператора вызова функции с сигнатурой `void operator()()`.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Значение, указывающее, было ли выполнено ожидания или группа задач была отменена в связи с явной операцией отмены или исключение из одного из своих задач. Дополнительные сведения см. в разделе [task_group_status](concurrency-namespace-enums.md#task_group_status).  

  
### <a name="remarks"></a>Примечания  
 Обратите внимание на один или несколько задач, назначенных этому `task_group` объекта может выполняться встроено в вызывающий контекст.  
  
 Если один или несколько задач, назначенных этому `task_group` объекта вызывает исключение, среда выполнения выбирает одно такое исключение и распространить из вызова `run_and_wait` метод.  
  
 После возврата из `run_and_wait` метод `task_group` объекта, среда выполнения сбрасывает объект в исходное состояние, когда он повторно. Это включает случай где `task_group` объекта была отменена.  
  
 В пути выполнения, без поддержки исключений, у вас есть обязательные для вызова этого метода либо или `wait` метод до деструктора `task_group` выполняет.  
  
##  <a name="ctor"></a> task_group 

 Создает новое `task_group` объекта.  
  
```  
task_group();  
  
task_group(  
   cancellation_token _CancellationToken  
);  
```  
  
### <a name="parameters"></a>Параметры  
 `_CancellationToken`  
 Токен отмены для связывания с этой группой задач. Группа задач будет отменена, когда будет отменен токен.  
  
### <a name="remarks"></a>Примечания  
 Конструктор, который принимает токен отмены, создает `task_group`, которая будет отменена, когда будет отменен источник, связанный с этим токеном. Предоставление явного токена отмены также изолирует эту группу задач от участия в неявной отмене из родительской группы с другим токеном или без токена.  
  
##  <a name="dtor"></a> ~ task_group 

 Уничтожает объект `task_group`. Вы должны вызвать либо метод `wait` или `run_and_wait` метод на объект до выполнения деструктора, если деструктор не выполняется в результате из-за исключения очистки стека.  
  
```  
~task_group();  
```  
  
### <a name="remarks"></a>Примечания  
 Если деструктор выполняется как результат обычного выполнения (например, не освобождения стека из-за исключения) и ни `wait` , ни `run_and_wait` методы вызываются, деструктор может вызвать [missing_wait](missing-wait-class.md) исключение.  
  
##  <a name="wait"></a> Ожидание 

 Ожидает, пока не работают на `task_group` объекта завершена или отменена.  
  
```  
task_group_status wait();  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Значение, указывающее, было ли выполнено ожидания или группа задач была отменена в связи с явной операцией отмены или исключение из одного из своих задач. Дополнительные сведения см. в разделе [task_group_status](concurrency-namespace-enums.md#task_group_status).  

  
### <a name="remarks"></a>Примечания  
 Обратите внимание на один или несколько задач, назначенных этому `task_group` объекта может выполняться встроено в вызывающий контекст.  
  
 Если один или несколько задач, назначенных этому `task_group` объекта вызывает исключение, среда выполнения выбирает одно такое исключение и распространить из вызова `wait` метод.  
  
 Вызов `wait` на `task_group` объект сбрасывает его в исходное состояние, когда он повторно. Это включает случай где `task_group` объекта была отменена.  
  
 В пути выполнения, без поддержки исключений, у вас есть обязательные для вызова этого метода либо или `run_and_wait` метод до деструктора `task_group` выполняет.  
  
## <a name="see-also"></a>См. также  
 [пространство имен Concurrency](concurrency-namespace.md)   
 [Класс structured_task_group](structured-task-group-class.md)   
 [Класс task_handle](task-handle-class.md)