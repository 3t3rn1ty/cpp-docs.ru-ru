---
title: "Класс планировщика | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-cpp
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords:
- Scheduler
- CONCRT/concurrency::Scheduler
- CONCRT/concurrency::Scheduler::Scheduler
- CONCRT/concurrency::Scheduler::Attach
- CONCRT/concurrency::Scheduler::Create
- CONCRT/concurrency::Scheduler::CreateScheduleGroup
- CONCRT/concurrency::Scheduler::GetNumberOfVirtualProcessors
- CONCRT/concurrency::Scheduler::GetPolicy
- CONCRT/concurrency::Scheduler::Id
- CONCRT/concurrency::Scheduler::IsAvailableLocation
- CONCRT/concurrency::Scheduler::Reference
- CONCRT/concurrency::Scheduler::RegisterShutdownEvent
- CONCRT/concurrency::Scheduler::Release
- CONCRT/concurrency::Scheduler::ResetDefaultSchedulerPolicy
- CONCRT/concurrency::Scheduler::ScheduleTask
- CONCRT/concurrency::Scheduler::SetDefaultSchedulerPolicy
dev_langs:
- C++
helpviewer_keywords:
- Scheduler class
ms.assetid: 34cf7961-048d-4852-8a5c-a32f823e3506
caps.latest.revision: 19
author: mikeblome
ms.author: mblome
manager: ghogen
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
translationtype: Machine Translation
ms.sourcegitcommit: 5faef5bd1be6cc02d6614a6f6193c74167a8ff23
ms.openlocfilehash: cc39a524e9a65aeab0c84fb43f5b38ddd892923e
ms.lasthandoff: 03/17/2017

---
# <a name="scheduler-class"></a>Класс Scheduler
Представляет абстракцию для планировщика среды выполнения с параллелизмом.  
  
## <a name="syntax"></a>Синтаксис  
  
```
class Scheduler;
```  
  
## <a name="members"></a>Члены  
  
### <a name="protected-constructors"></a>Защищенные конструкторы  
  
|Имя|Описание|  
|----------|-----------------|  
|[Планировщик](#ctor)|Объект `Scheduler` класса можно создавать только с помощью методов фабрики или неявно.|  
|[~ Деструктор планировщика](#dtor)|Объект `Scheduler` класс неявно уничтожается, когда все внешние ссылки на него исчезают.|  
  
### <a name="public-methods"></a>Открытые методы  
  
|Имя|Описание|  
|----------|-----------------|  
|[Attach](#attach)|Присоединяет планировщик к контексту вызова. После возврата этого метода, вызывающий контекст управляется планировщиком и планировщик становится текущим планировщиком.|  
|[Создание](#create)|Создает новый планировщик, поведение которого описывается `_Policy` параметра, помещает исходную ссылку на планировщик и возвращает указатель на него.|  
|[CreateScheduleGroup](#createschedulegroup)|Перегружен. Создает новую группу расписания в планировщике. Версия, которая принимает параметр `_Placement` вызывает задачи в пределах группы вновь созданное расписание стремиться к выполнению в расположении, указанном этим параметром.|  
|[GetNumberOfVirtualProcessors](#getnumberofvirtualprocessors)|Возвращает текущее число виртуальных процессоров для планировщика.|  
|[GetPolicy](#getpolicy)|Возвращает копию политики, был создан планировщик.|  
|[Идентификатор](#id)|Возвращает уникальный идентификатор для планировщика.|  
|[IsAvailableLocation](#isavailablelocation)|Определяет, доступно ли данное расположение в планировщике.|  
|[Ссылки](#reference)|Увеличивает значение счетчика ссылок планировщика.|  
|[RegisterShutdownEvent](#registershutdownevent)|Причины, переданный дескриптор события Windows `_Event` параметр сигнал, когда планировщик завершает работу и удаляет себя. В то время, когда событие получает сигнал вся работа, запланированная планировщику завершена. Таким способом можно зарегистрировать несколько событий завершения работы.|  
|[Релиз](#release)|Уменьшает значение счетчика ссылок планировщика.|  
|[ResetDefaultSchedulerPolicy](#resetdefaultschedulerpolicy)|Восстанавливает политику по умолчанию планировщика по умолчанию среды выполнения. Далее время создания планировщик по умолчанию будет использовать параметры политики по умолчанию среды выполнения.|  
|[ScheduleTask](#scheduletask)|Перегружен. Назначает легкое задание в планировщике. Упрощенная задача будет размещена в группе расписаний, определенной средой выполнения. Версия, принимающая параметр `_Placement`, склоняет задачу к выполнению в указанном расположении.|  
|[SetDefaultSchedulerPolicy](#setdefaultschedulerpolicy)|Позволяет политику определенную пользователем для создания планировщика по умолчанию. Этот метод может вызываться только в том случае, когда планировщик по умолчанию существует внутри процесса. После настройки политики по умолчанию остается в силе до следующего допустимого вызова либо `SetDefaultSchedulerPolicy` или [ResetDefaultSchedulerPolicy](#resetdefaultschedulerpolicy) метод.|  
  
## <a name="remarks"></a>Примечания  
 Планировщик среды выполнения с параллелизмом использует контекстов выполнения, которые сопоставляются с контекстов выполнения операционной системы, например поток, для выполнения работы в очереди в приложении. В любое время уровень параллелизма выполнения планировщика равен номеру виртуальный процессор, предоставленные ему диспетчером ресурсов. Виртуальный процессор является абстракцией для обработки ресурсов и сопоставляется с аппаратным потоком в базовой системе. В определенный момент времени только один контекст планировщика может выполняться на виртуальный процессор.  
  
 Среда выполнения с параллелизмом создаст планировщик по умолчанию на процесс для выполнения параллельной работы. В дополнение к этому можно создавать экземпляры собственного планировщика и управлять им с помощью этого класса.  
  
## <a name="inheritance-hierarchy"></a>Иерархия наследования  
 `Scheduler`  
  
## <a name="requirements"></a>Требования  
 **Заголовок:** concrt.h  
  
 **Пространство имен:** concurrency  
  
##  <a name="attach"></a>Присоединение 

 Присоединяет планировщик к контексту вызова. После возврата этого метода, вызывающий контекст управляется планировщиком и планировщик становится текущим планировщиком.  
  
```
virtual void Attach() = 0;
```  
  
### <a name="remarks"></a>Примечания  
 Присоединение планировщик неявно помещает ссылку на планировщике.  
  
 В некоторый момент в будущем, необходимо вызвать [CurrentScheduler::Detach](currentscheduler-class.md#detach) метод, чтобы разрешить завершение работы планировщика.  
  
 Если этот метод вызывается из контекста, который уже присоединен к другому планировщику, существующий планировщик запоминается как предыдущий планировщик и вновь созданный планировщик становится текущим планировщиком. При вызове `CurrentScheduler::Detach` метода позднее, предыдущий планировщик восстанавливается как текущий планировщик.  
  
 Этот метод вызывает исключение [improper_scheduler_attach](improper-scheduler-attach-class.md) исключение, если данный планировщик является текущим планировщиком вызывающего контекста.  
  
##  <a name="create"></a>Создание 

 Создает новый планировщик, поведение которого описывается `_Policy` параметра, помещает исходную ссылку на планировщик и возвращает указатель на него.  
  
```
static Scheduler* __cdecl Create(const SchedulerPolicy& _Policy);
```  
  
### <a name="parameters"></a>Параметры  
 `_Policy`  
 Политика планировщика, описывающая поведение вновь созданного планировщика.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Указатель на только что созданный планировщик. Это `Scheduler` объект имеет начальное значение счетчика ссылок к нему.  
  
### <a name="remarks"></a>Примечания  
 После создания планировщика с `Create` метод, необходимо вызвать метод `Release` метод в некоторый момент в будущем, чтобы удалить исходный значение счетчика ссылок и разрешить завершение работы планировщика.  
  
 Планировщик, созданный с помощью этого метода не присоединен к контексту вызова. Она может быть присоединена к контекста с помощью [присоединить](#attach) метод.  
  
 Этот метод можно вызвать ряд исключений, включая [scheduler_resource_allocation_error](scheduler-resource-allocation-error-class.md) и [invalid_scheduler_policy_value](invalid-scheduler-policy-value-class.md).  
  
##  <a name="createschedulegroup"></a>CreateScheduleGroup 

 Создает новую группу расписания в планировщике. Версия, которая принимает параметр `_Placement` вызывает задачи в пределах группы вновь созданное расписание стремиться к выполнению в расположении, указанном этим параметром.  
  
```
virtual ScheduleGroup* CreateScheduleGroup() = 0;

virtual ScheduleGroup* CreateScheduleGroup(location& _Placement) = 0;
```  
  
### <a name="parameters"></a>Параметры  
 `_Placement`  
 Ссылка на расположение, где задачи в пределах группы расписание будет склонна выполняться упрощенная.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Указатель на вновь созданное расписание группы. Это `ScheduleGroup` объект имеет начальное значение счетчика ссылок к нему.  
  
### <a name="remarks"></a>Примечания  
 Необходимо вызвать метод [выпуска](schedulegroup-class.md#release) метод на группу расписаний после завершения планирования работы для него. Планировщик уничтожит расписание группы, когда вся работа в очереди для его завершения.  
  
 Обратите внимание, что если явно создан данный планировщик, необходимо освободить все ссылки на группы, расписания, перед освобождением ссылок на планировщик.  
  
##  <a name="getnumberofvirtualprocessors"></a>GetNumberOfVirtualProcessors 

 Возвращает текущее число виртуальных процессоров для планировщика.  
  
```
virtual unsigned int GetNumberOfVirtualProcessors() const = 0;
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Текущее число виртуальных процессоров для планировщика.  
  
##  <a name="getpolicy"></a>GetPolicy 

 Возвращает копию политики, был создан планировщик.  
  
```
virtual SchedulerPolicy GetPolicy() const = 0;
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Копия политики, созданный планировщик.  
  
##  <a name="id"></a>Идентификатор 

 Возвращает уникальный идентификатор для планировщика.  
  
```
virtual unsigned int Id() const = 0;
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Уникальный идентификатор для планировщика.  
  
##  <a name="isavailablelocation"></a>IsAvailableLocation 

 Определяет, доступно ли данное расположение в планировщике.  
  
```
virtual bool IsAvailableLocation(const location& _Placement) const = 0;
```  
  
### <a name="parameters"></a>Параметры  
 `_Placement`  
 Ссылка на расположение для запроса о планировщике.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Индикация ли расположения, указанного параметром `_Placement` аргумент доступен в планировщике.  
  
### <a name="remarks"></a>Примечания  
 Обратите внимание, что возвращаемое значение является результатом проверки доступности указанного расположения в данный момент. При наличии нескольких планировщиков динамическое управление ресурсами может добавлять или забирать ресурсы у планировщиков в любой момент. Если это произошло, доступность заданного расположения может измениться.  
  
##  <a name="reference"></a>Ссылка 

 Увеличивает значение счетчика ссылок планировщика.  
  
```
virtual unsigned int Reference() = 0 ;
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Увеличенное счетчик.  
  
### <a name="remarks"></a>Примечания  
 Обычно используется для управления временем жизни планировщика для объединения. Когда значение счетчика ссылок планировщика снижается до нуля, планировщик завершит работу и уничтожится после завершения всей работы, указанной в планировщике.  
  
 Метод создает исключение [improper_scheduler_reference](improper-scheduler-reference-class.md) исключение, если число ссылок до вызова метода `Reference` метод равно нулю и вызов выполняется из контекста, который не принадлежит планировщику.  
  
##  <a name="registershutdownevent"></a>RegisterShutdownEvent 

 Причины, переданный дескриптор события Windows `_Event` параметр сигнал, когда планировщик завершает работу и удаляет себя. В то время, когда событие получает сигнал вся работа, запланированная планировщику завершена. Таким способом можно зарегистрировать несколько событий завершения работы.  
  
```
virtual void RegisterShutdownEvent(HANDLE _Event) = 0;
```  
  
### <a name="parameters"></a>Параметры  
 `_Event`  
 Дескриптор объекта события Windows, который будет оповещаться средой выполнения, когда планировщик завершает работу и удаляет себя.  
  
##  <a name="release"></a>Выпуск 

 Уменьшает значение счетчика ссылок планировщика.  
  
```
virtual unsigned int Release() = 0;
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Вновь уменьшается на единицу счетчик.  
  
### <a name="remarks"></a>Примечания  
 Обычно используется для управления временем жизни планировщика для объединения. Когда значение счетчика ссылок планировщика снижается до нуля, планировщик завершит работу и уничтожится после завершения всей работы, указанной в планировщике.  
  
##  <a name="resetdefaultschedulerpolicy"></a>ResetDefaultSchedulerPolicy 

 Восстанавливает политику по умолчанию планировщика по умолчанию среды выполнения. Далее время создания планировщик по умолчанию будет использовать параметры политики по умолчанию среды выполнения.  
  
```
static void __cdecl ResetDefaultSchedulerPolicy();
```  
  
### <a name="remarks"></a>Примечания  
 Этот метод может вызываться во время существования планировщика по умолчанию внутри процесса. Он не влияет на политику существующих планировщик по умолчанию. Однако если планировщик по умолчанию для завершения работы, и новое значение по умолчанию создаваться на более позднем этапе, новый планировщик будет использовать параметры политики по умолчанию среды выполнения.  
  
##  <a name="ctor"></a>Планировщик 

 Объект `Scheduler` класса можно создавать только с помощью методов фабрики или неявно.  
  
```
Scheduler();
```  
  
### <a name="remarks"></a>Примечания  
 Планировщик по умолчанию процесса создается неявно при использовании многих функций среды выполнения, для которых требуется планировщик, присоединенный к контексту вызова. Методы в `CurrentScheduler` класса и возможности PPL и уровни агентов обычно выполняют неявное вложение.  
  
 Можно также создать планировщика явно с помощью либо `CurrentScheduler::Create` метода или `Scheduler::Create` метод.  
  
##  <a name="dtor"></a>~ Планировщика 

 Объект `Scheduler` класс неявно уничтожается, когда все внешние ссылки на него исчезают.  
  
```
virtual ~Scheduler();
```  
  
##  <a name="scheduletask"></a>ScheduleTask 

 Назначает легкое задание в планировщике. Упрощенная задача будет размещена в группе расписаний, определенной средой выполнения. Версия, принимающая параметр `_Placement`, склоняет задачу к выполнению в указанном расположении.  
  
```
virtual void ScheduleTask(
    TaskProc _Proc,
    _Inout_opt_ void* _Data) = 0;

virtual void ScheduleTask(
    TaskProc _Proc,
    _Inout_opt_ void* _Data,
    location& _Placement) = 0;
```  
  
### <a name="parameters"></a>Параметры  
 `_Proc`  
 Указатель на функцию, выполняемую для выполнения тексте упрощенная задача.  
  
 `_Data`  
 Указатель void на данные, на которые будут передаваться в качестве параметра в теле задачи.  
  
 `_Placement`  
 Ссылка на расположение, где будет склонна выполняться упрощенная задача.  
  
##  <a name="setdefaultschedulerpolicy"></a>SetDefaultSchedulerPolicy 

 Позволяет политику определенную пользователем для создания планировщика по умолчанию. Этот метод может вызываться только в том случае, когда планировщик по умолчанию существует внутри процесса. После настройки политики по умолчанию остается в силе до следующего допустимого вызова либо `SetDefaultSchedulerPolicy` или [ResetDefaultSchedulerPolicy](#resetdefaultschedulerpolicy) метод.  
  
```
static void __cdecl SetDefaultSchedulerPolicy(const SchedulerPolicy& _Policy);
```  
  
### <a name="parameters"></a>Параметры  
 `_Policy`  
 Политики в качестве политики планировщика по умолчанию.  
  
### <a name="remarks"></a>Примечания  
 Если `SetDefaultSchedulerPolicy` метод вызывается, когда планировщик по умолчанию уже существует внутри процесса, среда выполнения вызывает [default_scheduler_exists](default-scheduler-exists-class.md) исключение.  
  
## <a name="see-also"></a>См. также  
 [пространство имен Concurrency](concurrency-namespace.md)   
 [Класс планировщика](scheduler-class.md)   
 [PolicyElementKey](concurrency-namespace-enums.md)   
 [Планировщик заданий](../../../parallel/concrt/task-scheduler-concurrency-runtime.md)




