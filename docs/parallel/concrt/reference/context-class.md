---
title: "Класс контекста | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords:
- Context
- CONCRT/concurrency::Context
- CONCRT/concurrency::Context::Block
- CONCRT/concurrency::Context::CurrentContext
- CONCRT/concurrency::Context::GetId
- CONCRT/concurrency::Context::GetScheduleGroupId
- CONCRT/concurrency::Context::GetVirtualProcessorId
- CONCRT/concurrency::Context::Id
- CONCRT/concurrency::Context::IsCurrentTaskCollectionCanceling
- CONCRT/concurrency::Context::IsSynchronouslyBlocked
- CONCRT/concurrency::Context::Oversubscribe
- CONCRT/concurrency::Context::ScheduleGroupId
- CONCRT/concurrency::Context::Unblock
- CONCRT/concurrency::Context::VirtualProcessorId
- CONCRT/concurrency::Context::Yield
dev_langs: C++
helpviewer_keywords: Context class
ms.assetid: c0d553f3-961d-4ecd-9a29-4fa4351673b8
caps.latest.revision: "20"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: 7a15b041f638312081417daae8c800647fbfb7d1
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="context-class"></a>Класс Context
Представляет абстракцию для контекста выполнения.  
  
## <a name="syntax"></a>Синтаксис  
  
```
class Context;
```  
  
## <a name="members"></a>Участники  
  
### <a name="protected-constructors"></a>Защищенные конструкторы  
  
|Имя|Описание:|  
|----------|-----------------|  
|[~ Деструктор контекста](#dtor)||  
  
### <a name="public-methods"></a>Открытые методы  
  
|Имя|Описание:|  
|----------|-----------------|  
|[Block](#block)|Блокирует текущий контекст.|  
|[CurrentContext](#currentcontext)|Возвращает указатель на текущий контекст.|  
|[GetId](#getid)|Возвращает идентификатор для контекста, который уникален в пределах планировщика, к которому принадлежит контекст.|  
|[GetScheduleGroupId](#getschedulegroupid)|Возвращает идентификатор для группы расписаний, контекст в настоящее время занимается.|  
|[GetVirtualProcessorId](#getvirtualprocessorid)|Возвращает идентификатор для виртуального процессора, контекст выполняется в данный момент.|  
|[Идентификатор](#id)|Возвращает идентификатор для текущего контекста, уникальный в пределах планировщик, к которой принадлежит текущий контекст.|  
|[IsCurrentTaskCollectionCanceling](#iscurrenttaskcollectioncanceling)|Возвращает значение, указывающее, следует ли коллекция задач, которая в данный момент выполняется в текущем контексте, в процессе активной отмены (или будет вскоре).|  
|[IsSynchronouslyBlocked](#issynchronouslyblocked)|Определяет, ли контекст синхронно заблокирован. Контекст считается синхронно заблокировано, если он явно выполнил действие, которое привело к блокировке.|  
|[Использовать превышение лимита подписки](#oversubscribe)|Внедряет дополнительный виртуальный процессор в планировщике до конца блока кода при вызове контекста выполнения на одном из виртуальных процессоров в данном планировщике.|  
|[ScheduleGroupId](#schedulegroupid)|Возвращает идентификатор для группы расписаний, которым работает текущий контекст.|  
|[Разблокировать](#unblock)|Разблокирует контекст и приводит к запуску.|  
|[VirtualProcessorId](#virtualprocessorid)|Возвращает идентификатор для виртуального процессора, на котором выполняется текущий контекст.|  
|[Yield](#yield)|Уступает выполнение, чтобы мог выполняться другой контекст. Если доступных контекстов для уступки выполнения нет, планировщик может уступить выполнение другому потоку операционной системы.|  
  
## <a name="remarks"></a>Примечания  
 Планировщик среды выполнения с параллелизмом (см. [планировщика](scheduler-class.md)) в очереди контекстов выполнения использует для выполнения работы в приложении. Потоком Win32 является примером контекста выполнения в операционной системе Windows.  
  
 В любое время уровень параллелизма выполнения планировщика равен номеру виртуальных процессоров, предоставленные ему диспетчером ресурсов. Виртуальный процессор является абстракцией для обработки ресурсов и сопоставляется с аппаратным потоком в базовой системе. В определенный момент времени только один контекст планировщика может выполняться на виртуальный процессор.  
  
 Планировщик выполняется совместно по своей природе и выполняемый контекст может привести его виртуальный процессор другому контексту в любое время, если он хочет перейдет в состояние ожидания. При удовлетворении его ожидания, его нельзя возобновить, пока доступный виртуальный процессор из планировщика не начнет его выполнения.  
  
## <a name="inheritance-hierarchy"></a>Иерархия наследования  
 `Context`  
  
## <a name="requirements"></a>Требования  
 **Заголовок:** concrt.h  
  
 **Пространство имен:** concurrency  
  
##  <a name="block"></a>Блок 

 Блокирует текущий контекст.  
  
```
static void __cdecl Block();
```  
  
### <a name="remarks"></a>Примечания  
 В результате этого метода в процессе будет создан планировщик по умолчанию и/или присоединен к вызывающему контексту, если отсутствует планировщик, в данный момент связанный с вызывающим контекстом.  
  
 Если вызывающий контекст выполняется на виртуальный процессор, виртуальный процессор найдет другого работоспособный контекст для выполнения или потенциально может создать новую.  
  
 После `Block` метод был вызван или будет вызываться, вы должны обеспечить с помощью вызова [Unblock](#unblock) метод из другого контекста выполнения, чтобы его можно снова запустите. Имейте в виду, что имеется критический период между точкой, где код публикует его контекст для другого потока, чтобы иметь возможность вызывать `Unblock` метод и точки, где вызов метода фактический `Block` выполняется. Во время этого периода не следует вызывать ни один метод, который может блокировать и разблокировать по своим собственным причинам (например, получение блокировки). Вызовы `Block` и `Unblock` метод не отслеживать причины блокировки и разблокирования. Только один объект должен быть владельцем `Block` -  `Unblock` пары.  
  
 Этот метод можно вызвать ряд исключений, включая [scheduler_resource_allocation_error](scheduler-resource-allocation-error-class.md).  
  
##  <a name="dtor"></a>~ Контекста 

```
virtual ~Context();
```  
  
##  <a name="currentcontext"></a>CurrentContext 

 Возвращает указатель на текущий контекст.  
  
```
static Context* __cdecl CurrentContext();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Указатель на текущий контекст.  
  
### <a name="remarks"></a>Примечания  
 В результате этого метода в процессе будет создан планировщик по умолчанию и/или присоединен к вызывающему контексту, если отсутствует планировщик, в данный момент связанный с вызывающим контекстом.  
  
##  <a name="getid"></a>GetId 

 Возвращает идентификатор для контекста, который уникален в пределах планировщика, к которому принадлежит контекст.  
  
```
virtual unsigned int GetId() const = 0;
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Идентификатор для контекста, который уникален в пределах планировщика, к которому принадлежит контекст.  
  
##  <a name="getschedulegroupid"></a>GetScheduleGroupId 

 Возвращает идентификатор для группы расписаний, контекст в настоящее время занимается.  
  
```
virtual unsigned int GetScheduleGroupId() const = 0;
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Идентификатор для группы расписаний контекст в настоящее время занимается.  
  
### <a name="remarks"></a>Примечания  
 Возвращаемое значение из этого метода является результатом группы расписаний, выполняемый в контексте. Если этот метод вызывается в контексте, отличном от текущего контекста, значение может быть устаревшим в момент возврата и полагаться на него нельзя. Как правило этот метод используется для только для целей отладки или трассировки.  
  
##  <a name="getvirtualprocessorid"></a>GetVirtualProcessorId 

 Возвращает идентификатор для виртуального процессора, контекст выполняется в данный момент.  
  
```
virtual unsigned int GetVirtualProcessorId() const = 0;
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Если контекст в данный момент на виртуальном процессоре, идентификатор виртуального процессора, контекст выполняющийся в данный момент в противном случае — значение `-1`.  
  
### <a name="remarks"></a>Примечания  
 Возвращаемое значение из этого метода является результатом виртуального процессора, выполняемый в контексте. Это значение может быть устаревшим в момент возврата, и на него нельзя полагаться. Как правило этот метод используется для только для целей отладки или трассировки.  
  
##  <a name="id"></a>Идентификатор 

 Возвращает идентификатор для текущего контекста, уникальный в пределах планировщик, к которой принадлежит текущий контекст.  
  
```
static unsigned int __cdecl Id();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Если текущий контекст присоединен к планировщик, идентификатор для текущего контекста, уникальный в пределах планировщик, к которой принадлежит текущий контекст; в противном случае — значение `-1`.  
  
##  <a name="iscurrenttaskcollectioncanceling"></a>IsCurrentTaskCollectionCanceling 

 Возвращает значение, указывающее, следует ли коллекция задач, которая в данный момент выполняется в текущем контексте, в процессе активной отмены (или будет вскоре).  
  
```
static bool __cdecl IsCurrentTaskCollectionCanceling();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Если планировщик присоединен к вызывающему контексту и группа задач выполняет задачу встроено в этом контексте, указание, следует ли группа задач, в процессе активной отмены (или будет вскоре); в противном случае — значение `false`.  
  
##  <a name="issynchronouslyblocked"></a>IsSynchronouslyBlocked 

 Определяет, ли контекст синхронно заблокирован. Контекст считается синхронно заблокировано, если он явно выполнил действие, которое привело к блокировке.  
  
```
virtual bool IsSynchronouslyBlocked() const = 0;
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Является ли контекст синхронно блокируется.  
  
### <a name="remarks"></a>Примечания  
 Контекст считается синхронно заблокировано, если он явно выполнил действие, которое привело к блокировке. В планировщике потоков это означает прямой вызов метода `Context::Block` или объекта синхронизации, который был создан с помощью метода `Context::Block`.  
  
 Возвращаемое значение из этого метода является образец ли контекст синхронно блокируется на данный момент. Это значение может быть устаревшим в момент возврата и может использоваться только в особых обстоятельствах.  
  
##  <a name="operator_delete"></a>оператор delete 

 Объект `Context` объект уничтожается внутренним образом средой выполнения. Его невозможно удалить явно.  
  
```
void operator delete(void* _PObject);
```  
  
### <a name="parameters"></a>Параметры  
 `_PObject`  
 Указатель на объект для удаления.  
  
##  <a name="oversubscribe"></a>Использовать превышение лимита подписки 

 Внедряет дополнительный виртуальный процессор в планировщике до конца блока кода при вызове контекста выполнения на одном из виртуальных процессоров в данном планировщике.  
  
```
static void __cdecl Oversubscribe(bool _BeginOversubscription);
```  
  
### <a name="parameters"></a>Параметры  
 `_BeginOversubscription`  
 Если `true`, указывает на то, что дополнительный виртуальный процессор должны быть добавлены в течение переподписки. Если `false`, указывает на то что превышение лимита подписки следует завершить, и следует удалить ранее добавленный виртуальный процессор.  
  
##  <a name="schedulegroupid"></a>ScheduleGroupId 

 Возвращает идентификатор для группы расписаний, которым работает текущий контекст.  
  
```
static unsigned int __cdecl ScheduleGroupId();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Если текущий контекст присоединен к планировщик и работает над группой расписаний, идентификатор для планировщика групп, текущий контекст работает; в противном случае — значение `-1`.  
  
##  <a name="unblock"></a>Разблокировать 

 Разблокирует контекст и приводит к запуску.  
  
```
virtual void Unblock() = 0;
```  
  
### <a name="remarks"></a>Примечания  
 Вполне допустимо для вызова `Unblock` метод произойти до соответствующего вызова [блок](#block) метод. Пока вызовы `Block` и `Unblock` методы правильно объединены в пару, среда выполнения правильно обрабатывает естественное состояние гонки любого порядка. `Unblock` Поступающих до вызова `Block` вызов просто устраняет эффект `Block` вызова.  
  
 Существует несколько исключений, которые могут создаваться из этого метода. Если контекст пытается вызвать `Unblock` метод для себя, [context_self_unblock](context-self-unblock-class.md) будет создано исключение. Если вызовы `Block` и `Unblock` объединены неправильно (например, два вызова к `Unblock` создаются в контексте, который выполняется в данный момент), [context_unblock_unbalanced](context-unblock-unbalanced-class.md) будет создано исключение.  
  
 Имейте в виду, что имеется критический период между точкой, где код публикует его контекст для другого потока, чтобы иметь возможность вызывать `Unblock` метод и точки, где вызов метода фактический `Block` выполняется. Во время этого периода не следует вызывать ни один метод, который может блокировать и разблокировать по своим собственным причинам (например, получение блокировки). Вызовы `Block` и `Unblock` метод не отслеживать причины блокировки и разблокирования. Только один объект должен быть владельцем `Block` и `Unblock` пары.  
  
##  <a name="virtualprocessorid"></a>VirtualProcessorId 

 Возвращает идентификатор для виртуального процессора, на котором выполняется текущий контекст.  
  
```
static unsigned int __cdecl VirtualProcessorId();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Если текущий контекст присоединен к планировщик, идентификатор виртуального процессора, контекст текущего выполняемого для; в противном случае — значение `-1`.  
  
### <a name="remarks"></a>Примечания  
 Возвращаемое значение из этого метода является результатом виртуального процессора, на котором выполняется текущий контекст. Это значение может быть устаревшим в момент возврата, и на него нельзя полагаться. Как правило этот метод используется для только для целей отладки или трассировки.  
  
##  <a name="yield"></a>Yield 

 Уступает выполнение, чтобы мог выполняться другой контекст. Если доступных контекстов для уступки выполнения нет, планировщик может уступить выполнение другому потоку операционной системы.  
  
```
static void __cdecl Yield();
```  
  
### <a name="remarks"></a>Примечания  
 В результате этого метода в процессе будет создан планировщик по умолчанию и/или присоединен к вызывающему контексту, если отсутствует планировщик, в данный момент связанный с вызывающим контекстом.  
  
##  <a name="yieldexecution"></a>YieldExecution 

 Уступает выполнение, чтобы мог выполняться другой контекст. Если доступных контекстов для уступки выполнения нет, планировщик может уступить выполнение другому потоку операционной системы.  
  
```
static void __cdecl YieldExecution();
```  
  
### <a name="remarks"></a>Примечания  
 В результате этого метода в процессе будет создан планировщик по умолчанию и/или присоединен к вызывающему контексту, если отсутствует планировщик, в данный момент связанный с вызывающим контекстом.  
  
 Эта функция представляет новые возможности [!INCLUDE[vs_dev14](../../../ide/includes/vs_dev14_md.md)] и идентичен [Yield](#yield) работать, но не конфликтует с макросом Yield в Windows.h.  
  
## <a name="see-also"></a>См. также  
 [пространство имен Concurrency](concurrency-namespace.md)   
 [Класс Scheduler](scheduler-class.md)   
 [Планировщик задач](../../../parallel/concrt/task-scheduler-concurrency-runtime.md)



