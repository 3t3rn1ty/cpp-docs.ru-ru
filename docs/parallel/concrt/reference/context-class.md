---
title: "Класс контекста | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords:
- Context
- CONCRT/concurrency::Context
- CONCRT/concurrency::Context::Block
- CONCRT/concurrency::Context::CurrentContext
- CONCRT/concurrency::Context::GetId
- CONCRT/concurrency::Context::GetScheduleGroupId
- CONCRT/concurrency::Context::GetVirtualProcessorId
- CONCRT/concurrency::Context::Id
- CONCRT/concurrency::Context::IsCurrentTaskCollectionCanceling
- CONCRT/concurrency::Context::IsSynchronouslyBlocked
- CONCRT/concurrency::Context::Oversubscribe
- CONCRT/concurrency::Context::ScheduleGroupId
- CONCRT/concurrency::Context::Unblock
- CONCRT/concurrency::Context::VirtualProcessorId
- CONCRT/concurrency::Context::Yield
dev_langs:
- C++
helpviewer_keywords:
- Context class
ms.assetid: c0d553f3-961d-4ecd-9a29-4fa4351673b8
caps.latest.revision: 20
author: mikeblome
ms.author: mblome
manager: ghogen
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: Machine Translation
ms.sourcegitcommit: 5faef5bd1be6cc02d6614a6f6193c74167a8ff23
ms.openlocfilehash: fd6f59e1e94329ef73e8fdbe946ec22241815e2e
ms.contentlocale: ru-ru
ms.lasthandoff: 03/17/2017

---
# <a name="context-class"></a>Класс Context
Представляет абстракцию для контекста выполнения.  
  
## <a name="syntax"></a>Синтаксис  
  
```
class Context;
```  
  
## <a name="members"></a>Члены  
  
### <a name="protected-constructors"></a>Защищенные конструкторы  
  
|Имя|Описание|  
|----------|-----------------|  
|[~ Деструктор контекста](#dtor)||  
  
### <a name="public-methods"></a>Открытые методы  
  
|Имя|Описание|  
|----------|-----------------|  
|[Block](#block)|Блокирует текущий контекст.|  
|[CurrentContext](#currentcontext)|Возвращает указатель на текущий контекст.|  
|[GetId](#getid)|Возвращает идентификатор для контекста, уникальный в пределах планировщик, к которому принадлежит контекст.|  
|[GetScheduleGroupId](#getschedulegroupid)|Возвращает идентификатор для группы расписаний, контекст в настоящее время занимается.|  
|[GetVirtualProcessorId](#getvirtualprocessorid)|Возвращает идентификатор для виртуального процессора, контекст выполняется в данный момент.|  
|[Идентификатор](#id)|Возвращает идентификатор для текущего контекста, уникальный в пределах планировщик, к которому принадлежит текущий контекст.|  
|[IsCurrentTaskCollectionCanceling](#iscurrenttaskcollectioncanceling)|Возвращает значение, указывающее, следует ли коллекция задач, которая выполняется в данный момент встроено в текущем контексте, в процессе активной отмены (или будет вскоре).|  
|[IsSynchronouslyBlocked](#issynchronouslyblocked)|Определяет ли контекст синхронно блокироваться. Контекст считается синхронно блокированным, если он явно выполнил действие, которое привело к блокировке.|  
|[Использовать превышение лимита подписки](#oversubscribe)|Внедряет дополнительный виртуальный процессор в планировщике до конца блока кода при вызове контекста выполнения на одном из виртуальных процессоров в данном планировщике.|  
|[ScheduleGroupId](#schedulegroupid)|Возвращает идентификатор для группы расписаний, занимается текущего контекста.|  
|[Разблокировать](#unblock)|Разблокирует контекст и приводит к запуску.|  
|[VirtualProcessorId](#virtualprocessorid)|Возвращает идентификатор для виртуального процессора, выполняемый в текущий контекст.|  
|[Yield](#yield)|Уступает выполнение, чтобы мог выполняться другой контекст. Если доступных контекстов для уступки выполнения нет, планировщик может уступить выполнение другому потоку операционной системы.|  
  
## <a name="remarks"></a>Примечания  
 Планировщик среды выполнения с параллелизмом (см. [планировщика](scheduler-class.md)) в очереди контекстов выполнения использует для выполнения работы в приложении. Поток Win32 является примером контекста выполнения в операционной системе Windows.  
  
 В любое время уровень параллелизма выполнения планировщика равен номеру виртуальных процессоров, предоставленные ему диспетчером ресурсов. Виртуальный процессор является абстракцией для обработки ресурсов и сопоставляется с аппаратным потоком в базовой системе. В определенный момент времени только один контекст планировщика может выполняться на виртуальный процессор.  
  
 Планировщик выполняется совместно по своей природе и исполняющий контекст можно передать его виртуальный процессор другому контексту в любое время, если он хочет войти в состояния ожидания. При удовлетворении его ожидания, он не может возобновиться пока доступный виртуальный процессор из планировщика не начнет его выполнением.  
  
## <a name="inheritance-hierarchy"></a>Иерархия наследования  
 `Context`  
  
## <a name="requirements"></a>Требования  
 **Заголовок:** concrt.h  
  
 **Пространство имен:** concurrency  
  
##  <a name="block"></a>Блок 

 Блокирует текущий контекст.  
  
```
static void __cdecl Block();
```  
  
### <a name="remarks"></a>Примечания  
 В результате этого метода в процессе будет создан планировщик по умолчанию и/или присоединен к вызывающему контексту, если отсутствует планировщик, в данный момент связанный с вызывающим контекстом.  
  
 Если вызывающий контекст выполняется на виртуальный процессор, виртуальный процессор найдет другого работоспособный контекст для выполнения или потенциально может создать новый.  
  
 После `Block` метод был вызван или будет вызываться, вы должны сопоставить с помощью вызова [разблокировать](#unblock) метод из другого контекста выполнения, чтобы он снова запустить. Имейте в виду, что существует критический период между точкой, где код публикует его контекст для другого потока, который может вызвать `Unblock` метод и точки, где вызов фактического метода `Block` выполняется. Во время этого периода не следует вызывать ни один метод, который может блокировать и разблокировать по своим собственным причинам (например, получение блокировки). Вызовы `Block` и `Unblock` метод не отслеживают причины блокировки и разблокирования. Только один объект должен быть владельцем `Block` -  `Unblock` пары.  
  
 Этот метод можно вызвать ряд исключений, включая [scheduler_resource_allocation_error](scheduler-resource-allocation-error-class.md).  
  
##  <a name="dtor"></a>~ Контекста 

```
virtual ~Context();
```  
  
##  <a name="currentcontext"></a>CurrentContext 

 Возвращает указатель на текущий контекст.  
  
```
static Context* __cdecl CurrentContext();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Указатель на текущий контекст.  
  
### <a name="remarks"></a>Примечания  
 В результате этого метода в процессе будет создан планировщик по умолчанию и/или присоединен к вызывающему контексту, если отсутствует планировщик, в данный момент связанный с вызывающим контекстом.  
  
##  <a name="getid"></a>GetId 

 Возвращает идентификатор для контекста, уникальный в пределах планировщик, к которому принадлежит контекст.  
  
```
virtual unsigned int GetId() const = 0;
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Идентификатор контекста, уникальный в пределах планировщик, к которому принадлежит контекст.  
  
##  <a name="getschedulegroupid"></a>GetScheduleGroupId 

 Возвращает идентификатор для группы расписаний, контекст в настоящее время занимается.  
  
```
virtual unsigned int GetScheduleGroupId() const = 0;
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Идентификатор для группы расписаний контекста в настоящее время работает над.  
  
### <a name="remarks"></a>Примечания  
 Возвращаемое значение из этого метода является результатом проверки группы планирования, выполняемый в контексте. Если этот метод вызывается в контексте, отличном от текущего контекста, значение может быть устаревшим в момент возврата и полагаться на него нельзя. Как правило этот метод используется для только для целей отладки или трассировки.  
  
##  <a name="getvirtualprocessorid"></a>GetVirtualProcessorId 

 Возвращает идентификатор для виртуального процессора, контекст выполняется в данный момент.  
  
```
virtual unsigned int GetVirtualProcessorId() const = 0;
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Если контекст в данный момент на виртуальном процессоре, идентификатор виртуального процессора, контекст выполняющийся в данный момент в противном случае — значение `-1`.  
  
### <a name="remarks"></a>Примечания  
 Возвращаемое значение из этого метода является результатом проверки виртуального процессора, выполняемый в контексте. Это значение может быть устаревшим в момент возврата, и на него нельзя полагаться. Как правило этот метод используется для только для целей отладки или трассировки.  
  
##  <a name="id"></a>Идентификатор 

 Возвращает идентификатор для текущего контекста, уникальный в пределах планировщик, к которому принадлежит текущий контекст.  
  
```
static unsigned int __cdecl Id();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Если текущий контекст присоединен к планировщик, идентификатор для текущего контекста, уникальный в пределах планировщик, к которому принадлежит текущий контекст; в противном случае — значение `-1`.  
  
##  <a name="iscurrenttaskcollectioncanceling"></a>IsCurrentTaskCollectionCanceling 

 Возвращает значение, указывающее, следует ли коллекция задач, которая выполняется в данный момент встроено в текущем контексте, в процессе активной отмены (или будет вскоре).  
  
```
static bool __cdecl IsCurrentTaskCollectionCanceling();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Если планировщик присоединен к вызывающему контексту и группа задач выполняет задачу встроено в данный контекст, указывающее, находится ли этой группе задач, в процессе активной отмены (или будет вскоре); в противном случае — значение `false`.  
  
##  <a name="issynchronouslyblocked"></a>IsSynchronouslyBlocked 

 Определяет ли контекст синхронно блокироваться. Контекст считается синхронно блокированным, если он явно выполнил действие, которое привело к блокировке.  
  
```
virtual bool IsSynchronouslyBlocked() const = 0;
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Является ли контекст синхронно блокируется.  
  
### <a name="remarks"></a>Примечания  
 Контекст считается синхронно блокированным, если он явно выполнил действие, которое привело к блокировке. В планировщике потоков это означает прямой вызов метода `Context::Block` или объекта синхронизации, который был создан с помощью метода `Context::Block`.  
  
 Возвращаемое значение из этого метода является образец ли контекст синхронно блокировка на данный момент. Это значение может быть устаревшим в момент возврата и может использоваться только в особых обстоятельствах.  
  
##  <a name="operator_delete"></a>оператор delete 

 Объект `Context` объект уничтожается внутренне средой выполнения. Его невозможно удалить явно.  
  
```
void operator delete(void* _PObject);
```  
  
### <a name="parameters"></a>Параметры  
 `_PObject`  
 Указатель на объект для удаления.  
  
##  <a name="oversubscribe"></a>Использовать превышение лимита подписки 

 Внедряет дополнительный виртуальный процессор в планировщике до конца блока кода при вызове контекста выполнения на одном из виртуальных процессоров в данном планировщике.  
  
```
static void __cdecl Oversubscribe(bool _BeginOversubscription);
```  
  
### <a name="parameters"></a>Параметры  
 `_BeginOversubscription`  
 Если `true`, указывает на то, что дополнительный виртуальный процессор должны быть добавлены в течение переподписки. Если `false`, указывает на то что превышение лимита подписки следует завершить и ранее добавленный виртуальный процессор должны быть удалены.  
  
##  <a name="schedulegroupid"></a>ScheduleGroupId 

 Возвращает идентификатор для группы расписаний, занимается текущего контекста.  
  
```
static unsigned int __cdecl ScheduleGroupId();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Если текущий контекст присоединен к планировщик и работает над группой расписаний, идентификатор для планировщика группу, текущий контекст работает; в противном случае — значение `-1`.  
  
##  <a name="unblock"></a>Разблокировать 

 Разблокирует контекст и приводит к запуску.  
  
```
virtual void Unblock() = 0;
```  
  
### <a name="remarks"></a>Примечания  
 Вполне допустимо для вызова `Unblock` метод произойти до соответствующего вызова [блок](#block) метод. При условии, что вызовы `Block` и `Unblock` методов правильно объединены в пару, среда выполнения правильно обрабатывает естественное состояние гонки любого порядка. `Unblock` Поступающих до вызова `Block` вызов просто устраняет эффект `Block` вызова.  
  
 Существует несколько исключений, которые могут создаваться из этого метода. Если контекст пытается вызвать `Unblock` метод для себя, [context_self_unblock](context-self-unblock-class.md) будет создано исключение. Если вызовы `Block` и `Unblock` объединены неправильно (например, два вызова к `Unblock` для контекста, который выполняется в данный момент выполняется), [context_unblock_unbalanced](context-unblock-unbalanced-class.md) будет создано исключение.  
  
 Имейте в виду, что существует критический период между точкой, где код публикует его контекст для другого потока, который может вызвать `Unblock` метод и точки, где вызов фактического метода `Block` выполняется. Во время этого периода не следует вызывать ни один метод, который может блокировать и разблокировать по своим собственным причинам (например, получение блокировки). Вызовы `Block` и `Unblock` метод не отслеживают причины блокировки и разблокирования. Только один объект должен быть владельцем `Block` и `Unblock` пары.  
  
##  <a name="virtualprocessorid"></a>VirtualProcessorId 

 Возвращает идентификатор для виртуального процессора, выполняемый в текущий контекст.  
  
```
static unsigned int __cdecl VirtualProcessorId();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Если текущий контекст присоединен к планировщик, идентификатор виртуального процессора, выполняющего текущий контекст; в в противном случае — значение `-1`.  
  
### <a name="remarks"></a>Примечания  
 Возвращаемое значение из этого метода является результатом проверки виртуального процессора, выполняемый в текущий контекст. Это значение может быть устаревшим в момент возврата, и на него нельзя полагаться. Как правило этот метод используется для только для целей отладки или трассировки.  
  
##  <a name="yield"></a>Yield 

 Уступает выполнение, чтобы мог выполняться другой контекст. Если доступных контекстов для уступки выполнения нет, планировщик может уступить выполнение другому потоку операционной системы.  
  
```
static void __cdecl Yield();
```  
  
### <a name="remarks"></a>Примечания  
 В результате этого метода в процессе будет создан планировщик по умолчанию и/или присоединен к вызывающему контексту, если отсутствует планировщик, в данный момент связанный с вызывающим контекстом.  
  
##  <a name="yieldexecution"></a>YieldExecution 

 Уступает выполнение, чтобы мог выполняться другой контекст. Если доступных контекстов для уступки выполнения нет, планировщик может уступить выполнение другому потоку операционной системы.  
  
```
static void __cdecl YieldExecution();
```  
  
### <a name="remarks"></a>Примечания  
 В результате этого метода в процессе будет создан планировщик по умолчанию и/или присоединен к вызывающему контексту, если отсутствует планировщик, в данный момент связанный с вызывающим контекстом.  
  
 Эта функция представляет новые возможности [!INCLUDE[vs_dev14](../../../ide/includes/vs_dev14_md.md)] и идентичен [Yield](#yield) работать, но не конфликтует с макросом Yield в файле Windows.h.  
  
## <a name="see-also"></a>См. также  
 [пространство имен Concurrency](concurrency-namespace.md)   
 [Класс планировщика](scheduler-class.md)   
 [Планировщик заданий](../../../parallel/concrt/task-scheduler-concurrency-runtime.md)




