---
title: "Библиотека параллельных шаблонов | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "Библиотека параллельных шаблонов"
ms.assetid: 40fd86b2-69fa-45e5-93d8-98a75636c242
caps.latest.revision: 27
caps.handback.revision: 27
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Библиотека параллельных шаблонов
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

Библиотека параллельных шаблонов (PPL) предоставляет императивную модель программирования, обеспечивающую масштабируемость и повышающую удобство разработки параллельных приложений. Библиотека PPL основана на компонентах планирования и управления ресурсами среды выполнения с параллелизмом. Она создает уровень абстракции между кодом приложения и базовым потоковым механизмом, предоставляя универсальные типобезопасные алгоритмы и контейнеры, работающие с данными параллельно. Кроме того, PPL позволяет разрабатывать приложения с возможностью масштабирования, предоставляя альтернативы состоянию с общим доступом.  
  
 PPL обеспечивает следующие возможности.  
  
- *Параллелизм задач*: механизм, который работает поверх ThreadPool Windows для параллельного выполнения нескольких рабочих элементов (задач)  
  
- *Параллельные алгоритмы*: универсальные алгоритмы, которые работает поверх среда выполнения с параллелизмом для работы с коллекциями данных в параллельном режиме  
  
- *Параллельные контейнеры и объекты*: универсальные типы контейнеров, предоставляющие безопасный одновременный доступ к элементам  
  
## <a name="example"></a>Пример  
 PPL предоставляет модель программирования, схожую с библиотекой стандартных шаблонов (STL). В следующем примере показаны различные функции PPL. В нем последовательно и параллельно вычисляется несколько чисел Фибоначчи. Оба вычисления работают с [std::array](../../standard-library/array-class-stl.md) объекта. В этом примере в консоль также выводится время, необходимое на выполнение обоих вычислений.  
  
 STL использует последовательную версию [std::for_each](../Topic/for_each.md) для прохождения массива алгоритм и сохраняет результаты в [std::vector](vector%20Class.md) объекта. Параллельная версия выполняет ту же задачу, но использует PPL [concurrency::parallel_for_each](../Topic/parallel_for_each%20Function.md) алгоритм и сохраняет результаты в [concurrency::concurrent_vector](../../parallel/concrt/reference/concurrent-vector-class.md) объекта. Класс `concurrent_vector` позволяет каждой итерации цикла одновременно добавлять элементы, не требуя синхронизации доступа на запись в контейнер.  
  
 Поскольку `parallel_for_each` действует одновременно, версия программы для параллельного вычисления, используемая в данном примере, должна выполнить сортировку объекта `concurrent_vector`, чтобы получить те же результаты, что и версия программы для последовательного вычисления.  
  
 Обратите внимание, что в примере используется упрощенный метод вычисления чисел Фибоначчи, однако этот метод показывает, как с помощью среды выполнения с параллелизмом можно повысить производительность системы при выполнении длинных вычислений.  
  
 [!code-cpp[concrt-parallel-fibonacci#1](../../parallel/concrt/codesnippet/CPP/parallel-patterns-library-ppl_1.cpp)]  
  
 В следующем примере показаны выходные данные, полученные на четырехпроцессорном компьютере.  
  
```Output  
serial time: 9250 ms  
parallel time: 5726 ms  
 
fib(24): 46368  
fib(26): 121393  
fib(41): 165580141  
fib(42): 267914296  
```  
  
 Все итерации цикла различаются по продолжительности. Производительность `parallel_for_each` ограничивается операцией, которая завершается последней. Следовательно, не стоит ожидать линейного повышения производительности системы в зависимости от версий, используемых в данном примере (для последовательных и параллельных вычислений).  
  
## <a name="related-topics"></a>См. также  
  
|Заголовок|Описание|  
|-----------|-----------------|  
|[Параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md)|Описывает роль задач и групп задач в PPL.|  
|[Параллельные алгоритмы](../Topic/Parallel%20Algorithms.md)|Описывает способы использования алгоритмов параллельной обработки, таких как `parallel_for` и `parallel_for_each`.|  
|[Параллельные контейнеры и объекты](../../parallel/concrt/parallel-containers-and-objects.md)|Описывает различные параллельные контейнеры и объекты, предоставляемые PPL.|  
|[Отмена](../Topic/Exception%20Handling%20in%20the%20Concurrency%20Runtime.md#cancellation_in_the_ppl)|Объясняет, как отменить работу, выполняемую алгоритмом параллельной обработки.|  
|[Среда выполнения с параллелизмом](../../parallel/concrt/concurrency-runtime.md)|Описывает среду выполнения с параллелизмом, которая упрощает процесс параллельного программирования и содержит ссылки на соответствующие разделы.|

