---
title: "Практическое руководство. Использование групп планирования для определения порядка выполнения | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "группы расписаний, использование [среда выполнения с параллелизмом]"
  - "использование групп расписаний [среда выполнения с параллелизмом]"
ms.assetid: 73124194-fc3a-491e-a23f-fbd7b5a4455c
caps.latest.revision: 15
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 12
---
# Практическое руководство. Использование групп планирования для определения порядка выполнения
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

В среде выполнения с параллелизмом порядок планирования задач не является определяющим.  Однако для изменения порядка выполнения задач можно использовать политики планирования.  В этом разделе показано, как использовать группы расписаний совместно с политикой планировщика [concurrency::SchedulingProtocol](../Topic/PolicyElementKey%20Enumeration.md) для определения порядка выполнения задач.  
  
 В этом примере набор задач выполняется дважды с двумя разными политиками планирования.  Обе политики ограничивают максимальное число ресурсов обработки двумя.  При первом выполнении используется политика `EnhanceScheduleGroupLocality`  \(по умолчанию\), а при втором — политика `EnhanceForwardProgress`.  В условиях политики `EnhanceScheduleGroupLocality` планировщик выполняет все задачи в одной группе расписаний, пока не будут завершены или переданы все задачи.  В условиях политики `EnhanceForwardProgress` планировщик переходит к следующей группе расписаний методом циклического перебора после завершения или передачи каждой задачи.  
  
 Если каждая группа расписаний содержит связанные задачи, политика `EnhanceScheduleGroupLocality`, как правило, позволяет повысить производительность, так как расположение кэша при выполнении всех задач сохраняется.  Политика `EnhanceForwardProgress` позволяет продвигаться вперед с выполнением задач, ее полезно использовать, если необходимо равноправное планирование в разных группах расписаний.  
  
## Пример  
 В этом примере определяется класс `work_yield_agent`, наследуемый от [concurrency::agent](../../parallel/concrt/reference/agent-class.md).  Класс `work_yield_agent` выполняет блок работы, возвращает текущий контекст, затем выполняет еще один блок работы.  Агент использует функцию [concurrency::wait](../Topic/wait%20Function.md) для совместной передачи текущего контекста, чтобы обеспечить возможность выполнения других контекстов.  
  
 В этом примере создается четыре объекта `work_yield_agent`.  Чтобы проиллюстрировать, как задавать политики планировщика для определения порядка выполнения агентов, в этом примере первые два агента связываются с одной группой расписаний, а другие два — с другой.  В этом примере метод [concurrency::CurrentScheduler::CreateScheduleGroup](../Topic/CurrentScheduler::CreateScheduleGroup%20Method.md) используется для создания объектов [concurrency::ScheduleGroup](../Topic/ScheduleGroup%20Class.md).  В этом примере все четыре агента выполняются дважды с двумя разными политиками планирования.  
  
 [!code-cpp[concrt-scheduling-protocol#1](../../parallel/concrt/codesnippet/CPP/how-to-use-schedule-groups-to-influence-order-of-execution_1.cpp)]  
  
 В результате выполнения примера получается следующий результат:  
  
  **Использование EnhanceScheduleGroupLocality…**  
**группа 0, задача 0: первый цикл…**  
**группа 0, задача 1: первый цикл…**  
**группа 0, задача 0: ожидание…**  
**группа 1, задача 0: первый цикл…**  
**группа 0, задача 1: ожидание…**  
**группа 1, задача 1: первый цикл…**  
**группа 1, задача 0: ожидание…**  
**группа 0, задача 0: второй цикл…**  
**группа 1, задача 1: ожидание…**  
**группа 0, задача 1: второй цикл…**  
**группа 0, задача 0: готово…**  
**группа 1, задача 0: второй цикл…**  
**группа 0, задача 1: готово…**  
**группа 1, задача 1: второй цикл…**  
**группа 1, задача 0: готово…**  
**группа 1, задача 1: готово…**  
**Использование EnhanceForwardProgress…**  
**группа 0, задача 0: первый цикл…**  
**группа 1, задача 0: первый цикл…**  
**группа 0, задача 0: ожидание…**  
**группа 0, задача 1: первый цикл…**  
**группа 1, задача 0: ожидание…**  
**группа 1, задача 1: первый цикл…**  
**группа 0, задача 1: ожидание…**  
**группа 0, задача 0: второй цикл…**  
**группа 1, задача 1: ожидание…**  
**группа 1, задача 0: второй цикл…**  
**группа 0, задача 0: готово…**  
**группа 0, задача 1: второй цикл…**  
**группа 1, задача 0: готово…**  
**группа 1, задача 1: второй цикл…**  
**группа 0, задача 1: готово…**  
**группа 1, задача 1: готово…** Обе политики создают одну и ту же последовательность событий.  Однако политика, которая использует `EnhanceScheduleGroupLocality`, запускает оба агента первой группы планирования, прежде чем будут запущены агенты второй группы.  Политика, использующая `EnhanceForwardProgress`, запускает один агент из первой группы, затем запускает первый агент во второй группе.  
  
## Компиляция кода  
 Скопируйте код примера и вставьте его в проект Visual Studio или файл с именем `scheduling-protocol.cpp`, затем выполните в окне командной строки Visual Studio следующую команду.  
  
 **cl.exe \/EHsc scheduling\-protocol.cpp**  
  
## См. также  
 [Группы расписаний](../../parallel/concrt/schedule-groups.md)   
 [Асинхронные агенты](../../parallel/concrt/asynchronous-agents.md)