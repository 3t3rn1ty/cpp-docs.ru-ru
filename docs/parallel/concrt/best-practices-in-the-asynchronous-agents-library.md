---
title: "Советы и рекомендации в библиотеке асинхронных агентов | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
helpviewer_keywords:
- best practices, Asynchronous Agents Library
- Asynchronous Agents Library, best practices
- Asynchronous Agents Library, practices to avoid
- practices to avoid, Asynchronous Agents Library
ms.assetid: 85f52354-41eb-4b0d-98c5-f7344ee8a8cf
caps.latest.revision: "15"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.openlocfilehash: 15e4b6aca6d9f00806a37a04ffb7c93008125b6a
ms.sourcegitcommit: ebec1d449f2bd98aa851667c2bfeb7e27ce657b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/24/2017
---
# <a name="best-practices-in-the-asynchronous-agents-library"></a>Рекомендации по работе с библиотекой асинхронных агентов
Этот документ описывает, как эффективно использовать библиотеки асинхронных агентов. Библиотека агентов поддерживает модель программирования на основе субъектов и в процессе передачи сообщений для недетализированного потока данных и задач по конвейеризации.  
  
 Дополнительные сведения о библиотеке агентов см. в разделе [библиотеки асинхронных агентов](../../parallel/concrt/asynchronous-agents-library.md).  
  
##  <a name="top"></a> Разделы  
 Этот документ содержит следующие разделы.  
  
- [Используйте агенты для изолирования состояния](#isolation)  
  
- [Используйте механизм регулирования для ограничения числа сообщений в конвейере данных](#throttling)  
  
- [Не выполняйте детализированную работу в конвейере данных](#fine-grained)  
  
- [Не передавайте большие полезные нагрузки сообщений по значению](#large-payloads)  
  
- [Использовать данные сети при владения является неопределенным shared_ptr](#ownership)  
  
##  <a name="isolation"></a>Используйте агенты для изолирования состояния  
 Библиотека агентов предоставляет альтернативы общему состоянию, позволяя подключать изолированные компоненты через механизм асинхронной передачи сообщений. Асинхронные агенты наиболее эффективны, когда они изолировать их внутреннее состояние от других компонентов. При изоляции состояний несколько компонентов обычно не работают с общими данными. Изоляция состояния позволяет приложению масштабироваться, так как это снижает конкуренцию за общей памяти. Изоляция состояния также снижает вероятность возникновения взаимоблокировок и состояния гонки, так как компоненты не имеют для синхронизации доступа к общим данным.  
  
 Обычно, чтобы изолировать состояние агента, удерживая элементов данных в `private` или `protected` разделах класса агента и использовать буферы сообщений, чтобы сообщать об изменениях состояния. В следующем примере показан `basic_agent` класс, который является производным от [concurrency::agent](../../parallel/concrt/reference/agent-class.md). `basic_agent` Класс использует два буфера сообщений для взаимодействия с внешними компонентами. Один буфер сообщений содержит входящие сообщения; буфер сообщений — исходящие сообщения.  
  
 [!code-cpp[concrt-simple-agent#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-asynchronous-agents-library_1.cpp)]  
  
 Полные примеры определения и использования агентов см. [Пошаговое руководство: Создание приложения на основе агентов](../../parallel/concrt/walkthrough-creating-an-agent-based-application.md) и [Пошаговое руководство: создание агента потоков данных](../../parallel/concrt/walkthrough-creating-a-dataflow-agent.md).  
  
 [[В начало](#top)]  
  
##  <a name="throttling"></a>Используйте механизм регулирования для ограничения числа сообщений в конвейере данных  
 Многие типы буфер сообщений, таких как [concurrency::unbounded_buffer](reference/unbounded-buffer-class.md), может содержать неограниченное число сообщений. Если производитель отправляет сообщения в конвейер данных быстрее, чем получатель может обработать эти сообщения, приложения могут переходить в состояние нехватки памяти или нехватки памяти. Можно использовать механизм регулирования, например, семафор, чтобы ограничить количество сообщений, которые одновременно активны в конвейере данных.  
  
 Следующий пример демонстрирует использовать семафор, чтобы ограничить количество сообщений в конвейере данных. Данные конвейера использует [concurrency::wait](reference/concurrency-namespace-functions.md#wait) функции, чтобы имитировать операцию, занимающую не менее 100 миллисекунд. Так как отправитель создает сообщения быстрее, чем получатель может обработать эти сообщения, в этом примере определяется `semaphore` класса этого приложения ограничить количество активных сообщений.  
  
 [!code-cpp[concrt-message-throttling#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-asynchronous-agents-library_2.cpp)]  
  
 `semaphore` Объект ограничивает конвейер для обработки не более двух сообщений одновременно.  
  
 В этом примере производитель отправляет сообщения относительно небольшого числа потребителя. Таким образом этот пример не демонстрирует потенциальные условия нехватки памяти или нехватки памяти. Тем не менее этот механизм полезен, если конвейер данных содержит относительно большое количество сообщений.  
  
 Дополнительные сведения о создании semaphore-класс, используемый в этом примере см. в разделе [как: использование класса Context для реализации семафора совместной](../../parallel/concrt/how-to-use-the-context-class-to-implement-a-cooperative-semaphore.md).  
  
 [[В начало](#top)]  
  
##  <a name="fine-grained"></a>Не выполняйте детализированную работу в конвейере данных  
 Библиотека агентов может пригодиться при очень крупных фрагментов работы, выполняемой в конвейере данных. Например один компонент приложения может считывать данные из файла или сетевого подключения и отправлять эти данные в другой компонент. Протокол, который использует библиотеку агентов для распространения сообщений вызывает механизм передачи сообщений к дополнительным затратам ресурсов, чем задача параллельные конструкции, предоставляемые [библиотеки параллельных шаблонов](../../parallel/concrt/parallel-patterns-library-ppl.md) (PPL). Таким образом Убедитесь, что работа, выполняемая в конвейере данных достаточно большим, чтобы оправдать дополнительную нагрузку.  
  
 Несмотря на то, что конвейер данных является наиболее эффективным, когда недетализированного его задачи, каждый этап конвейера данных можно использовать структуры PPL, например группы задач и параллельных алгоритмов для выполнения более детализированную работу. Пример сети крупных фрагментов данных, которая использует точного параллелизма на каждом этапе обработки см. в разделе [Пошаговое руководство: создание сети обработки изображений](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md).  
  
 [[В начало](#top)]  
  
##  <a name="large-payloads"></a>Не передавайте большие полезные нагрузки сообщений по значению  

 В некоторых случаях среда выполнения создает копию всех сообщений, передаваемых между буферами сообщений. Например [concurrency::overwrite_buffer](../../parallel/concrt/reference/overwrite-buffer-class.md) класс предлагает копию каждого сообщения, для каждого из его целевых объектов. Среда выполнения также создает копию данных сообщения при использовании функции передачи сообщений [concurrency::send](reference/concurrency-namespace-functions.md#send) и [concurrency::receive](reference/concurrency-namespace-functions.md#receive) писать и считывать сообщения из сообщения буфер. Несмотря на то, что этот механизм помогает исключить опасность параллельной записи в общие данные, это может привести к падению производительности памяти, если полезные данные сообщения относительно велико.  
  
 Можно использовать указатели или ссылки для повышения производительности памяти, при передаче сообщений, имеют большой объем данных. В следующем примере сравнивается передача больших сообщений по значению передача указателей на тот же тип сообщений. В примере определяются два типа агента, `producer` и `consumer`, работающие с `message_data` объектов. В примере сравнивается время, необходимое для производителя для отправки нескольких `message_data` потребителю время, которое требуется для производитель агента для отправки нескольких указателей на объекты `message_data` объекты с потребителем.  
  
 [!code-cpp[concrt-message-payloads#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-asynchronous-agents-library_3.cpp)]  
  
 В этом примере получается следующий результат:  
  
```Output  
Using message_data...  
took 437ms.  
Using message_data*...  
took 47ms.  
```  
  
 Версия, использующая указатели дает более высокую производительность, поскольку это исключают потребность для среды выполнения для создания полной копии каждые `message_data` объектов, передаваемых от производителя получателю.  
  
 [[В начало](#top)]  
  
##  <a name="ownership"></a>Использовать данные сети при владения является неопределенным shared_ptr  
 При отправке сообщений по указателю через конвейеры или сети передачи сообщений обычно выделяют память для каждого сообщения в начале сети и высвобождают память в конце сети. Хотя этот механизм часто работает хорошо, существуют случаи, в которых трудно или невозможно использовать его. Например рассмотрим случай, в которой сеть данных содержит несколько конечных узлов. В этом случае нет нет определенного расположения, чтобы освободить память для сообщения.  
  
 Чтобы решить эту проблему, можно использовать механизм, например, [std::shared_ptr](../../standard-library/shared-ptr-class.md), позволяющий указатель принадлежать нескольким компонентам. Если конечный `shared_ptr` является объект, которому принадлежит ресурс, ресурс освобождается также.  
  
 В следующем примере демонстрируется использование `shared_ptr` для совместного использования значений указателя несколькими буферами сообщений. В примере выполняется подключение [concurrency::overwrite_buffer](../../parallel/concrt/reference/overwrite-buffer-class.md) объекта до трех [concurrency::call](../../parallel/concrt/reference/call-class.md) объектов. `overwrite_buffer` Класс предлагает сообщения всем своим целевым объектам. Так как существует несколько владельцев данных в конце сети данных, в этом примере используется `shared_ptr` чтобы активировать все `call` объекта владеть сообщений.  
  
 [!code-cpp[concrt-message-sharing#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-asynchronous-agents-library_4.cpp)]  
  
 В этом примере получается следующий результат:  
  
```Output  
Creating resource 42...  
receiver1: received resource 42  
Creating resource 64...  
receiver2: received resource 42  
receiver1: received resource 64  
Destroying resource 42...  
receiver2: received resource 64  
Destroying resource 64...  
```  
  
## <a name="see-also"></a>См. также  
 [Рекомендации для среды выполнения с параллелизмом](../../parallel/concrt/concurrency-runtime-best-practices.md)   
 [Библиотека асинхронных агентов](../../parallel/concrt/asynchronous-agents-library.md)   
 [Пошаговое руководство: Создание приложения на основе агентов](../../parallel/concrt/walkthrough-creating-an-agent-based-application.md)   
 [Пошаговое руководство: Создание агента потоков данных](../../parallel/concrt/walkthrough-creating-a-dataflow-agent.md)   
 [Пошаговое руководство: Создание сети обработки изображений](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md)   
 [Рекомендации в библиотеке параллельных шаблонов](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md)   
 [Общие рекомендации в среде выполнения с параллелизмом](../../parallel/concrt/general-best-practices-in-the-concurrency-runtime.md)

