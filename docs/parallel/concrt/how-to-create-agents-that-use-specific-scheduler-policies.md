---
title: "Практическое руководство. Создание агентов, использующих определенные политики планировщика | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "политики планировщика, агенты [среда выполнения с параллелизмом]"
  - "создание агентов, использующих определенные политики [среда выполнения с параллелизмом]"
ms.assetid: 46a3e265-0777-4ec3-a142-967bafc49d67
caps.latest.revision: 14
caps.handback.revision: 11
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Практическое руководство. Создание агентов, использующих определенные политики планировщика
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

Агент — это компонент приложения, который работает асинхронно с другими компонентами для решения более крупных вычислительных задач.  Как правило, агент имеет заданный жизненный цикл и поддерживает состояние.  
  
 Каждый агент может иметь уникальные требования к приложению.  Например, агент, который обеспечивает взаимодействие с пользователем \(извлекая входные данные или отображая выходные данные\), может потребовать доступ к вычислительным ресурсам более высокого приоритета.  Политики планировщика позволяют управлять стратегией, которую планировщик использует при управлении задачами.  В этом разделе продемонстрировано создание агентов, использующих определенные политики планировщика.  
  
 Общий пример использования пользовательских политик планировщика совместно с асинхронными блоками сообщений см. в разделе [Практическое руководство. Задание определенных политик планировщика](../Topic/How%20to:%20Specify%20Specific%20Scheduler%20Policies.md).  
  
 В этом разделе для выполнения работы используются функции из библиотеки асинхронных агентов, такие как агенты, блоки сообщений и функции передачи сообщений.  Дополнительные сведения о библиотеке асинхронных агентов см. в разделе [Библиотека асинхронных агентов](../../parallel/concrt/asynchronous-agents-library.md).  
  
## Пример  
 В следующем примере определяется два класса, наследующихся от [concurrency::agent](../../parallel/concrt/reference/agent-class.md): `permutor` и `printer`.  Класс `permutor` вычисляет все перестановки заданной введенной строки.  Класс `printer` выводит сообщения хода выполнения на консоль.  Класс `permutor` выполняет операцию с большим объемом вычислений, которая может расходовать все доступные вычислительные ресурсы.  Класс `printer` полезен, только если он своевременно выводит каждое сообщение о ходе выполнения.  
  
 Чтобы обеспечить классу `printer` адекватный доступ к вычислительным ресурсам, в данном примере с помощью шагов, описанных в разделе [Практическое руководство. Управление экземпляром планировщика](../../parallel/concrt/how-to-manage-a-scheduler-instance.md), создается экземпляр планировщика с пользовательской политикой.  Пользовательская политика задает, что поток имеет наивысший класс приоритета.  
  
 Для демонстрации преимуществ использования планировщика с пользовательской политикой в этом примере вся задача выполняется дважды.  Сначала для планирования обеих задач используется планировщик по умолчанию.  Затем используется планировщик по умолчанию для планирования объекта `permutor` и планировщик с пользовательской политикой для планирования объекта `printer`.  
  
 [!code-cpp[concrt-permute-strings#1](../../parallel/concrt/codesnippet/CPP/how-to-create-agents-that-use-specific-scheduler-policies_1.cpp)]  
  
 В результате выполнения примера получается следующий результат:  
  
  **С планировщиком по умолчанию:**  
**Вычисление всех перестановок «грейпфрута»…**  
**100% выполнено...**  
**С более высоким приоритетом контекста:**  
**Вычисление всех перестановок «грейпфрута»…**  
**100% выполнено...** Хотя оба набора задач дают одинаковый результат, версия, в которой используется пользовательская политика, позволяет выполнять объект `printer` с повышенными приоритетом, обеспечивая более отзывчивое поведение.  
  
## Компиляция кода  
 Скопируйте код примера и вставьте его в проект Visual Studio или в файл с именем `permute-strings.cpp`, затем выполните в окне командной строки Visual Studio следующую команду.  
  
 **cl.exe \/EHsc permute\-strings.cpp**  
  
## См. также  
 [Политики планировщика](../../parallel/concrt/scheduler-policies.md)   
 [Асинхронные агенты](../../parallel/concrt/asynchronous-agents.md)   
 