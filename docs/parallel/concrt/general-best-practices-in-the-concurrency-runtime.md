---
title: "Общие рекомендации в среде выполнения с параллелизмом | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "Среда выполнения с параллелизмом, общие рекомендации"
ms.assetid: ce5c784c-051e-44a6-be84-8b3e1139c18b
caps.latest.revision: 16
caps.handback.revision: 12
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Общие рекомендации в среде выполнения с параллелизмом
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

В этом документе приведены рекомендации по работе с различными областями среды выполнения с параллелизмом.  
  
##  <a name="top"></a> Подразделы  
 Этот документ содержит следующие разделы.  
  
-   [При возможности используйте конструкции совместной синхронизации](#synchronization)  
  
-   [Избегайте продолжительных задач, не выполняющих передачу](#yield)  
  
-   [Используйте превышение лимита подписки для смещения заблокированных операций или операций с высокой задержкой](#oversubscription)  
  
-   [При возможности используйте функции параллельного управления памятью](#memory)  
  
-   [Используйте RAII для управления временем существования параллельных объектов](#raii)  
  
-   [Не создавайте параллельные объекты в глобальной области](#global-scope)  
  
-   [Не используйте параллельные объекты в сегментах данных совместного доступа](#shared-data)  
  
##  <a name="synchronization"></a> При возможности используйте конструкции совместной синхронизации  
 Среда выполнения с параллелизмом предоставляет множество безопасных в режиме параллелизма структур, не требующих внешнего объекта синхронизации.  Например, класс [concurrency::concurrent\_vector](../../parallel/concrt/reference/concurrent-vector-class.md) предоставляет безопасные в режиме параллелизма операции добавления и доступа к элементу.  Тем не менее, для случаев, когда необходим монопольный доступ к ресурсу, среда выполнения предоставляет классы [concurrency::critical\_section](../../parallel/concrt/reference/critical-section-class.md), [concurrency::reader\_writer\_lock](../Topic/reader_writer_lock%20Class.md) и [concurrency::event](../Topic/event%20Class.md).  Эти типы предназначены для совместной работы, поэтому планировщик заданий может перераспределять ресурсы обработки в другой контекст, пока первая задача ожидает получения данных.  При возможности следует использовать эти типы синхронизации, а не другие механизмы, например предоставляемые Windows API, не предназначенные для совместной работы.  Дополнительные сведения об этих типах синхронизации и пример кода см. в разделах [Структуры данных синхронизации](../Topic/Synchronization%20Data%20Structures.md) и [Сравнение структур данных синхронизации с интерфейсом Windows API](../Topic/Comparing%20Synchronization%20Data%20Structures%20to%20the%20Windows%20API.md).  
  
 \[[Наверх](#top)\]  
  
##  <a name="yield"></a> Избегайте продолжительных задач, не выполняющих передачу  
 Так как планировщик заданий работает совместно, он не обеспечивает балансировку ресурсов между задачами.  Поэтому задача может предотвратить запуск других задач.  В некоторых случаях это допустимо, но иногда это может привести к взаимоблокировке или истощению ресурсов.  
  
 В следующем примере количество выполняемых задач больше, чем количество выделенных ресурсов обработки.  Первая задача не выполняет передачу планировщику заданий, поэтому вторая задача не запускается до завершения первой.  
  
 [!code-cpp[concrt-cooperative-tasks#1](../../parallel/concrt/codesnippet/CPP/general-best-practices-in-the-concurrency-runtime_1.cpp)]  
  
 В этом примере выводятся следующие данные:  
  
 1: 250000000 1: 500000000 1: 750000000 1: 1000000000 2: 250000000 2: 500000000 2: 750000000 2: 1000000000  
  
 Есть несколько способов обеспечить совместную работу двух задач.  Один — выполнить передачу продолжительной задачи планировщику заданий.  В следующем примере функция `task` изменяется для вызова метода [concurrency::Context::Yield](../Topic/Context::Yield%20Method.md), передающего выполнение планировщику заданий, чтобы могла запуститься другая задача.  
  
 [!code-cpp[concrt-cooperative-tasks#2](../../parallel/concrt/codesnippet/CPP/general-best-practices-in-the-concurrency-runtime_2.cpp)]  
  
 В этом примере выводятся следующие данные:  
  
  **1: 250000000**  
**2: 250000000**  
**1: 500000000**  
**2: 500000000**  
**1: 750000000**  
**2: 750000000**  
**1: 1000000000**  
**2: 1000000000** Метод `Context::Yield` выполняет передачу только другому активному потоку в планировщике, к которому относится текущий поток, упрощенной задаче или потоку другой операционной системы.  Он не выполняет передачу работе, запланированной для выполнения в объекте [concurrency::task\_group](../Topic/task_group%20Class.md) или [concurrency::structured\_task\_group](../../parallel/concrt/reference/structured-task-group-class.md), но еще не запущенной.  
  
 Есть другие способы обеспечить совместную работу продолжительных задач.  Можно разделить большие задачи на меньшие подзадачи.  Также можно разрешить превышение лимита подписки при выполнении продолжительной задачи.  Превышение лимита подписки позволяет создать больше потоков, чем количество доступных аппаратных потоков.  Превышение лимита подписки особенно полезно, если продолжительная задача связана с большими задержками, например при считывании данных с диска или сетевого ресурса.  Дополнительные сведения об упрощенных задачах и превышении лимита подписки см. в разделе [Планировщик задач](../../parallel/concrt/task-scheduler-concurrency-runtime.md).  
  
 \[[Наверх](#top)\]  
  
##  <a name="oversubscription"></a> Используйте превышение лимита подписки для смещения заблокированных операций или операций с высокой задержкой  
 Среда выполнения с параллелизмом предоставляет примитивы синхронизации, такие как [concurrency::critical\_section](../../parallel/concrt/reference/critical-section-class.md), позволяющие задачам выполнять совместную блокировку и передачу друг другу.  Когда одна задача выполняет совместную блокировку или передачу, планировщик заданий может перераспределять ресурсы обработки в другой контекст, пока первая задача ожидает получения данных.  
  
 В некоторых случаях нельзя использовать механизм совместной блокировки, предоставленный средой выполнения с параллелизмом.  Например, может использоваться внешняя библиотека, применяющая другой механизм синхронизации.  Еще один пример — выполнение операции, при которой возможны большие задержки, например использование функции Windows API `ReadFile` для чтения данных с сетевого ресурса.  В этих случаях превышение лимита подписки может позволить выполнять другие задачи, пока текущая задача неактивна.  Превышение лимита подписки позволяет создать больше потоков, чем количество доступных аппаратных потоков.  
  
 Рассмотрим следующую функцию, `download`, загружающую файл с данного URL\-адреса.  В этом примере для временного увеличения количества активных потоков используется метод [concurrency::Context::Oversubscribe](../Topic/Context::Oversubscribe%20Method.md).  
  
 [!CODE [concrt-download-oversubscription#4](../CodeSnippet/VS_Snippets_ConcRT/concrt-download-oversubscription#4)]  
  
 Так как функция `GetHttpFile` выполняет операцию с возможностью задержек, превышение лимита подписки может позволить выполнять другие задачи, пока текущая задача ожидает получения данных.  Полную версию этого примера см. в разделе [Практическое руководство. Использование лимита подписки для устранения задержек](../../parallel/concrt/how-to-use-oversubscription-to-offset-latency.md).  
  
 \[[Наверх](#top)\]  
  
##  <a name="memory"></a> При возможности используйте функции параллельного управления памятью  
 При работе с конкретными задачами, постоянно выделяющими небольшие объекты с коротким временем существования, следует использовать функции управления памятью [concurrency::Alloc](../Topic/Alloc%20Function.md) и [concurrency::Free](../Topic/Free%20Function.md).  Среда выполнения с параллелизмом содержит отдельный кэш памяти для каждого выполняющегося потока.  Функции `Alloc` и `Free` выделяют и высвобождают память из такого кэша, не используя блокировки или барьеры памяти.  
  
 Дополнительные сведения об этих функциях управления памятью см. в разделе [Планировщик задач](../../parallel/concrt/task-scheduler-concurrency-runtime.md).  Пример использования этих функций см. в разделе [Практическое руководство. Использование функций Alloc и Free для повышения производительности операций с памятью](../../parallel/concrt/how-to-use-alloc-and-free-to-improve-memory-performance.md).  
  
 \[[Наверх](#top)\]  
  
##  <a name="raii"></a> Используйте RAII для управления временем существования параллельных объектов  
 Среда выполнения с параллелизмом использует обработку исключений для реализации таких функций, как отмена.  Поэтому при выполнении вызовов в среду выполнения или в другую библиотеку, которая выполняет вызовы в среду выполнения, следует писать код, безопасный в отношении исключений.  
  
 Шаблон *Получение ресурса есть инициализация* \(RAII\) — один из способов безопасного управления временем существования параллельных объектов в данной области.  При использовании шаблона RAII структура данных располагается в стеке.  Эта структура данных инициализирует или приобретает ресурс во время создания структуры и уничтожает или освобождает ресурс во время уничтожения структуры данных.  Шаблон RAII гарантирует, что деструктор вызывается до выхода из внешней области видимости.  Этот шаблон полезен, если функция содержит несколько операторов `return`.  Этот шаблон также помогает писать код, безопасный в отношении исключений.  Когда оператор `throw` вызывает раскручивание стека, вызываются деструкторы объекта RAII; поэтому ресурс всегда правильно удаляется или высвобождается.  
  
 Среда выполнения определяет несколько классов, использующих шаблон RAII, например [concurrency::critical\_section::scoped\_lock](../Topic/critical_section::scoped_lock%20Class.md) и [concurrency::reader\_writer\_lock::scoped\_lock](../Topic/reader_writer_lock::scoped_lock%20Class.md).  Эти вспомогательные классы называются *блокировками с областью*.  Эти классы обеспечивают несколько преимуществ при работе с объектом [concurrency::critical\_section](../../parallel/concrt/reference/critical-section-class.md) или [concurrency::reader\_writer\_lock](../Topic/reader_writer_lock%20Class.md).  Конструктор этих классов получает доступ к предоставленному объекту `critical_section` или `reader_writer_lock`; деструктор высвобождает доступ к этому объекту.  Так как блокировка с областью высвобождает доступ к своему взаимоисключающему объекту автоматически при ее уничтожении, не требуется вручную разблокировать основной объект.  
  
 Рассмотрим следующий класс, `account`, который нельзя изменять, так как он определен внешней библиотекой.  
  
 [!CODE [concrt-account-transactions#1](../CodeSnippet/VS_Snippets_ConcRT/concrt-account-transactions#1)]  
  
 В следующем примере параллельно выполняется несколько транзакций в объекте `account`.  В примере для синхронизации доступа к объекту `account` используется объект `critical_section`, так как класс `account` не является безопасным в режиме параллелизма.  Каждая параллельная операция использует объект `critical_section::scoped_lock`, чтобы разблокировать объект `critical_section` после выполнения операции \(ее успеха или сбоя\).  Если баланс счета отрицательный, операция `withdraw` дает сбой и создает исключение.  
  
 [!CODE [concrt-account-transactions#2](../CodeSnippet/VS_Snippets_ConcRT/concrt-account-transactions#2)]  
  
 В данном примере получается следующий результат.  
  
  **Баланс перед депозитом: 1924**  
**Баланс после депозита: 2924**  
**Баланс перед списанием: 2924**  
**Баланс после списания: \-76**  
**Баланс перед списанием: \-76**  
**Подробности ошибки:**  
 **отрицательный баланс: \-76** Дополнительные примеры, использующие шаблон RAII для управления временем существования параллельных объектов, см. в разделах [Пошаговое руководство. Удаление задач из потоков пользовательского интерфейса](../../parallel/concrt/walkthrough-removing-work-from-a-user-interface-thread.md), [Практическое руководство. Использование класса Context для реализации семафора, поддерживающего параллельный доступ](../../parallel/concrt/how-to-use-the-context-class-to-implement-a-cooperative-semaphore.md) и [Практическое руководство. Использование лимита подписки для устранения задержек](../../parallel/concrt/how-to-use-oversubscription-to-offset-latency.md).  
  
 \[[Наверх](#top)\]  
  
##  <a name="global-scope"></a> Не создавайте параллельные объекты в глобальной области  
 При создании объекта параллелизма в глобальной области в приложении могут возникнуть такие проблемы, как взаимоблокировка или нарушение доступа к памяти.  
  
 Например, при создании объекта среды выполнения с параллелизмом, среда создает планировщик по умолчанию, если он еще не создан.  Объект среды выполнения, созданный при конструировании глобального объекта, соответственно вызовет то, что среда выполнения создаст этот планировщик по умолчанию.  Однако этот процесс принимает внутреннюю блокировку, которая может помешать инициализации других объектов, поддерживающих инфраструктуру среды выполнения с параллелизмом.  Эта внутренняя блокировка может потребоваться другому, еще не инициализированному, объекту инфраструктуры, и поэтому может привести к возникновению взаимоблокировки в приложении.  
  
 В следующем примере показано создание глобального объекта [concurrency::Scheduler](../../parallel/concrt/reference/scheduler-class.md).  Эта схема применяется не только к классу `Scheduler`, но и к любым другим типам, предоставленным средой выполнения с параллелизмом.  Рекомендуется не использовать эту схему, поскольку она может привести к неожиданному поведению в приложении.  
  
 [!code-cpp[concrt-global-scheduler#1](../../parallel/concrt/codesnippet/CPP/general-best-practices-in-the-concurrency-runtime_3.cpp)]  
  
 Примеры правильного создания объектов `Scheduler` см. в разделе [Планировщик задач](../../parallel/concrt/task-scheduler-concurrency-runtime.md).  
  
 \[[Наверх](#top)\]  
  
##  <a name="shared-data"></a> Не используйте параллельные объекты в сегментах данных совместного доступа  
 Среда выполнения с параллелизмом не поддерживает использование параллельных объектов в разделах данных совместного доступа, например разделах данных, созданных директивой [data\_seg](../../preprocessor/data-seg.md) `#pragma`.  Параллельный объект, использующийся совместно в нескольких процессах, может привести к несогласованному или недопустимому состоянию среды выполнения.  
  
 \[[Наверх](#top)\]  
  
## См. также  
 [Рекомендации по работе со средой выполнения с параллелизмом](../Topic/Concurrency%20Runtime%20Best%20Practices.md)   
 [Библиотека параллельных шаблонов](../../parallel/concrt/parallel-patterns-library-ppl.md)   
 [Библиотека асинхронных агентов](../../parallel/concrt/asynchronous-agents-library.md)   
 [Планировщик задач](../../parallel/concrt/task-scheduler-concurrency-runtime.md)   
 [Структуры данных синхронизации](../Topic/Synchronization%20Data%20Structures.md)   
 [Сравнение структур данных синхронизации с интерфейсом Windows API](../Topic/Comparing%20Synchronization%20Data%20Structures%20to%20the%20Windows%20API.md)   
 [Практическое руководство. Использование функций Alloc и Free для повышения производительности операций с памятью](../../parallel/concrt/how-to-use-alloc-and-free-to-improve-memory-performance.md)   
 [Практическое руководство. Использование лимита подписки для устранения задержек](../../parallel/concrt/how-to-use-oversubscription-to-offset-latency.md)   
 [Практическое руководство. Использование класса Context для реализации семафора, поддерживающего параллельный доступ](../../parallel/concrt/how-to-use-the-context-class-to-implement-a-cooperative-semaphore.md)   
 [Пошаговое руководство. Удаление задач из потоков пользовательского интерфейса](../../parallel/concrt/walkthrough-removing-work-from-a-user-interface-thread.md)   
 [Рекомендации по работе с библиотекой параллельных шаблонов](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md)   
 [Рекомендации по работе с библиотекой асинхронных агентов](../Topic/Best%20Practices%20in%20the%20Asynchronous%20Agents%20Library.md)