---
title: "Создание асинхронных операций в C++ для приложений для Магазина Windows | Microsoft Docs"
ms.custom: ""
ms.date: "12/16/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "приложения Магазина Windows, создание асинхронных операций C++"
  - "Создание асинхронных операций C++"
ms.assetid: a57cecf4-394a-4391-a957-1d52ed2e5494
caps.latest.revision: 31
caps.handback.revision: 30
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Создание асинхронных операций в C++ для приложений для Магазина Windows
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

В этом документе описываются некоторые ключевые аспекты, которые необходимо учитывать при использовании класса задачи для создания асинхронных операций на основе Windows ThreadPool в приложениях [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)].  
  
 Использование асинхронного программирования является ключевым компонентом в модели приложения [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)], поскольку позволяет приложениям не терять способности реагировать на действия пользователя. Можно запустить длительную задачу без блокировки потока ИП и получить результаты выполнения задачи позже. Можно также отменять задачи и получать уведомления о ходе выполнения задач, выполняемых в фоновом режиме. В документе [Асинхронное программирование в C\+\+](http://msdn.microsoft.com/library/windows/apps/Hh780559.aspx) приведены общие сведения об асинхронной модели, которая доступна в Visual C\+\+ при создании приложений [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]. В этом документе приводятся сведения об использовании и создании асинхронных операций [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]. В этом разделе описываются способы использования типов из файла ppltasks.h для создания асинхронных операций, которые могут быть использованы другим компонентом [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)], и способы управления выполнением асинхронных задач. Также рекомендуется прочитать статью [Шаблоны асинхронного программирования и советы по Hilo \(приложения Магазина Windows на C\+\+ и XAML\)](http://msdn.microsoft.com/library/windows/apps/jj160321.aspx), чтобы получить представление о том, как мы использовали класс задач для реализации асинхронных операций в Hilo, приложении [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)], использующем C\+\+ и XAML.  
  
> [!NOTE]
>  Можно использовать [Библиотеку параллельных шаблонов](../../parallel/concrt/parallel-patterns-library-ppl.md) \(PPL\) и [Библиотека асинхронных агентов](../../parallel/concrt/asynchronous-agents-library.md) в приложении [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]. Однако невозможно использовать планировщик задач или диспетчер ресурсов. В этом документе описываются дополнительные функции, предоставляемые PPL, которые доступны только в приложениях [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)], но не в классических приложениях.  
  
## Ключевые моменты  
  
-   Используйте [concurrency::create\_async](../Topic/create_async%20Function.md) для создания асинхронных операций, которые могут использоваться другими компонентами \(которые могут быть написаны на языках, отличных от C\+\+\).  
  
-   Используйте [concurrency::progress\_reporter](../../parallel/concrt/reference/progress-reporter-class.md) для передачи уведомлений о ходе выполнения компонентам, которые вызывают ваши асинхронные операции.  
  
-   Используйте токены отмены, чтобы обеспечить возможность отмены внутренних асинхронных операций.  
  
-   Поведение функции `create_async` зависит от передаваемого ей возвращаемого типа рабочей функции. Рабочая функция, которая возвращает задачу \(`task<T>` или `task<void>`\) выполняется синхронно в контексте, который вызвал `create_async`. Рабочая функция, возвращающая `T` или `void`, выполняется в произвольном контексте.  
  
-   Можно использовать метод [concurrency::task::then](../Topic/task::then%20Method.md) для создания цепочки задач, выполняемых друг за другом. В приложении [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] контекст по умолчанию для продолжений задачи зависит от способа создания этой задачи. Если задача была создана путем передачи асинхронного действия конструктору задачи, или путем передачи лямбда\-выражения, возвращающего асинхронное действие, то контекстом по умолчанию для всех продолжений этой задачи будет текущий контекст. Если задача создана не из асинхронного действия, для продолжений задачи по умолчанию используется произвольный контекст. Можно переопределить контекст по умолчанию с помощью класса [concurrency::task\_continuation\_context](../../parallel/concrt/reference/task-continuation-context-class.md).  
  
## В этом документе  
  
-   [Создание асинхронных операций](#create-async)  
  
-   [Пример: создание компонента среды выполнения Windows на C\+\+](#example-component)  
  
-   [Управление потоком выполнения](#exethread)  
  
-   [Пример: управление выполнением в приложении Магазина Windows с помощью C\+\+ и XAML](#example-app)  
  
##  <a name="create-async"></a> Создание асинхронных операций  
 Можно использовать задачу и модель продолжения в библиотеке параллельных шаблонов \(PPL\) для определения фоновых задач, а также и дополнительных задач, выполняемых по завершении предыдущей задачи. Эта функциональность предоставляется классом [concurrency::task](../../parallel/concrt/reference/task-class-concurrency-runtime.md). Дополнительные сведения об этой модели и классе `task` см. в разделе [Параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md).  
  
 [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)] — это программный интерфейс, который можно использовать для создания приложений [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)], выполняемых только в специальной среде операционной системы. Такие приложения используют авторизованные функции, типы данных и устройства и распространяются через [!INCLUDE[win8_appstore_long](../../build/reference/includes/win8_appstore_long_md.md)].[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)] представлен *двоичным интерфейсом приложений* \(ABI\). ABI — базовый бинарный контракт, который делает интерфейсы API [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)] доступными для языков программирования, например Visual C\+\+.  
  
 С помощью [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)] можно использовать лучшие функции различных языков программирования и объединять их в одном приложении. Например, можно создать ИП в JavaScript и выполнять трудоемкую вычислительную логику приложения в компоненте, написанном на C\+\+. Возможность выполнять такие ресурсоемкие операции в фоновом режиме является ключевым фактором в обеспечении скорости реагирования ИП. Поскольку класс `task` доступен только в C\+\+, необходимо использовать интерфейс [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)] для взаимодействия асинхронных операций с другими компонентами \(которые могут быть написаны на языках, отличных от C\+\+\).[!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)] предоставляет 4 интерфейса, которые можно использовать для представления асинхронных операций:  
  
 [Windows::Foundation::IAsyncAction](http://msdn.microsoft.com/library/windows/apps/windows.foundation.iasyncaction.aspx)  
 Представляет асинхронное действие.  
  
 [Windows::Foundation::IAsyncActionWithProgress\<TProgress\>](http://msdn.microsoft.com/library/windows/apps/br206581.aspx)  
 Представляет асинхронное действие, сообщающее о ходе выполнения.  
  
 [Windows::Foundation::IAsyncOperation\<TResult\>](http://msdn.microsoft.com/library/windows/apps/br206598.aspx)  
 Представляет асинхронную операцию, которая возвращает результат.  
  
 [Windows::Foundation::IAsyncOperationWithProgress\<TResult, TProgress\>](http://msdn.microsoft.com/library/windows/apps/br206594.aspx)  
 Возвращает асинхронную операцию, которая возвращает результат и отчитывается о ходе выполнения.  
  
 Понятие *действие* означает, что асинхронная задача не создает значение \(представьте функцию, которая возвращает `void`\). Понятие *операция* означает, что асинхронная задача создает значение. Понятие *ход выполнения* означает, что задача может отправить сообщение о ходе выполнения вызывающему объекту. Языки JavaScript, .NET Framework и Visual C\+\+ предоставляют свои собственные способы создания экземпляров таких интерфейсов для использования с переходом через границы ABI. Для Visual C\+\+ PPL предоставляет функцию [concurrency::create\_async](../Topic/create_async%20Function.md). Эта функция создает асинхронное действие или операцию [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)], представляющее завершение задачи. Функция `create_async` принимает рабочую функцию \(обычно лямбда\-выражение\), внутренне создает объект `task` и оборачивает задачу в один из 4 асинхронных интерфейсов [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)].  
  
> [!NOTE]
>  Используйте `create_async` только при необходимости создать функциональность, которая должна быть доступна из другого языка программирования или другого компонента [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]. Используйте класс `task` напрямую, если известно, что операция и создается, и используется кодом C\+\+ в том же компоненте.  
  
 Возвращаемый тип `create_async` определяется типом аргументов. Например, если рабочая функция не возвращает значение и не сообщает о ходе выполнения, `create_async` возвращает `IAsyncAction`. Если рабочая функция не возвращает значение и сообщает о ходе выполнения, `create_async` возвращает `IAsyncActionWithProgress`. Чтобы сообщить о ходе выполнения, укажите объект [concurrency::progress\_reporter](../../parallel/concrt/reference/progress-reporter-class.md) в качестве параметра рабочей функции. Возможность уведомления о ходе выполнения позволяет отчитываться о выполненном объеме работы и оставшемся объеме \(например, в процентах\). Это также позволяет сообщать о результатах, как только они становятся доступными.  
  
 Интерфейсы `IAsyncAction`, `IAsyncActionWithProgress<TProgress>`, `IAsyncOperation<TResult>`, `IAsyncActionOperationWithProgress<TProgress, TProgress>` предоставляют метод `Cancel`, позволяющий отменить асинхронную операцию. Класс `task` работает с токенами отмены. При использовании токена отмены, чтобы отменить работу, среда выполнения не запускает новую работу, которая подписывается на этот токен. Уже выполняющаяся работа может отслеживать свой токен отмены и останавливаться, когда имеет такую возможность. Этот механизм описан подробнее в документе [Отмена](../../parallel/concrt/cancellation-in-the-ppl.md). Связь отмены задачи с методами [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]`Cancel` можно осуществить двумя способами. Во\-первых, можно определить рабочую функцию, передаваемую `create_async` для получения объекта [concurrency::cancellation\_token](cancellation_token). Когда метод `Cancel` вызывается, этот токен отмены отменяется, и обычные правила отмены применяются к основному объекту `task`, поддерживающему вызов метода `create_async`. Если объект `cancellation_token` не предоставляется, базовый объект `task` определит его неявно. Определите объект `cancellation_token` при необходимости совместно реагировать на отмену в вашей рабочей функции. В разделе [Пример: управление выполнением в приложении Магазина Windows с помощью C\+\+ и XAML](#example-app) приводится пример того, как можно выполнить отмену в приложении [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] с C\# и XAML, использующем пользовательский компонент С\+\+ [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)].  
  
> [!WARNING]
>  В цепочке продолжений задач всегда очищайте состояние, а затем вызывайте метод [concurrency::cancel\_current\_task](../Topic/cancel_current_task%20Function.md), когда токен отмены отменяется. Если возврат выполняется раньше вместо вызова `cancel_current_task`, операция переходит в состояние завершения вместо состояния отмены.  
  
 В следующей таблице приведены сочетания, которые можно использовать для определения асинхронных операций в приложении.  
  
|Создание этого интерфейса [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)]|Верните этот тип из `create_async`|Передайте эти типы параметров рабочей функции для использования неявного токена отмены|Передайте эти типы параметров рабочей функции для использования явного токена отмены|  
|-----------------------------------------------------------------------------------|----------------------------------------|--------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|  
|`IAsyncAction`|`void` или `task<void>`|\(нет\)|\(`cancellation_token`\)|  
|`IAsyncActionWithProgress<TProgress>`|`void` или `task<void>`|\(`progress_reporter`\)|\(`progress_reporter`, `cancellation_token`\)|  
|`IAsyncOperation<TResult>`|`T` или `task<T>`|\(нет\)|\(`cancellation_token`\)|  
|`IAsyncActionOperationWithProgress<TProgress, TProgress>`|`T` или `task<T>`|\(`progress_reporter`\)|\(`progress_reporter`, `cancellation_token`\)|  
  
 Можно вернуть значение или объект `task` из рабочей функции, которое было передано функции `create_async`. Эти различия обеспечивают различное поведение. Если возвращается значение, рабочая функция оборачивается в `task`, чтобы ее можно выполнить в фоновом потоке. Кроме того базовый объект `task` использует неявный токен отмены. И наоборот, если возвращается объект `task`, рабочая функция выполняется синхронно. Следовательно, если возвращается объект `task`, убедитесь, что все длительные операции в вашей рабочей функции выполняются как задачи, чтобы приложение быстро реагировало на действия пользователя. Кроме того базовый объект `task` не использует неявный токен отмены. Поэтому необходимо определить вашу рабочую функцию, чтобы она принимала объект `cancellation_token`, если необходима поддержка отмены при возврате объекта `task` из `create_async`.  
  
 В следующем примере показаны различные способы создания объекта `IAsyncAction`, который может быть использован другим компонентом [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)].  
  
 [!code-cpp[concrt-windowsstore-primes#100](../../parallel/concrt/codesnippet/CPP/creating-asynchronous-operations-in-cpp-for-windows-store-apps_1.cpp)]  
  
##  <a name="example-component"></a> Пример. Создание компонента среды выполнения Windows на C\+\+ и его использования в коде C\#  
 Рассмотрим приложение, которое использует XAML и C\# для определения ИП и компонент [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)] на C\+\+ для выполнения ресурсоемких вычислительных операций. В этом примере компонент C\+\+ обнаруживает простые числа в заданном диапазоне. Чтобы увидеть различия между 4 интерфейсами асинхронных задач [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)], начните работу в Visual Studio, создав **Новое решение** и назовите его `Primes`. Затем добавьте в решение проект **Компонент среды выполнения Windows** и назовите его `PrimesLibrary`. Добавьте следующий код в создаваемый файл заголовка C\+\+ \(в примере Class1.h переименовывается в Primes.h\). Каждый метод `public` определяет один из 4 асинхронных интерфейсов. Методы, возвращающие значение, возвращают объект [Windows::Foundation::Collections::IVector\<int\>](http://msdn.microsoft.com/library/windows/apps/br206631.aspx). Методы, которые уведомляют о ходе выполнения, генерируют значения `double`, которые показывают, какой процент общей работы завершен.  
  
 [!code-cpp[concrt-windowsstore-primes#1](../../parallel/concrt/codesnippet/CPP/creating-asynchronous-operations-in-cpp-for-windows-store-apps_2.h)]  
  
> [!NOTE]
>  По соглашению имена асинхронных методов в [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)] обычно заканчиваются на "Async".  
  
 Добавьте следующий код в сгенерированный файл с исходным кодом C\+\+ \(в примере Class1.cpp переименовывается в Primes.cpp\). Функция `is_prime` определяет, является ли входное число простым. Остальные методы реализуют класс `Primes`. Каждый вызов `create_async` использует сигнатуру, которая совместима с методом, из которого он вызывается. Например, поскольку `Primes::ComputePrimesAsync` возвращает `IAsyncAction`, рабочая функция, переданная в `create_async`, не возвращает значение и не принимает объект `progress_reporter` в качестве параметра.  
  
 [!code-cpp[concrt-windowsstore-primes#2](../../parallel/concrt/codesnippet/CPP/creating-asynchronous-operations-in-cpp-for-windows-store-apps_3.cpp)]  
  
 Каждый метод сначала выполняет проверку, чтобы убедиться, что входные параметры не являются отрицательными. Если входное значение отрицательное, метод выдает исключение [Platform::InvalidArgumentException](http://msdn.microsoft.com/library/windows/apps/hh755794\(v=vs.110\).aspx). Обработка ошибок объясняется далее в этом разделе.  
  
 Чтобы использовать эти методы из приложения [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)], используйте шаблон Visual C\# **Пустого приложения \(XAML\)**, чтобы добавить второй проект в решение Visual Studio. В этом примере проект называется `Primes`. Затем из проекта `Primes` добавьте ссылку на проект `PrimesLibrary`.  
  
 Добавьте следующий код в MainPage.xaml. Этот код определяет пользовательский интерфейс, чтобы можно было вызвать компонент на С\+\+ и вывести результат.  
  
 [!code-xml[concrt-windowsstore-primes#3](../../parallel/concrt/codesnippet/Xaml/creating-asynchronous-operations-in-cpp-for-windows-store-apps_4.xaml)]  
  
 Добавьте следующий код в класс `MainPage` в файле MainPage.xaml. Этот код определяет объект `Primes` и обработчики событий для кнопки.  
  
 [!code-cs[concrt-windowsstore-primes#4](../../parallel/concrt/codesnippet/CSharp/creating-asynchronous-operations-in-cpp-for-windows-store-apps_5.cs)]  
  
 Эти методы используют ключевые слова `async` и `await` для обновления пользовательского интерфейса после выполнения асинхронных операций. Дополнительные сведения об асинхронных шаблонах, доступных для C\# и Visual Basic, см. в разделах [Асинхронные шаблоны в приложениях для Магазина Windows с C\#](http://msdn.microsoft.com/library/windows/apps/hh464924.aspx) и [Асинхронные шаблоны в приложениях для Магазина Windows с VB](http://msdn.microsoft.com/library/windows/apps/hh464924.aspx).  
  
 Методы `getPrimesCancellation` и `cancelGetPrimes` работают вместе, позволяя пользователю отменить операцию. Когда пользователь нажимает кнопку **Отмена**, метод `cancelGetPrimes` вызывает [IAsyncOperationWithProgress\<TResult, TProgress\>::Cancel](http://msdn.microsoft.com/library/windows/apps/windows.foundation.iasyncinfo.cancel.aspx) для отмены операции. Исполняющая среда с параллелизмом, которая управляет базовой асинхронной операцией, создает исключение внутреннего типа, которое перехватывает [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)] и сообщает, что отмена завершена. Дополнительные сведения о модели отмены см. в разделе [Отмена](../../parallel/concrt/cancellation-in-the-ppl.md).  
  
> [!IMPORTANT]
>  Чтобы PPL правильно уведомляла компонент [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)] об отмене операции, не перехватывайте исключения этого внутреннего типа. Это означает, что не нужно перехватывать все исключения \(`catch (...)`\). Если необходимо перехватывать все исключения, повторно создайте исключение, чтобы быть уверенным, что [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)] может выполнить операцию отмены.  
  
 На следующем рисунке показано приложение `Primes` после выбора каждого параметра.  
  
 ![Приложение Primes для Магазина Windows](../../parallel/concrt/media/concrt_windows_primes.png "ConcRT\_windows\_Primes")  
  
 Дополнительную информацию о примерах, которые применяют `create_async` для создания асинхронных задач, которые могут использоваться другими языками, см. в разделе [Использование C\+\+ в примере Bing Maps Trip Optimizer](http://msdn.microsoft.com/library/windows/apps/hh699891\(v=vs.110\).aspx) и [Асинхронные операции в Windows 8 в C\+\+ с PPL](http://code.msdn.microsoft.com/windowsapps/Windows-8-Asynchronous-08009a0d).  
  
##  <a name="exethread"></a> Управление потоком выполнения  
 [!INCLUDE[wrt](../../atl/reference/includes/wrt_md.md)] использует потоковую модель COM. В этой модели объекты размещаются в различных подразделениях в зависимости от того, как они обрабатывают свою синхронизацию. Потокобезопасные объекты размещаются в многопотоковых подразделениях \(MTA\). Объекты, которые должны быть доступны из одного потока, размещаются в однопотоковых подразделениях \(STA\).  
  
 В приложении с пользовательским интерфейсом поток ASTA \(STA приложения\) отвечает за перенос сообщений окна и является единственным потоком в процессе, который может обновить размещенные в STA элементы управления пользовательского интерфейса. Это имеет два последствия. Во\-первых, для быстрого реагирования приложения на ввод пользователя все вычислительно сложные операции и операции ввода\-вывода не должны выполняться в потоке ASTA. Во\-вторых, результаты, полученные из фоновых потоков, должны маршалироваться обратно в ASTA для обновления пользовательского интерфейса. В приложении [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] на C\+\+ `MainPage` и другие XAML\-страницы выполняются в ATSA. Поэтому продолжения задачи, которые объявляются в ASTA, выполняются там по умолчанию, поэтому можно обновлять элементы управления напрямую в теле продолжения. Однако если вложить задачу в другую задачу, все продолжения в этой вложенной задаче выполняются в MTA. Поэтому необходимо рассмотреть, требуется ли явно указать, в каком контексте выполняются эти продолжения.  
  
 Задачи, которые создаются из асинхронной операции, такие как `IAsyncOperation<TResult>`, используют специальную семантику, которая поможет игнорировать детали многопоточной реализации. Хотя операция может выполняться в фоновом потоке \(или может совсем не обеспечиваться потоком\), гарантируется выполнение ее продолжений по умолчанию в подразделении, начавшем операции продолжения \(другими словами, из подразделения, вызвавшего `task::then`\). Можно использовать класс [concurrency::task\_continuation\_context](../../parallel/concrt/reference/task-continuation-context-class.md) для управления контекстом выполнения продолжения. Используйте эти статические вспомогательные методы для создания объектов `task_continuation_context`.  
  
-   Используйте [concurrency::task\_continuation\_context::use\_arbitrary](../Topic/task_continuation_context::use_arbitrary%20Method.md), чтобы указать, что продолжение выполняется в фоновом потоке.  
  
-   Используйте [concurrency::task\_continuation\_context::use\_current](../Topic/task_continuation_context::use_current%20Method.md), чтобы указать, что продолжение выполняется в потоке, который вызвал `task::then`.  
  
 Можно передать объект `task_continuation_context` в метод [task::then](../Topic/task::then%20Method.md), чтобы явно управлять контекстом выполнения продолжения, или можно передать задачу в другое подразделение и затем вызвать метод `task::then` для неявного управления контекстом выполнения.  
  
> [!IMPORTANT]
>  Поскольку основной поток ИП приложений [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] выполняется в STA, продолжения, созданные в этом STA, по умолчанию выполняются в STA. Соответственно, продолжения, созданные в MTA, выполняются в MTA.  
  
 В следующем разделе показано приложение, которое считывает файл с диска, находит наиболее распространенные слова в этом файле, а затем отображает результаты в пользовательском интерфейсе. Последняя операция, обновление пользовательского интерфейса, происходит в потоке ИП.  
  
> [!IMPORTANT]
>  Это поведение характерно только для приложений [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]. В приложениях для настольных систем не требуется контролировать, где выполняются продолжения. Вместо этого планировщик выбирает рабочий поток, в котором будет выполняться каждое продолжение.  
  
> [!IMPORTANT]
>  Не вызывайте [concurrency::task::wait](../Topic/task::wait%20Method.md) в теле продолжения, выполняемого в STA. В противном случае среда выполнения создает [concurrency::invalid\_operation](../Topic/invalid_operation%20Class.md) так как этот метод блокирует текущий поток и может вызвать зависание приложения. Тем не менее можно вызвать метод [concurrency::task::get](../Topic/task::get%20Method.md) для получения результата из предшествующей задачи в потоке задач.  
  
##  <a name="example-app"></a> Пример. Управление выполнением в приложении [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] с помощью C\+\+ и XAML  
 Рассмотрим приложение C\+\+ XAML, которое считывает файл с диска, находит наиболее распространенные слова в этом файле, а затем отображает результаты в пользовательском интерфейсе. Чтобы создать приложение, начните работу в Visual Studio, создав проект **Пустое приложение \(XAML\)**[!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] и назвав его `CommonWords`. В манифесте приложения укажите возможность **Библиотека документов**, которая позволяет приложению обращаться к папке "Документы". Также добавьте текстовый тип файла \(TXT\) в раздел объявлений манифеста приложения. Дополнительные сведения о возможностях и объявлениях приложения см. в разделе [Пакеты приложений и их развертывание](http://msdn.microsoft.com/library/windows/apps/hh464929.aspx).  
  
 Обновите элемент `Grid` в MainPage.xaml для включения элемента `ProgressRing` и элемента `TextBlock`.`ProgressRing` показывает, что операция выполняется, а `TextBlock` отображает результаты вычислений.  
  
 [!code-xml[concrt-windowsstore-commonwords#1](../../parallel/concrt/codesnippet/Xaml/creating-asynchronous-operations-in-cpp-for-windows-store-apps_6.xaml)]  
  
 Добавьте следующие выражения `#include` в pch.h.  
  
 [!code-cpp[concrt-windowsstore-commonwords#2](../../parallel/concrt/codesnippet/CPP/creating-asynchronous-operations-in-cpp-for-windows-store-apps_7.h)]  
  
 Добавьте следующие объявления методов в класс `MainPage` \(MainPage.h\).  
  
 [!code-cpp[concrt-windowsstore-commonwords#3](../../parallel/concrt/codesnippet/CPP/creating-asynchronous-operations-in-cpp-for-windows-store-apps_8.h)]  
  
 Добавьте следующие выражения `using` в MainPage.cpp.  
  
 [!code-cpp[concrt-windowsstore-commonwords#4](../../parallel/concrt/codesnippet/CPP/creating-asynchronous-operations-in-cpp-for-windows-store-apps_9.cpp)]  
  
 В файле MainPage.cpp реализуйте методы `MainPage::MakeWordList`, `MainPage::FindCommonWords` и `MainPage::ShowResults`.`MainPage::MakeWordList` и `MainPage::FindCommonWords` выполняют ресурсоемкие вычислительные операции. Метод `MainPage::ShowResults` отображает результат вычисления в пользовательском интерфейсе.  
  
 [!code-cpp[concrt-windowsstore-commonwords#5](../../parallel/concrt/codesnippet/CPP/creating-asynchronous-operations-in-cpp-for-windows-store-apps_10.cpp)]  
  
 Измените конструктор `MainPage` для создания цепочки задач продолжения, которые будут отображать в пользовательском интерфейсе распространенные слова из книги Гомера *Илиада*. Первые две задачи продолжения, которые разделят текст на отдельные слова и найдут распространенные слова, могут занимать продолжительное время, поэтому для них явно задано выполнение в фоновом режиме. Последняя задача продолжения, которая обновляет пользовательский интерфейс, не определяет контекст продолжения, поэтому следует правилам потоковых подразделений.  
  
 [!code-cpp[concrt-windowsstore-commonwords#6](../../parallel/concrt/codesnippet/CPP/creating-asynchronous-operations-in-cpp-for-windows-store-apps_11.cpp)]  
  
> [!NOTE]
>  В этом примере показано, как определить контексты выполнения и как составить цепочку продолжений. Помните, что по умолчанию задача, созданная из асинхронной операции, выполняет свои продолжения в подразделении, которое вызвало `task::then`. Таким образом, в этом примере используется `task_continuation_context::use_arbitrary` для указания того, что операции, которые не используют пользовательский интерфейс, должны выполняться в фоновом потоке.  
  
 На следующем рисунке показаны результаты выполнения приложения `CommonWords`.  
  
 ![Приложение CommonWords для Магазина Windows](../../parallel/concrt/media/concrt_windows_common_words.png "ConcRT\_windows\_Common\_Words")  
  
 В этом примере можно поддерживать отмену, поскольку объекты `task`, которые поддерживают `create_async`, используют неявный токен отмены. Определите свою рабочую функцию для приема объекта `cancellation_token`, если задачи должны отвечать на отмену в режиме совместной работы. Дополнительные сведения об отмене в PPL см. в разделе [Отмена](../../parallel/concrt/cancellation-in-the-ppl.md).  
  
## См. также  
 [Среда выполнения с параллелизмом](../../parallel/concrt/concurrency-runtime.md)