---
title: "Практическое руководство. Управление экземпляром планировщика | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "управление экземпляром планировщика [среда выполнения с параллелизмом]"
  - "экземпляры планировщика, управление [среда выполнения с параллелизмом]"
ms.assetid: 2cc804f0-5ff3-498b-97f1-a9f67a005448
caps.latest.revision: 15
caps.handback.revision: 12
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Практическое руководство. Управление экземпляром планировщика
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

Экземпляры планировщика позволяют связывать конкретные политики планирования с различными видами рабочих нагрузок.  В этом разделе содержатся два базовых примера, демонстрирующих создание экземпляра планировщика и управление им.  
  
 В этих примерах создаются планировщики, использующие политики планировщика по умолчанию.  Пример создания планировщика, использующего пользовательскую политику, см. в разделе [Практическое руководство. Задание определенных политик планировщика](../Topic/How%20to:%20Specify%20Specific%20Scheduler%20Policies.md).  
  
### Управление экземпляром планировщика в приложении  
  
1.  Создайте объект [concurrency::SchedulerPolicy](../../parallel/concrt/reference/schedulerpolicy-class.md), содержащий значения политики, которые должны использоваться планировщиком.  
  
2.  Вызовите метод [concurrency::CurrentScheduler::Create](../Topic/CurrentScheduler::Create%20Method.md) или [concurrency::Scheduler::Create](../Topic/Scheduler::Create%20Method.md), чтобы создать экземпляр планировщика.  
  
     Если используется метод `Scheduler::Create`, вызовите метод [concurrency::Scheduler::Attach](../Topic/Scheduler::Attach%20Method.md), когда нужно связать планировщик с текущим контекстом.  
  
3.  Вызовите функцию [CreateEvent](http://msdn.microsoft.com/library/windows/desktop/ms682396), чтобы создать дескриптор объекта события автоматического сброса с отсутствием сигнала.  
  
4.  Передайте дескриптор только что созданного объекта события методу [concurrency::CurrentScheduler::RegisterShutdownEvent](../Topic/CurrentScheduler::RegisterShutdownEvent%20Method.md) или [concurrency::Scheduler::RegisterShutdownEvent](../Topic/Scheduler::RegisterShutdownEvent%20Method.md).  Это позволяет зарегистрировать событие, которое необходимо настраивать при уничтожении планировщика.  
  
5.  Выполните задачи, которые должны планироваться текущим планировщиком.  
  
6.  Вызовите метод [concurrency::CurrentScheduler::Detach](../Topic/CurrentScheduler::Detach%20Method.md), чтобы отключить текущий планировщик и восстановить предыдущий планировщик в качестве текущего.  
  
     Если используется метод `Scheduler::Create`, вызовите метод [concurrency::Scheduler::Release](../Topic/Scheduler::Release%20Method.md), чтобы уменьшить число ссылок в объекте `Scheduler`.  
  
7.  Передайте дескриптор события функции [WaitForSingleObject](http://msdn.microsoft.com/library/windows/desktop/ms687032), чтобы дождаться завершения работы планировщика.  
  
8.  Вызовите функцию [CloseHandle](http://msdn.microsoft.com/library/windows/desktop/ms724211), чтобы закрыть дескриптор объекта события.  
  
## Пример  
 В следующем фрагменте кода показаны два способа управления экземпляром планировщика.  В каждом примере для выполнения задачи, выводящей уникальный идентификатор текущего планировщика, сначала используется планировщик по умолчанию.  Затем в каждом примере для повторного выполнения той же задачи используется экземпляр планировщика.  Наконец, в каждом примере планировщик по умолчанию восстанавливается в качестве текущего и еще раз выполняет эту задачу.  
  
 В первом примере для создания экземпляра планировщика и связывания его с текущим контекстом используется класс [concurrency::CurrentScheduler](../Topic/CurrentScheduler%20Class.md).  Во втором примере для выполнения той же задачи используется класс [concurrency::Scheduler](../../parallel/concrt/reference/scheduler-class.md).  Как правило, класс `CurrentScheduler` используется для работы с текущим планировщиком.  Сценарий, описанный во втором примере, в котором используется класс `Scheduler`, нужно использовать, если необходимо контролировать время связывания планировщика с текущим контекстом или связывать конкретные планировщики с конкретными задачами.  
  
 [!code-cpp[concrt-scheduler-instance#1](../../parallel/concrt/codesnippet/CPP/how-to-manage-a-scheduler-instance_1.cpp)]  
  
 В результате выполнения примера получается следующий результат:  
  
  **Использование класса CurrentScheduler…**  
**Идентификатор текущего планировщика: 0**  
**Создание и прикрепление планировщика…**  
**Идентификатор текущего планировщика: 1**  
**Открепление планировщика…**  
**Идентификатор текущего планировщика: 0**  
**Использование класса Scheduler…**  
**Идентификатор текущего планировщика: 0**  
**Создание планировщика…**  
**Прикрепление планировщика…**  
**Идентификатор текущего планировщика: 2**  
**Открепление планировщика…**  
**Идентификатор текущего планировщика: 0**   
## Компиляция кода  
 Скопируйте пример кода и вставьте его в проект Visual Studio или файл с именем `scheduler-instance.cpp`, затем выполните в окне командной строки Visual Studio следующую команду.  
  
 **cl.exe \/EHsc scheduler\-instance.cpp**  
  
## См. также  
 [Экземпляры планировщика](../../parallel/concrt/scheduler-instances.md)   
 [Практическое руководство. Задание определенных политик планировщика](../Topic/How%20to:%20Specify%20Specific%20Scheduler%20Policies.md)