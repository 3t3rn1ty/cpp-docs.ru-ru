---
title: "Практическое руководство. Использование фильтра блоков сообщений | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "фильтры блоков сообщений, использование [среда выполнения с параллелизмом]"
  - "использование фильтров блоков сообщений [среда выполнения с параллелизмом]"
ms.assetid: db6b99fb-288d-4477-96dc-b9751772ebb2
caps.latest.revision: 20
caps.handback.revision: 20
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Практическое руководство. Использование фильтра блоков сообщений
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

В этом документе показано, как использовать функцию фильтрации, чтобы асинхронный блок сообщений принимать или отклонять сообщения в зависимости от полезных данных сообщения.  
  
 При создании объекта блока сообщений, таких как [concurrency::unbounded_buffer](../Topic/unbounded_buffer%20Class.md),  [concurrency::call](../../parallel/concrt/reference/call-class.md), или [concurrency::transformer](../../parallel/concrt/reference/transformer-class.md), можно указать *функция filter* определяет ли блок сообщений принимает или отклоняет сообщение. Функция фильтрации является удобным способом гарантировать, что блок сообщений получать только определенные значения.  
  
 Функции фильтрации важны, поскольку они позволяют соединять блоки сообщений для формы *сети потока данных*. В сети потока данных блоки сообщений управляют потоком данных, обрабатывая только сообщения, которые удовлетворяют определенным критериям. Это отличается от модели потока управления, где поток данных контролируется с помощью структур управления, например условных операторов, циклов и так далее.  
  
 В этом документе содержится основной пример использования фильтра сообщений. Дополнительные примеры использования фильтров сообщений и модели потока данных для соединения блоков сообщений см. в разделе [Пошаговое руководство: создание агента потоков данных](../Topic/Walkthrough:%20Creating%20a%20Dataflow%20Agent.md) и [Пошаговое руководство: создание сети обработки изображений](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md).  
  
## <a name="example"></a>Пример  
 Рассмотрим следующую функцию `count_primes`, который иллюстрирует основное использование блока сообщений, который фильтрует входящие сообщения. Блок сообщений добавляет простые числа к [std::vector](vector%20Class.md) объекта.  `count_primes` Функция отправляет несколько чисел блоку сообщений, принимает выходные значения от блока сообщений и выводит эти простые числа на консоль.  
  
 [!CODE [concrt-primes-filter#1](../CodeSnippet/VS_Snippets_ConcRT/concrt-primes-filter#1)]  
  
  `transformer` Объект обрабатывает все входные значения; Однако он требует только простые числа. Несмотря на то, что можно написать приложение, таким образом, чтобы отправитель сообщений отправлял только простые числа, требования получателя сообщений не всегда известны.  
  
## <a name="example"></a>Пример  
 Следующая функция `count_primes_filter`, выполняет одну и ту же задачу как `count_primes` функции. Тем не менее `transformer` объект в этой версии использует функцию фильтрации, чтобы принимать только простые числа. Функция, которая выполняет действие принимает только простые числа; Таким образом, его не требуется вызывать `is_prime` функции.  
  
 Так как `transformer` объект принимает только простые числа, `transformer` может сам содержать простые числа. Другими словами `transformer` в этом примере не требуется добавлять простые числа к `vector` объекта.  
  
 [!CODE [concrt-primes-filter#2](../CodeSnippet/VS_Snippets_ConcRT/concrt-primes-filter#2)]  
  
  `transformer` Объект теперь обрабатывает только простые числа. В предыдущем примере `transformer` объект обрабатывает все сообщения. Следовательно предыдущий пример должна получать одинаковое количество сообщений, которые он отправляет. В этом примере результат [concurrency::send](../Topic/send%20Function.md) функции, чтобы определить, сколько сообщений нужно получить от `transformer` объекта.  `send` Возвращает `true` Если буфер сообщений принимает сообщение и `false` Когда буфер сообщений отклоняет сообщение. Следовательно сколько раз, что буфер сообщений принимает сообщение соответствует количество простых чисел.  
  
## <a name="example"></a>Пример  
 Ниже приведен полный пример кода. Пример вызывает и `count_primes` функции и `count_primes_filter` функции.  
  
 [!CODE [concrt-primes-filter#3](../CodeSnippet/VS_Snippets_ConcRT/concrt-primes-filter#3)]  
  
## <a name="compiling-the-code"></a>Компиляция кода  
 Скопируйте код примера и вставьте его в проект Visual Studio и вставьте его в файл с именем `primes-filter.cpp` и затем выполните следующую команду в окне командной строки Visual Studio.  
  
 **/ EHsc CL.exe простые числа filter.cpp**  
  
## <a name="robust-programming"></a>Отказоустойчивость  
 Функция filter может быть лямбда-функции, указателя функции или объекта функции. Любая функция фильтрации принимает одну из следующих форм:  
  
```Output  
bool (T)  
bool (T const &)  
```  
  
 Чтобы исключить лишнее копирование данных, следует используйте вторую форму при наличии с составным типом, передаваемым по значению.  
  
## <a name="see-also"></a>См. также  
 [Библиотека асинхронных агентов](../../parallel/concrt/asynchronous-agents-library.md)   
 [Пошаговое руководство: Создание агента потоков данных](../Topic/Walkthrough:%20Creating%20a%20Dataflow%20Agent.md)   
 [Пошаговое руководство: Создание сети обработки изображений](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md)   
 [Класс transformer](../../parallel/concrt/reference/transformer-class.md)
