---
title: Асинхронные блоки сообщений | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-concrt
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- non-greedy join [Concurrency Runtime]
- asynchronous message blocks
- greedy join [Concurrency Runtime]
ms.assetid: 79c456c0-1692-480c-bb67-98f2434c1252
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 5de4a9ed20e20c03f44f8b8d421a628f220099f7
ms.sourcegitcommit: 7019081488f68abdd5b2935a3b36e2a5e8c571f8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/07/2018
ms.locfileid: "33695035"
---
# <a name="asynchronous-message-blocks"></a>Асинхронные блоки сообщений

Библиотека агентов предоставляет несколько типов блоков сообщений, которые позволяют передавать сообщения между компонентами приложения в потокобезопасным способом. Эти типы блоков сообщений часто используются с различные процедуры передачи сообщений, таких как [concurrency::send](reference/concurrency-namespace-functions.md#send), [concurrency::asend](reference/concurrency-namespace-functions.md#asend), [concurrency::receive](reference/concurrency-namespace-functions.md#receive), и [concurrency::try_receive](reference/concurrency-namespace-functions.md#try_receive). Дополнительные сведения о процедурах, которые определены в библиотеке агентов передачи сообщений см. в разделе [функции передачи сообщений](../../parallel/concrt/message-passing-functions.md).  
  
##  <a name="top"></a> Разделы  
 В этом разделе содержатся следующие подразделы.  
  
- [Источники и целевые объекты](#sources_and_targets)  
  
- [Распространение сообщений](#propagation)  
  
- [Обзор типов блоков сообщений](#overview)  
  
- [Класс unbounded_buffer](#unbounded_buffer)  
  
- [Класс overwrite_buffer](#overwrite_buffer)  
  
- [Класс single_assignment](#single_assignment)  
  
- [Класс call](#call)  
  
- [Класс transformer](#transformer)  
  
- [Класс choice](#choice)  
  
- [Классы JOIN и multitype_join](#join)  
  
- [Класс timer](#timer)  
  
- [Фильтрация сообщений](#filtering)  
  
- [Резервирование сообщений](#reservation)  
  
##  <a name="sources_and_targets"></a> Источники и целевые объекты  
 Источники и целевые объекты находятся два важных участника передачи сообщений. Объект *источника* — это конечная точка передачи данных, которая отправляет сообщения. Объект *целевой* — это конечная точка передачи данных, которая получает сообщения. Можно рассматривать как конечную точку, считываемых из источника и целевой конечной точки, можно написать для. Приложения подключаются исходные и целевые объекты вместе форму *сети обмена сообщениями*.  
  
 Библиотека агентов использует два абстрактные классы для представления источников и целевых объектов: [concurrency::ISource](../../parallel/concrt/reference/isource-class.md) и [concurrency::ITarget](../../parallel/concrt/reference/itarget-class.md). Типы блоков сообщений, выполняющие роль источников, являются производными от `ISource`; типы блоков сообщений, выполняющие роль целевых объектов являются производными от `ITarget`. Типы блоков сообщений, выступающих в качестве источников и целевых объектов, наследуются от классов `ISource` и `ITarget`.  
  
 [[В начало](#top)]  
  
##  <a name="propagation"></a> Распространение сообщений  
 *Сообщения* — это процесс отправки сообщения из одного компонента. Когда блок сообщений предлагается сообщение, он может принять, отклонить или отложить его. Типы блоков сообщений сохраняют и передают сообщения по-разному. Например `unbounded_buffer` класс хранит неограниченное число сообщений, `overwrite_buffer` класс хранит одно сообщение за раз, а класс transformer сохраняет измененную версию каждого сообщения. Эти типы блоков сообщений описаны более подробно далее в этом документе.  
  
 Когда блок сообщений принимает сообщение, он может при необходимости выполнения работы и, если блок сообщений является источником, передать обработанное сообщение другому члену сети. Блок сообщений можно использовать функцию фильтрации, чтобы отказаться от сообщений, которые не нужно получать. Фильтры описаны более подробно далее в этом разделе, в разделе [фильтрации сообщений](#filtering). Блок сообщений, откладывающий сообщения можно зарезервировать и использовать его позже. Резервирование сообщений является более подробно далее в этом разделе, в разделе [резервирование сообщений](#reservation).  
  
 Библиотека агентов позволяет блокам сообщений асинхронно или синхронно передавать сообщения. При передаче сообщения в блок сообщений синхронно, например, с помощью `send` функции, среда выполнения блокирует текущий контекст, пока целевой блок принимает или отклоняет сообщение. При передаче сообщения в блок сообщений асинхронно, например, с помощью `asend` функция, среда выполнения предлагает сообщение целевому объекту, и если целевой объект принимает сообщение, планирует асинхронную задачу, распространяющую сообщение в приемник. Среда выполнения использует упрощенные задачи для распространения сообщений в режиме совместной работы. Дополнительные сведения об упрощенных задачах см. в разделе [планировщик](../../parallel/concrt/task-scheduler-concurrency-runtime.md).  
  

 Приложения для связывания исходные и целевые объекты сети обмена сообщениями. Обычно выполняется подключение к ней и вызов `send` или `asend` для передачи данных в сети. Для подключения к целевому объекту исходного блока сообщений, вызовите [concurrency::ISource::link_target](reference/isource-class.md#link_target) метод. Чтобы отключить блок источника от целевого объекта, вызовите [concurrency::ISource::unlink_target](reference/isource-class.md#unlink_target) метод. Чтобы отключить блок источника от всех целевых объектов, вызовите [concurrency::ISource::unlink_targets](reference/isource-class.md#unlink_targets) метод. Когда один из предопределенных типов блоков сообщений покидает область или освобождается, он автоматически отключает сам от любых целевых блоков. Некоторые типы блоков сообщений ограничить максимальное число целевых объектов, которые могут быть записаны. Далее описываются ограничения, которые применяются для предопределенных типов блоков сообщений.  
  
 [[В начало](#top)]  
  
##  <a name="overview"></a> Обзор типов блоков сообщений  
 В следующей таблице кратко описывается роль типов блоков важных сообщений.  
  
 [unbounded_buffer](#unbounded_buffer)  
 Хранит очередь сообщений.  
  
 [overwrite_buffer](#overwrite_buffer)  
 Хранит одно сообщение, которое можно записать и многократно считывать.  
  
 [single_assignment](#single_assignment)  
 Хранит одно сообщение, которое можно один раз записать и многократно считывать.  
  
 [Вызов](#call)  
 Выполняет работу, когда он получает сообщение.  
  
 [transformer](#transformer)  
 Выполняет работу при получении данных и отправляет результат своей работы другому целевому блоку. `transformer` Класс может действовать на различные входные и выходные типы.  
  
 [Выбор](#choice)  
 Выбирает первое доступное сообщение из набора источников.  
  
 [соединения и возвращаемым соединения](#join)  
 Ожидания для всех сообщений, полученных из набора источников и затем объединяет эти сообщения в одно сообщение для другого блока сообщений.  
  
 [Таймера](#timer)  
 Отправляет сообщение в целевой блок через равные промежутки времени.  
  
 Эти типы блоков сообщений, имеют разные характеристики, которые используются в различных ситуациях. Ниже приведено несколько характеристик:  
  
- *Тип распространения*: является ли блок сообщений выступает в качестве источника данных и приемником данных.  
  
- *Упорядочение сообщений*: сохраняет ли блок сообщений исходный порядок, отправка или получение сообщений. Каждый предопределенные типы блоков сообщений сохраняет исходный порядок, в котором отправлять или получать сообщения.  
  
- *Счетчик источника*: максимальное число источников, которые блок сообщений может производить чтение.  
  
- *Число целевых*: максимальное число целевых объектов, которые блок сообщений может производить запись.  
  
 Следующая таблица показывает, как эти характеристики соотносятся с различными типами блоков сообщений.  
  
|Тип блока сообщений|Тип распространения (источник, целевая или оба)|Сообщение заказа (Ordered или Unordered)|Число источников|Число целевых объектов|  
|------------------------|--------------------------------------------------|-----------------------------------------------|------------------|------------------|  
|`unbounded_buffer`|Оба значения|Упорядоченного|без привязки|без привязки|  
|`overwrite_buffer`|Оба значения|Упорядоченного|без привязки|без привязки|  
|`single_assignment`|Оба значения|Упорядоченного|без привязки|без привязки|  
|`call`|целевого объекта|Упорядоченного|без привязки|Не применимо|  
|`transformer`|Оба значения|Упорядоченного|без привязки|1|  
|`choice`|Оба значения|Упорядоченного|10|1|  
|`join`|Оба значения|Упорядоченного|без привязки|1|  
|`multitype_join`|Оба значения|Упорядоченного|10|1|  
|`timer`|Исходный код|Не применимо|Не применимо|1|  
  
 В следующих разделах описаны типы блоков сообщений, более подробно.  
  
 [[В начало](#top)]  
  
##  <a name="unbounded_buffer"></a> Класс unbounded_buffer  
 [Concurrency::unbounded_buffer](reference/unbounded-buffer-class.md) класс представляет структуру общего назначения асинхронного обмена сообщениями. В этом классе хранится очередь сообщений типа «первым вошел — первым вышел» (FIFO), в которую могут записывать данные несколько источников и из которой могут читать данные несколько целевых объектов. Когда целевой объект получает сообщение от `unbounded_buffer` объекта, это сообщение удаляется из очереди сообщений. Таким образом несмотря на то что `unbounded_buffer` может иметь несколько целевых объектов, только один целевой объект получит каждое сообщение. Класс `unbounded_buffer` удобен, если нужно передать несколько сообщений другому компоненту и этот компонент должен принять каждое сообщение.  
  
### <a name="example"></a>Пример  
 В следующем примере показана базовая структура работы с `unbounded_buffer` класса. В этом примере отправляются три значения `unbounded_buffer` объект, а затем эти значения считываются из тот же объект.  
  
 [!code-cpp[concrt-unbounded_buffer-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_1.cpp)]  
  
 В этом примере выводятся следующие данные:  
  
```Output  
334455  
```  
  
 Полный пример, демонстрирующий использование `unbounded_buffer` см. в описании [как: реализация различных шаблонов производитель-получатель](../../parallel/concrt/how-to-implement-various-producer-consumer-patterns.md).  
  
 [[В начало](#top)]  
  
##  <a name="overwrite_buffer"></a> Класс overwrite_buffer  
 [Concurrency::overwrite_buffer](../../parallel/concrt/reference/overwrite-buffer-class.md) похож `unbounded_buffer` класса, за исключением того, что `overwrite_buffer` объект сохраняет только одно сообщение. Кроме того, когда целевой объект получает сообщение от `overwrite_buffer` объекта, это сообщение не удаляется из буфера. Поэтому копию сообщения могут получить несколько целевых объектов.  
  
 `overwrite_buffer` Класс полезен, когда требуется передать несколько сообщений другому компоненту, но этому компоненту нужно только самое последнее значение. Этот класс также может оказаться полезным при необходимости широковещательной передачи сообщения нескольким компонентам.  
  
### <a name="example"></a>Пример  
 В следующем примере показана базовая структура работы с `overwrite_buffer` класса. В этом примере отправляются три значения `overwrite _buffer` объекта, а затем считывает текущее значение из того же объекта три раза. Этот пример похож на пример для `unbounded_buffer` класса. Однако `overwrite_buffer` класса сохраняет только одно сообщение. Кроме того, среда выполнения не удаляет сообщение из `overwrite_buffer` объекта после его чтения.  
  
 [!code-cpp[concrt-overwrite_buffer-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_2.cpp)]  
  
 В этом примере выводятся следующие данные:  
  
```Output  
555555  
```  
  
 Полный пример, демонстрирующий использование `overwrite_buffer` см. в описании [как: реализация различных шаблонов производитель-получатель](../../parallel/concrt/how-to-implement-various-producer-consumer-patterns.md).  
  
 [[В начало](#top)]  
  
##  <a name="single_assignment"></a> Класс single_assignment  
 [Concurrency::single_assignment](../../parallel/concrt/reference/single-assignment-class.md) похож `overwrite_buffer` класса, за исключением того, что `single_assignment` объект можно записать только один раз. Как и в случае с классом `overwrite_buffer`, когда целевой объект получает сообщение от объекта `single_assignment`, это сообщение не удаляется. Поэтому копию сообщения могут получить несколько целевых объектов. `single_assignment` Класс полезен при необходимости широковещательной передачи одного сообщения нескольким компонентам.  
  
### <a name="example"></a>Пример  
 В следующем примере показана базовая структура работы с `single_assignment` класса. В этом примере отправляются три значения `single_assignment` объекта, а затем считывает текущее значение из того же объекта три раза. Этот пример похож на пример для `overwrite_buffer` класса. Несмотря на то что оба `overwrite_buffer` и `single_assignment` классы хранить одно сообщение `single_assignment` класса можно записать только один раз.  
  
 [!code-cpp[concrt-single_assignment-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_3.cpp)]  
  
 В этом примере выводятся следующие данные:  
  
```Output  
333333  
```  
  
 Полный пример, демонстрирующий использование `single_assignment` см. в описании [Пошаговое руководство: реализация фьючерсов](../../parallel/concrt/walkthrough-implementing-futures.md).  
  
 [[В начало](#top)]  
  
##  <a name="call"></a> Класс Call  
 [Concurrency::call](../../parallel/concrt/reference/call-class.md) класс действует как получатель сообщения, которое выполняет рабочую функцию при получении данных. Эта рабочая функция может быть лямбда-выражение, объект функции или указатель функции. Объект `call` объекта отличается от обычного вызова функции, так как он работает параллельно с другими компонентами, отправку сообщений. Если `call` объект выполняет работу, когда он получает сообщение, он добавляет это сообщение в очередь. Каждый `call` объект обрабатывает сообщения в порядке их получения из очереди.  
  
### <a name="example"></a>Пример  
 В следующем примере показана базовая структура работы с `call` класса. В этом примере создается `call` объект, который выводит все значения, получаемые в консоль. Затем в примере выполняется отправка три значения `call` объекта. Поскольку `call` объект обрабатывает сообщения в отдельном потоке, в этом примере также использует переменную счетчика и [событий](../../parallel/concrt/reference/event-class.md) объекта, чтобы убедиться, что `call` объект обрабатывает все сообщения, прежде чем `wmain` функция возвращает.  
  
 [!code-cpp[concrt-call-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_4.cpp)]  
  
 В этом примере выводятся следующие данные:  
  
```Output  
334455  
```  
  
 Полный пример, демонстрирующий использование `call` см. в описании [как: предоставления рабочих функций классам call и transformer](../../parallel/concrt/how-to-provide-work-functions-to-the-call-and-transformer-classes.md).  
  
 [[В начало](#top)]  
  
##  <a name="transformer"></a> Класс transformer  
 [Concurrency::transformer](../../parallel/concrt/reference/transformer-class.md) класс действует как получателя, так и как отправителя сообщения. `transformer` Похож `call` класса, так как он выполняет рабочую функцию определяемых пользователем, при получении данных. Тем не менее `transformer` класс также отправляет результат функции рабочих объекты получателя. Как `call` объекта, `transformer` действует параллельно с другими компонентами, отправку сообщений. Если `transformer` объект выполняет работу, когда он получает сообщение, он добавляет это сообщение в очередь. Каждый `transformer` объект обрабатывает сообщения из своей очереди в порядке их получения.  
  
 `transformer` Класс отправляет свои сообщения одному целевому объекту. Если задать `_PTarget` параметра в конструктор для `NULL`, позже можно указать целевой объект путем вызова метода [concurrency::link_target](reference/source-block-class.md#link_target) метод.  
  
 В отличие от всех других асинхронных типов блоков сообщений, предоставляемых библиотекой агентов `transformer` класс может действовать на различные входные и выходные типы. Эта способность преобразовывать данные из одного типа в другой превращает `transformer` класса является ключевым компонентом многих параллельных сетей. Кроме того, можно добавить возможность параллельной обработки более детально в рабочая функция `transformer` объекта.  
  
### <a name="example"></a>Пример  
 В следующем примере показана базовая структура работы с `transformer` класса. В этом примере создается `transformer` объекта, умножающий все введенные `int` 0,33, чтобы получить значение `double` значение в качестве выходных данных. Затем пример получает преобразованные значения из того же `transformer` объекта и выводит их на консоль.  
  
 [!code-cpp[concrt-transformer-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_5.cpp)]  
  
 В этом примере выводятся следующие данные:  
  
```Output  
10.8914.5218.15  
```  
  
 Полный пример, демонстрирующий использование `transformer` см. в описании [как: использование преобразователя в конвейере данных](../../parallel/concrt/how-to-use-transformer-in-a-data-pipeline.md).  
  
 [[В начало](#top)]  
  
##  <a name="choice"></a> Класс Choice  
 [Concurrency::choice](../../parallel/concrt/reference/choice-class.md) класс выбирает первое доступное сообщение из набора источников. `choice` Класс представляет механизм потока управления вместо механизма потока данных (раздел [библиотеки асинхронных агентов](../../parallel/concrt/asynchronous-agents-library.md) описаны различия между потока данных и потока управления).  
  
 Чтение из объекта choice похоже на вызов функции Windows API `WaitForMultipleObjects` котором `bWaitAll` равным `FALSE`. Тем не менее `choice` класс выполняет привязку их данных событий, а не к внешнему объекту синхронизации.  
  

 Как правило, используется `choice` класса вместе с [concurrency::receive](reference/concurrency-namespace-functions.md#receive) функции для использования потока управления в приложении. Используйте `choice` класса, когда необходимо выбрать один из буферов сообщений, которые имеют разные типы. Используйте `single_assignment` класса, если необходимо выбрать один из буферов сообщений, которые имеют одинаковый тип.  

  
 Порядок, в котором связывания источников с `choice` важен, поскольку он определяет которой сообщения. Например, рассмотрим случай, где связывать несколько буферов сообщений, которые уже содержат сообщение `choice` объекта. `choice` Объект выбирает сообщение из первого источника, которым он связан. После привязки всех источников `choice` сохраняет порядок, в котором каждый из источников получает сообщение.  
  
### <a name="example"></a>Пример  

 В следующем примере показана базовая структура работы с `choice` класса. В этом примере используется [concurrency::make_choice](reference/concurrency-namespace-functions.md#make_choice) функция, создающая `choice` объект, который выбирает среди трех блоков сообщений. Затем вычисляются различные числа Фибоначчи и каждый результат сохраняется в разных SMB. В примере затем выводится на консоль сообщения, основанный на первой завершившейся операции.  

  
 [!code-cpp[concrt-choice-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_6.cpp)]  
  
 В этом примере получается следующий результат:  
  
```Output  
fib35 received its value first. Result = 9227465  
```  
  
 Так как задача, которая вычисляет 35<sup>й</sup> Фибоначчи не обязательно завершится первой, результат этого примера может различаться.  
  

 В этом примере используется [concurrency::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) алгоритм для вычисления чисел Фибоначчи параллельно. Дополнительные сведения о `parallel_invoke`, в разделе [параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md).  
  
 Полный пример, демонстрирующий использование `choice` см. в описании [как: выбор среди завершения задач](../../parallel/concrt/how-to-select-among-completed-tasks.md).  
  
 [[В начало](#top)]  
  
##  <a name="join"></a> Классы JOIN и multitype_join  
 [Concurrency::join](../../parallel/concrt/reference/join-class.md) и [concurrency::multitype_join](../../parallel/concrt/reference/multitype-join-class.md) классы позволяют ожидать каждого элемента набора источников для получения сообщения. `join` Класс предназначен для источника объектов, имеющих общий тип сообщений. `multitype_join` Класс предназначен для источника объектов, которые могут иметь разные типы сообщений.  
  
 Чтение из `join` или `multitype_join` похоже на вызов функции Windows API `WaitForMultipleObjects` котором `bWaitAll` равным `TRUE`. Однако, как `choice` объекта, `join` и `multitype_join` объекты используют механизм событий, который привязывает данные событий, а не к внешнему объекту синхронизации.  
  
 Чтение из `join` объект создает объект std::[вектор](../../standard-library/vector-class.md) объекта. Чтение из `multitype_join` объект создает объект std::[кортежа](../../standard-library/tuple-class.md) объекта. Элементы располагаются в этих объектах в том же порядке, как их соответствующих буферов источника связаны с `join` или `multitype_join` объекта. Поскольку порядок, в котором связать источник буферов для `join` или `multitype_join` объект связан с порядком элементов в итоговом `vector` или `tuple` объекта, рекомендуется не отсоединять существующий исходный буфер из соединение. Это может привести к непредсказуемому поведению.  
  
### <a name="greedy-versus-non-greedy-joins"></a>Жадного и нежадные объединения  
 `join` И `multitype_join` классы поддерживают концепцию жадный и нежадный соединения. Объект *жадное объединение* принимает сообщения от каждого из своих источников, как сообщения будут доступны, пока не будут доступны все сообщения. Объект *нежадное объединение* получает сообщения в два этапа. Во-первых нежадное объединение ожидает, пока не предлагается сообщение от каждого из своих источников. Во-вторых все исходные сообщения доступны, нежадное соединение пытается зарезервировать все эти сообщения. Если он может зарезервировать все сообщения, он получает все сообщения и распространяет их на целевой объект. В противном случае — он освобождает, или отменяет резервирования сообщение и ожидает еще раз для каждого источника для получения сообщения.  
  
 Жадное объединение работает лучше, чем нежадные объединения, поскольку сообщения принимаются немедленно. Тем не менее в редких случаях жадное объединение может привести к взаимоблокировке. Используйте нежадное объединение при наличии нескольких объединений, содержащих один или несколько объектов общий источник.  
  
### <a name="example"></a>Пример  

 В следующем примере показана базовая структура работы с `join` класса. В этом примере используется [concurrency::make_join](reference/concurrency-namespace-functions.md#make_join) функцию для создания `join` объект, получающий трех `single_assignment` объектов. В этом примере вычисляются различные числа Фибоначчи, каждый результат сохраняется в другом `single_assignment` объекта, а затем выводит на консоль результатов, `join` содержащиеся в объекте. Этот пример похож на пример для `choice` класса, за исключением того, что `join` класс ожидает завершения всех исходных блоков сообщений для получения сообщения.  
  
 [!code-cpp[concrt-join-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_7.cpp)]  
  
 В этом примере выводятся следующие данные:  
  
```Output  
fib35 = 9227465fib37 = 24157817half_of_fib42 = 1.33957e+008  
```  

 В этом примере используется [concurrency::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) алгоритм для вычисления чисел Фибоначчи параллельно. Дополнительные сведения о `parallel_invoke`, в разделе [параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md).  
  
 Полные примеры, которые показывают, как использовать `join` см. в описании [как: выбор среди завершения задач](../../parallel/concrt/how-to-select-among-completed-tasks.md) и [Пошаговое руководство: использование класса join для предотвращения взаимоблокировок](../../parallel/concrt/walkthrough-using-join-to-prevent-deadlock.md).  
  
 [[В начало](#top)]  
  
##  <a name="timer"></a> Класс Timer  
 Уровень параллелизма::[класс timer](../../parallel/concrt/reference/timer-class.md) выступает в качестве источника сообщений. Объект `timer` объект отправляет сообщение целевому объекту по истечении указанного периода времени. `timer` Класс полезен, когда требуется задержать передачу сообщения или требуется передавать сообщения через равные промежутки времени.  
  

 `timer` Класс отправляет свое сообщение только одному целевому объекту. Если задать `_PTarget` параметра в конструктор для `NULL`, позже можно указать целевой объект путем вызова метода [concurrency::ISource::link_target](reference/source-block-class.md#link_target) метод.  

  
 Объект `timer` может быть повторяющимся или неповторяющихся. Чтобы создать повторяющийся таймер, передайте `true` для `_Repeating` параметра при вызове конструктора. В противном случае передайте `false` для `_Repeating` для создания неповторяющегося таймера. Если таймер повторяющийся, он отправляет одно сообщение своей цели после каждого интервала.  
  
 Библиотека агентов создает `timer` объекты в состоянии не запущен. Чтобы запустить объект таймера, вызовите [Concurrency::Timer:: Start](reference/timer-class.md#start) метод. Чтобы остановить `timer` объекта, уничтожить объект или вызов [concurrency::timer::stop](reference/timer-class.md#stop) метод. Чтобы приостановить повторяющийся таймер, вызовите [concurrency::timer::pause](reference/timer-class.md#pause) метод.  
  
### <a name="example"></a>Пример  
 В следующем примере показана базовая структура работы с `timer` класса. В этом примере `timer` и `call` объекты сообщают о ходе выполнения длительной операции.  
  
 [!code-cpp[concrt-timer-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_8.cpp)]  
  
 В этом примере получается следующий результат:  
  
```Output  
Computing fib(42)..................................................result is 267914296  
```  
  
 Полный пример, демонстрирующий использование `timer` см. в описании [как: отправить сообщение через определенные интервалы](../../parallel/concrt/how-to-send-a-message-at-a-regular-interval.md).  
  
 [[В начало](#top)]  
  
##  <a name="filtering"></a> Фильтрация сообщений  
 При создании объекта блока сообщений, можно указать *функция filter* , определяет, является ли блок сообщений принимает или отклоняет сообщение. Функция фильтрации является хорошим способом гарантировать, что блок сообщений получать только определенные значения.  
  
 В следующем примере показано, как создать `unbounded_buffer` объект, который использует функцию фильтрации, чтобы принимать только четные числа. `unbounded_buffer` Объект отклоняет нечетные цифры и таким образом, не распространяется нечетного числа своим целевым блокам.  
  
 [!code-cpp[concrt-filter-function#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_9.cpp)]  
  
 В этом примере выводятся следующие данные:  
  
```Output  
0 2 4 6 8  
```  
  
 Функции фильтров может быть лямбда-функции, указателя функции или объекта функции. Любая функция фильтрации принимает одно из следующих форм.  
  
```Output  
bool (T)  
bool (T const &)  
```  
  
 Чтобы избежать ненужных копирования данных, используйте второй формы при наличии Агрегатный тип, передаваемый по значению.  
  
 Поддерживает фильтрации сообщений *потока данных* модель программирования, в которой компоненты выполняют вычисления при получении данных. Примеры использования функций фильтрации для управления потоком данных в сети, передача сообщений см. в разделе [как: использование фильтра блоков сообщений](../../parallel/concrt/how-to-use-a-message-block-filter.md), [Пошаговое руководство: создание агента потоков данных](../../parallel/concrt/walkthrough-creating-a-dataflow-agent.md), и [ Пошаговое руководство: Создание сети обработки изображений](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md).  
  
 [[В начало](#top)]  
  
##  <a name="reservation"></a> Резервирование сообщений  
 *Резервирование сообщений* позволяет блоку сообщений зарезервировать сообщение для последующего использования. Как правило резервирование сообщений не используется напрямую. Однако понимание сообщения резервирования, чтобы лучше понять поведение некоторых предопределенных типов блоков сообщений.  
  
 Рассмотрите возможность нежадном и нежадные соединения. Они используют резервирование сообщений резервирование сообщений для последующего использования. Как описано ранее, нежадное соединение получает сообщения в два этапа. Во время первой фазы нежадный `join` объект ожидает от каждого из своих источников для получения сообщения. Нежадное объединение пытается зарезервировать все эти сообщения. Если он может зарезервировать все сообщения, он получает все сообщения и распространяет их на целевой объект. В противном случае — он освобождает, или отменяет резервирования сообщение и ожидает еще раз для каждого источника для получения сообщения.  
  
 Жадное объединение, который также считывает входящие сообщения из нескольких источников, использует резервирование сообщений для чтения дополнительные сообщения, время ожидания получения сообщения из каждого источника. Например, рассмотрим жадное объединение, которая получает сообщения из блоков сообщений `A` и `B`. Если жадное объединение получает два сообщения с B, но еще не получил сообщение от `A`, жадное объединение сохраняет уникальный идентификатор сообщения для второе сообщение от `B`. После жадное объединение получает сообщение от `A` и распространяет эти сообщения, он использует идентификатор сохраненного сообщения ли второе сообщение от `B` по-прежнему доступен.  
  
 Резервирование сообщений можно использовать при реализации собственных типов блоков пользовательское сообщение. Пример о том, как создать пользовательский тип блока сообщений см. в разделе [Пошаговое руководство: Создание пользовательского блока сообщений](../../parallel/concrt/walkthrough-creating-a-custom-message-block.md).  
  
 [[В начало](#top)]  
  
## <a name="see-also"></a>См. также  
 [Библиотека асинхронных агентов](../../parallel/concrt/asynchronous-agents-library.md)

