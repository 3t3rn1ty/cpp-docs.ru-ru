---
title: "2.7.1 threadprivate Directive | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
ms.assetid: 08e0b70f-5359-4607-b0ca-38c2d570d7b3
caps.latest.revision: 7
caps.handback.revision: 7
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# 2.7.1 threadprivate Directive
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

`threadprivate` директива позволяет файл\-область с именем, пространством имен\-область или статические переменные, определенные в блок\-области список переменных private в поток.  *список переменных* список переменных с разделителями\-запятыми, которые не имеют неполный тип.  Синтаксис  `threadprivate` директива выглядит следующим образом:  
  
```  
#pragma omp threadprivate(variable-list) new-line  
```  
  
 Каждая копия a `threadprivate` переменная инициализирована раз для неопределенного шаг в программе до первой ссылки на эту копии, и в обычном режиме \(т е как мастер\-копия будет инициализирована в последовательном выполнении программы\).  Обратите внимание, что, если он имеется ссылка в явном инициализаторе a `threadprivate` переменная, а значение объекта изменены до первой ссылки на копии переменной, а затем расширения функциональности не определено.  
  
 Как и в закрытой переменной поток не должен ссылаться на копию другого потока a `threadprivate` объект.  При выполнении последовательных областей и мастерских областей программы, ссылки будут к копии главного потока объекта.  
  
 После первой параллельной области выполняет данных в `threadprivate` гарантируется сохраняет объекты, только если был заблокирован динамического механизма потоков, и если количество потоков остается неизменным для всех параллельных областей.  
  
 Ограничения `threadprivate` директива выглядит следующим образом:  
  
-   A `threadprivate` директива для переменных файл\-области или пространство имен\-области должна использоваться вне любых определения или объявления и должна предшествовать любому лексически ссылки на переменные в списке.  
  
-   Каждая переменная список переменных a `threadprivate` директива в области файла или пространства имен должна ссылаться на переменную объявлению в области файла или пространства имен, которые лексически предшествует директива.  
  
-   A `threadprivate` директива для статических переменных блок\-области должна отображаться в область действия переменной, а не во вложенной области.  Рекомендация должна предшествовать любому лексически ссылки на переменные в списке.  
  
-   Каждая переменная список переменных a `threadprivate` директива в области блока должна ссылаться на переменную объявлению в той же области, которые лексически предшествует директива.  Объявление переменной должно использовать статический описатель хранени\-класса.  
  
-   Если переменная определена в a `threadprivate` директива в одной единице измерения перевода, ее необходимо определить в выражении  `threadprivate` директива в каждой единицы измерения перевода, в которой он объявлен.  
  
-   A `threadprivate` переменная не должна появляться в любое предложение, отличный от  `copyin`"  `copyprivate`"  `schedule`"  `num_threads`или  **If** предложение.  
  
-   Адрес a `threadprivate` переменная не константы адреса.  
  
-   A `threadprivate` переменная должна иметь неполный тип или ссылочный тип.  
  
-   A `threadprivate` переменная с типом класса non\-СТРУЧКА должна иметь точно, выраженный конструктор копии, если объявлено с явным инициализатором.  
  
 В следующем примере показано, как изменить переменную, которая отображается в инициализатор может привести к неспецифицированную расширения функциональности, а также как избежать этой проблемы с помощью вспомогательного объекта и копия\-конструктора.  
  
```  
int x = 1;  
T a(x);  
const T b_aux(x); /* Capture value of x = 1 */  
T b(b_aux);  
#pragma omp threadprivate(a, b)  
  
void f(int n) {  
   x++;  
   #pragma omp parallel for  
   /* In each thread:  
   * Object a is constructed from x (with value 1 or 2?)  
   * Object b is copy-constructed from b_aux  
   */  
   for (int i=0; i<n; i++) {  
      g(a, b); /* Value of a is unspecified. */  
   }  
}  
```  
  
## Перекрестные ссылки:  
  
-   Динамические потоки, см. в разделе [Раздел 3.1.7](../../parallel/openmp/3-1-7-omp-set-dynamic-function.md) на странице 39.  
  
-   `OMP_DYNAMIC` переменная среды выполнения, см. в разделе  [Шаг 4.3](../../parallel/openmp/4-3-omp-dynamic.md) на странице 49.