---
title: "2.6.5 директива flush | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
ms.assetid: a2ec5f74-9c37-424a-8376-47ab4a5829a2
caps.latest.revision: 
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: 7607070692941606b863be9248b2d69f093f3a13
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="265-flush-directive"></a>2.6.5 Директива flush
**Flush** директивы, явных или подразумеваемых, указывается точка «между потоками» последовательности для убедитесь, что все потоки в группе имеют согласованное представление определенных объектов (указанным ниже) в, с которой требуется реализация объем памяти. Это означает, что выполнены предыдущие оценки выражений, ссылающихся на эти объекты, и последующие вычисления еще не начали. Например компиляторов необходимо восстановить значения объектов из регистров в памяти и оборудования может потребоваться очистить буферы записи в память и перезагрузить значений объектов из памяти.  
  
 Синтаксис **flush** директивы таков:  
  
```  
#pragma omp flush [(variable-list)]  new-line  
```  
  
 Если объекты, для которых необходима синхронизация всех, назначается переменных, то эти переменные можно указать в необязательном *списка переменной*. Если указатель находится в *списка переменной*, записываемых сам указатель, не объект указатель ссылается.  
  
 Объект **flush** директив без *списка переменной* синхронизируется с автоматической длительностью хранения всех общих объектов, кроме недоступные объекты. (Это может иметь несколько сложнее, чем **flush** с *списка переменной*.) Объект **flush** директив без *списка переменной* подразумевается для следующие директивы:  
  
-   `barrier`  
  
-   На вход и выход из **критические**  
  
-   На вход и выход из`ordered`  
  
-   На вход и выход из **параллельных**  
  
-   AT выхода из **для**  
  
-   AT выхода из **разделы**  
  
-   AT выхода из **один**  
  
-   На вход и выход из **параллельных для**  
  
-   На вход и выход из **параллельные разделов**  
  
 Если не подразумевается директива `nowait` присутствует предложение. Следует отметить, **flush** не подразумевается директива для любого из следующих:  
  
-   При входе **для**  
  
-   В записи или выхода из **master**  
  
-   При входе **разделы**  
  
-   При входе **один**  
  
 Ссылка, которая обращается к значению объекта с типом с квалификатором volatile ведет себя как если бы **flush** директивы, указав этот объект в предыдущей точке последовательности. Ссылка, которая изменяет значение объекта с типом с квалификатором volatile ведет себя как если бы **flush** директивы, указав этот объект в точке последующих последовательности.  
  
 Обратите внимание, что поскольку **flush** директива не поддерживает инструкции языка C, как часть его синтаксис, существуют некоторые ограничения на его размещение в программе. В разделе [приложении C](../../parallel/openmp/c-openmp-c-and-cpp-grammar.md) для формальная грамматика. В следующем примере иллюстрируется эти ограничения.  
  
```  
/* ERROR - The flush directive cannot be the immediate  
*          substatement of an if statement.  
*/  
if (x!=0)  
   #pragma omp flush (x)  
...  
  
/* OK - The flush directive is enclosed in a  
*      compound statement  
*/  
if (x!=0) {  
   #pragma omp flush (x)  
}  
```  
  
 Ограничения для **flush** директивы, следующим образом:  
  
-   Переменная, указанная в **flush** директива не должен иметь ссылочный тип.