---
title: 1.3 модель выполнения | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-parallel
ms.topic: conceptual
dev_langs:
- C++
ms.assetid: 85ae8bc4-5bf0-45e0-a45f-02de9adaf716
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 0acdd7a5d9f2dcb58850254281b5c18fd0d1123c
ms.sourcegitcommit: 7019081488f68abdd5b2935a3b36e2a5e8c571f8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/07/2018
---
# <a name="13-execution-model"></a>1.3 Модель выполнения
OpenMP используется модель ветвления соединения параллельного выполнения. Хотя эта модель ветвления соединения может быть полезна для решения различных проблем, немного приспособлено для крупных приложений на основе массива. OpenMP предназначен для поддержки программ, будет выполняться правильно и что параллельного программы (нескольких потоков выполнения и полная библиотека поддержки OpenMP) и как последовательные программы (директив обрабатывается и простую библиотеку заглушки OpenMP). Тем не менее возможно и может разработать программу, которая будет работать некорректно, если выполняются последовательно. Кроме того различные степени параллелизма может привести к различных числовых результатов из-за изменений в ассоциации математических операций. Например уменьшение последовательного добавления может быть другим шаблоном Добавление связи, чем параллельной редукции. Эти разные связи может повлиять на результаты сложения чисел с плавающей запятой.  
  
 Программы, написанной с помощью API OpenMP C/C++ начинает выполнение, как один поток выполнения называется *главный поток*. Главный поток выполняет в последовательной области до появления первой параллельной конструкции. В API OpenMP C/C++ **параллельных** директива составляет параллельной конструкции. При обнаружении параллельной конструкции, основной поток создает группу потоков, а master становится master рабочей группы. Каждый поток в команде выполняет инструкции в динамических экстент параллельной области, за исключением конструкции совместной работы. Конструкции совместной работы, которые необходимо получить из всех потоков в группе в том же порядке и в пределах связанные Структурированный блок инструкции для одного или нескольких потоков. Барьер подразумевается в конце конструкции совместной работы без `nowait` предложение выполняется из всех потоков в группе.  
  
 Если поток изменяет общий объект, он влияет не только средой выполнения, но также те, другие потоки в программе. Изменение гарантированно будет завершена, с точки зрения одного из других потоков, в следующей точке последовательности (как определено в базовый язык), только в том случае, если объект объявлен как volatile. В противном случае — изменение гарантированно будет завершено после сначала изменяется потока, и затем (или одновременно) возникают другие потоки **flush** директивы, указывающий объект (явно или неявно). Обратите внимание, что при **flush** директивы, которые содержится в другие директивы OpenMP не являются достаточно обеспечить нужный порядок побочные эффекты, программиста обязан предоставить дополнительные, явные  **Очистить** директивы.  
  
 По завершении параллельные конструкции потоков в группе синхронизации при неявных барьера и только главный поток продолжает выполнение. В одной программе можно указать любое количество параллельные конструкции. В результате программа может выполнить разветвление и присоединить несколько раз во время выполнения.  
  
 API OpenMP C/C++ позволяет разработчикам использовать директивы в функциях, вызванных из внутри параллельные конструкции. Директивы, которые не отображаются в лексическую область параллельной конструкции, но может находиться в области динамических называются *потерянные* директивы. Потерянные директивы предоставляет программистам возможность выполнения основной части их программы одновременно только минимальные изменения для последовательной программы. Эта функциональная возможность пользователей можно создавать параллельные конструкции на верхних уровнях дерева вызовов программы, а директивы можно использовать для управления выполнением в любом вызываемых функций.  
  
 В выходных данных, в котором данные, записанные в различных потоках отображается в порядке, недетерминированные функции, которые выполняют запись в тот же файл может привести к вывода несинхронизированные вызовы C и C++. Аналогичным образом несинхронизированные вызовы функции, выполняющие чтение из одного файла ввода может читать данные в порядке, недетерминированные. Несинхронизированные использования операций ввода-вывода, таким образом, что каждый поток обращается к другой файл, выводятся те же результаты, как последовательного выполнения функций ввода-вывода.