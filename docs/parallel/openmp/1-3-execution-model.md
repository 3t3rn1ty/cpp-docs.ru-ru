---
title: "1.3 Execution Model | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
ms.assetid: 85ae8bc4-5bf0-45e0-a45f-02de9adaf716
caps.latest.revision: 5
caps.handback.revision: 5
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# 1.3 Execution Model
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

OpenMP использует модель вилк\-объединения параллельного выполнения.  Хотя эта модель вилк\-объединения может быть полезна для решения различных проблем, она существует несколько портняжничана для больших на основе массива приложений.  Предназначено для поддержки OpenMP программы, которые будут выполняться правильно и параллельных программ \(несколько потоков выполнения и полной библиотеки поддержки OpenMP\) и неучитываемые как последовательные программы \(директивы OpenMP и простое заштырят библиотеку\).  Однако возможна и не может начинаться программы, которая работает правильно выполняться последовательно.  Кроме того, различные степени параллелизма может привести к созданию различных числовых результатах из\-за изменений в ассоциации числовых операций.  Например, уменьшение серийного сложения может быть другой шаблон ассоциаций сложения, чем снижение параллельно.  Эти различные ассоциации не может изменить результаты сложения с плавающей запятой.  
  
 Программа C\/C\+\+ записанная с API OpenMP начинается выполнение по мере один поток выполнения вызвавшей *главный поток*.  Главный поток выполняется в области серийной до тех пор, пока первая параллельной конструкции не обнаружена.  В API модели OpenMP C\/C\+\+ **Параллельно** директива составляет параллельной конструкции.  При параллельной конструкции обнаружена, главный поток создается команда потоков и образец будет образцом рабочей группы.  Каждый поток в рабочей группе выполняется выписки в динамической экстенты параллельной области, за исключением рабочий\-совместно с помощью конструкций.  Использование конструкции быть Рабочий\-совместно обнаруженные всеми потоками в рабочей группе в том же порядке и в структурированном блоке выписки связанный выполняется одно или несколько из потоков.  Барьер неявный в конце рабочий\-совместно с помощью конструктора без a `nowait` предложение выполняется всеми потоками в рабочей группе.  
  
 Если поток изменяет общий объект, он не затрагивает только свою собственную среду выполнения, но также из других потоков в программе.  Гарантированно будут объявлены, что изменение завершения с точки зрения одного из других потоков, следующий шаг в последовательности \(как указано в базовым языком\), только если объект испаряюще.  В противном случае гарантируется, что будет завершено после изменения вначале изменение потока, а затем \(синхронно\) или встречаются другие потоки, a **flush** директива, которая указывает объект \(явно или неявно\).  Обратите внимание, что при **flush** директивы, которые подразумеваются другими директивами OpenMP не достаточны, чтобы обеспечить требуемый порядок побочных эффектов, оно обязанностью программиста на языке, точно указать дополнительное  **flush** директивы.  
  
 После завершения параллельной конструкции, потоки в рабочей группе синхронизировать в неявном барьере, и только главный поток продолжает выполнение.  Любое количество параллельных конструкций можно указать в одной программе.  В результате программа может разветвить и union много раз во время выполнения.  
  
 API OpenMP C\/C\+\+ позволяет программистам к предоставлению использования в функциях, вызванных внутри параллельной конструкции.  Директивы, которые не появляются в лексическую область памяти параллельной конструкции, но могут находиться в области памяти называется динамической *осиротело* директивы.  Потерянные рекомендации разработчикам приложений получают возможность выполнять основные части программы в порядке их только минимальные необходимые изменения последовательной программе.  С этой функцией, пользователи могут конструкции кода параллельные высших директив на уровнях дерева вызовов отслеживать выполнение программы и использования в любых функциях, вызванных.  
  
 Unsynchronized вызовы функции выход c и C\+\+, которые записывают на один и тот же файл может привести к созданию выходе, в котором данные, записываемые различными потоками отображаются в заказ являются недетерминированными.  Аналогично, unsynchronized вызовы функций ввода, которые считывают из одного и того же файла могут считывать данные в недетерминированном порядке.  Unsynchronized использование ВВОДА\-ВЫВОДА, такого, что каждый поток, обращающийся к другой файл, дает такие же, как и последовательное выполнение функций ВВОДА\-ВЫВОДА.