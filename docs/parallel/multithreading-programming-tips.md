---
title: 'Многопоточность: Советы по программированию | Документация Майкрософт'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-parallel
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- multithreading [C++], programming tips
- handle maps [C++]
- access control [C++], multithreading
- objects [C++], multiple threads and
- non-MFC threads [C++]
- threading [MFC], programming tips
- critical sections [C++]
- synchronization [C++], multithreading
- programming [C++], multithreaded
- communications [C++], between threads
- threading [C++], best practices
- troubleshooting [C++], multithreading
- Windows handle maps [C++]
ms.assetid: ad14cc70-c91c-4c24-942f-13a75e58bf8a
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 2ad830117323aef807fcebc1ef61b4dfb1900bd9
ms.sourcegitcommit: 6f8dd98de57bb80bf4c9852abafef1c35a7600f1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/22/2018
ms.locfileid: "42591315"
---
# <a name="multithreading-programming-tips"></a>Многопоточность. Советы по программированию
Многопоточные приложения требуют больше внимания, чем однопоточные приложения, при доступе к данным. Так как их несколько, независимых путей выполнения в одновременно использовать в многопоточных приложениях алгоритмы, данные или оба необходимо иметь в виду эти данные могут использоваться только один поток за раз. В этом разделе описаны способы предотвращения потенциальных проблем, при программировании многопоточных приложений с помощью библиотеки Microsoft Foundation Class (MFC).  
  
- [Доступ к объектам из нескольких потоков](#_core_accessing_objects_from_multiple_threads)  
  
- [Доступ к объектам MFC из потоков не являющихся MFC](#_core_accessing_mfc_objects_from_non.2d.mfc_threads)  
  
- [Дескриптор карты Windows](#_core_windows_handle_maps)  
  
- [Взаимодействие между потоками](#_core_communicating_between_threads)  
  
##  <a name="_core_accessing_objects_from_multiple_threads"></a> Доступ к объектам из нескольких потоков  
 
По соображениям размером и производительностью MFC объекты, не поточно ориентированные на уровне объектов, только на уровне класса. Это означает, что можно иметь два отдельных потоках, управлять двумя различными `CString` объектов, но не двух потоков, управление одним `CString` объекта. Если совершенно необходимо иметь несколько потоков, управление и тот же объект, защитить такой доступ с помощью соответствующих механизмов синхронизации Win32, таких как критические секции. Дополнительные сведения о критических секциях и других связанных объектов, см. в разделе [синхронизации](http://msdn.microsoft.com/library/windows/desktop/ms686353) в пакете Windows SDK.  
  
Библиотека классов использует критические секции для защиты глобальные структуры данных, таких как выделение памяти отладки.  
  
##  <a name="_core_accessing_mfc_objects_from_non.2d.mfc_threads"></a> Доступ к объектам MFC из потоков не являющихся MFC  
 
Если у вас есть многопоточного приложения, которое создает поток не с помощью с [CWinThread](../mfc/reference/cwinthread-class.md) объекта, воспользоваться другими объектами MFC из этого потока. Другими словами, если вы хотите получить доступ к любому объекту MFC из второго потока, необходимо создать этот поток с одним из методов, описанных в [Многопоточность: создание потоков пользовательского интерфейса](../parallel/multithreading-creating-user-interface-threads.md) или [Многопоточность: Создание рабочих потоков](../parallel/multithreading-creating-worker-threads.md). Эти методы являются единственными, позволяющие библиотеке классов для инициализации внутренних переменных, необходимых для многопоточных приложений.  
  
##  <a name="_core_windows_handle_maps"></a> Дескриптор карты Windows  
 
Как правило поток может получить доступ к только объектов MFC, созданные им. Это обусловлено временных и постоянных maps дескриптор Windows, хранятся в локальном хранилище потока в целях обеспечения защиты от одновременного доступа нескольких потоков. Например, рабочий поток не производят вычисление и затем вызвать документа `UpdateAllViews` функцию-член для окон, которые содержат новые измененные данные. Это не влияет, так как сопоставление от `CWnd` объектов HWND является локальным для основного потока. Это означает, что один поток может иметь сопоставление из дескриптора Windows для объекта C++, но другой поток может сопоставить тот же дескриптор другому объекту C++. Изменения, внесенные в одном потоке не будут отражаться в другом.  
  
Существует несколько способов решения проблемы. Первый — для передачи отдельных дескрипторов (HWND) вместо того, чтобы объекты C++ на рабочий поток. Рабочий поток затем добавит эти объекты во временное сопоставление, вызывая соответствующий `FromHandle` функция-член. Можно также добавить объект постоянное сопоставление потока путем вызова `Attach`, но это следует делать только в том случае, если гарантируется, что объект будет существовать дольше, чем поток.  
  
Другой метод заключается в создании новых определяемых пользователем сообщений, соответствующих различным задачам рабочих потоков будет и помещают эти сообщения в главное окно приложения с помощью `::PostMessage`. Данный метод взаимодействия аналогична два разных приложения, обменивающиеся данными, за исключением того, что оба потока выполняются в том же адресном пространстве.  
  
Дополнительные сведения о сопоставлении дескрипторов см. в разделе [технические Примечание 3](../mfc/tn003-mapping-of-windows-handles-to-objects.md). Дополнительные сведения о локальной памяти потока, см. в разделе [локальное хранилище потока](http://msdn.microsoft.com/library/windows/desktop/ms686749) и [с помощью локального хранилища потока](http://msdn.microsoft.com/library/windows/desktop/ms686991) в пакете Windows SDK.  
  
##  <a name="_core_communicating_between_threads"></a> Взаимодействие между потоками  
 
MFC предоставляет ряд классов, которые позволяют потокам синхронизировать доступ к объектам, для обеспечения безопасности потока. Описывается использование этих классов в [Многопоточность: Практическое использование классов синхронизации](../parallel/multithreading-how-to-use-the-synchronization-classes.md) и [Многопоточность: использование классов синхронизации](../parallel/multithreading-when-to-use-the-synchronization-classes.md). Дополнительные сведения об этих объектах см. в разделе [синхронизации](http://msdn.microsoft.com/library/windows/desktop/ms686353) в пакете Windows SDK.  
  
## <a name="see-also"></a>См. также  

[Реализация многопоточности на языке C++ с помощью классов MFC](../parallel/multithreading-with-cpp-and-mfc.md)