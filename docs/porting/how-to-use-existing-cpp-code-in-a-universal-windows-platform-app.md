---
title: "Практическое руководство. Использование существующего кода C++ в приложении универсальной платформы Windows | Документы Майкрософт"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-cpp
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
ms.assetid: 87e5818c-3081-42f3-a30d-3dca2cf0645c
caps.latest.revision: 5
author: mikeblome
ms.author: mblome
manager: ghogen
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
translationtype: Human Translation
ms.sourcegitcommit: 220ecd24c6056737d0338cc584663e4664ac81b1
ms.openlocfilehash: 4ea001f8f60a771e46a99960c14201cf6afabc99

---
# <a name="how-to-use-existing-c-code-in-a-universal-windows-platform-app"></a>Практическое руководство. Использование существующего кода C++ в приложении универсальной платформы Windows
Возможно, самым простым способом запуска классической программы в среде UWP является использование технологий Desktop Bridge. К ним относится Desktop App Converter, позволяющий преобразовывать имеющиеся классические приложения в приложения универсальной платформы Windows (UWP) без изменения кода. Дополнительные сведения см. в статье [Перенос классического приложения на универсальную платформу Windows (UWP) с помощью Desktop Bridge](https://msdn.microsoft.com/windows/uwp/porting/desktop-to-uwp-root).

В остальной части этого раздела описывается процедура переноса библиотек C++ (библиотек DLL и статических библиотек) на универсальную платформу Windows (UWP). Это можно сделать, чтобы использовать основную логику C++ в нескольких приложениях UWP. 
  
 Приложения UWP выполняются в защищенной среде, в результате чего многие вызовы Win32, COM и API CRT, которые могут нарушить безопасность платформы, запрещены. Компилятор может обнаруживать такие вызовы и формировать ошибки, если используется параметр /ZW. Для выявления кода, который вызывает запрещенные API, используется набор сертификации приложений. См. статью [Using the App Certification Kit](https://msdn.microsoft.com/library/windows/apps/hh694081.aspx) (Использование набора сертификации приложений).  
  
 Если исходный код доступен для библиотеки, можно исключить запрещенные вызовы API. Дополнительные сведения, включая список разрешенных или запрещенных интерфейсов API, см. в статьях [Win32 and COM for Windows Runtime Apps and Universal Windows platform (UWP) Apps](https://msdn.microsoft.com/library/windows/apps/br205762.aspx) (Win32 и COM для приложений среды выполнения Windows и приложений универсальной платформы Windows (UWP)) и [CRT Functions Not Supported with /ZW](https://msdn.microsoft.com/library/windows/apps/jj606124.aspx) (Функции CRT, не поддерживаемые с параметром /ZW). Некоторые альтернативные решения можно найти в статье [Alternatives to Windows APIs in Windows Runtime apps and Universal Windows Platform (UWP) apps](https://msdn.microsoft.com/library/windows/apps/hh464945.aspx) (Альтернативы интерфейсов API Windows в приложениях среды выполнения Windows и приложениях универсальной платформы Windows (UWP)).  
  
 При попытке добавить ссылку из универсального проекта Windows в классическую библиотеку настольной системы появится сообщение об ошибке, информирующее о несовместимости библиотеки. При использовании статической библиотеки можно создать ссылку на библиотеку, просто добавив библиотеку (LIB-файл) во входные данные компоновщика так же, как в классическом приложении Win32. Это единственный вариант для библиотек, где доступен только двоичный файл. Статическая библиотека связана в исполняемом файле приложения, но библиотека DLL Win32, используемая в приложении UWP, должна быть упакована в приложение путем включения в проект и пометки как содержимого. Для загрузки библиотеки DLL Win32 в приложении универсальной платформы Windows необходимо также вызвать [LoadPackagedLibrary](https://msdn.microsoft.com/library/windows/desktop/hh447159.aspx) вместо LoadLibrary или LoadLibraryEx.  
  
 При наличии исходного кода для библиотеки DLL или статической библиотеки можно выполнить перекомпиляцию с параметром /ZW в виде проекта UWP. После этого можно добавить ссылку с помощью обозревателя решений и использовать ее в приложениях UWP на C++. В случае с DLL осуществляется связь с библиотекой экспорта.  
  
 Чтобы сделать функциональные возможности доступными вызывающим объектам на других языках, библиотеку можно преобразовать в компонент среды выполнения Windows. Компоненты среды выполнения Windows отличаются от обычных библиотек DLL тем, что они содержат метаданные в виде WINMD-файлов, которые описывают содержимое так, как это требуется потребителям .NET и JavaScript. Чтобы предоставить элементы API на других языках, можно добавить конструкции C++/CX, такие как ссылочные классы, и сделать их общедоступными либо использовать [библиотеку шаблонов C++ среды выполнения Windows (WRL)](../windows/windows-runtime-cpp-template-library-wrl.md).  В Windows 10 и более поздних версиях вместо C++/CX можно использовать [библиотеку C++/WinRT](https://github.com/microsoft/cppwinrt). 
  
 Вышесказанное не распространяется на использование COM-компонентов, которые должны обрабатываться другим образом. Если в EXE или DLL имеется COM-сервер, его можно использовать в универсальном проекте Windows до тех пор, пока он не будет упакован как [не требующий регистрации COM-компонент](https://msdn.microsoft.com/library/dd408052.aspx). Его можно добавить в проект как файл содержимого и создать его с помощью [CoCreateInstanceFromApp](https://msdn.microsoft.com/library/windows/apps/hh404137.aspx). См. статью [Using Free-COM DLL in Windows Store C++ Project](http://blogs.msdn.com/b/win8devsupport/archive/2013/05/20/using-free-com-dll-in-windows-store-c-project.aspx) (Использование DLL без COM в проекте C++ для Магазина Windows).  
  
 Существующую библиотеку COM, которую требуется перенести на универсальную платформу Windows, можно преобразовать в компонент среды выполнения Windows с помощью [библиотеки шаблонов C++ среды выполнения Windows (WRL)](../windows/windows-runtime-cpp-template-library-wrl.md). WRL не поддерживает все возможности ATL и OLE, поэтому целесообразность такого переноса зависит от того, какому объему кода COM требуются определенные возможности COM, ATL и OLE.  
  
 Далее приводятся различные способы использования существующего кода C++ в проектах универсальной платформы Windows. В некоторых из них не требуется выполнять перекомпиляцию кода с включенными расширениями компонентов (C++/CX) (то есть с параметром /ZW), тогда как в других это является необходимостью. Поэтому чтобы сохранить код на стандартном C++ или сохранить классическую среду компиляции Win32 для определенного кода, это можно сделать с выбором соответствующей архитектуры. Например, весь код, содержащий пользовательский интерфейс и типы универсальной платформы Windows, которые будут предоставляться вызывающим объектам C#, Visual Basic и JavaScript, должен находиться в проектах приложений Windows и проектах компонента среды выполнения Windows. Код, который должен использоваться только в коде на C++ (включая C++/CX), может быть либо в проекте, компилируемом с параметром /WX, либо в стандартном проекте C++. Код только для двоичного файла используется путем связывания в качестве статической библиотеки или упаковывается с приложением качестве содержимого и загружается в библиотеку DLL только при отсутствии запрещенных интерфейсов API.  
  
 Независимо от выбранного сценария разработки следует учитывать ряд определений макросов, которые можно использовать в коде для его последующей условной компиляции на платформе Win32 для классических настольных приложений и на универсальной платформе Windows.  
  
```cpp  
#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_PC_APP)  
#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_PHONE_APP)  
#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)  
#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)  
```  
  
 Эти выражения применяются к приложениям для Магазина Windows, приложениям для Магазина Windows Phone, к обоим видам или ни к одному из них (только для классических приложений Win32 для настольной системы), соответственно. Эти макросы доступны только в пакете SDK Windows 8.1 и более поздних версиях. Поэтому если код должен компилироваться в более ранних версиях пакета SDK Windows или для других платформ, помимо Windows, необходимо учитывать ситуацию, в которой не определена ни одна их этих возможностей.  
  
 В этом разделе описываются следующие процедуры.  
  
1.  [Использование библиотеки DLL Win32 в приложении универсальной платформы Windows](#BK_Win32DLL)  
  
2.  [Использование собственной статической библиотеки C++ в приложении UWP](#BK_StaticLib)  
  
3.  [Перенос библиотеки C++ в компонент среды выполнения Windows](#BK_WinRTComponent)  
  
##  <a name="a-namebkwin32dlla-using-a-win32-dll-in-a-universal-windows-platform-app"></a><a name="BK_Win32DLL"></a> Использование библиотеки DLL Win32 в приложении универсальной платформы Windows  
 В целях повышения безопасности и надежности универсальные приложения Windows работают в среде выполнения с ограниченным доступом, поэтому здесь способ использования собственных библиотек DLL отличается от использования в классическом настольном приложении Windows. Исходный код для библиотеки DLL можно перенести для выполнения на платформе UWP. Сначала следует изменить несколько параметров проекта и метаданных файла проекта, чтобы определять проект как проект UWP. Необходимо скомпилировать код библиотеки с помощью параметра /ZW для активации C++/CX. В приложениях UWP запрещены некоторые вызовы API. Это связано с более строгим уровнем управления этой средой. См. статью [Win32 and COM for Windows Runtime apps and Universal Windows Platform (UWP) apps](https://msdn.microsoft.com/library/windows/apps/br205757.aspx) (Win32 и модель COM для приложений среды выполнения Windows и приложений универсальной платформы Windows (UWP)).  
  
 Следующая процедура применяется в тех случаях, когда у вас есть собственная библиотека DLL, которая предоставляет функции с помощью __declspec(dllexport).  
  
#### <a name="to-port-a-native-dll-to-the-uwp-without-creating-a-new-project"></a>Перенос собственной библиотеки DLL на UWP без создания нового проекта  
  
1.  Если у вас есть собственная библиотека DLL, которая экспортирует функции с помощью __declspec(dllexport), эти функции можно вызывать из приложения UWP путем повторной компиляции библиотеки DLL в качестве проекта UWP. В качестве примера предположим, что у нас есть библиотека DLL, которая экспортирует несколько классов и их методов с кодом, похожим на следующий файл заголовка:  
  
    ```  
    // giraffe.h  
    #pragma once  
  
    #ifdef _DLL  
    #define GIRAFFE_API __declspec(dllexport)  
    #else  
    #define GIRAFFE_API   
    #endif  
  
    GIRAFFE_API int giraffeFunction();  
  
    class Giraffe  
    {  
        int id;  
            Giraffe(int id_in);  
        friend class GiraffeFactory;  
  
    public:  
        GIRAFFE_API int GetID();  
    };  
  
    class GiraffeFactory  
    {  
        static int nextID;  
    
    public:  
        GIRAFFE_API GiraffeFactory();  
        GIRAFFE_API static int GetNextID();  
        GIRAFFE_API static Giraffe* Create();  
   };  
    ```  
  
     И следующий файл кода:  
  
    ```  
    // giraffe.cpp  
    #include "stdafx.h"  
    #include "giraffe.h"  
  
    Giraffe::Giraffe(int id_in) : id(id_in)  
    {  
    }  
  
    int Giraffe::GetID()  
    {  
      return id;  
    }  
  
    int GiraffeFactory::nextID = 0;  
  
    GiraffeFactory::GiraffeFactory()  
    {  
        nextID = 0;  
    }  
  
    int GiraffeFactory::GetNextID()  
    {  
        return nextID;  
    }  
  
    Giraffe* GiraffeFactory::Create()  
    {  
        return new Giraffe(nextID++);  
    }  
  
    int giraffeFunction();  
    ```  
  
     Все остальное в проекте (stdafx.h, dllmain.cpp) является частью стандартного шаблона проекта Win32. Если вы хотите продолжать процедуру, но пока не хотите использовать собственные библиотеки DLL, создайте проект Win32, выберите DLL в мастере проектов, добавьте файл заголовка giraffe.h и файл кода giraffe.cpp и скопируйте содержимое из кода на этом шаге в соответствующие файлы.  
  
     Код определяет макрос GIRAFFE_API, который разрешается в __declspec(dllexport), когда определяется _DLL (то есть, когда проект построен как DLL).  
  
2.  Откройте свойства проекта для проекта DLL и для конфигурации установите значение **Все конфигурации**.  
  
3.  В свойствах проекта на вкладке **C/C++**, **Общие** установите значение **Да (/ZW)** для параметра **Использовать расширение среды выполнения Windows**. Будут включены расширения компонента (C++/CX).  
  
4.  В **обозревателе решений** выберите узел проекта, откройте контекстное меню и выберите **Выгрузить проект**. Затем откройте контекстное меню узла выгруженного проекта и выберите команду редактирования файла проекта. Найдите элемент WindowsTargetPlatformVersion и замените его следующими элементами.  
  
    ```xml  
    <AppContainerApplication>true</AppContainerApplication>  
    <ApplicationType>Windows Store</ApplicationType>  
    <WindowsTargetPlatformVersion>10.0.10156.0</WindowsTargetPlatformVersion>  
    <WindowsTargetPlatformMinVersion>10.0.10156.0</WindowsTargetPlatformMinVersion>  
    <ApplicationTypeRevision>10.0</ApplicationTypeRevision>  
    ```  
  
     Закройте файл с расширением VCXPROJ, снова откройте контекстное меню и выберите **Перезагрузить проект**.  
  
     Теперь обозреватель решений идентифицирует проект как универсальный проект Windows.  
  
5.  Убедитесь, что файл предкомпилированного заголовка имеет правильное имя. В разделе "Предварительно скомпилированные заголовки" измените файл предварительно скомпилированного заголовка с ch.h на stdafx.h. Если этого не сделать, может появиться следующее сообщение об ошибке.  
  
    ```Output  
    error C2857: '#include' statement specified with the /Ycpch.h command-line option was not found in the source file  
    ```  
  
     Проблема заключается в том, что в универсальных проектах Windows используются другие правила именования для предкомпилированного файла заголовка.  
  
6.  Выполните построение проекта. Возможно, появятся сообщения об ошибках, связанных с несовместимыми параметрами командной строки. Например, часто используемый параметр «Включить минимальное перестроение» (/Gm) установлен по умолчанию во многих проектах C++, но он несовместим с /ZW.  
  
     Во время компиляции для универсальной платформы Windows некоторые функции оказываются недоступны. Компилятор сообщит о любых проблемах. Их необходимо устранить. В результате вы получите чистую сборку.  
  
7.  Чтобы использовать библиотеку DLL в приложении UWP в том же решении, откройте контекстное меню для узла проекта UWP и выберите **Добавить ссылку**.  
  
     В разделе **Проекты, решение** установите флажок для проекта DLL и нажмите кнопку **ОК**.  
  
8.  Включите файлов заголовка библиотеки в файл pch.h приложения UWP.  
  
    ```  
    #include "..\MyNativeDLL\giraffe.h"  
    ```  
  
9. Обычным способом добавьте код в проекте UWP, чтобы вызывать функции и создавать типы из библиотеки DLL.  
  
    ```  
    MainPage::MainPage()  
    {  
        InitializeComponent();  
        GiraffeFactory gf;  
        Giraffe* g = gf.Create();  
        int id = g->GetID();  
    }  
  
    ```  
  
##  <a name="a-namebkstaticliba-using-a-native-c-static-library-in-a-uwp-app"></a><a name="BK_StaticLib"></a> Использование собственной статической библиотеки C++ в приложении UWP  
 Собственную статическую библиотеку C++ можно использовать в проекте UWP, однако существуют некоторые ограничения, которые необходимо принимать во внимание. Начните с изучения этого [раздела](https://msdn.microsoft.com/library/hh771041.aspx) о статических библиотеках C++/CX. Доступ к машинному коду в статической библиотеке можно выполнить из приложения UWP, однако в такой библиотеке не рекомендуется создавать открытые ссылочные типы. При компиляции статической библиотеки с параметром /ZW библиотекарь (фактически скрытый компоновщик) выводит следующее предупреждение.  
  
```  
LNK4264: archiving object file compiled with /ZW into a static library; note that when authoring Windows Runtime types it is not recommended to link with a static library that contains Windows Runtime metadata  
```  
  
 Тем не менее статическую библиотеку можно использовать в UWP без повторной компиляции с параметром /ZW. Вы не сможете объявлять ссылочные типы или использовать конструкции C++/CX. Но если вашей целью является простое использование библиотеки машинного кода, это можно сделать, выполнив следующие действия.  
  
#### <a name="to-use-a-native-c-static-library-in-a-uwp-project"></a>Использование собственной статической библиотеки C++ в проекте UWP  
  
1.  В окне свойств проекта для проекта UWP в разделе "Компоновщик" добавьте путь к библиотеке в свойстве "Входные данные". Например, для библиотеки в проекте, которая помещает выходные данные в *папка_решения*\Debug\MyNativeLibrary\MyNativeLibrary.lib, добавьте относительный путь `Debug\MyNativeLibrary\MyNativeLibrary.lib`.  
  
2.  Добавьте выражение include для ссылки на файл заголовка в pch.h в проекте UWP и приступите к добавлению кода, использующего библиотеку.  
  
    ```  
    #include "..\MyNativeLibrary\giraffe.h"  
    ```  
  
     Не добавляйте ссылки в узел **Ссылки** в **обозревателе решений**. Этот механизм работает только для компонентов среды выполнения Windows.  
  
##  <a name="a-namebkwinrtcomponenta-porting-a-c-library-to-a-windows-runtime-component"></a><a name="BK_WinRTComponent"></a> Перенос библиотеки C++ в компонент среды выполнения Windows  
 Если требуется использовать собственные интерфейсы API в статической библиотеке из приложения UWP и имеется исходный код для собственной библиотеки, можно перенести код в компонент среды выполнения Windows. Вместо статической библиотеки будет существовать библиотека DLL. Ее можно использовать в любом приложении UWP на C++, но в отличие от статической библиотеки появится возможность добавления ссылочных типов и других конструкций C ++/CX, которые доступны клиентам в любом коде приложения UWP независимо от языка. Таким образом, эти типы доступны из C#, Visual Basic или JavaScript.  Основная процедура заключается в создании проекта "Компонент среды выполнения Windows", копировании в него кода для статической библиотеки и исправления ошибок, возникающих в связи с перемещением кода из стандартной компиляции C++ в компиляцию /ZW.  
  
#### <a name="to-port-a-c-library-to-a-windows-runtime-component"></a>Перенос библиотеки C++ в компонент среды выполнения Windows  
  
1.  Создайте проект "Компонент среды выполнения Windows".  
  
2.  Закройте проект.  
  
3.  В проводнике Windows найдите проект. По умолчанию Visual Studio использует папку Visual Studio 2017\Projects в папке "Документы". Найдите проект библиотеки C++, который содержит код, который нужно перенести. Скопируйте исходные файлы (файлы заголовков, файлы кода и другие ресурсы, включая находящиеся в подкаталогах) из проекта библиотеки C++ и вставьте их в папку проекта, сохранив структуру папок.  
  
4.  Повторно откройте проект "Компонент среды выполнения Windows", в **обозревателе решений** откройте контекстное меню для узла проекта и выберите команды **Добавить, Существующий элемент**.  
  
5.  Выберите все файлы, которые будут добавлены, в исходном проекте и нажмите кнопку "ОК". При необходимости повторите эти действия для вложенных папок.  
  
6.  На этом этапе может появиться повторяющийся код. Если имеется несколько предварительно скомпилированных заголовков (например, stdafx.h и pch.h), выберите один, который будет сохранен. В него скопируйте необходимый код, например выражения include. Затем удалите другой и в окне свойств проекта в разделе **Предкомпилированные заголовки** проверьте правильность имени файла заголовка.  
  
     Если файл был изменен для использования в качестве предкомпилированного заголовка, убедитесь в правильности параметров предкомпилированных заголовков для каждого файла. По очереди выберите каждый CPP-файл, откройте его окно свойств и убедитесь, что все параметры имеют значение **Использовать (/Yu)**. Нужному предкомпилированному заголовку должно быть задано значение **Создать (/Yc)**.  
  
7.  Постройте проект и устраните все ошибки. Причиной этих ошибок может быть использование параметра /ZW, они могут быть связаны с новой версией пакета SDK Windows, они могут отражать зависимости, такие как файлы заголовков, от которых зависит библиотека, или различия в параметрах нового и старого проектов.  
  
8.  Добавьте в проект открытые ссылочные типы или преобразуйте обычные типы в ссылочные, чтобы указать точки входа в функциональные возможности, которые требуется вызвать из приложений UWP.  
  
9. Протестируйте компонент, добавив ссылку на него из проекта приложения UWP, и добавьте код для вызова созданных открытых API.  
  
## <a name="see-also"></a>См. также  
 [Перенос на универсальную платформу Windows](../porting/porting-to-the-universal-windows-platform-cpp.md)


<!--HONumber=Feb17_HO4-->


