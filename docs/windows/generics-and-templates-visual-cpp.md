---
title: "Универсальные типы и шаблоны (Visual C++) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "language-reference"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "универсальные [C++], сравнение с шаблонами"
  - "шаблоны, C++"
ms.assetid: 63adec79-b1dc-4a1a-a21d-b8a72a8fce31
caps.latest.revision: 19
caps.handback.revision: 19
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Универсальные типы и шаблоны (Visual C++)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Универсальные шаблоны \(generics\) и шаблоны \(templates\) являются функциями языков программирования, обеспечивающими поддержку параметризированных типов.  Однако они отличаются и имеют разные применения.  В этом разделе дан обзор многих отличий.  
  
 Дополнительные сведения см. в разделах [Среда выполнения Windows и управляемые шаблоны](../windows/windows-runtime-and-managed-templates-cpp-component-extensions.md) и [Обзор шаблонов](../Topic/Templates%20Overview.md).  
  
## Сравнение шаблонов и универсальных шаблонов  
 Основные различия между универсальными шаблонами и шаблонами языка C\+\+:  
  
-   Универсальные шаблоны являются универсальными до тех пор, пока не подставлены типы во время выполнения.  Шаблоны специализируются во время компиляции, поэтому во время выполнения они не являются по\-прежнему параметризованными типами.  
  
-   Среда CLR специально поддерживает универсальные шаблоны в MSIL.  Поскольку среда выполнения знает о универсальных шаблонах, определенные типы можно подставить вместо универсальных типов при ссылке на сборку, содержащую универсальный тип.  Шаблоны, напротив, сводятся к обычным типам во время компиляции, и результирующие типы могут быть не указаны в других сборках.  
  
-   Универсальные шаблоны, специализированные в 2 разных сборках с теми же аргументами типов, принадлежат одному типу.  Шаблоны, специализированные в 2 разных сборках с теми же аргументами типов, среда выполнения считает принадлежащими к разным типам.  
  
-   Универсальные шаблоны создаются как один элемент исполняемого кода, который используется для всех аргументов ссылочного типа \(это не относится к типам значений, которые имеют уникальную реализацию для каждого типа значения\).  JIT\-компилятор знает об универсальных шаблонах и может оптимизировать код для ссылочных типов или типов значений, которые используются в качестве аргументов типа.  Шаблоны создают отдельный код среды выполнения для каждой специализации.  
  
-   Универсальные шаблоны не позволяют использовать параметры шаблона, не являющиеся типами, например `template <int i> C {}`.  Шаблоны позволяют делать это.  
  
-   Универсальные шаблоны не поддерживают явную специализацию \(т.е. индивидуальную реализацию шаблона для конкретного типа\).  Шаблоны поддерживают.  
  
-   Универсальные шаблоны не поддерживают частичную специализацию \(индивидуальную реализацию для подмножества аргументов типа\).  Шаблоны поддерживают.  
  
-   Универсальные шаблоны не позволяют использовать параметр типа в качестве базового класса для универсального типа.  Шаблоны позволяют.  
  
-   Шаблоны поддерживают шаблонные параметры \(например  `template<template<class T> class X> class MyClass`\), а универсальные шаблоны нет.  
  
## Объединение шаблонов и универсальных шаблонов  
  
-   Основное различие в универсальных шаблонах имеет последствия для построения приложений, которые объединяют шаблоны и универсальные шаблоны.  Например, рассмотрим шаблонный класс, для которого требуется создать универсальную оболочку для предоставления этого шаблона в других языках в качестве универсального шаблона.  Нельзя, чтобы универсальный шаблон принимал параметр типа, который затем передавал в шаблон, поскольку шаблон должен иметь этот параметр типа во время компиляции, но универсальный шаблон не позволяет получить этот параметр типа до выполнения.  Размещение шаблона внутри универсального шаблона также не будет работать, поскольку нет способа развернуть шаблоны во время компиляции для произвольных универсальных типов, экземпляры которых могут создаваться во время выполнения.  
  
## Пример  
  
### Описание  
 В следующем примере показан простой пример использования шаблонов и универсальных шаблонов вместе.  В этом примере класс шаблона передает свой параметр универсальному типу.  Обратное невозможно.  
  
 Эта идиома может использоваться, когда требуется выполнить построение на существующем универсальном API с кодом шаблона, который является локальным для сборки Visual C\+\+, или при необходимости добавить дополнительный слой параметризации к универсальному типу, чтобы воспользоваться преимуществами некоторых функций шаблонов, не поддерживаемых универсальными шаблонами.  
  
### Код  
  
```  
// templates_and_generics.cpp  
// compile with: /clr  
using namespace System;  
  
generic <class ItemType>  
ref class MyGeneric {  
   ItemType m_item;  
  
public:  
   MyGeneric(ItemType item) : m_item(item) {}  
   void F() {   
      Console::WriteLine("F");   
   }  
};  
  
template <class T>  
public ref class MyRef {  
MyGeneric<T>^ ig;  
  
public:  
   MyRef(T t) {  
      ig = gcnew MyGeneric<T>(t);  
      ig->F();  
    }      
};  
  
int main() {  
   // instantiate the template  
   MyRef<int>^ mref = gcnew MyRef<int>(11);  
}  
```  
  
### Output  
  
```  
F  
```  
  
## См. также  
 [Универсальные шаблоны](../windows/generics-cpp-component-extensions.md)