---
title: "property (расширения компонентов C++) | Microsoft Docs"
ms.custom: ""
ms.date: "12/16/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "language-reference"
f1_keywords: 
  - "property_cpp"
  - "property"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "property - ключевое слово [C++]"
ms.assetid: cc79d2b2-f013-4d81-8252-eece97a18704
caps.latest.revision: 31
caps.handback.revision: 29
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# property (расширения компонентов C++)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Объявляет *свойство*, являющееся функцией\-членом, которая действует и доступна как элемент данных или элемент массива.  
  
## Все среды выполнения  
 Можно объявить один из следующих типов свойств.  
  
 *Простое свойство*  
 По умолчанию создает *метод доступа set*, который присваивает значение свойства, *метод доступа get*, который получает значение свойства, и создаваемый компилятором закрытый элемент данных, содержащий значение свойства.  
  
 *Блок свойств*  
 Используется для создания определяемых пользователем методов доступа get и\/или set.  Свойство доступно для чтения и записи, если заданы оба метода доступа — get и set, доступно только для чтения, если задан только метод доступа get, и доступно только для записи, если задан только метод доступа set.  
  
 Вы должны явно объявить элемент данных для хранения значения свойства.  
  
 *Индексированное свойство*  
 Блок свойств, который можно использовать для получения и задания значения свойства, указанного одним или несколькими индексами.  
  
 Вы можете создать индексированное свойство, которое имеет либо заданное пользователем имя, либо имя *по умолчанию*.  Имя свойства индекса по умолчанию — это имя класса, в котором это свойство определено.  Чтобы объявить свойство по умолчанию, укажите ключевое слово `default` вместо имени свойства.  
  
 Вы должны явно объявить элемент данных для хранения значения свойства.  Для индексированного свойства элементом данных обычно является массив или коллекция.  
  
### Синтаксис  
  
```cpp  
  
property type property_name;  
  
property type property_name {  
   access-modifier type get() inheritance-modifier {property_body};  
   access-modifier void set(type value) inheritance-modifier {property_body};  
} property type property_name[index_list] {  
   access-modifier type get(index_list) inheritance-modifier {property_body};  
   access-modifier void set(index_list, value) inheritance-modifier {property_body};  
} property type default[index_list] {  
   access-modifier type get(index_list) inheritance-modifier {property_body};  
   access-modifier void set(index_list, value) inheritance-modifier {property_body};  
}  
  
```  
  
### Параметры  
 `type`  
 Тип данных значения свойства и, следовательно, самого свойства.  
  
 `property_name`  
 Имя свойства.  
  
 `access-modifier`  
 Квалификатор доступа.  Допустимые квалификаторы — `static` и `virtual`.  
  
 Методы доступа get или set не требуется согласовывать с квалификатором `virtual`, но они должны быть согласованы с квалификатором `static`.  
  
 `inheritance-modifier`  
 Квалификатор наследования.  Допустимые квалификаторы — `abstract` и `sealed`.  
  
 `index_list`  
 Разделенный запятыми список из одного или нескольких индексов.  Каждый индекс состоит из типа индекса и необязательного идентификатора, который может использоваться в теле метода свойства.  
  
 `value`  
 Значение для назначения свойству в операции set или извлечения в операции get.  
  
 `property_body`  
 Тело метода свойства метода доступа set или get.  Параметр `property_body` может использовать `index_list` для доступа к базовому элементу данных свойства или в качестве параметров в пользовательской обработке.  
  
## [!INCLUDE[wrt](../atl/reference/includes/wrt_md.md)]  
 Дополнительные сведения см. в разделе [Свойства \(C\+\+\/CX\)](http://msdn.microsoft.com/library/windows/apps/hh755807.aspx).  
  
### Требования  
 Параметр компилятора: **\/ZW**  
  
## [!INCLUDE[clr_for_headings](../dotnet/includes/clr_for_headings_md.md)]  
 **Синтаксис**  
  
```  
  
modifier property type property_name;  
  
modifier property type property_name {  
   modifier void set(type);  
   modifier type get();  
}  
modifier property type property_name[index-list, value] {  
   modifier void set(index-list, value);  
   modifier type get(index-list);  
  
modifier property type default[index];  
}  
```  
  
 **Параметры**  
  
 *modifier*  
 Модификатор, который может использоваться в объявлении свойства или в методе доступа get\/set свойства.  Возможными значениями являются `static` и `virtual`.  
  
 *тип*  
 Тип значения, представленного свойством.  
  
 *property\_name*  
 Параметр или параметры для метода raise; необходимо соответствие сигнатуре делегата.  
  
 *index\_list*  
 Разделенный запятыми список из одного или нескольких индексов, указанных в квадратных скобках \(оператор индекса, \(\[\]\)\).  Для каждого индекса укажите тип и \(необязательно\) идентификатор, который может использоваться в теле метода свойства.  
  
 **Примечания**  
  
 В первом примере синтаксиса показано *простое свойство*, которое неявно объявляет методы `set` и `get`.  Компилятор автоматически создает закрытое поле для хранения значения свойства.  
  
 Во втором примере синтаксиса показан *блок свойств*, который явно объявляет методы `set` и `get`.  
  
 В третьем примере синтаксиса показано определяемое пользователем *свойство индекса*.  Свойство индекса принимает параметры, а также значение для установки или получения.  Необходимо указать имя для свойства.  В отличие от простого свойства методы `set` и `get` свойства индекса должны быть явно определены, и необходимо указать имя для свойства.  
  
 В четвертом примере синтаксиса показано свойство *по умолчанию*, которое предоставляет подобный массиву доступ к экземпляру типа.  Ключевое слово `default` служит только для указания свойства по умолчанию.  Имя свойства по умолчанию — это имя типа, в котором это свойство определено.  
  
 Ключевое слово `property` может встречаться в классе, интерфейсе или типе значения.  Свойство может иметь функцию get \(только чтение\), функцию set \(только запись\) или обе эти функции \(чтение и запись\).  
  
 Имя свойства не может совпадать с именем управляемого класса, к которому оно относится.  Функция получения свойства должна иметь тип, который совпадает с типом последнего параметра в соответствующей функции задания свойства.  
  
 В отношении клиентского кода свойство имеет вид обычного элемента данных и может записываться или считываться с помощью того же синтаксиса, что и элемент данных.  
  
 Методы get и set не требуется согласовывать с модификатором `virtual`.  
  
 Доступность методов get и set может отличаться.  
  
 Определение метода свойства может отображаться за пределами тела класса, так же, как в случае обычного метода.  
  
 Методы get и set для свойства должны быть согласованными с модификатором **static**.  
  
 Свойство является скалярным, если его методы get и set соответствуют следующему описанию.  
  
-   Метод get не имеет параметров и возвращает значение типа `T`.  
  
-   Метод set имеет параметр типа `T` и возвращает значение типа **void**.  
  
 Должно существовать только одно скалярное свойство, объявленное в области с тем же идентификатором.  Скалярные свойства не могут быть перегружены.  
  
 При объявлении элемента данных свойства компилятор вставляет элемент данных — иногда называемый «резервным хранилищем» — в класс.  Однако имя элемента данных имеет такую форму, что вы не можете ссылаться на этот элемент в источнике, как если бы это был фактический элемент данных содержащего класса.  Используйте Ildasm.exe для просмотра метаданных для вашего типа и созданного компилятором имени для резервного хранилища свойства.  
  
 В блоке свойств разрешается разная доступность для методов доступа.  То есть метод set может быть открытым, а метод get может быть закрытым.  Однако было бы ошибкой, если бы метод доступа имел менее строгий доступ, нежели в объявлении самого свойства.  
  
 `property` — контекстно\-зависимое ключевое слово.  Дополнительные сведения см. в разделе [Контекстные ключевые слова](../windows/context-sensitive-keywords-cpp-component-extensions.md).  
  
 Дополнительные сведения о свойствах см. в следующих разделах.  
  
-   [Индексированные свойства](../misc/how-to-use-indexed-properties.md)  
  
-   [Статические свойства](../misc/how-to-declare-and-use-static-properties.md)  
  
-   [Виртуальные свойства](../misc/how-to-declare-and-use-virtual-properties.md)  
  
-   [Многомерные свойства](../Topic/How%20to:%20Use%20Multidimensional%20Properties.md)  
  
-   [Перегрузка методов доступа к свойству](../misc/how-to-overload-property-accessor-methods.md)  
  
-   [Практическое руководство. Объявление абстрактных и запечатанных свойств](../misc/how-to-declare-abstract-and-sealed-properties.md)  
  
### Требования  
 Параметр компилятора: **\/clr**  
  
### Примеры  
 В следующем примере показано объявление и использование элемента данных свойства и блока свойств.  В этом примере также показывается, что метод доступа свойства можно определить вне класса.  
  
```  
// mcppv2_property.cpp  
// compile with: /clr  
using namespace System;  
public ref class C {  
   int MyInt;  
public:  
  
   // property data member  
   property String ^ Simple_Property;  
  
   // property block  
   property int Property_Block {  
  
      int get();  
  
      void set(int value) {  
         MyInt = value;  
      }  
   }  
};  
  
int C::Property_Block::get() {  
   return MyInt;  
}  
  
int main() {  
   C ^ MyC = gcnew C();  
   MyC->Simple_Property = "test";  
   Console::WriteLine(MyC->Simple_Property);  
  
   MyC->Property_Block = 21;  
   Console::WriteLine(MyC->Property_Block);  
}  
```  
  
 **Вывод**  
  
  **тест**  
 **21**   
## См. также  
 [Расширения компонентов для платформ среды выполнения](../windows/component-extensions-for-runtime-platforms.md)