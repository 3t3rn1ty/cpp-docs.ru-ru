---
title: "класс Enum (расширения компонентов C++) | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-windows
ms.tgt_pltfrm: 
ms.topic: language-reference
dev_langs:
- C++
ms.assetid: 8010fa8c-bad6-45b4-8214-b4db64d7ffe1
caps.latest.revision: 
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
- uwp
ms.openlocfilehash: 876cab344f1177000f63740ca6c33bc1db1afefe
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="enum-class--c-component-extensions"></a>enum class (расширения компонентов C++)
Объявляет перечисление в области видимости пространства имен, которое является определяемым пользователем типом, состоящим из ряда именованных констант, называемых перечислителями.  
  
## <a name="all-runtimes"></a>Все среды выполнения  
 **Заметки**  
  
 C++/CX и C++/CLI поддерживают классы `public enum class` и `private enum class` , подобные стандартному классу `enum class` C++, но с добавлением спецификатора доступа. В **/clr**тип `enum class` C++11 разрешен, но будет создавать предупреждение C4472, предназначенное для обеспечения гарантии того, что действительно требуется тип перечисления стандарта ISO, а не тип C++/CX и C++/CLI. Дополнительные сведения о языка C++ стандарта ISO `enum` ключевое слово в разделе [перечисления](../cpp/enumerations-cpp.md).  
  
## <a name="windows-runtime"></a>Среда выполнения Windows  
 **Синтаксис**  
  
```  
  
      access  
      enum class  
      enumeration-identifier  
      [:underlying-type] { enumerator-list } [var];  
accessenum structenumeration-identifier[:underlying-type] { enumerator-list } [var];  
```  
  
 **Параметры**  
  
 *access*  
 Уровень доступа перечисления, который может иметь значение `public` или `private`.  
  
 *enumeration-identifier*  
 Имя перечисления.  
  
 *underlying-type*  
 (Необязательно) Базовый тип перечисления.  
  
 (Необязательно. Среда выполнения Windows только) базовый тип перечисления, который может быть `bool`, `char`, `char16`, `int16`, `uint16`, `int`, `uint32`, `int64`, или `uint64`.  
  
 *enumerator-list*  
 Разделенный запятыми список имен перечислителей.  
  
 Значение каждого перечислителя — константное выражение, которое или определяется неявно компилятором, или явно нотацией *enumerator*`=`*constant-expression*. По умолчанию значение первого перечислителя ноль, если он определен неявно. Значение каждого следующего неявно определенного перечислителя — значение предыдущего перечислителя + 1.  
  
 *var*  
 (Необязательно) Имя переменной типа перечисления.  
  
 **Заметки**  
  
 Дополнительные сведения и примеры см. в разделе [Перечисления](http://msdn.microsoft.com/%20library/windows/apps/hh755820.aspx).  
  
 Обратите внимание, что компилятор выводит сообщения об ошибках, если константное выражение, задающее значение перечислителя, не может быть представлено *underlying-type*.  Однако компилятор не сообщает об ошибке для значения, недопустимого для базового типа. Пример:  
  
-   Если тип *underlying-type* числовой и перечислитель определяет максимальное значение для этого типа, то нельзя представить значение следующего неявно указанного перечисления.  
  
-   Если *underlying-type* является `bool`и более двух перечислителей определены неявно, то нельзя представить перечислители после первых двух.  
  
-   Если *underlying-type* является `char16`и значение перечисления в диапазоне от 0xD800 до 0xDFFF, то значение можно представить. Однако логически значение неверно, так как оно представляет половину пары символов-заместителей Юникода и не должно отображаться в изоляции.  
  
### <a name="requirements"></a>Требования  
 Параметр компилятора: **/ZW**  
  
## <a name="common-language-runtime"></a>Среда CLR 
 **Синтаксис**  
  
```  
  
      access  
      enum class  
      name [:type] { enumerator-list } var;  
accessenum structname [:type] { enumerator-list } var;  
```  
  
 **Параметры**  
  
 `access`  
 Уровень доступа перечисления.  Может быть либо **public** , либо `private`.  
  
 `enumerator-list`  
 Разделенный запятыми список идентификаторов (перечислителей) в перечислении.  
  
 `name`  
 Имя перечисления.  Анонимные управляемые перечисления не допускаются.  
  
 `type` (необязательно)  
 Базовый тип *identifiers*.  Это может быть любой скалярный тип, например int, short или long со знаком или без.  `bool` или `char` также допустимы.  
  
 `var` (необязательно)  
 Имя переменной типа перечисления.  
  
 **Заметки**  
  
 **enum class** и **enum struct** являются эквивалентными объявлениями.  
  
 Существуют два типа перечислений: управляемые (C++/CX) и стандартные.  
  
 Управляемые перечисления (или перечисления C++/CX) могут быть определены следующим образом:  
  
```cpp  
public enum class day {sun, mon };  
```  
  
 Это семантически эквивалентно:  
  
```cpp  
ref class day {  
public:  
   static const int sun = 0;  
   static const int mon = 1;  
};  
```  
  
 Стандартное перечисление может быть определено следующим образом:  
  
```cpp  
enum day2 { sun, mon };  
```  
  
 Это семантически эквивалентно:  
  
```cpp  
static const int sun = 0;  
static const int mon = 1;  
```  
  
 Управляемые имена перечислителей (*identifiers*) не вводятся в область, в которой определяется перечисление; все ссылки на перечислители должны быть полными (*имя*`::`*идентификатор*).  По этой причине нельзя определить анонимное управляемое перечисление.  
  
 Перечислители стандартного перечисления строго вводятся во внешнюю область.  То есть, если есть другой символ с таким же именем, как у перечислителя во внешней области видимости, компилятор выдаст ошибку.  
  
 В Visual C++ 2002 и Visual C++ 2003 перечислители были нестрого вводимыми (видимыми во внешней области, если не было другого идентификатора с таким же именем).  
  
 Если определяется стандартное перечисление C++ (без ключевого слова **class** или `struct`), компиляция с параметром **/clr** будет приводить к компиляции перечисления как управляемого.  Перечисление по-прежнему имеет семантику неуправляемого перечисления.  Обратите внимание, что компилятор вводит атрибут `Microsoft::VisualC::NativeEnumAttribute`, который компилятор Visual C++ распознает для определения намерения программиста сделать перечисление собственным.  Другие компиляторы просто увидят стандартное перечисление как управляемое перечисление.  
  
 Именованное стандартное перечисление, скомпилированное с параметром /clr, будет видимо в сборке как управляемое перечисление и может использоваться любым другим управляемым компилятором.   Однако безымянное стандартное перечисление не будет видимо из сборки.  
  
 В Visual C++ 2002 и Visual C++ 2003 стандартное перечисление использовалось в качестве типа в параметре функции:  
  
```cpp  
// mcppv2_enum.cpp  
// compile with: /clr  
enum E { a, b };  
void f(E) {System::Console::WriteLine("hi");}  
  
int main() {  
   E myi = b;  
   f(myi);  
}  
```  
  
 Этот код выдал бы в MSIL для сигнатуры функции следующее:  
  
```  
void f(int32);  
```  
  
 Однако в текущих версиях компилятора стандартное перечисление выдается как управляемое перечисление с [NativeEnumAttribute], а в MSIL для сигнатуры функции выдается следующее:  
  
```  
void f(E)  
```  
  
 Дополнительные сведения о неуправляемых перечислителях см. в разделе [Объявление перечислений C++](../cpp/enumerations-cpp.md).  
  
 Дополнительные сведения о перечислителях CLR см. в следующем разделе:  
  
-   [Базовый тип перечисления](../dotnet/how-to-define-and-consume-enums-in-cpp-cli.md)  
  
### <a name="requirements"></a>Требования  
 Параметр компилятора: **/clr**  
  
### <a name="examples"></a>Примеры  
 **Пример**  
  
 убыв.  
  
```cpp  
// mcppv2_enum_2.cpp  
// compile with: /clr  
// managed enum  
public enum class m { a, b };  
  
// standard enum  
public enum n { c, d };  
  
// unnamed, standard enum  
public enum { e, f } o;  
  
int main()   
{  
   // consume managed enum  
   m mym = m::b;  
   System::Console::WriteLine("no automatic conversion to int: {0}", mym);  
   System::Console::WriteLine("convert to int: {0}", (int)mym);  
  
   // consume standard enum  
   n myn = d;  
   System::Console::WriteLine(myn);  
  
   // consume standard, unnamed enum  
   o = f;  
   System::Console::WriteLine(o);  
}   
```  
  
 **Вывод**  
  
```Output  
no automatic conversion to int: b  
  
convert to int: 1  
  
1  
  
1  
  
```  
  
## <a name="see-also"></a>См. также  
 [Расширения компонентов для платформ среды выполнения](../windows/component-extensions-for-runtime-platforms.md)