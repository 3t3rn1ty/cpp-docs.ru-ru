---
title: "Критические изменения в Visual C++&#160;2015 с обновлением 2 | Microsoft Docs"
ms.custom: ""
ms.date: "11/16/2016"
ms.reviewer: ""
ms.suite: ""
ms.tgt_pltfrm: ""
ms.topic: "article"
ms.assetid: 5545ce3f-d8da-4007-88b7-8dba7dcd4d10
caps.latest.revision: 8
caps.handback.revision: 8
ms.author: "mithom"
---
# Критические изменения в Visual C++&#160;2015 с обновлением 2
При обновлении до CTP\-версии Visual C\+\+ 2015 с обновлением 2 могут возникать ошибки компиляции и \(или\) ошибки времени выполнения в коде, который ранее правильно компилировался и выполнялся. Изменения в поведении компилятора или среды выполнения, вызывающие такие проблемы, именуются *критическими изменениями* и, как правило, связаны с изменениями стандарта языка C\+\+, сигнатур функций или структуры объектов в памяти.  
  
 В остальной части статьи описаны конкретные критические изменения в CTP\-версии Visual C\+\+ 2015 с обновлением 2, и в рамках этой статьи термины "новое поведение" или "сейчас" относятся к этой версии. Термины "старое поведение" и "раньше" относятся к Visual Studio C\+\+ 2015 с обновлением 1 и более ранним версиям. Сведения о критических изменениях, введенных с первоначального выпуска Visual C\+\+ 2015 и до выпуска Visual C\+\+ 2015 с обновлением 1, см. в статье [Критические изменения в обновлении 1](../misc/breaking-changes-in-visual-cpp-2015-update-1.md). Сведения о критических изменениях, введенных со времени выпуска Visual C\+\+ 2013 до выпуска Visual C\+\+ 2015, см. в статье [Критические изменения в Visual C\+\+ 2015](../Topic/Visual%20C++%20change%20history%202003%20-%2020151.md).  
  
-   [Критические изменения компилятора](#BK_compiler)  
  
##  <a name="BK_compiler"></a> Компилятор Visual C\+\+  
  
-   **В результате частичной поддержки правила SFINAE для выражений могут возникать дополнительные предупреждения и ошибки.**  
  
     В предыдущих версиях компилятора из\-за отсутствия поддержки правила SFINAE для выражений не анализировались некоторые типы выражений внутри описателей `decltype`. Это поведение было неправильным и не соответствовало стандарту языка C\+\+. В результате непрерывной оптимизации соответствия компилятор теперь анализирует эти выражения и частично поддерживает правило SFINAE для выражений. Поэтому компилятор теперь выдает предупреждения и сообщения об ошибках, найденных в выражениях, которые в предыдущих версиях компилятора не анализировались.  
  
     Если в новой версии анализируется выражение `decltype`, включающее тип, который еще не был объявлен, выдается ошибка компилятора C2039.  
  
 **Ошибка C2039: *"тип"*: не является членом *"глобальное пространство имен"***     Пример 1. Использование необъявленного типа в предыдущих версиях  
  
    ```cpp  
    struct s1  
    {  
      template <typename T>  
      auto f() -> decltype(s2<T>::type::f());  // error C2039  
  
      template<typename>  
      struct s2 {};  
    }  
    ```  
  
     Пример 1 в текущей версии  
  
    ```cpp  
    struct s1  
    {  
      template <typename>  // forward declare s2struct s2;  
  
      template <typename T>  
      auto f() -> decltype(s2<T>::type::f());  
  
      template<typename>  
      struct s2 {};  
    }  
    ```  
  
     Если в новой версии анализируется выражение `decltype`, в котором не используется обязательное ключевое слово `typename` для указания на то, что зависимое имя представляет собой тип, выдается предупреждение компилятора C4346, а также ошибка компилятора C2923.  
  
 **Предупреждение C4346: *"S2\<T\>::Тип"*: зависимое имя не является типом Ошибка C2923: *"s1"*: *"S2\<T\>::Тип"* не является допустимым аргументом типа шаблона для параметра *"T"***     Пример 2. Зависимое имя не является типом \(в предыдущих версиях\)  
  
    ```cpp  
    template <typename T>  
    struct s1  
    {  
      typedef T type;  
    };  
  
    template <typename T>  
    struct s2  
    {  
      typedef T type;  
    };  
  
    template <typename T>  
    T declval();  
  
    struct s  
    {  
      template <typename T>  
      auto f(T t) -> decltype(t(declval<S1<S2<T>::type>::type>()));  // warning C4346, error C2923  
    };  
    ```  
  
     Пример 2 в текущей версии  
  
    ```cpp  
    template <typename T> struct s1 {...};  // as above  
    template <typename T> struct s2 {...};  // as above  
  
    template <typename T>  
    T declval();  
  
    struct s  
    {  
      template <typename T>  
      auto f(T t) -> decltype(t(declval<S1<typename S2<T>::type>::type>()));  
    };  
    ```  
  
-   **Переменные\-члены `volatile` не допускают неявно определенных конструкторов и операторов присваивания**  
  
     В предыдущих версиях компилятора допускалось автоматическое создание конструкторов копирования и перемещения по умолчанию, а также операторов присваивания копирования и перемещения по умолчанию для класса, содержащего переменные\-члены `volatile`. Это поведение было неправильным и не соответствовало стандарту языка C\+\+. Теперь компилятор рассматривает класс с переменными\-членами volatile как имеющий нетривиальные конструкторы и операторы присваивания, что делает невозможным автоматическую реализацию этих операторов по умолчанию.  Если такой класс является членом объединения \(или анонимного объединения внутри класса\), конструкторы копирования и перемещения и операторы присваивания копирования и перемещения объединения \(или класса, содержащего анонимное объединение\) будут неявно определены как удаленные. Попытка создать или скопировать объединение \(или класс, содержащий анонимное объединение\), не объявляя их явно, будет являться ошибкой. В результате будет выдана ошибка компилятора C2280.  
  
 **Ошибка C2280: *"B::B\(const B &\)"*: предпринята попытка ссылки на удаленную функцию**     Пример \(раньше\)  
  
    ```cpp  
    struct A  
    {  
      volatile int i;  
      volatile int j;  
    };  
  
    extern A* pa;  
  
    struct B  
    {  
      union  
      {  
        A a;  
        int i;  
      };  
    };  
  
    B b1 {*pa};  
    B b2 (b1);  // error C2280  
    ```  
  
     Пример \(теперь\)  
  
    ```cpp  
    struct A  
    {  
      int i;int j;  
    };  
  
    extern volatile A* pa;  
  
    A getA()  // returns an A instance copied from contents of pa  
    {  
      A a;  
      a.i = pa->i;  
      a.j = pa->j;  
      return a;  
    }  
  
    struct B;  // as above  
  
    B b1 {GetA()};  
    B b2 (b1);  // error C2280  
    ```  
  
-   **Статические функции\-члены не поддерживают CV\-квалификаторы.**  
  
     В предыдущих версиях Visual C\+\+ 2015 допускалось наличие CV\-квалификаторов у статических функций\-членов. Это поведение связано с регрессией в Visual C\+\+ 2015 и Visual C\+\+ 2015 с обновлением 1. В Visual C\+\+ 2013 и более ранних версиях Visual C\+\+ код, написанный таким образом, отклонялся. Такое поведение Visual C\+\+ 2015 и Visual C\+\+ 2015 с обновлением 1 является неправильным и не соответствует стандарту C\+\+.  Среда Visual Studio 2015 с обновлением 2 отклоняет код, написанный таким образом, и выдает вместо этого ошибку компилятора C2511.  
  
 **Ошибка C2511: "void A::func\(void\) const": перегруженная функция\-член не найдена в "A"**     Пример \(раньше\)  
  
    ```  
    struct A  
    {  
      static void func();  
    };  
  
    void A::func() const {}  // C2511  
  
    ```  
  
     Пример \(теперь\)  
  
    ```  
    struct A  
    {  
      static void func();  
    };  
  
    void A::func() {}  // removed const  
  
    ```  
  
-   **Опережающее объявление перечисления недопустимо в коде WinRT** \(влияет только на параметр \/ZW\)  
  
     Код, скомпилированный для среды выполнения Windows \(WinRT\), не допускает опережающего объявления типов `enum`. Это аналогично случаю, когда управляемый код C\+\+ компилируется для платформы .Net Framework с помощью параметра компилятора \/clr. Таким образом гарантируется, что размер перечисления всегда известен и может быть правильно спрогнозирован для системы типов WinRT. Компилятор отклоняет код, написанный таким образом, и выдает ошибку компилятора C2599, а также ошибку компилятора C3197.  
  
 **Ошибка C2599: *"пользовательское\_перечисление"*: опережающее объявление перечисляемого типа WinRT не допускается Ошибка C3197: *"public"*: можно использовать только в определениях**     Пример \(раньше\)  
  
    ```cpp  
    namespace A {  
      public enum class CustomEnum: int32;  // forward declaration; error C2599, error C3197  
    }  
  
    namespace A {  
      public enum class CustomEnum: int32  
      {  
        Value1  
      };  
    }  
  
    public ref class Component sealed  
    {  
    public:  
      CustomEnum f()  
      {  
        return CustomEnum::Value1;  
      }  
    };  
    ```  
  
     Пример \(теперь\)  
  
    ```cpp  
  
              // forward declaration of CustomEnum removed  
  
    namespace A {  
      public enum class CustomEnum: int32  
      {  
        Value1  
      };  
    }  
  
    public ref class Component sealed  
    {  
    public:  
      CustomEnum f()  
      {  
        return CustomEnum::Value1;  
      }  
    };  
    ```  
  
-   **Встроенное объявление перегруженных операторов new и delete, не являющихся членами, невозможно** \(уровень 1 \(\/W1\) включен по умолчанию\)  
  
     При встроенном объявлении функций с операторами new и delete, не являющимися членами, в предыдущих версиях компилятора не выводилось предупреждение. Код, написанный таким образом, является неверно сформированным \(диагностика не требуется\) и может приводить к проблемам с памятью, которые возникают в результате несоответствия операторов new и delete \(особенно при совместном использовании в размерных функциях удаления\) и которые может быть трудно диагностировать.   Для выявления кода, написанного таким образом, компилятор теперь выдает предупреждение C4595.  
  
 **Предупреждение C4595: *"operator new"*: не допускается встроенное объявление функций operator new или operator delete, не являющихся членами**     Пример \(раньше\)  
  
    ```cpp  
  
              inline void* operator new(size_t sz)  // warning C4595  
    {  
      ...  
    }  
    ```  
  
     Пример \(теперь\)  
  
    ```cpp  
  
              void* operator new(size_t sz)  // removed inline  
    {  
      ...  
    }  
    ```  
  
     Для исправления кода, написанного таким образом, может потребоваться перенести определения операторов из файла заголовка в соответствующий исходный файл.