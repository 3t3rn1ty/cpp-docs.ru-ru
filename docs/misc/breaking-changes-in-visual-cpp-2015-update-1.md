---
title: "Критические изменения в Visual C++&#160;2015 с обновлением 1 | Microsoft Docs"
ms.custom: ""
ms.date: "11/16/2016"
ms.reviewer: ""
ms.suite: ""
ms.tgt_pltfrm: ""
ms.topic: "article"
ms.assetid: 1c0b1c2b-e1cf-4767-885b-b98df9b3730e
caps.latest.revision: 7
caps.handback.revision: 7
ms.author: "mithom"
manager: "ghogen"
---
# Критические изменения в Visual C++&#160;2015 с обновлением 1
При обновлении до Visual C\+\+ 2015 с обновлением 1 могут возникать ошибки компиляции и ошибки во время выполнения кода, который ранее правильно компилировался и выполнялся. Изменения в поведении компилятора или среды выполнения, вызывающие такие проблемы, именуются *критическими изменениями* и, как правило, связаны с изменениями стандарта языка C\+\+, сигнатур функций или структуры объектов в памяти.  
  
 В остальной части статьи описаны конкретные критические изменения в Visual C\+\+ 2015 с обновлением 1, и в рамках этой статьи термины "новое поведение" или "сейчас" относятся к этой версии. Термины "старое поведение" и "раньше" относятся к первоначальному выпуску Visual Studio 2015 и более ранним выпускам. Информацию о критических изменениях, введенных со времени выпуска Visual Studio 2013 до выпуска Visual Studio 2015, см. в разделе [Критические изменения в Visual C\+\+ 2015](../Topic/Visual%20C++%20change%20history%202003%20-%2020151.md).  
  
-   [Критические изменения компилятора](#BK_compiler)  
  
##  <a name="BK_compiler"></a> Компилятор Visual C\+\+  
  
-   **Закрытые виртуальные базовые классы и косвенное наследование**  
  
     В предыдущих версиях компилятора производному классу разрешалось вызывать функции\-члены *косвенных* `private virtual` базовых классов. Это поведение было неправильным и не соответствовало стандарту языка C\+\+. Компилятор больше не принимает код, написанный таким образом, и выдает в результате ошибку C2280.  
  
 **ошибка C2280: *"void \*S3::\_\_delDtor\(unsigned int\)"*: предпринята попытка ссылки на удаленную функцию**     Пример \(раньше\)  
  
    ```cpp  
    class base { protected: base(); ~base(); }; class middle: private virtual base {};class top: public virtual middle {}; void destroy(top *p) { delete p;  // }  
    ```  
  
     Пример \(теперь\)  
  
    ```cpp  
    class base;  // as above class middle: protected virtual base {}; class top: public virtual middle {}; void destroy(top *p) { delete p; }  
    ```  
  
     \-или\-  
  
    ```  
    class base;  // as above class middle: private virtual base {}; class top: public virtual middle, private virtual bottom {}; void destroy(top *p) { delete p; }  
    ```  
  
-   **Перегруженный оператор new и оператор delete**  
  
     В предыдущих версиях компилятора можно было объявлять `operator new`, не являющийся членом, и `operator delete`, не являющийся членом, статически и в пространствах имен, отличных от глобального пространства имен.  При этом создавался риск того, что программа вызовет не ту реализацию оператора `new` или `delete`, которую планировал программист, результатом чего будет неправильное поведение во время выполнения. Компилятор больше не принимает код, написанный таким образом, и выдает вместо этого ошибку C2323.  
  
 **ошибка C2323: *"operator new"*: оператор new или функции delete, не являющиеся членами, нельзя объявлять статически или в пространстве имен, отличном от глобального.**     Пример \(раньше\)  
  
    ```cpp  
  
    static inline void * __cdecl operator new(size_t cb, const std::nothrow_t&)  // error C2323  
    ```  
  
     Пример \(теперь\)  
  
    ```cpp  
  
    void * __cdecl operator new(size_t cb, const std::nothrow_t&)  // removed 'static inline'  
    ```  
  
     Кроме того, хотя компилятор не выдает соответствующего диагностического сообщения, встроенный оператор new считается некорректным.  
  
-   **Вызов "operator *тип*\(\)" \(пользовательское преобразование\) для типов, не являющихся классами**  
  
     В предыдущих версиях компилятора допускался вызов "operator *тип*\(\)" для типов, не являющихся классами, при этом он игнорировался без вывода предупреждения. Это создавало риск создания некорректного кода и непредсказуемого поведения во время выполнения. Компилятор больше не принимает код, написанный таким образом, и выдает вместо этого ошибку C2228.  
  
 **ошибка C2228: выражение слева от ".operator *тип*" должно представлять класс, структуру или объединение**     Пример \(раньше\)  
  
    ```cpp  
    typedef int index_t; void bounds_check(index_t index); void login(int column) { bounds_check(column.operator index_t());  // error C2228 }  
    ```  
  
     Пример \(теперь\)  
  
    ```cpp  
    typedef int index_t; void bounds_check(index_t index); void login(int column) { bounds_check(column);  // removed cast to 'index_t', 'index_t' is an alias of 'int' }  
    ```  
  
-   **Избыточное ключевое слово typename в сложных спецификаторах типов**  
  
     В предыдущих версиях компилятора допускалось ключевое слово `typename` в сложных спецификаторах типов. Код, написанный таким образом, семантически неправилен. Компилятор больше не принимает код, написанный таким образом, и выдает вместо этого ошибку C3406.  
  
 **ошибка C3406: "typename" нельзя использовать в сложном спецификаторе типа**     Пример \(раньше\)  
  
    ```cpp  
    template <typename class T> class container;  
    ```  
  
     Пример \(теперь\)  
  
    ```cpp  
    template <class T>  // alternatively, could be 'template <typename T>'; 'typename' is not elaborating a type specifier in this case class container;  
    ```  
  
-   **Выведение типов массивов из списка инициализаторов**  
  
     В предыдущих версиях компилятора не поддерживалось выведение типов массивов из списка инициализаторов. Теперь компилятор поддерживает подобное выведение типов, и в результате вызовы шаблонов функций с помощью списков инициализаторов теперь могут быть неоднозначными либо может выбираться не та перегрузка, что в предыдущих версиях компилятора. Для устранения этой проблемы теперь необходимо явно указывать в программе требуемую перегрузку.  
  
     Если в результате этого нового поведения при разрешении перегрузки дополнительный кандидат считается равноценным ранее существовавшему, вызов становится неоднозначным, и компилятор выдает ошибку C2668.  
  
 **ошибка C2668: "*функция*": неоднозначный вызов перегруженной функции.**     Пример 1. Неоднозначный вызов перегруженной функции \(раньше\)  
  
    ```cpp  
    // In previous versions of the compiler, code written in this way would unambiguously call f(int, Args...) template <typename... Args> void f(int, Args...);  // template <int N, typename... Args> void f(const int (&)[N], Args...); int main() { // The compiler now considers this call ambiguous, and issues a compiler error  f({3});  error C2668: 'f' ambiguous call to overloaded function }  
    ```  
  
     Пример 1. Неоднозначный вызов перегруженной функции \(теперь\)  
  
    ```cpp  
    template <typename... Args> void f(int, Args...);  // template <int N, typename... Args> void f(const int (&)[N], Args...); int main() { // To call f(int, Args...) when there is just one expression in the initializer list, remove the braces from it. f(3); }  
    ```  
  
     Если в результате этого нового поведения при разрешении перегрузки дополнительный кандидат считается лучше ранее существовавшего, вызов разрешается однозначно в нового кандидата, что приводит к изменению поведения программы, которое, возможно, не планировалось программистом.  
  
     Пример 2. Изменение в разрешении перегрузки \(раньше\)  
  
    ```cpp  
    // In previous versions of the compiler, code written in this way would unambiguously call f(S, Args...) struct S { int i; int j; }; template <typename... Args> void f(S, Args...); template <int N, typename... Args> void f(const int *&)[N], Args...); int main() { // The compiler now resolves this call to f(const int (&)[N], Args...) instead  f({1, 2}); }  
    ```  
  
     Пример 2. Изменение в разрешении перегрузки \(теперь\)  
  
    ```cpp  
    struct S;  // as before template <typename... Args> void f(S, Args...); template <int N, typename... Args> void f(const int *&)[N], Args...); int main() { // To call f(S, Args...), perform an explicit cast to S on the initializer list. f(S{1, 2}); }  
    ```  
  
-   **Восстановление предупреждений, касающихся оператора switch**  
  
     В предыдущей версии компилятора были удалены ранее существовавшие предупреждения, касающиеся операторов `switch`. Теперь эти предупреждения восстановлены. Компилятор теперь выдает эти предупреждения. Предупреждения, связанные с определенными вариантами \(включая вариант по умолчанию\), теперь выдаются в строке, содержащей неправильный вариант, а не в последней строке оператора switch. В результате того, что теперь предупреждения выдаются не в тех строках, что раньше, предупреждения, которые ранее подавлялись с помощью `#pragma warning(disable:####)`, могут больше не подавляться, как планировалось. Для правильного подавления этих предупреждений может потребоваться перенести директиву `#pragma warning(disable:####)` в строку перед первым потенциально неправильным вариантом. Ниже приведены восстановленные предупреждения.  
  
 **предупреждение C4060: оператор switch не содержит метку "case" или "default" предупреждение C4061: перечислитель "*bit1*" в операторе switch с перечислением "*флаги*" не обрабатывается явно меткой выбора предупреждение C4062: перечислитель "*bit1*" в операторе switch с перечислением "*флаги*" не обрабатывается предупреждение C4063: вариант "*bit32*" не является допустимым значением для оператора switch с перечислением "*флаги*" предупреждение C4064: оператор switch с неполным перечислением "*флаги*" предупреждение C4065: оператор switch содержит метку "default", но не содержит ни одной метки "case" предупреждение C4808: вариант "*значение*" недопустим в операторе switch с условием типа "*bool*" Предупреждение C4809: в операторе switch имеется ненужная метка "default"; все возможные метки "case" уже заданы**     Пример предупреждения C4063 \(раньше\)  
  
    ```cpp  
    class settings { public: enum flags { bit0 = 0x1, bit1 = 0x2, ... }; ... }; int main() { auto val = settings::bit1; switch (val) { case settings::bit0: break; case settings::bit1: break;  case settings::bit0 | settings::bit1:  // warning C4063 break; } };  
    ```  
  
     Пример предупреждения C4063 \(теперь\)  
  
    ```cpp  
    class settings {...};  // as above int main() { // since C++11, use std::underlying_type to determine the underlying type of an enum typedef std::underlying_type<settings::flags>::type flags_t; auto val = settings::bit1; switch (static_cast<flags_t>(val)) { case settings::bit0: break; case settings::bit1: break; case settings::bit0 | settings::bit1:  // ok break; } };  
    ```  
  
     Примеры других восстановленных предупреждений приведены в соответствующей документации.  
  
-   **\#include: использование спецификатора parent\-directory ".." в пути** \(касается только \/Wall \/WX\)  
  
     В предыдущих версиях компилятора не определялись случаи использования спецификатора parent\-directory ".." в пути директив `#include`. Код, написанный таким образом, обычно предназначен для включения заголовков, находящихся за пределами проекта, путем неправильного использования относительных путей к проектам. Это прежнее поведение создавало риск того, что при компиляции программы мог включаться не тот файл исходного кода, который планировал программист, или что эти относительные пути невозможно было бы перенести в другие среды сборки. Компилятор теперь обнаруживает код, написанный таким образом, уведомляет о нем программиста и выдает необязательное предупреждение C4464, если оно включено.  
  
 **предупреждение C4464: относительный путь включения содержит ".."**     Пример \(раньше\)  
  
    ```cpp  
    #include "..\headers\C4426.h"  // emits warning C4464  
    ```  
  
     Пример \(теперь\)  
  
    ```cpp  
    #include "C4426.h"  // add absolute path to 'headers\' to your project's include directories  
    ```  
  
     Кроме того, хотя компилятор не выдает соответствующего диагностического сообщения, мы также рекомендуем не использовать спецификатор parent\-directory ".." для указания включаемых в проект каталогов.  
  
-   **\#pragma optimize\(\) выходит за пределы файла заголовка** \(касается только \/Wall \/WX\)  
  
     В предыдущих версиях компилятора не определялись изменения в параметрах флагов оптимизации за пределами файла заголовка, включенного в запись преобразования. Компилятор теперь обнаруживает код, написанный таким образом, уведомляет о нем программиста и выдает необязательное предупреждение C4426 в месте нахождения неправильного `#include`, если оно включено. Это предупреждение выдается только в том случае, если изменения конфликтуют с флагами оптимизации, установленными аргументами командной строки, переданными в компилятор.  
  
 **предупреждение C4426: изменение флагов оптимизации после включения заголовка может быть связано с \#pragma optimize\(\)**     Пример \(раньше\)  
  
    ```cpp  
    // C4426.h #pragma optimize("g", off) ... // C4426.h ends // C4426.cpp #include "C4426.h"  // warning C4426  
    ```  
  
     Пример \(теперь\)  
  
    ```cpp  
    // C4426.h #pragma optimize("g", off) ... #pragma optimize("", on)  // restores optimization flags set via command-line arguments // C4426.h ends // C4426.cpp #include "C4426.h"  
    ```  
  
-   **Несоответствие \#pragma warning\(push\)** и **\#pragma warning\(pop\)** \(касается только \/Wall \/WX\)  
  
     В предыдущих версиях компилятора не обнаруживалось сопоставление изменений состояния `#pragma warning(push)` с изменениями состояния `#pragma warning(pop)` в другом файле исходного кода, которое редко бывает намеренным. Это создавало риск компиляции программы с набором включенных предупреждений, отличным от того, которое запланировал программист, что могло приводить к неправильному поведению во время выполнения. Компилятор теперь обнаруживает код, написанный таким образом, уведомляет о нем программиста и выдает необязательное предупреждение C5031 в месте нахождения соответствующего `#pragma warning(pop)`, если это предупреждение включено. Это предупреждение включает ссылку на местоположение соответствующего выражения \#pragma warning\(push\).  
  
 **предупреждение C5031: \#pragma warning\(pop\): возможное несоответствие, состояние всплывающего предупреждения передано в другой файл**     Пример \(раньше\)  
  
    ```cpp  
    // C5031_part1.h #pragma warning(push) #pragma warning(disable:####) ... // C5031_part1.h ends without #pragma warning(pop) // C5031_part2.h ... #pragma warning(pop)  // pops a warning state not pushed in this source file ... // C5031_part1.h ends // C5031.cpp #include "C5031_part1.h" // leaves #pragma warning(push) 'dangling' ... #include "C5031_part2.h" // matches 'dangling' #pragma warning(push), resulting in warning C5031 ...   
    ```  
  
     Пример \(теперь\)  
  
    ```cpp  
    // C5031_part1.h #pragma warning(push) #pragma warning(disable:####) ... #pragma warning(pop)  // pops the warning state pushed in this source file // C5031_part1.h ends without #pragma warning(pop) // C5031_part2.h #pragma warning(push)  // pushes the warning state pushed in this source file #pragma warning(disable:####) ... #pragma warning(pop) // C5031_part1.h ends // C5031.cpp #include "C5031_part1.h" // #pragma warning state changes are self-contained and independent of other source files or their #include order. ... #include "C5031_part2.h" ...   
    ```  
  
     Хотя и нечасто, подобный код может быть написан намеренно. Код, написанный подобным образом, чувствителен к порядку следования `#include`. Мы рекомендуем, чтобы по возможности файлы исходного кода управляли состояниями предупреждений самостоятельно.  
  
-   **Несоответствие \#pragma warning\(push\)** \(касается только \/Wall \/WX\)  
  
     В предыдущих версиях компилятора не определялось несоответствие изменений состояния `#pragma warning(push)` в конце записи преобразования. Теперь компилятор обнаруживает код, написанный таким образом, уведомляет о нем программиста и выдает необязательное предупреждение C5032 в месте нахождения несоответствующего выражения \#pragma warning\(push\), если это предупреждение включено. Это предупреждение выдается только в том случае, если в записи преобразования нет ошибок компиляции.  
  
 **предупреждение C5032: обнаружено выражение \#pragma warning\(push\) без соответствующего выражения \#pragma warning\(pop\)**     Пример \(раньше\)  
  
    ```cpp  
    // C5032.h #pragma warning(push) #pragma warning(disable:####) ... // C5032.h ends without #pragma warning(pop) // C5032.cpp #include "C5032.h" ... // C5032.cpp ends -- the translation unit is completed without #pragma warning(pop), resulting in warning C5032 on line 1 of C5032.h  
    ```  
  
     Пример \(теперь\)  
  
    ```cpp  
    // C5032.h #pragma warning(push) #pragma warning(disable:####) ... #pragma warning(pop) // matches #pragma warning (push) on line 1 // C5032.h ends // C5032.cpp #include "C5032.h" ... // C5032.cpp ends -- the translation unit is completed without unmatched #pragma warning(push)  
    ```  
  
-   **В результате усовершенствования отслеживания состояния \#pragma warning, могут выдаваться дополнительные предупреждения**  
  
     В предыдущей версии компилятора изменения состояния \#pragma warning отслеживались недостаточно хорошо для того, чтобы выдавались все необходимые предупреждения. В результате возникал риск того, что некоторые предупреждения могли подавляться в ситуациях, не предусмотренных программистом. Теперь компилятор более тщательно отслеживает состояние \#pragma, а особенно изменения состояния \#pragma warning внутри шаблонов. При необходимости он также выдает новые предупреждения C5031 и C5032, которые призваны помочь программисту в определении случаев непредусмотренного использования `#pragma warning(push)` и `#pragma warning(pop)`.  
  
     В результате усовершенствованного отслеживания изменения состояния \#pragma warning теперь могут выдаваться предупреждения, которые раньше некорректно подавлялись, или предупреждения о проблемах, которые ранее диагностировались неправильно.  
  
-   **Улучшенное определение недостижимого кода**  
  
     Изменения, внесенные в стандартную библиотеку C\+\+, и улучшенная возможность встраивания вызовов функций по сравнению с предыдущими версиями компилятора позволяют компилятору определять недостижимость определенного кода. Это может привести к тому, что предупреждение C4720 будет выдаваться чаще.  
  
 **предупреждение C4720: недостижимый код**     Зачастую это предупреждение выдается только при компиляции с включенными оптимизациями, так как при этом может встраиваться больше вызовов функций, удаляться избыточный код или могут производиться другие действия, позволяющие определить недостижимость определенного кода. По нашим наблюдениям, предупреждение C4720 начало часто появляться в блоках try\/catch, особенно в связи с использованием [std::find](assetId:///std::find?qualifyHint=False&autoUpgrade=True).  
  
     Пример \(раньше\)  
  
    ```cpp  
    try { auto iter = std::find(v.begin(), v.end(), 5); } catch(…) { do_something();  // ok }  
    ```  
  
     Пример \(теперь\)  
  
    ```cpp  
    try { auto iter = std::find(v.begin(), v.end(), 5); } catch(…) { do_something();  // warning C4702: unreachable code }  
    ```