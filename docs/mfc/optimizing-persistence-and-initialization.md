---
title: "Оптимизация постоянства и инициализации | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
helpviewer_keywords:
- MFC ActiveX controls [MFC], optimizing
- performance, ActiveX controls
- optimization, ActiveX controls
- optimizing performance, ActiveX controls
ms.assetid: e821e19e-b9eb-49ab-b719-0743420ba80b
caps.latest.revision: 
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: eeddfe4c67de2e96d42c7714619463ae3be45187
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="optimizing-persistence-and-initialization"></a>Оптимизация постоянства и инициализации
По умолчанию постоянства и инициализации в элементе управления обрабатываются `DoPropExchange` функции-члена. Типичные элемента управления, эта функция содержит несколько вызовов **PX_** функции (`PX_Color`, `PX_Font`и так далее), один для каждого свойства.  
  
 Такой подход имеет то преимущество, один `DoPropExchange` реализация может быть использована для инициализации, сохраняемости в двоичном формате и сохраняемость в так называемых «-контейнер свойств» формат, используемый в некоторые контейнеры. Это одна функция предоставляет все сведения о свойствах и их значения по умолчанию в одном месте.  
  
 Однако этот универсальности можно реализовать за счет повышения эффективности. **PX_** функции получить их гибкость посредством многоуровневую реализации, которые по своей природе меньше эффективным, чем непосредственно, но менее гибкими подходами. Кроме того Если элемент управления передает значение по умолчанию **PX_** функции, что по умолчанию должно быть указано значение каждый раз, даже в случаях, когда значение по умолчанию может не обязательно будет использоваться. При формировании значения по умолчанию является непростой задачей (например, если значение получается из внешнего свойства), то лишние, ненужные работа выполняется в случаях, когда значение по умолчанию не используется.  
  
 Можно повысить производительность двоичных сохраняемости элемента управления путем переопределения элемента управления `Serialize` функции. Реализация по умолчанию эта функция-член вызывает метод вашей `DoPropExchange` функции. Путем переопределения его, можно добавить непосредственно реализацию для двоичных сохраняемости. Например, рассмотрим это `DoPropExchange` функции:  
  
 [!code-cpp[NVC_MFC_AxOpt#1](../mfc/codesnippet/cpp/optimizing-persistence-and-initialization_1.cpp)]  
  
 Чтобы повысить производительность двоичных сохраняемости данного элемента управления, можно переопределить `Serialize` работать следующим образом:  
  
 [!code-cpp[NVC_MFC_AxOpt#2](../mfc/codesnippet/cpp/optimizing-persistence-and-initialization_2.cpp)]  
  
 `dwVersion` Локальная переменная может использоваться для обнаружения версии постоянное состояние элемента управления загрузки или сохранения. Эту переменную можно использовать вместо вызова метода [CPropExchange::GetVersion](../mfc/reference/cpropexchange-class.md#getversion).  
  
 Чтобы сохранить небольшом пространстве в постоянном формате для **BOOL** свойство (и во избежание совместимые с форматом, полученных при `PX_Bool`), можно хранить свойство как **БАЙТОВ**, как показано ниже:  
  
 [!code-cpp[NVC_MFC_AxOpt#3](../mfc/codesnippet/cpp/optimizing-persistence-and-initialization_3.cpp)]  
  
 Обратите внимание, что в случае загрузки используется временной переменной и затем ей назначается значение, а не приведение `m_boolProp` для **БАЙТОВ** ссылки. Метод приведения приведет к появлению всего один байт `m_boolProp` изменяемым, оставляя оставшиеся байты не инициализирована.  
  
 Для одного элемента управления, можно оптимизировать инициализации элемента управления путем переопределения [COleControl::OnResetState](../mfc/reference/colecontrol-class.md#onresetstate) следующим образом:  
  
 [!code-cpp[NVC_MFC_AxOpt#4](../mfc/codesnippet/cpp/optimizing-persistence-and-initialization_4.cpp)]  
  
 Несмотря на то что `Serialize` и `OnResetState` был переопределен, `DoPropExchange` функция должна храниться без изменений, так как он по-прежнему используется для сохранения в формате контейнер свойств. Очень важно для обслуживания всех трех этих функций, чтобы элемент управления управляет его свойства согласованно, независимо от того, какие сохраняемости использует механизм контейнера.  
  
## <a name="see-also"></a>См. также  
 [Элементы ActiveX в MFC. Оптимизация](../mfc/mfc-activex-controls-optimization.md)

