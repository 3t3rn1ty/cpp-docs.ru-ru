---
title: "Производные схемы сообщений | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "производные схемы сообщений"
  - "обработка сообщений, производные обработчики сообщений"
  - "схемы сообщений, производные"
  - "сообщения, маршрутизация"
ms.assetid: 21829556-6e64-40c3-8279-fed85d99de77
caps.latest.revision: 11
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 7
---
# Производные схемы сообщений
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Во время обработки сообщений, чтобы проверить собственную схему класса сообщений нет конца описания функциональности схемы сообщений.  Что происходит, если класс `CMyView` \(производное от `CView`\) не имеет сопоставления для записи сообщения?  
  
 Имейте в виду, `CView`, базовый класс `CMyView`, в свою очередь, является производным из `CWnd`.  Таким образом `CMyView` `CView` и `CWnd`.  Каждый из этих классов имеет собственную схему сообщений.  На рисунке иерархия «представления» ниже показано иерархическую связь классов, но считается, что объект `CMyView` один объект с характеристиками 3 классов.  
  
 ![Иерархия представления](../mfc/media/vc38621.png "vc38621")  
Иерархия представлений  
  
 Поэтому, если сообщение не удается сопоставить с схеме сообщений, `CMyView` класса, среда выполнения также схема сообщений его непосредственного базового класса.  Макрос `BEGIN_MESSAGE_MAP` в начале сопоставления сообщений определяет 2 имени класса в качестве ее аргументы:  
  
 [!CODE [NVC_MFCMessageHandling#2](../CodeSnippet/VS_Snippets_Cpp/NVC_MFCMessageHandling#2)]  
  
 Имена аргументов первый класс, к которому принадлежит схема сообщений.  Второй аргумент предоставляет соединение с немедленным базовым классом — `CView` здесь — поэтому платформа выполняет поиск в качестве схемы сообщений, слишком.  
  
 Обработчик сообщений предусмотренные в базовом классе таким образом наследуются производным классом.  Это очень похоже на нормальным виртуальной функции\-члена без вносить функции\-члены обработчика виртуальным.  
  
 Если ни один обработчик не найден в любой схеме сообщений базового класса, обработка сообщений по умолчанию выполняется.  Если сообщение команды, платформа направляет ее к следующему конечному объекту команды.  Если стандартное сообщение Windows, это сообщение передается в соответствующей процедуре окна по умолчанию.  
  
 Для сопоставления схемы сообщений скорости платформа кэшировать последние совпадения на вероятность того, что она получит такое же сообщение.  Следствием этого является то, что процессы платформы необработанные сообщения гораздо эффективнее.  Схемы сообщений также является более эффективным, чем реализации, использующих виртуальные функции.  
  
## См. также  
 [Выполнение платформой поиска по схемам сообщений](../mfc/how-the-framework-searches-message-maps.md)