---
title: Производные схемы сообщений | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-mfc
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- message handling [MFC], derived message handlers
- messages, routing
- message maps [MFC], derived
- derived message maps
ms.assetid: 21829556-6e64-40c3-8279-fed85d99de77
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 7e780d411e62d1347d8286f86b45df864b0fcdb3
ms.sourcegitcommit: 76b7653ae443a2b8eb1186b789f8503609d6453e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
---
# <a name="derived-message-maps"></a>Производные схемы сообщений
Во время сообщения, обработка, проверка класса собственные сообщения карты не конец статьи схемы сообщений. Что произойдет, если класс `CMyView` (производный от `CView`), не имеет соответствующей записи сообщения  
  
 Имейте в виду, что `CView`, базовый класс для `CMyView`, в свою очередь производный от `CWnd`. Таким образом `CMyView` *—* `CView` и *—* `CWnd`. Каждый из этих классов имеет собственную схему сообщений. Рисунок, «просмотр иерархии «ниже показано иерархическую связь между классами, но имейте в виду, что `CMyView` объект представляет собой один объект, с характеристиками все три класса.  
  
 ![Иерархия представления](../mfc/media/vc38621.gif "vc38621")  
Просмотр иерархии  
  
 Таким образом, если сообщение не может быть сопоставлен в классе `CMyView`в схему сообщений, платформа, кроме того, выполняет сопоставление сообщений, немедленное базового класса. `BEGIN_MESSAGE_MAP` Макрос в начале схему сообщений определяет два имени класса в качестве аргументов:  
  
 [!code-cpp[NVC_MFCMessageHandling#2](../mfc/codesnippet/cpp/derived-message-maps_1.cpp)]  
  
 Первый аргумент имен класса, к которому принадлежит схеме сообщений. Второй аргумент содержит подключения непосредственно к базовому классу — `CView` здесь, чтобы платформу можно осуществлять поиск схему сообщений, слишком.  
  
 Обработчики сообщений, предоставляемых в базовом классе таким образом, наследуются от производного класса. Это очень похоже на обычный виртуальных функций-членов без необходимости вносить все функции-члены обработчика виртуальной.  
  
 Если обработчик не найден в любой из схем сообщений базового класса, выполняется по умолчанию обработку сообщения. Если сообщение команды, платформа направляет его в следующий целевой объект команды. Если стандартных сообщений Windows, сообщение передается процедуре окна соответствующее значение по умолчанию.  
  
 Чтобы ускорить сопоставления схемы сообщений, платформа кэширует последних совпадений на вероятность того, что она будет это сообщение еще раз. Следствием этого является процессы framework весьма эффективно необработанных сообщений. Схемы сообщений также являются пространства эффективнее, чем реализации, использующих виртуальные функции.  
  
## <a name="see-also"></a>См. также  
 [Выполнение платформой поиска по схемам сообщений](../mfc/how-the-framework-searches-message-maps.md)

