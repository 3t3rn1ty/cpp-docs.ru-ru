---
title: "Производные схемы сообщений | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
helpviewer_keywords:
- message handling [MFC], derived message handlers
- messages, routing
- message maps [MFC], derived
- derived message maps
ms.assetid: 21829556-6e64-40c3-8279-fed85d99de77
caps.latest.revision: "11"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: 6e5901602368e60a3873a1dba2fc681c6ac146f5
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="derived-message-maps"></a>Производные схемы сообщений
Во время сообщения, обработка, проверка класса собственные сообщения карты не конец статьи схемы сообщений. Что произойдет, если класс `CMyView` (производный от `CView`), не имеет соответствующей записи сообщения  
  
 Имейте в виду, что `CView`, базовый класс для `CMyView`, в свою очередь производный от `CWnd`. Таким образом `CMyView` *—* `CView` и *—* `CWnd`. Каждый из этих классов имеет собственную схему сообщений. Рисунок, «просмотр иерархии «ниже показано иерархическую связь между классами, но имейте в виду, что `CMyView` объект представляет собой один объект, с характеристиками все три класса.  
  
 ![Иерархия представления](../mfc/media/vc38621.gif "vc38621")  
Просмотр иерархии  
  
 Таким образом, если сообщение не может быть сопоставлен в классе `CMyView`в схему сообщений, платформа, кроме того, выполняет сопоставление сообщений, немедленное базового класса. `BEGIN_MESSAGE_MAP` Макрос в начале схему сообщений определяет два имени класса в качестве аргументов:  
  
 [!code-cpp[NVC_MFCMessageHandling#2](../mfc/codesnippet/cpp/derived-message-maps_1.cpp)]  
  
 Первый аргумент имен класса, к которому принадлежит схеме сообщений. Второй аргумент содержит подключения непосредственно к базовому классу — `CView` здесь, чтобы платформу можно осуществлять поиск схему сообщений, слишком.  
  
 Обработчики сообщений, предоставляемых в базовом классе таким образом, наследуются от производного класса. Это очень похоже на обычный виртуальных функций-членов без необходимости вносить все функции-члены обработчика виртуальной.  
  
 Если обработчик не найден в любой из схем сообщений базового класса, выполняется по умолчанию обработку сообщения. Если сообщение команды, платформа направляет его в следующий целевой объект команды. Если стандартных сообщений Windows, сообщение передается процедуре окна соответствующее значение по умолчанию.  
  
 Чтобы ускорить сопоставления схемы сообщений, платформа кэширует последних совпадений на вероятность того, что она будет это сообщение еще раз. Следствием этого является процессы framework весьма эффективно необработанных сообщений. Схемы сообщений также являются пространства эффективнее, чем реализации, использующих виртуальные функции.  
  
## <a name="see-also"></a>См. также  
 [Выполнение платформой поиска по схемам сообщений](../mfc/how-the-framework-searches-message-maps.md)

