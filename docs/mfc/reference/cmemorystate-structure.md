---
title: "CMemoryState Structure | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "reference"
f1_keywords: 
  - "CMemoryState"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "CMemoryState structure"
  - "обнаружение утечек памяти"
  - "утечки памяти, обнаружение"
ms.assetid: 229d9de7-a6f3-4cc6-805b-5a9d9b1bfe1d
caps.latest.revision: 19
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 21
---
# CMemoryState Structure
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

Обеспечивает удобный способ обнаружения утечек памяти в программе.  
  
## Синтаксис  
  
```  
struct CMemoryState  
```  
  
## Члены  
  
### Открытые конструкторы  
  
|Имя|Описание|  
|---------|--------------|  
|[CMemoryState::CMemoryState](../Topic/CMemoryState::CMemoryState.md)|Создает a класс\- как структура контрольные точки этой памяти элементов управления.|  
  
### Открытые методы  
  
|Имя|Описание|  
|---------|--------------|  
|[CMemoryState::Checkpoint](../Topic/CMemoryState::Checkpoint.md)|Возвращает моментальный снимок \(контрольную точку\) текущего состояния памяти.|  
|[CMemoryState::Difference](../Topic/CMemoryState::Difference.md)|Вычисляет разницу между объектами типа `CMemoryState`2.|  
|[CMemoryState::DumpAllObjectsSince](../Topic/CMemoryState::DumpAllObjectsSince.md)|Создает дамп сводку всех выбранных объектов с предыдущей контрольной точки.|  
|[CMemoryState::DumpStatistics](../Topic/CMemoryState::DumpStatistics.md)|Статистика операций выделения памяти печатей для объекта `CMemoryState`.|  
  
## Заметки  
 `CMemoryState` структура и не имеет базовый класс.  
  
 "Утечку памяти" возникает, когда память для объекта выделена в куче, но не освобождаются, когда он больше не нужен.  Такие утечек памяти, наконец, могут привести к ошибкам переполнения памяти.  Существует несколько способов выделения и отмены выделения памяти в программе.  
  
-   Использование семейство `malloc`\/**свободно;бесплатно;бесплатные** функции из библиотеки времени выполнения.  
  
-   Использование функции управления памятью API Windows, **LocalAlloc**\/**LocalFree** и **GlobalAlloc**\/**GlobalFree**.  
  
-   Использование C\+\+ **новый** и операторы **удалить**.  
  
 Справка диагностики `CMemoryState` только обнаруживает, вызванные утечек памяти, когда память, выделенная с помощью оператора **новый** освобождена с помощью **удалить**.  Остальные 2 группы в составе функции управления памятью для программ non\-C\+\+ и не рекомендуется **новый** и объединяет их с **удалить** в одной программе.  Этот дополнительный, что заменяет макрос, `DEBUG_NEW`, оператор **новый**, когда требуется отслеживание выделений памяти файла и номера линии.  `DEBUG_NEW` обычно используется в том случае, если используется оператор **новый**.  
  
 Как и в случае с другими диагностиками устранение неполадок `CMemoryState`, доступны только внутри отладочные версии программы.  Отладочная версия должна иметь **\_DEBUG** указанную константу.  
  
 Если есть, то программа имеет утечку памяти, можно использовать `Checkpoint`, **Разница** и функции `DumpStatistics`, чтобы обнаружить разницу между состояниями памяти \(выделенными объектами\) на 2 различных этапов выполнения программы.  Эти сведения могут оказаться полезными в определение, является ли функция очистки очищает все объекты она выделяет.  
  
 Если просто знать, где должна быть вычислена разница в распространении и освобождение происходит не предоставляет достаточно сведений, можно использовать функцию `DumpAllObjectsSince` чтобы сбросить все объекты, выбранные с момента предыдущего вызова `Checkpoint`.  Этот дамп указывает порядок распределения исходного файла и линии, где был выбрать объект \(если используется `DEBUG_NEW` для распространения\) и вывода объекта, его адрес и его размера.  `DumpAllObjectsSince` также вызывает функцию `Dump` каждого объекта для предоставления сведений о текущем состоянии.  
  
 Дополнительные сведения об использовании `CMemoryState`, а другой для устранения неполадок см. в разделе [Отладка приложений MFC](../Topic/MFC%20Debugging%20Techniques.md).  
  
> [!NOTE]
>  Объявления объектов типа `CMemoryState` и вызовов функции\-членам должны быть отысканы вилку рекомендации `#if defined(_DEBUG)/#endif` .  В результате диагностики памяти быть включено только в построениях отладки программы.  
  
## Иерархия наследования  
 `CMemoryState`  
  
## Требования  
 **Header:**  afx.h  
  
## См. также  
 [Диаграмма иерархии](../../mfc/hierarchy-chart.md)