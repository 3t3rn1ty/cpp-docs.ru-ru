---
title: "Класс CMultiLock | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-windows
ms.tgt_pltfrm: 
ms.topic: reference
f1_keywords:
- CMultiLock
- AFXMT/CMultiLock
- AFXMT/CMultiLock::CMultiLock
- AFXMT/CMultiLock::IsLocked
- AFXMT/CMultiLock::Lock
- AFXMT/CMultiLock::Unlock
dev_langs: C++
helpviewer_keywords:
- CMultiLock [MFC], CMultiLock
- CMultiLock [MFC], IsLocked
- CMultiLock [MFC], Lock
- CMultiLock [MFC], Unlock
ms.assetid: c5b7c78b-1f81-4387-b7dd-2c813c5b6b61
caps.latest.revision: "20"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: dc3c391c624351b2835e1ec497d78bc191eb1fe7
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="cmultilock-class"></a>Класс CMultiLock
Класс представляет механизм контроля доступа к ресурсам в многопоточных программах.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
class CMultiLock  
```  
  
## <a name="members"></a>Участники  
  
### <a name="public-constructors"></a>Открытые конструкторы  
  
|Имя|Описание:|  
|----------|-----------------|  
|[CMultiLock::CMultiLock](#cmultilock)|Создает объект `CMultiLock`.|  
  
### <a name="public-methods"></a>Открытые методы  
  
|Имя|Описание:|  
|----------|-----------------|  
|[CMultiLock::IsLocked](#islocked)|Определяет, если объект определенного синхронизации в массиве заблокирован.|  
|[CMultiLock::Lock](#lock)|Ожиданий в массиве объектов синхронизации.|  
|[CMultiLock::Unlock](#unlock)|Освобождает все объекты принадлежащие синхронизации.|  
  
## <a name="remarks"></a>Примечания  
 `CMultiLock`не имеет базового класса.  
  
 Использование классов синхронизации [CSemaphore](../../mfc/reference/csemaphore-class.md), [CMutex](../../mfc/reference/cmutex-class.md), и [CEvent](../../mfc/reference/cevent-class.md), можно создать либо **CMultiLock** или [Класс CSingleLock](../../mfc/reference/csinglelock-class.md) объект для ожидания и освобождения объекта синхронизации. Используйте **CMultiLock** при наличии нескольких объектов, которые можно использовать в конкретный момент времени. Используйте `CSingleLock` при требуется только для одного объекта во время ожидания.  
  
 Для использования **CMultiLock** объекта, сначала создайте массив объектов синхронизации, которые вы хотите ожидание. Затем вызовите **CMultiLock** в конструктор объекта внутри функции-члена в классе управляемого ресурса. Затем вызовите [блокировки](#lock) функции-члена для определения доступности ресурса (сигнал). Если он, продолжите и остальная часть функции-члена. Если ресурс не доступна, дождитесь на указанный период времени для освобождения ресурса или возвращена ошибка. После завершения использования ресурса вызвать [Unlock](#unlock) функционировать, если **CMultiLock** должен использоваться повторно, либо разрешить **CMultiLock** объекта будут уничтожены.  
  
 **CMultiLock** объектов наиболее полезны, когда потоку большое количество `CEvent` может реагировать на объекты. Создайте массив, содержащий все `CEvent` указатели и вызова `Lock`. В результате поток ожидает завершения события, получает сигнал.  
  
 Дополнительные сведения об использовании **CMultiLock** объектов, см. в статье [Многопоточность: использование классов синхронизации](../../parallel/multithreading-how-to-use-the-synchronization-classes.md).  
  
## <a name="inheritance-hierarchy"></a>Иерархия наследования  
 `CMultiLock`  
  
## <a name="requirements"></a>Требования  
 **Заголовок:** afxmt.h  
  
##  <a name="cmultilock"></a>CMultiLock::CMultiLock  
 Создает **CMultiLock** объекта.  
  
```  
CMultiLock(
    CSyncObject* ppObjects [ ],  
    DWORD dwCount,  
    BOOL bInitialLock = FALSE);
```  
  
### <a name="parameters"></a>Параметры  
 `ppObjects`  
 Массив указателей на объекты синхронизации для ожидания на. Не может быть **NULL**.  
  
 `dwCount`  
 Количество объектов в `ppObjects`. Должно быть больше 0.  
  
 `bInitialLock`  
 Указывает необходимость сначала пытаются получить доступ к любой из предоставленных объектов.  
  
### <a name="remarks"></a>Примечания  
 Эта функция вызывается после создания массива объектов синхронизации, чтобы быть ожидание. Обычно она вызывается из потока, необходимо дождаться один из объектов синхронизации станут доступны.  
  
##  <a name="islocked"></a>CMultiLock::IsLocked  
 Определяет, является ли указанный объект несигнальное (недоступно).  
  
```  
BOOL IsLocked(DWORD dwItem);
```  
  
### <a name="parameters"></a>Параметры  
 *dwItem*  
 Индекс в массиве объектов, связанный с объектом, состояние которого выполняется запрос.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если указанный объект заблокирован; в противном случае — 0.  
  
##  <a name="lock"></a>CMultiLock::Lock  
 Эта функция вызывается для получения доступа к одному или нескольким ресурсы, управляемые объекты синхронизации, передаваемые **CMultiLock** конструктор.  
  
```  
DWORD Lock(
    DWORD dwTimeOut = INFINITE,  
    BOOL bWaitForAll = TRUE,  
    DWORD dwWakeMask = 0);
```  
  
### <a name="parameters"></a>Параметры  
 *dwTimeOut*  
 Указывает время ожидания для объекта синхронизации доступны (сигнал). Если **БЕСКОНЕЧНЫЙ**, `Lock` ожидает сигнала перед возвращением объекта.  
  
 `bWaitForAll`  
 Указывает, должны принять сигнал ожидания на все объекты, в то же время перед возвратом. Если **FALSE**, `Lock` возвращает, если один из объектов, Ожидание, получает сигнал.  
  
 `dwWakeMask`  
 Указывает другие условия, которые разрешены для отмены ожидания. Полный список доступных параметров для этого параметра см. в разделе [MsgWaitForMultipleObjects](http://msdn.microsoft.com/library/windows/desktop/ms684242) в Windows SDK.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Если `Lock` завершается ошибкой, то возвращается значение - 1. В случае успешного выполнения возвращает одно из следующих значений:  
  
-   Между **WAIT_OBJECT_0** и **WAIT_OBJECT_0** + (число объектов - 1)  
  
     Если `bWaitForAll` — **TRUE**, все объекты получают сигнал (доступно). Если `bWaitForAll` — **FALSE**, возвращаемое значение — **WAIT_OBJECT_0** — это индекс в массиве объектов объекта, которому отправляется сигнал (доступно).  
  
- **WAIT_OBJECT_0** + (число объектов)  
  
     События, указанного в `dwWakeMask` доступен входной очереди потока.  
  
-   Между **WAIT_ABANDONED_0** и **WAIT_ABANDONED_0** + (число объектов - 1)  
  
     Если `bWaitForAll` — **TRUE**, все объекты получают сигнал и по крайней мере один из объектов — это объект Брошенный mutex. Если `bWaitForAll` — **FALSE**, возвращаемое значение — **WAIT_ABANDONED_0** — это индекс в массиве объектов Брошенный mutex объекта, удовлетворившего операцию ожидания.  
  
- **WAIT_TIMEOUT**  
  
     Интервал времени ожидания, указанный в *dwTimeOut* истек срок действия без ожидания успешному выполнению.  
  
### <a name="remarks"></a>Примечания  
 Если `bWaitForAll` — **TRUE**, `Lock` вернет успешно, как только все объекты синхронизации сигнальное одновременно. Если `bWaitForAll` — **FALSE**, `Lock` вернет как только один или несколько объектов синхронизации сигнала.  
  
 Если `Lock` не сможет выполнять возврат немедленно, он будет ожидать не более указанного числа миллисекунд в *dwTimeOut* параметра перед возвратом. Если *dwTimeOut* — **БЕСКОНЕЧНЫЙ**, `Lock` не возвращается до получить доступ к объекту или условия, указанного в `dwWakeMask` было выполнено. В противном случае, если `Lock` был нельзя получить объект синхронизации, то возвращается успешно; в противном случае будет возвращена ошибка.  
  
##  <a name="unlock"></a>CMultiLock::Unlock  
 Освобождает объект синхронизации, принадлежащих `CMultiLock`.  
  
```  
BOOL Unlock();

 
BOOL Unlock(
    LONG lCount,  
    LPLONG lPrevCount = NULL);
```  
  
### <a name="parameters"></a>Параметры  
 `lCount`  
 Номер ссылки счетчики для выпуска. Должно быть больше 0. Если указанное приводит число объектов превышает максимальный, счетчик не изменяется, и функция возвращает **FALSE**.  
  
 `lPrevCount`  
 Указывает переменную, чтобы получить последнее значение счетчика для объекта синхронизации. Если **NULL**, последнее значение счетчика не возвращается.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если функция выполнена успешно; в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 Эта функция вызывается `CMultiLock`деструктор.  
  
 Первая форма `Unlock` пытается разблокировать объект синхронизации, который управляется `CMultiLock`. Во второй форме `Unlock` пытается разблокировать `CSemaphore` объектов, принадлежащих `CMultiLock`. Если `CMultiLock` не владеет заблокированные `CSemaphore` объекта, возвращаемого функцией **FALSE**; в противном случае он возвращает **TRUE**. `lCount`и `lpPrevCount` одинаковы, что и параметры [CSingleLock::Unlock](../../mfc/reference/csinglelock-class.md#unlock). Во второй форме `Unlock` редко применяется к multilock ситуациях.  
  
## <a name="see-also"></a>См. также  
 [Диаграмма иерархии](../../mfc/hierarchy-chart.md)



