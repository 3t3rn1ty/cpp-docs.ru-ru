---
title: "CDaoRecordset-класс | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-cpp
ms.tgt_pltfrm: 
ms.topic: reference
f1_keywords:
- CDaoRecordset
- AFXDAO/CDaoRecordset
- AFXDAO/CDaoRecordset::CDaoRecordset
- AFXDAO/CDaoRecordset::AddNew
- AFXDAO/CDaoRecordset::CanAppend
- AFXDAO/CDaoRecordset::CanBookmark
- AFXDAO/CDaoRecordset::CancelUpdate
- AFXDAO/CDaoRecordset::CanRestart
- AFXDAO/CDaoRecordset::CanScroll
- AFXDAO/CDaoRecordset::CanTransact
- AFXDAO/CDaoRecordset::CanUpdate
- AFXDAO/CDaoRecordset::Close
- AFXDAO/CDaoRecordset::Delete
- AFXDAO/CDaoRecordset::DoFieldExchange
- AFXDAO/CDaoRecordset::Edit
- AFXDAO/CDaoRecordset::FillCache
- AFXDAO/CDaoRecordset::Find
- AFXDAO/CDaoRecordset::FindFirst
- AFXDAO/CDaoRecordset::FindLast
- AFXDAO/CDaoRecordset::FindNext
- AFXDAO/CDaoRecordset::FindPrev
- AFXDAO/CDaoRecordset::GetAbsolutePosition
- AFXDAO/CDaoRecordset::GetBookmark
- AFXDAO/CDaoRecordset::GetCacheSize
- AFXDAO/CDaoRecordset::GetCacheStart
- AFXDAO/CDaoRecordset::GetCurrentIndex
- AFXDAO/CDaoRecordset::GetDateCreated
- AFXDAO/CDaoRecordset::GetDateLastUpdated
- AFXDAO/CDaoRecordset::GetDefaultDBName
- AFXDAO/CDaoRecordset::GetDefaultSQL
- AFXDAO/CDaoRecordset::GetEditMode
- AFXDAO/CDaoRecordset::GetFieldCount
- AFXDAO/CDaoRecordset::GetFieldInfo
- AFXDAO/CDaoRecordset::GetFieldValue
- AFXDAO/CDaoRecordset::GetIndexCount
- AFXDAO/CDaoRecordset::GetIndexInfo
- AFXDAO/CDaoRecordset::GetLastModifiedBookmark
- AFXDAO/CDaoRecordset::GetLockingMode
- AFXDAO/CDaoRecordset::GetName
- AFXDAO/CDaoRecordset::GetParamValue
- AFXDAO/CDaoRecordset::GetPercentPosition
- AFXDAO/CDaoRecordset::GetRecordCount
- AFXDAO/CDaoRecordset::GetSQL
- AFXDAO/CDaoRecordset::GetType
- AFXDAO/CDaoRecordset::GetValidationRule
- AFXDAO/CDaoRecordset::GetValidationText
- AFXDAO/CDaoRecordset::IsBOF
- AFXDAO/CDaoRecordset::IsDeleted
- AFXDAO/CDaoRecordset::IsEOF
- AFXDAO/CDaoRecordset::IsFieldDirty
- AFXDAO/CDaoRecordset::IsFieldNull
- AFXDAO/CDaoRecordset::IsFieldNullable
- AFXDAO/CDaoRecordset::IsOpen
- AFXDAO/CDaoRecordset::Move
- AFXDAO/CDaoRecordset::MoveFirst
- AFXDAO/CDaoRecordset::MoveLast
- AFXDAO/CDaoRecordset::MoveNext
- AFXDAO/CDaoRecordset::MovePrev
- AFXDAO/CDaoRecordset::Open
- AFXDAO/CDaoRecordset::Requery
- AFXDAO/CDaoRecordset::Seek
- AFXDAO/CDaoRecordset::SetAbsolutePosition
- AFXDAO/CDaoRecordset::SetBookmark
- AFXDAO/CDaoRecordset::SetCacheSize
- AFXDAO/CDaoRecordset::SetCacheStart
- AFXDAO/CDaoRecordset::SetCurrentIndex
- AFXDAO/CDaoRecordset::SetFieldDirty
- AFXDAO/CDaoRecordset::SetFieldNull
- AFXDAO/CDaoRecordset::SetFieldValue
- AFXDAO/CDaoRecordset::SetFieldValueNull
- AFXDAO/CDaoRecordset::SetLockingMode
- AFXDAO/CDaoRecordset::SetParamValue
- AFXDAO/CDaoRecordset::SetParamValueNull
- AFXDAO/CDaoRecordset::SetPercentPosition
- AFXDAO/CDaoRecordset::Update
- AFXDAO/CDaoRecordset::m_bCheckCacheForDirtyFields
- AFXDAO/CDaoRecordset::m_nFields
- AFXDAO/CDaoRecordset::m_nParams
- AFXDAO/CDaoRecordset::m_pDAORecordset
- AFXDAO/CDaoRecordset::m_pDatabase
- AFXDAO/CDaoRecordset::m_strFilter
- AFXDAO/CDaoRecordset::m_strSort
dev_langs:
- C++
helpviewer_keywords:
- recordsets, types
- CDaoRecordset class
- records, CDaoRecordSet
ms.assetid: 2322067f-1027-4662-a5d7-aa2fc7488630
caps.latest.revision: 26
author: mikeblome
ms.author: mblome
manager: ghogen
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
translationtype: Machine Translation
ms.sourcegitcommit: 0e0c08ddc57d437c51872b5186ae3fc983bb0199
ms.openlocfilehash: 3d3d830a7d423a2653819e9cbf160538e486cfb0
ms.lasthandoff: 02/24/2017

---
# <a name="cdaorecordset-class"></a>CDaoRecordset-класс
Представляет набор записей, выбранных из источника данных.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
class CDaoRecordset : public CObject  
```  
  
## <a name="members"></a>Члены  
  
### <a name="public-constructors"></a>Открытые конструкторы  
  
|Имя|Описание|  
|----------|-----------------|  
|[CDaoRecordset::CDaoRecordset](#cdaorecordset)|Создает объект `CDaoRecordset`.|  
  
### <a name="public-methods"></a>Открытые методы  
  
|Имя|Описание|  
|----------|-----------------|  
|[CDaoRecordset::AddNew](#addnew)|Подготавливает для добавления новой записи. Вызов [обновление](#update) для завершения добавления.|  
|[CDaoRecordset::CanAppend](#canappend)|Возвращает ненулевое значение, если можно добавить новые записи в набор записей через [AddNew](#addnew) функции-члена.|  
|[CDaoRecordset::CanBookmark](#canbookmark)|Возвращает ненулевое значение, если набор записей поддерживает закладки.|  
|[CDaoRecordset::CancelUpdate](#cancelupdate)|Отменяет все отложенные обновления из-за [изменить](#edit) или [AddNew](#addnew) операции.|  
|[CDaoRecordset::CanRestart](#canrestart)|Возвращает ненулевое значение, если [Requery](#requery) можно вызвать, чтобы снова выполнить запрос набора записей.|  
|[CDaoRecordset::CanScroll](#canscroll)|Возвращает ненулевое значение, если можно прокручивать записи.|  
|[CDaoRecordset::CanTransact](#cantransact)|Возвращает ненулевое значение, если источник данных поддерживает транзакции.|  
|[CDaoRecordset::CanUpdate](#canupdate)|Возвращает ненулевое значение, если можно обновить набор записей (можно добавить, обновить или удалить записи).|  
|[CDaoRecordset::Close](#close)|Закрытие набора записей.|  
|[CDaoRecordset::Delete](#delete)|Удаляет текущую запись из набора записей. Явным образом, необходимо перейти к другой записи после удаления.|  
|[CDaoRecordset::DoFieldExchange](#dofieldexchange)|Вызывается для обмена данными (в обоих направлениях) между элементами данных полей набора записей и соответствующей записи в источнике данных. Реализует DAO обмен полями записей (DFX).|  
|[CDaoRecordset::Edit](#edit)|Подготавливает для изменения текущей записи. Вызов **обновление** чтобы завершить редактирование.|  
|[CDaoRecordset::FillCache](#fillcache)|Заполняет все или часть локального кэша для объекта набора записей, содержащий данные из источника данных ODBC.|  
|[CDaoRecordset::Find](#find)|Находит первый, далее предыдущей, или последний расположение определенной строки в наборе записей, который удовлетворяет указанным критериям и делает записи текущей записи.|  
|[CDaoRecordset::FindFirst](#findfirst)|Находит первой записи в наборе или записей статического типа, который удовлетворяет указанным критериям и делает записи текущей записи.|  
|[CDaoRecordset::FindLast](#findlast)|Находит последнюю запись в наборе или записей статического типа, который удовлетворяет указанным критериям и делает записи текущей записи.|  
|[CDaoRecordset::FindNext](#findnext)|Находит следующую запись в наборе или записей статического типа, который удовлетворяет указанным критериям и делает записи текущей записи.|  
|[CDaoRecordset::FindPrev](#findprev)|Находит предыдущей записи в наборе или записей статического типа, который удовлетворяет указанным критериям и делает записи текущей записи.|  
|[CDaoRecordset::GetAbsolutePosition](#getabsoluteposition)|Возвращает номер текущей записи объекта набора записей.|  
|[CDaoRecordset::GetBookmark](#getbookmark)|Возвращает значение, представляющее закладку на запись.|  
|[CDaoRecordset::GetCacheSize](#getcachesize)|Возвращает значение, указывающее количество записей в наборе записей, содержащий данные локально кэшировать из источника данных ODBC.|  
|[CDaoRecordset::GetCacheStart](#getcachestart)|Возвращает значение, указывающее закладки первой записи в наборе записей должно кэшироваться.|  
|[CDaoRecordset::GetCurrentIndex](#getcurrentindex)|Возвращает `CString` содержащая имя индекса наиболее недавно используется для индексированного типа таблицы `CDaoRecordset`.|  
|[CDaoRecordset::GetDateCreated](#getdatecreated)|Возвращает дату и время базовой таблицы базового `CDaoRecordset` был создан объект|  
|[CDaoRecordset::GetDateLastUpdated](#getdatelastupdated)|Возвращает дату и время последнего изменения, внесенные в структуру базовой таблицы, расположенных `CDaoRecordset` объекта.|  
|[CDaoRecordset::GetDefaultDBName](#getdefaultdbname)|Возвращает имя источника данных по умолчанию.|  
|[CDaoRecordset::GetDefaultSQL](#getdefaultsql)|Вызывается, чтобы получить строку SQL по умолчанию для выполнения.|  
|[CDaoRecordset::GetEditMode](#geteditmode)|Возвращает значение, указывающее состояние редактирования для текущей записи.|  
|[CDaoRecordset::GetFieldCount](#getfieldcount)|Возвращает значение, представляющее число полей в наборе записей.|  
|[CDaoRecordset::GetFieldInfo](#getfieldinfo)|Возвращает определенные виды информации о поля в наборе записей.|  
|[CDaoRecordset::GetFieldValue](#getfieldvalue)|Возвращает значение поля в наборе записей.|  
|[CDaoRecordset::GetIndexCount](#getindexcount)|Получает количество индексов в таблице набора записей.|  
|[CDaoRecordset::GetIndexInfo](#getindexinfo)|Возвращает различные сведения об индексе.|  
|[CDaoRecordset::GetLastModifiedBookmark](#getlastmodifiedbookmark)|Используется для определения наиболее недавно добавленные или обновленные записи.|  
|[CDaoRecordset::GetLockingMode](#getlockingmode)|Возвращает значение, указывающее тип блокировки, которая действует во время редактирования.|  
|[CDaoRecordset::GetName](#getname)|Возвращает `CString` содержащее имя набора записей.|  
|[CDaoRecordset::GetParamValue](#getparamvalue)|Извлекает текущее значение указанного параметра в базовом объекте DAOParameter.|  
|[CDaoRecordset::GetPercentPosition](#getpercentposition)|Возвращает позицию текущей записи в процентах от общего количества записей.|  
|[CDaoRecordset::GetRecordCount](#getrecordcount)|Возвращает количество записей, доступных в объекте набора записей.|  
|[CDaoRecordset::GetSQL](#getsql)|Возвращает строку SQL, используемую для выбора записей для набора записей.|  
|[CDaoRecordset::GetType](#gettype)|Вызывается, чтобы определить тип набора записей: тип таблицы, добавляющий или статического типа.|  
|[CDaoRecordset::GetValidationRule](#getvalidationrule)|Возвращает `CString` содержащий значение, которое проверяет данные, вводимые в поле.|  
|[CDaoRecordset::GetValidationText](#getvalidationtext)|Получает текст, который отображается, если условие не удовлетворено.|  
|[CDaoRecordset::IsBOF](#isbof)|Возвращает ненулевое значение, если набор записей был был размещен перед первой записью. Отсутствует запись текущей.|  
|[CDaoRecordset::IsDeleted](#isdeleted)|Возвращает ненулевое значение, если набор записей располагается на удаленную запись.|  
|[CDaoRecordset::IsEOF](#iseof)|Возвращает ненулевое значение, если набор записей расположенных после последней записи. Отсутствует запись текущей.|  
|[CDaoRecordset::IsFieldDirty](#isfielddirty)|Возвращает ненулевое значение, если указанное поле в текущей записи был изменен.|  
|[CDaoRecordset::IsFieldNull](#isfieldnull)|Возвращает ненулевое значение, если указанное поле в текущей записи имеет значение Null (значение не наличие).|  
|[CDaoRecordset::IsFieldNullable](#isfieldnullable)|Возвращает ненулевое значение, если указанное поле в текущей записи может иметь значение Null (значение не наличие).|  
|[CDaoRecordset::IsOpen](#isopen)|Возвращает ненулевое значение, если [откройте](#open) был вызван ранее.|  
|[CDaoRecordset::Move](#move)|Устанавливает набор записей на указанное число записей от текущей записи в любом направлении.|  
|[CDaoRecordset::MoveFirst](#movefirst)|Помещает текущая запись на первой записи в наборе записей.|  
|[CDaoRecordset::MoveLast](#movelast)|Помещает текущей записи на последней записи в наборе записей.|  
|[CDaoRecordset::MoveNext](#movenext)|Помещает текущей записи к следующей записи в наборе записей.|  
|[CDaoRecordset::MovePrev](#moveprev)|Помещает текущая запись на предыдущие записи в наборе записей.|  
|[CDaoRecordset::Open](#open)|Создает новый набор записей из таблицы, динамический или статический.|  
|[CDaoRecordset::Requery](#requery)|Выполнение запроса набора записей еще раз, чтобы обновить выбранные записи.|  
|[CDaoRecordset::Seek](#seek)|Поиск записи в объект recordset индексированных таблицей, удовлетворяющий указанному условию для текущего индекса и делает записи текущей записи.|  
|[CDaoRecordset::SetAbsolutePosition](#setabsoluteposition)|Задает номер текущей записи объекта набора записей.|  
|[CDaoRecordset::SetBookmark](#setbookmark)|Устанавливает набор записей на запись, содержащую указанную закладку.|  
|[CDaoRecordset::SetCacheSize](#setcachesize)|Задает значение, указывающее количество записей в наборе записей, содержащий данные локально кэшировать из источника данных ODBC.|  
|[CDaoRecordset::SetCacheStart](#setcachestart)|Задает значение, указывающее закладки первой записи в наборе записей должно кэшироваться.|  
|[CDaoRecordset::SetCurrentIndex](#setcurrentindex)|Вызывается для задания индекса для объекта recordset типа таблицы.|  
|[CDaoRecordset::SetFieldDirty](#setfielddirty)|Помечает указанного поля в текущей записи, как измененный.|  
|[CDaoRecordset::SetFieldNull](#setfieldnull)|Задает значение указанного поля в текущей записи в значение Null (значение не наличие).|  
|[CDaoRecordset::SetFieldValue](#setfieldvalue)|Задает значение поля в наборе записей.|  
|[CDaoRecordset::SetFieldValueNull](#setfieldvaluenull)|Задает значение поля в наборе записей, значение Null. (наличие никакого значения).|  
|[CDaoRecordset::SetLockingMode](#setlockingmode)|Задает значение, указывающее тип блокировки, чтобы вступили в силу во время редактирования.|  
|[CDaoRecordset::SetParamValue](#setparamvalue)|Задает текущее значение указанного параметра в базовом объекте DAOParameter|  
|[CDaoRecordset::SetParamValueNull](#setparamvaluenull)|Задает текущее значение указанного параметра значение Null (значение не наличие).|  
|[CDaoRecordset::SetPercentPosition](#setpercentposition)|Задает позицию текущей записи в расположение, соответствующее значение в процентах от общего количества записей в наборе записей.|  
|[CDaoRecordset::Update](#update)|Завершает `AddNew` или **изменить** операции путем сохранения новых или измененных данных в источнике данных.|  
  
### <a name="public-data-members"></a>Открытые члены данных  
  
|Имя|Описание|  
|----------|-----------------|  
|[CDaoRecordset::m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields)|Содержит флаг, указывающий ли поля автоматически помечаются как измененный.|  
|[CDaoRecordset::m_nFields](#m_nfields)|Содержит количество элементов данных полей в классе записей и число столбцов, выбранных в набор записей из источника данных.|  
|[CDaoRecordset::m_nParams](#m_nparams)|Содержит количество элементов данных параметров в классе записей — количество параметров, передаваемый с запроса набора записей|  
|[CDaoRecordset::m_pDAORecordset](#m_pdaorecordset)|Указатель на интерфейс DAO базового объекта набора записей.|  
|[CDaoRecordset::m_pDatabase](#m_pdatabase)|Базы данных-источника для данного результирующего набора. Содержит указатель на [CDaoDatabase](../../mfc/reference/cdaodatabase-class.md) объекта.|  
|[CDaoRecordset::m_strFilter](#m_strfilter)|Содержит строку, используемую для создания SQL **ГДЕ** инструкции.|  
|[CDaoRecordset::m_strSort](#m_strsort)|Содержит строку, используемую для создания SQL **ORDER BY** инструкции.|  
  
## <a name="remarks"></a>Примечания  
 Известный как «наборы данных», `CDaoRecordset` объекты доступны в трех следующих форм:  
  
-   Наборы записей табличный тип представления базовой таблицы, можно использовать для проверки, добавления, изменения или удаления записей из одной таблицы базы данных.  
  
-   Наборы записей динамического типа являются результатом запроса, который может быть обновляемой записи. Эти наборы данных являются набор записей, которые можно использовать для проверки, добавления, изменения или удаления записей в базовой таблице или таблицах. Наборы записей динамического типа может содержать поля из одной или нескольких таблиц в базе данных.  
  
-   Записей типа снимка — это Статическая копия набора записей, которые можно использовать для поиска данных или создавать отчеты. Эти наборы данных могут содержать поля из одной или нескольких таблиц в базе данных, но не может быть обновлен.  
  
 Каждая форма набора записей представляет набор записей, фиксированных во время открытия набора записей. При прокрутке записи в набор записей табличный тип или тип динамический набор записей отражает изменения, внесенные в запись после открытия набора записей другими пользователями или другими наборами записей в приложении. (Не удается обновить набор записей статического типа.) Можно использовать `CDaoRecordset` непосредственно или создать производный класс набора записей для конкретного приложения из `CDaoRecordset`. После этого можно:  
  
-   Прокрутки записей.  
  
-   Значение индекса и быстро искать записи с помощью [Seek](#seek) (только в табличный тип записей).  
  
-   Найти записи на основании сравнения строк: «<",></",>\<=», «=», «настроек =», или «настроек» (динамический набор типов и записей типа снимка).  
  
-   Обновление записей и указать режим блокировки (за исключением записей типа снимка).  
  
-   Фильтрация записей для ограничения записей происходит выбор из доступных в источнике данных.  
  
-   Сортировка набора записей.  
  
-   Параметризация набора записей можно изменить выбранный для него сведения, которые неизвестны до времени выполнения.  
  
 Класс `CDaoRecordset` предоставляет интерфейс аналогичен класса `CRecordset`. Основное различие заключается в этом классе `CDaoRecordset` обращается к данным через доступ объект данным (DAO) основании OLE. Класс `CRecordset` обращается к СУБД через Open Database Connectivity (ODBC) и драйвер ODBC для этой СУБД.  
  
> [!NOTE]
>  Классы баз данных DAO отличаются от классов базы данных MFC на основе на Open Database Connectivity (ODBC). Все имена классов DAO базы данных имеют префикс «CDao». Вы можете по-прежнему обращаться к источникам данных ODBC с помощью классов DAO. классы DAO обычно предлагают превосходит возможности, поскольку они являются специфическими для базы данных Microsoft Jet.  
  
 Можно использовать либо `CDaoRecordset` напрямую или являются производными от класса `CDaoRecordset`. Чтобы использовать класс набора записей в любом случае, открыть базу данных и создайте объект набора записей, передав конструктору указатель на `CDaoDatabase` объект. Можно также создать `CDaoRecordset` объекта и позволяют создать временный MFC `CDaoDatabase` объект. Затем вызовите набора записей [откройте](#open) функция-член, указывающее, является ли объект recordset табличного типа, добавляющий записей или записей статического типа. Вызов **откройте** выбирает данные из базы данных и извлекает первую запись.  
  
 Член объекта функции и данные элементы используются для прокрутки записей и работать с ними. Доступные операции зависят от того, является ли объект recordset табличного типа, добавляющий записей или записей статического типа и является ли обновляться или только для чтения — это зависит от возможностей базы данных или источник данных Open Database Connectivity (ODBC). Для обновления записей, которые могут были изменены или добавлены с момента **откройте** вызова, вызывающие этот объект [Requery](#requery) функции-члена. Вызов объекта **закрыть** члена функции и уничтожить объект после завершения работы с его.  
  
 `CDaoRecordset`использует обмен полями записей DAO (DFX) для поддержки чтения и обновления поля записи через строго типизированные члены C++ вашей `CDaoRecordset` или `CDaoRecordset`-производного класса. Также можно реализовать динамическая привязка столбцов в базе данных без использования механизма DFX с помощью [GetFieldValue](#getfieldvalue) и [SetFieldValue](#setfieldvalue).  
  
 Дополнительные сведения см. в разделе «Объект набора записей» в справке DAO.  
  
## <a name="inheritance-hierarchy"></a>Иерархия наследования  
 [CObject](../../mfc/reference/cobject-class.md)  
  
 `CDaoRecordset`  
  
## <a name="requirements"></a>Требования  
 **Заголовок:** afxdao.h  
  
##  <a name="addnew"></a>CDaoRecordset::AddNew  
 Вызовите эту функцию-член для добавления новой записи в таблице типа или динамический набор записей.  
  
```  
virtual void AddNew();
```  
  
### <a name="remarks"></a>Примечания  
 Поля записи первоначально равно Null. (В терминологии связанных баз данных, значение Null означает «значение не установку» и не совпадает с **NULL** в C++.) Чтобы завершить операцию, необходимо вызвать [обновление](#update) функции-члена. **Обновление** сохраняет изменения в источнике данных.  
  
> [!CAUTION]
>  Если изменить запись, а затем перейти к другой записи без вызова **обновление**, изменения будут утеряны без предупреждения.  
  
 При добавлении записи в наборе записей путем вызова [AddNew](#addnew), запись является видимым в наборе записей и включается в базовой таблице, где оно становится видимым для любого новые `CDaoRecordset` объектов.  
  
 Положение новой записи зависит от типа набора записей  
  
-   В наборе записей, будет вставлена новая запись не гарантируется. Это поведение изменяется с Microsoft Jet 3.0 из соображений производительности и параллелизма. Если ваша цель — сделать вновь добавленной записи текущей, получить закладки последней измененной записи и перейти в эту закладку:  
  
 [!code-cpp[NVC_MFCDatabase&#1;](../../mfc/codesnippet/cpp/cdaorecordset-class_1.cpp)]  
  
-   В табличный тип записей, для которого указан индекс возвращаются записи в их местом в порядке сортировки. Если указано без индекса, новые записи возвращаются в конце набора записей.  
  
 Запись, которая была текущей до использования `AddNew` остаются актуальными. Если вы хотите сделать текущим новой записи и набор записей поддерживает закладок, вызов [SetBookmark](#setbookmark) закладку, определяемого параметром свойство LastModified базового объекта набора записей DAO. Это полезно для определения значения для полей счетчика (с автоматическим приращением) в добавленной записи. Дополнительные сведения см. в разделе [GetLastModifiedBookmark](#getlastmodifiedbookmark).  
  
 Если база данных поддерживает транзакции, можно сделать ваш `AddNew` вызовов, часть транзакции. Дополнительные сведения о транзакциях см. класс [CDaoWorkspace](../../mfc/reference/cdaoworkspace-class.md). Обратите внимание, что следует вызывать [CDaoWorkspace::BeginTrans](../../mfc/reference/cdaoworkspace-class.md#begintrans) перед вызовом метода `AddNew`.  
  
 Недопустимо для вызова `AddNew` для объекта recordset, [откройте](#open) функции-члена не был вызван. Объект `CDaoException` возникает при вызове метода `AddNew` для набора записей, который не может быть добавлен. Можно определить, является ли набор записей обновляемым путем вызова [CanAppend](#canappend).  
  
 Метки framework изменить поля элементов данных, чтобы убедиться, что они будут записаны записи в источнике данных с помощью механизма обмена (DFX) полями записей DAO. Как правило, изменение значения поля задает поле «грязные» автоматически, поэтому редко нужно вызывать [SetFieldDirty](#setfielddirty) самостоятельно, но иногда может потребоваться убедитесь, что столбцы будут будут явно обновлены или вставлены независимо от того, какое значение члена данных поля. Механизм DFX также используются использование **ПСЕВДО NULL**. Дополнительные сведения см. в разделе [CDaoFieldExchange::m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).  
  
 Если не используется механизм двойную буферизацию, изменив значение поля не задаются автоматически поля как «грязный». В этом случае будет необходимо явно задать в поле «грязные». Флаг, содержащихся в [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) управляет этого поля автоматической проверки.  
  
> [!NOTE]
>  Если есть записи, двойной буферизации (то есть поле автоматического включена проверка), вызов `CancelUpdate` восстанавливаются значения, которые они имели до переменные-члены, `AddNew` или **изменить** был вызван.  
  
 Дополнительные сведения см. в разделах «Метод AddNew», «Метод CancelUpdate», «Свойство LastModified» и «EditMode свойство» в справке DAO.  
  
##  <a name="canappend"></a>CDaoRecordset::CanAppend  
 Вызов этой функции-члена для определения ли ранее открытые записей позволяет добавлять новые записи путем вызова [AddNew](#addnew) функции-члена.  
  
```  
BOOL CanAppend() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если набор записей разрешает добавление новых записей; в противном случае — 0. `CanAppend`Возвращает 0 при открытии набора записей, только для чтения.  
  
### <a name="remarks"></a>Примечания  
 Дополнительные сведения см. в разделе «Добавить метод» в справке DAO.  
  
##  <a name="canbookmark"></a>CDaoRecordset::CanBookmark  
 Вызовите эту функцию-член для определения ли ранее открытые записей позволяет отдельно пометить записей с помощью закладок.  
  
```  
BOOL CanBookmark();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если набор записей поддерживает закладки, в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 При использовании наборов записей, целиком основанные на таблицах ядра базы данных Microsoft Jet, можно использовать закладки за исключением на помечены как наборы записей последовательного доступа прокрутки записей типа снимка. Другие продукты баз данных (внешние источники данных ODBC) могут не поддерживать закладки.  
  
 Дополнительные сведения см. в разделе «Свойство Bookmarkable» в справке DAO.  
  
##  <a name="cancelupdate"></a>CDaoRecordset::CancelUpdate  
 `CancelUpdate` Функция-член отменяет все отложенные обновления из-за [изменить](#edit) или [AddNew](#addnew) операции.  
  
```  
virtual void CancelUpdate();
```  
  
### <a name="remarks"></a>Примечания  
 Например, если приложение вызывает **изменить** или `AddNew` функции-члена и не вызван [обновление](#update), `CancelUpdate` отменяет любые изменения, внесенные после **изменить** или `AddNew` был вызван.  
  
> [!NOTE]
>  Если есть записи, двойной буферизации (то есть поле автоматического включена проверка), вызов `CancelUpdate` восстанавливаются значения, которые они имели до переменные-члены, `AddNew` или **изменить** был вызван.  
  
 Если не **изменить** или `AddNew` операцию ожидания, `CancelUpdate` вызывает MFC для создания исключения. Вызов [GetEditMode](#geteditmode) функции-члена определить операцию в очереди, которое может быть отменено.  
  
 Дополнительные сведения см. в разделе «Метод CancelUpdate» в справке DAO.  
  
##  <a name="canrestart"></a>CDaoRecordset::CanRestart  
 Вызовите эту функцию-член для определения того, допускает ли набор записей перезапуск его запроса (чтобы обновить свои записи) путем вызова **Requery** функции-члена.  
  
```  
BOOL CanRestart();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если **Requery** может быть вызван для запуска набора записей запрос повторно, в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 Наборы записей типа таблицы не поддерживают **Requery**.  
  
 Если **Requery** — не поддерживается вызов [закрыть](#close) затем [откройте](#open) обновления данных. Можно вызвать **Requery** обновление объекта набора записей основного запроса параметров после изменения значения параметра.  
  
 Дополнительные сведения см. в разделе «Свойство возобновляемой» в справке DAO.  
  
##  <a name="canscroll"></a>CDaoRecordset::CanScroll  
 Вызовите эту функцию-член, чтобы определить, допускает ли прокрутка набора записей.  
  
```  
BOOL CanScroll() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, при прокрутке записей, в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 При вызове метода [откройте](#open) с **dbForwardOnly**, набор записей только прокручиваться вперед.  
  
 Дополнительные сведения см. в разделе «Позиционирования текущей записи указатель с DAO» в справке DAO.  
  
##  <a name="cantransact"></a>CDaoRecordset::CanTransact  
 Вызовите эту функцию-член, чтобы определить, допускает ли набор записей транзакций.  
  
```  
BOOL CanTransact();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если базовый источник данных поддерживает транзакции, в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 Дополнительные сведения см. в разделе «Свойство транзакции» в справке DAO.  
  
##  <a name="canupdate"></a>CDaoRecordset::CanUpdate  
 Вызовите эту функцию-член для определения, можно ли обновить набор записей.  
  
```  
BOOL CanUpdate() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если можно обновить набор записей (Добавление, обновление и удаление записей), в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 Набор записей может быть только для чтения, если базовый источник данных доступен только для чтения, или при указании **dbReadOnly** для `nOptions` при вызове [откройте](#open) для набора записей.  
  
 Дополнительные сведения см. в разделах «Метод AddNew», «Изменить метод», «Метод Delete», «Метод Update» и «Обновляемые свойства» в справке DAO.  
  
##  <a name="cdaorecordset"></a>CDaoRecordset::CDaoRecordset  
 Создает объект `CDaoRecordset`.  
  
```  
CDaoRecordset(CDaoDatabase* pDatabase = NULL);
```  
  
### <a name="parameters"></a>Параметры  
 `pDatabase`  
 Содержит указатель на [CDaoDatabase](../../mfc/reference/cdaodatabase-class.md) объект или значение **NULL**. Если не **NULL** и `CDaoDatabase` объекта **откройте** функции-члена не был вызван соединиться с источником данных, набор записей попытается ее открыть автоматически во время свой собственный [откройте](#open) вызова. Если передать **NULL**, `CDaoDatabase` объект создается и подключение с использованием указанного Если производного класса набора записей из источника данных `CDaoRecordset`.  
  
### <a name="remarks"></a>Примечания  
 Можно использовать либо `CDaoRecordset` напрямую или являются производными от приложения класса из `CDaoRecordset`. ClassWizard можно использовать для формирования классов набора записей.  
  
> [!NOTE]
>  При наследовании `CDaoRecordset` класс, производный класс должен предоставить собственный конструктор. В конструкторе производного класса, вызовите конструктор `CDaoRecordset::CDaoRecordset`, передавая ему соответствующие параметры вместе.  
  
 Передайте **NULL** конструктор набора записей для `CDaoDatabase` объект создается и автоматически подключены для вас. Это удобно, не требует создания и подключения `CDaoDatabase` объекта до создания набора записей. Если `CDaoDatabase` объектов не открыт, [CDaoWorkspace](../../mfc/reference/cdaoworkspace-class.md) также создается объект, использует рабочей области по умолчанию. Дополнительные сведения см. в разделе [CDaoDatabase::CDaoDatabase](../../mfc/reference/cdaodatabase-class.md#cdaodatabase).  
  
##  <a name="close"></a>CDaoRecordset::Close  
 Закрытие `CDaoRecordset` объекта он удаляется из коллекции открытых наборов записей в соответствующей базе данных.  
  
```  
virtual void Close();
```  
  
### <a name="remarks"></a>Примечания  
 Поскольку **закрыть** не разрушает `CDaoRecordset` объекта, повторного использования объекта путем вызова **откройте** на тот же источник данных или другого источника данных.  
  
 Все ожидающие [AddNew](#addnew) или [изменить](#edit) отменяются и все незавершенные транзакции выполняется откат. Если вы хотите сохранить отложенные дополнений или изменений, вызвать [обновление](#update) перед вызовом метода **закрыть** для каждого набора записей.  
  
 Можно вызвать **откройте** снова после вызова метода **закрыть**. Это позволяет повторно использовать объект набора записей. Лучшим вариантом будет вызывать [Requery](#requery), если это возможно.  
  
 Дополнительные сведения см. в разделе «Метод Close» в справке DAO.  
  
##  <a name="delete"></a>CDaoRecordset::Delete  
 Вызовите эту функцию-член для удаления текущей записи в открытом объекте набора записей динамического или тип таблицы.  
  
```  
virtual void Delete();
```  
  
### <a name="remarks"></a>Примечания  
 После успешного удаления, элементам данных полей устанавливаются в значение Null, и необходимо явно вызвать один из функции-члены навигации набора записей ( [перемещение](#move), [Seek](#seek), [SetBookmark](#setbookmark)и так далее) для удаления удаленные записи. При удалении записей из набора записей должен существовать текущей записи в наборе записей перед вызовом метода **удаление**; в противном случае — MFC создает исключение.  
  
 **Удалить** удаляет текущую запись и делает ее недоступной. Несмотря на то, что нельзя изменять или использовать удаленную запись, остаются актуальными. Как только вы перейдете к другой записи, однако нельзя создать удаленную запись текущего снова.  
  
> [!CAUTION]
>  Набор записей должен являться обновляемым и должен существовать допустимой записи текущего набора записей при вызове **удаление**. Например, если удалить запись, но не прокручиваются новой записи перед вызовом метода **удалить** , **удаление** вызывает [CDaoException](../../mfc/reference/cdaoexception-class.md).  
  
 Отменить удаление записи при использовании транзакций и вызове [CDaoWorkspace::Rollback](../../mfc/reference/cdaoworkspace-class.md#rollback) функции-члена. Если базовая таблица является главной таблицей каскадом удалить связь, текущая запись может также при удалении одной или нескольких записей во внешней таблице. Дополнительные сведения см. в справке DAO определение «каскадное удаление».  
  
 В отличие от `AddNew` и **изменить**, вызов **удаление** не следуют вызов **обновление**.  
  
 Дополнительные сведения см. в разделах «Метод AddNew», «Изменить метод», «Метод Delete», «Метод Update» и «Обновляемые свойства» в справке DAO.  
  
##  <a name="dofieldexchange"></a>CDaoRecordset::DoFieldExchange  
 Платформа вызывает эту функцию-член автоматически обмен данными между элементами данных полей объекта набора записей и соответствующих столбцов текущей записи в источнике данных.  
  
```  
virtual void DoFieldExchange(CDaoFieldExchange* pFX);
```  
  
### <a name="parameters"></a>Параметры  
 `pFX`  
 Содержит указатель на `CDaoFieldExchange` объект. Платформа будет уже значение этого объекта для указания контекста для работы exchange поля.  
  
### <a name="remarks"></a>Примечания  
 Также привязывает параметризованные члены данных, если таковые имеются, с местозаполнителями параметров в строке инструкции SQL для выбора набора записей. Обмен данными полей, называется обмен полями записей DAO (DFX) работает в обоих направлениях: от элементов данных полей объекта набора записей в поля записи в источнике данных и записи в источнике данных в объект набора записей. Если динамическая привязка столбцов необходимых для реализации `DoFieldExchange`.  
  
 Только действие, обычно необходимо выполнить для реализации `DoFieldExchange` для набора записей производный класс является создание класса с помощью классов и укажите имена и типы данных элементов данных полей. Можно также добавить код для классов записывает для указания элементов данных параметров. Все поля, динамически связанной эта функция будет неактивна, если не указан параметр члены данных.  
  
 При объявлении класса производного набора записей с помощью классов, мастер создает переопределение метода `DoFieldExchange` , который напоминает приведенный ниже:  
  
 [!code-cpp[NVC_MFCDatabase&#2;](../../mfc/codesnippet/cpp/cdaorecordset-class_2.cpp)]  
  
##  <a name="edit"></a>CDaoRecordset::Edit  
 Вызовите эту функцию-член можно разрешить изменение текущей записи.  
  
```  
virtual void Edit();
```  
  
### <a name="remarks"></a>Примечания  
 При вызове метода **изменить** функция-член, изменения, внесенные в поля текущей записи, копируются в буфер копирования. После внесения необходимых изменений к записи, вызов **обновление** для сохранения изменений. **Изменить** сохраняет значения членов данных набора записей. При вызове метода **изменить**, внесите изменения, затем вызовите **изменить** , восстанавливаются значения записи он находился перед первым **изменить** вызова.  
  
> [!CAUTION]
>  Если изменить запись и затем выполнять любые операции, переходит к другой записи без предварительного вызова функции **обновление**, изменения будут утеряны без предупреждения. Кроме того при закрытии родительской базы данных или набора записей на измененной записи удаляются без предупреждения.  
  
 В некоторых случаях может потребоваться обновить столбец, делая Null (содержащий нет данных). Для этого нужно вызвать `SetFieldNull` с параметром **TRUE** пометить поле Null; это также вызовет обновляемого столбца. Если необходимо добавить поле к записи в источнике данных, несмотря на то, что его значение не изменилось, вызовите метод `SetFieldDirty` с параметром **TRUE**. Это работает, даже если оно имело значение Null.  
  
 Метки framework изменить поля элементов данных, чтобы убедиться, что они будут записаны записи в источнике данных с помощью механизма обмена (DFX) полями записей DAO. Как правило, изменение значения поля задает поле «грязные» автоматически, поэтому редко нужно вызывать [SetFieldDirty](#setfielddirty) самостоятельно, но иногда может потребоваться убедитесь, что столбцы будут будут явно обновлены или вставлены независимо от того, какое значение члена данных поля. Механизм DFX также используются использование **ПСЕВДО NULL**. Дополнительные сведения см. в разделе [CDaoFieldExchange::m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).  
  
 Если не используется механизм двойную буферизацию, изменив значение поля не задаются автоматически поля как «грязный». В этом случае будет необходимо явно задать в поле «грязные». Флаг, содержащихся в [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) управляет этого поля автоматической проверки.  
  
 Объект recordset, заблокированной pessimistically в многопользовательской среде, запись остается заблокированным от времени **изменить** используется до завершения обновления. Если набор записей оптимистически заблокирован, запись заблокирована и по сравнению с предварительно измененной записи непосредственно перед его обновлением базы данных. Если запись была изменена с момента вызова **изменить**, **обновление** завершается с ошибкой и MFC создает исключение. Можно изменить режим блокировки с `SetLockingMode`.  
  
> [!NOTE]
>  Для внешней базы данных форматов, таких как ODBC и устанавливаемый ISAM всегда используется оптимистическая блокировка.  
  
 Текущая запись остаются актуальными, после вызова метода **изменить**. Для вызова **изменить**, должно быть текущей записи. Если текущая запись или набор записей не ссылаться на открытые таблицей или динамического типа объекта набора записей, возникает исключение. Вызов **изменить** вызывает `CDaoException` исключение при следующих условиях:  
  
-   Отсутствует запись текущей.  
  
-   Базы данных или набора записей доступен только для чтения.  
  
-   Поля в записи не являются обновляемыми.  
  
-   База данных или набор записей был открыт для монопольного использования другим пользователем.  
  
-   Другой пользователь уже заблокировал страницы, содержащей записи.  
  
 Если источник данных поддерживает транзакции, можно сделать **изменить** вызовов, часть транзакции. Обратите внимание, что следует вызывать `CDaoWorkspace::BeginTrans` перед вызовом метода **изменить** и после открытия набора записей. Также Обратите внимание, что вызов `CDaoWorkspace::CommitTrans` не является заменой вызова **обновление** для завершения **изменить** операции. Дополнительные сведения о транзакциях см. класс `CDaoWorkspace`.  
  
 Дополнительные сведения см. в разделах «Метод AddNew», «Изменить метод», «Метод Delete», «Метод Update» и «Обновляемые свойства» в справке DAO.  
  
##  <a name="fillcache"></a>CDaoRecordset::FillCache  
 Вызовите эту функцию-член для кэширования указанное число записей из набора записей.  
  
```  
void FillCache(
    long* pSize = NULL,  
    COleVariant* pBookmark = NULL);
```  
  
### <a name="parameters"></a>Параметры  
 `pSize`  
 Указывает количество строк для заполнения кэша. Если этот параметр не указан, значение определяется значение свойства CacheSize базового объекта DAO.  
  
 `pBookmark`  
 Объект [COleVariant](../../mfc/reference/colevariant-class.md) указания закладки. Кэш заполняется, начиная с записи, обозначенными эту закладку. Если этот параметр опущен, кэш заполняется, начиная с записи, указанного в свойстве CacheStart базового объекта DAO.  
  
### <a name="remarks"></a>Примечания  
 Кэширование повышает производительность приложения, который извлекает или извлекает данные с удаленного сервера. Кэш, место в локальной памяти, который содержит данные, недавно полученные от сервера на предположении, что данные будут, вероятно, повторно запрошен во время выполнения приложения. При запросе данных базы данных Microsoft Jet сначала проверяет кэш для данных вместо его извлечение из на сервер, который занимает больше времени. С помощью кэширования данных на источники данных не ODBC действует как данные не сохраняются в кэше.  
  
 Дожидаться кэша должно быть подставлено записей, как они не будут выбраны, можно явно заполнить кэш в любое время путем вызова `FillCache` функции-члена. Это более быстрый способ заполнения кэша, поскольку `FillCache` извлекает несколько записей одновременно, вместо одной записи за раз. Например, во время отображения каждого экранной записей, может иметь свой вызов приложения `FillCache` для выборки следующего экранной записей.  
  
 Все базы данных ODBC с помощью объектов набора записей может иметь локальный кэш. Чтобы создать кэш, откройте объект набора записей из удаленного источника данных и затем вызвать `SetCacheSize` и `SetCacheStart` функций-членов набора записей. Если `lSize` и *lBookmark* создать диапазон, который находится за пределами диапазона, указанного в частично или полностью `SetCacheSize` и `SetCacheStart`, часть набора записей за пределами этого диапазона игнорируется и не загружается в кэш. Если `FillCache` запросы записей больше, чем остаются в удаленный источник данных, будут выбраны только оставшихся записей и исключение не возникает.  
  
 Записей, полученных из кэша не отражают изменений, внесенных одновременно с источником данных другим пользователям.  
  
 `FillCache`извлекает только те записи, которые еще не кэшируются. Чтобы принудительно обновить кэшированные данные, вызовите `SetCacheSize` функция-член с `lSize` параметра равно 0, вызов `SetCacheSize` с `lSize` параметра равно размер кэша первоначально запрошенную, а затем вызвать `FillCache`.  
  
 Дополнительные сведения см. в разделе «Метод FillCache» в справке DAO.  
  
##  <a name="find"></a>CDaoRecordset::Find  
 Вызовите эту функцию-член для обнаружения определенной строки в наборе записей типа динамических подмножеств данных и моментальных снимков с помощью оператора сравнения.  
  
```  
virtual BOOL Find(
    long lFindType,  
    LPCTSTR lpszFilter);
```  
  
### <a name="parameters"></a>Параметры  
 *lFindType*  
 Значение, указывающее тип требуемой операции поиска. Допустимые значения:  
  
- **AFX_DAO_NEXT** местоположения следующего совпадения.  
  
- **AFX_DAO_PREV** местоположения предыдущего совпадения.  
  
- **AFX_DAO_FIRST** найти первое расположение совпадения.  
  
- **AFX_DAO_LAST** местоположения последнего совпадения.  
  
 `lpszFilter`  
 Строковое выражение (как **ГДЕ** предложение в инструкцию SQL без слова **ГДЕ**) используется для поиска записи. Пример:  
  
 [!code-cpp[NVC_MFCDatabase&#3;](../../mfc/codesnippet/cpp/cdaorecordset-class_3.cpp)]  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если Обнаружены совпадающие записи, в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 Во-первых, Далее можно найти экземпляр предыдущего или последней строки. **Найти** является виртуальной функции, поэтому можно переопределить это поведение и добавить свою собственную реализацию. `FindFirst`, `FindLast`, `FindNext`, И `FindPrev` вызова функции-члены **найти** функция-член, чтобы можно было использовать **найти** для управления поведением всех операций поиска.  
  
 Чтобы найти запись в наборе записей, тип таблицы, вызовите [Seek](#seek) функции-члена.  
  
> [!TIP]
>  Меньший набор записей, у вас есть, тем она эффективнее **найти** будет. В целом и особенно данных ODBC лучше создать новый запрос, который извлекает необходимые записи.  
  
 Дополнительные сведения см. в разделе «FindNext FindFirst, FindLast, FindPrevious методы» в справке DAO.  
  
##  <a name="findfirst"></a>CDaoRecordset::FindFirst  
 Вызовите эту функцию-член для поиска первой записи, которая соответствует заданному условию.  
  
```  
BOOL FindFirst(LPCTSTR lpszFilter);
```  
  
### <a name="parameters"></a>Параметры  
 `lpszFilter`  
 Строковое выражение (как **ГДЕ** предложение в инструкцию SQL без слова **ГДЕ**) используется для поиска записи.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если Обнаружены совпадающие записи, в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 `FindFirst` Функция-член начинает поиск с начала набора записей и продолжается до конца набора данных.  
  
 Если требуется включить все записи в поиске (не только те, которые удовлетворяют определенному условию) используют одну из операций перемещения для перемещения по записям. Чтобы найти запись в наборе записей, тип таблицы, вызовите `Seek` функции-члена.  
  
 Не определено, если расположенный не на записи, соответствующие критерию, указатель текущей записи и `FindFirst` возвращает ноль. Если набор записей содержит более одной записи, которые удовлетворяют критериям, `FindFirst` находит первое вхождение `FindNext` находит следующее вхождение и т. д.  
  
> [!CAUTION]
>  При изменении текущей записи, не забудьте сохранить изменения, вызвав **обновление** функция-член, прежде чем перейти к другой записи. При переходе к другой записи без обновления, внесенные изменения будут потеряны без предупреждения.  
  
 **Найти** поиска функции-члены из расположения и в направлении, указанным в следующей таблице:  
  
|Найти операции|Begin|Направление поиска|  
|---------------------|-----------|----------------------|  
|`FindFirst`|Начало набора записей|Конец набора записей|  
|`FindLast`|Конец набора записей|Начало набора записей|  
|`FindNext`|Текущая запись|Конец набора записей|  
|**FindPrevious**|Текущая запись|Начало набора записей|  
  
> [!NOTE]
>  При вызове метода `FindLast`, ядро базы данных Microsoft Jet полностью заполняет набор записей до начала поиска, если это еще не было сделано. Первый поиск может занять больше времени, чем последующие поиска.  
  
 С помощью одного из операции поиска не является таким же, как вызов метода **MoveFirst** или `MoveNext`, тем не менее, который просто делает первой или следующей записи текущего без указания условие. Можно выполнить операцию поиска с помощью операции перемещения.  
  
 При использовании операции поиска необходимо учитывайте следующее:  
  
-   Если **найти** возвращает ненулевое значение, текущая запись не определен. В этом случае необходимо поместить указатель текущей записи к допустимой записи.  
  
-   Нельзя использовать операцию поиска с прокруткой статического типа данных последовательного доступа.  
  
-   Американский формат даты (месяц день год) следует использовать при поиске полей, содержащих даты, даже если американская версия ядра базы данных Microsoft Jet, не используются в противном случае — подходящие записи может быть не найдена.  
  
-   При работе с базами данных ODBC и больших динамических подмножеств данных, может оказаться, что с помощью операции поиска работает медленно, особенно при работе с большой наборы записей. Можно повысить производительность с помощью SQL-запросов с настроен **ORDERBY** или **ГДЕ** предложений, запросы с параметрами, или **CDaoQuerydef** объекты, получающие индексированных записей.  
  
 Дополнительные сведения см. в разделе «FindNext FindFirst, FindLast, FindPrevious методы» в справке DAO.  
  
##  <a name="findlast"></a>CDaoRecordset::FindLast  
 Вызовите эту функцию-член, чтобы найти последнюю запись, которая соответствует заданному условию.  
  
```  
BOOL FindLast(LPCTSTR lpszFilter);
```  
  
### <a name="parameters"></a>Параметры  
 `lpszFilter`  
 Строковое выражение (как **ГДЕ** предложение в инструкцию SQL без слова **ГДЕ**) используется для поиска записи.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если Обнаружены совпадающие записи, в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 `FindLast` Функция-член начинает поиск с конца набора данных и выполняет поиск назад к началу набора записей.  
  
 Если требуется включить все записи в поиске (не только те, которые удовлетворяют определенному условию) используют одну из операций перемещения для перемещения по записям. Чтобы найти запись в наборе записей, тип таблицы, вызовите `Seek` функции-члена.  
  
 Не определено, если расположенный не на записи, соответствующие критерию, указатель текущей записи и `FindLast` возвращает ноль. Если набор записей содержит более одной записи, которые удовлетворяют критериям, `FindFirst` находит первое вхождение `FindNext` находит следующее вхождение после первого вхождения и т. д.  
  
> [!CAUTION]
>  При изменении текущей записи, нужно убедиться, что сохранить изменения, вызвав **обновление** функция-член, прежде чем перейти к другой записи. При переходе к другой записи без обновления, внесенные изменения будут потеряны без предупреждения.  
  
 С помощью одного из операции поиска не является таким же, как вызов метода **MoveFirst** или `MoveNext`, тем не менее, который просто делает первой или следующей записи текущего без указания условие. Можно выполнить операцию поиска с помощью операции перемещения.  
  
 При использовании операции поиска необходимо учитывайте следующее:  
  
-   Если **найти** возвращает ненулевое значение, текущая запись не определен. В этом случае необходимо поместить указатель текущей записи к допустимой записи.  
  
-   Нельзя использовать операцию поиска с прокруткой статического типа данных последовательного доступа.  
  
-   Американский формат даты (месяц день год) следует использовать при поиске полей, содержащих даты, даже если американская версия ядра базы данных Microsoft Jet, не используются в противном случае — подходящие записи может быть не найдена.  
  
-   При работе с базами данных ODBC и больших динамических подмножеств данных, может оказаться, что с помощью операции поиска работает медленно, особенно при работе с большой наборы записей. Можно повысить производительность с помощью SQL-запросов с настроен **ORDERBY** или **ГДЕ** предложений, запросы с параметрами, или **CDaoQuerydef** объекты, получающие индексированных записей.  
  
 Дополнительные сведения см. в разделе «FindNext FindFirst, FindLast, FindPrevious методы» в справке DAO.  
  
##  <a name="findnext"></a>CDaoRecordset::FindNext  
 Вызовите эту функцию-член для следующей записи, который соответствует заданному условию поиска.  
  
```  
BOOL FindNext(LPCTSTR lpszFilter);
```  
  
### <a name="parameters"></a>Параметры  
 `lpszFilter`  
 Строковое выражение (как **ГДЕ** предложение в инструкцию SQL без слова **ГДЕ**) используется для поиска записи.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если Обнаружены совпадающие записи, в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 `FindNext` Функция-член начинает поиск с текущей записи и ищет в конец набора записей.  
  
 Если требуется включить все записи в поиске (не только те, которые удовлетворяют определенному условию) используют одну из операций перемещения для перемещения по записям. Чтобы найти запись в наборе записей, тип таблицы, вызовите `Seek` функции-члена.  
  
 Не определено, если расположенный не на записи, соответствующие критерию, указатель текущей записи и `FindNext` возвращает ноль. Если набор записей содержит более одной записи, которые удовлетворяют критериям, `FindFirst` находит первое вхождение `FindNext` находит следующее вхождение и т. д.  
  
> [!CAUTION]
>  При изменении текущей записи, нужно убедиться, что сохранить изменения, вызвав **обновление** функция-член, прежде чем перейти к другой записи. При переходе к другой записи без обновления, внесенные изменения будут потеряны без предупреждения.  
  
 С помощью одного из операции поиска не является таким же, как вызов метода **MoveFirst** или `MoveNext`, тем не менее, который просто делает первой или следующей записи текущего без указания условие. Можно выполнить операцию поиска с помощью операции перемещения.  
  
 При использовании операции поиска необходимо учитывайте следующее:  
  
-   Если **найти** возвращает ненулевое значение, текущая запись не определен. В этом случае необходимо поместить указатель текущей записи к допустимой записи.  
  
-   Нельзя использовать операцию поиска с прокруткой статического типа данных последовательного доступа.  
  
-   Американский формат даты (месяц день год) следует использовать при поиске полей, содержащих даты, даже если американская версия ядра базы данных Microsoft Jet, не используются в противном случае — подходящие записи может быть не найдена.  
  
-   При работе с базами данных ODBC и больших динамических подмножеств данных, может оказаться, что с помощью операции поиска работает медленно, особенно при работе с большой наборы записей. Можно повысить производительность с помощью SQL-запросов с настроен **ORDERBY** или **ГДЕ** предложений, запросы с параметрами, или **CDaoQuerydef** объекты, получающие индексированных записей.  
  
 Дополнительные сведения см. в разделе «FindNext FindFirst, FindLast, FindPrevious методы» в справке DAO.  
  
##  <a name="findprev"></a>CDaoRecordset::FindPrev  
 Вызовите эту функцию-член для поиска предыдущей записи, который соответствует заданному условию.  
  
```  
BOOL FindPrev(LPCTSTR lpszFilter);
```  
  
### <a name="parameters"></a>Параметры  
 `lpszFilter`  
 Строковое выражение (как **ГДЕ** предложение в инструкцию SQL без слова **ГДЕ**) используется для поиска записи.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если Обнаружены совпадающие записи, в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 `FindPrev` Функция-член начинает поиск с текущей записи и ищет в обратном направлении к началу набора записей.  
  
 Если требуется включить все записи в поиске (не только те, которые удовлетворяют определенному условию) используют одну из операций перемещения для перемещения по записям. Чтобы найти запись в наборе записей, тип таблицы, вызовите `Seek` функции-члена.  
  
 Не определено, если расположенный не на записи, соответствующие критерию, указатель текущей записи и `FindPrev` возвращает ноль. Если набор записей содержит более одной записи, которые удовлетворяют критериям, `FindFirst` находит первое вхождение `FindNext` находит следующее вхождение и т. д.  
  
> [!CAUTION]
>  При изменении текущей записи, нужно убедиться, что сохранить изменения, вызвав **обновление** функция-член, прежде чем перейти к другой записи. При переходе к другой записи без обновления, внесенные изменения будут потеряны без предупреждения.  
  
 С помощью одного из операции поиска не является таким же, как вызов метода **MoveFirst** или `MoveNext`, тем не менее, который просто делает первой или следующей записи текущего без указания условие. Можно выполнить операцию поиска с помощью операции перемещения.  
  
 При использовании операции поиска необходимо учитывайте следующее:  
  
-   Если **найти** возвращает ненулевое значение, текущая запись не определен. В этом случае необходимо поместить указатель текущей записи к допустимой записи.  
  
-   Нельзя использовать операцию поиска с прокруткой статического типа данных последовательного доступа.  
  
-   Американский формат даты (месяц день год) следует использовать при поиске полей, содержащих даты, даже если американская версия ядра базы данных Microsoft Jet, не используются в противном случае — подходящие записи может быть не найдена.  
  
-   При работе с базами данных ODBC и больших динамических подмножеств данных, может оказаться, что с помощью операции поиска работает медленно, особенно при работе с большой наборы записей. Можно повысить производительность с помощью SQL-запросов с настроен **ORDERBY** или **ГДЕ** предложений, запросы с параметрами, или **CDaoQuerydef** объекты, получающие индексированных записей.  
  
 Дополнительные сведения см. в разделе «FindNext FindFirst, FindLast, FindPrevious методы» в справке DAO.  
  
##  <a name="getabsoluteposition"></a>CDaoRecordset::GetAbsolutePosition  
 Возвращает номер текущей записи объекта набора записей.  
  
```  
long GetAbsolutePosition();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Целое число от 0 до число записей в наборе записей. Соответствует порядковой позиции текущей записи в наборе записей.  
  
### <a name="remarks"></a>Примечания  
 Значение свойства AbsolutePosition базового объекта DAO с нуля; значение 0 относится к первой записи в наборе записей. Можно определить количество заполненных записей в наборе записей, вызвав [GetRecordCount](#getrecordcount). Вызов `GetRecordCount` может занять некоторое время, так как он должен получить доступ к все записи, чтобы определить число.  
  
 Если имеется текущая запись не определена, как при нет записей в наборе записей, возвращается 1. При удалении текущей записи, значение свойства AbsolutePosition не определен и MFC вызывает исключение, если она была вызвана. Для наборов записей добавляющий новые записи добавляются в конец последовательности.  
  
> [!NOTE]
>  Это свойство не предназначено для использования в качестве номер записи символов-заместителей. Закладки будут по-прежнему рекомендуемый способ сохранения и возврат к заданной позиции и являются единственным способом позицию текущей записи для всех типов объектов наборов записей. В частности позицию для определенной записи изменяется при удалении записи предшествующего ему. Нет никакой гарантии, что данная запись будет же абсолютное положение, если повторно набора записей создается снова, потому что порядок отдельных записей в наборе записей не обязательно, если он создается с помощью инструкции SQL с помощью **ORDERBY** предложения.  
  
> [!NOTE]
>  Эта функция-член является допустимым только для динамического типа и записей типа снимка.  
  
 Дополнительные сведения см. в разделе «AbsolutePosition свойство» в справке DAO.  
  
##  <a name="getbookmark"></a>CDaoRecordset::GetBookmark  
 Вызовите эту функцию-член для получения значения закладки в определенной записи.  
  
```  
COleVariant GetBookmark();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Возвращает значение, представляющее закладку на текущей записи.  
  
### <a name="remarks"></a>Примечания  
 При создании или открытии объекта набора записей, каждый из его записи уже есть уникальная закладка если их поддерживает. Вызовите `CanBookmark` , чтобы определить, поддерживает ли набор записей закладки.  
  
 Можно сохранить закладку для текущей записи, назначив значение закладки `COleVariant` объекта. Чтобы быстро вернуться к этой записи в любое время после перехода к другой записи, вызовите `SetBookmark` с параметром соответствует значению, `COleVariant` объект.  
  
> [!NOTE]
>  Вызов [Requery](#requery) изменяет закладки DAO.  
  
 Дополнительные сведения см. в разделе «Свойства закладки» в справке DAO.  
  
##  <a name="getcachesize"></a>CDaoRecordset::GetCacheSize  
 Вызовите эту функцию-член, чтобы получить число записей в кэше.  
  
```  
long GetCacheSize();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Значение, указывающее количество записей в наборе записей, содержащий данные локально кэшировать из источника данных ODBC.  
  
### <a name="remarks"></a>Примечания  
 Кэширование данных повышает производительность приложения, получающий данные с удаленного сервера через объекты типа динамического набора записей. Кэш, пробел в локальной памяти, который содержит данные, самое последнее полученное от сервера, в том случае, если данные будет повторно запрошен во время выполнения приложения. При запросе данных базы данных Microsoft Jet сначала проверяет кэш для запрошенных данных вместо его получения с сервера, который занимает больше времени. Данные, которые получены не из источника данных ODBC не сохраняется в кэше.  
  
 Любой источник данных ODBC, например вложенные таблицы может иметь локальный кэш.  
  
 Дополнительные сведения см. в разделе «CacheSize свойства CacheStart» в справке DAO.  
  
##  <a name="getcachestart"></a>CDaoRecordset::GetCacheStart  
 Вызовите эту функцию-член для получения значения первой записи в наборе записей, кэшируемых закладки.  
  
```  
COleVariant GetCacheStart();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Объект `COleVariant` , указывающий закладки первой записи в наборе записей должно кэшироваться.  
  
### <a name="remarks"></a>Примечания  
 Ядро базы данных Microsoft Jet запрашивает записей в диапазоне кэша из кэша и записи вне диапазона кэша он запрашивает с сервера.  
  
> [!NOTE]
>  Записей, полученных из кэша не отражают изменений, внесенных одновременно с источником данных другим пользователям.  
  
 Дополнительные сведения см. в разделе «CacheSize свойства CacheStart» в справке DAO.  
  
##  <a name="getcurrentindex"></a>CDaoRecordset::GetCurrentIndex  
 Вызовите эту функцию-член для определения индекса в настоящее время индексированные таблицей `CDaoRecordset` объекта.  
  
```  
CString GetCurrentIndex();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 A `CString` содержащий имя индекса в данный момент recordset табличного типа. Если индекс не было задано, возвращается пустая строка.  
  
### <a name="remarks"></a>Примечания  
 Этот индекс является основой для упорядочения записей в наборе записей, тип таблицы и используется [Seek](#seek) функции-члена для поиска записей.  
  
 Объект `CDaoRecordset` объект может иметь несколько индексов, но одновременно можно использовать только один индекс (хотя [CDaoTableDef](../../mfc/reference/cdaotabledef-class.md) объекта может иметь несколько определенных индексов).  
  
 Дополнительные сведения см. раздел «Объект индекса» и определение «текущий индекс» в справке DAO.  
  
##  <a name="getdatecreated"></a>CDaoRecordset::GetDateCreated  
 Вызовите эту функцию-член для получения дату и время создания базовой таблицы.  
  
```  
COleDateTime GetDateCreated();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Объект [COleDateTime](../../atl-mfc-shared/reference/coledatetime-class.md) объект, содержащий дату и время создания базовой таблицы.  
  
### <a name="remarks"></a>Примечания  
 Параметры даты и времени являются производными от компьютера, на котором был создан базовой таблицы.  
  
 Дополнительные сведения см. в разделе «DateCreated свойства LastUpdated» в справке DAO.  
  
##  <a name="getdatelastupdated"></a>CDaoRecordset::GetDateLastUpdated  
 Вызовите эту функцию-член для извлечения даты и времени последнего обновления схемы.  
  
```  
COleDateTime GetDateLastUpdated();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Объект [COleDateTime](../../atl-mfc-shared/reference/coledatetime-class.md) объект, содержащий дату и время последнего обновления структуры базовой таблицы (схема).  
  
### <a name="remarks"></a>Примечания  
 Параметры даты и времени являются производными от компьютера, последнего обновления структуры базовой таблицы (схема).  
  
 Дополнительные сведения см. в разделе «DateCreated свойства LastUpdated» в справке DAO.  
  
##  <a name="getdefaultdbname"></a>CDaoRecordset::GetDefaultDBName  
 Вызовите эту функцию-член для определения имени базы данных для этого набора записей.  
  
```  
virtual CString GetDefaultDBName();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Объект `CString` , содержащий путь и имя базы данных, из которого создается данный набор записей.  
  
### <a name="remarks"></a>Примечания  
 Если набор записей создается без указатель [CDaoDatabase](../../mfc/reference/cdaodatabase-class.md), а затем этот путь используется набор записей для открытия базы данных по умолчанию. По умолчанию эта функция возвращает пустую строку. Если ClassWizard является производным нового набора записей из `CDaoRecordset`, эта функция будет создан автоматически.  
  
 В следующем примере показано использование двойная обратная косая черта (\\\\) в строке, как требуется для правильной интерпретации строки.  
  
 [!code-cpp[NVC_MFCDatabase&#4;](../../mfc/codesnippet/cpp/cdaorecordset-class_4.cpp)]  
  
##  <a name="getdefaultsql"></a>CDaoRecordset::GetDefaultSQL  
 Платформа вызывает эту функцию-член для получения оператора SQL по умолчанию, лежащие в основе набора записей.  
  
```  
virtual CString GetDefaultSQL();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Объект `CString` , содержащий инструкцию SQL по умолчанию.  
  
### <a name="remarks"></a>Примечания  
 Это может быть имя таблицы или SQL **ВЫБЕРИТЕ** инструкции.  
  
 Косвенно определить инструкцию SQL по умолчанию путем объявления класса набора записей с помощью классов и ClassWizard выполняет эту задачу за вас.  
  
 Если передается пустая строка для [откройте](#open), то эта функция вызывается для определения имени таблицы или SQL для набора записей.  
  
##  <a name="geteditmode"></a>CDaoRecordset::GetEditMode  
 Вызовите эту функцию-член для определения состояния редактирования, которое является одним из следующих значений:  
  
```  
short GetEditMode();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Возвращает значение, указывающее состояние редактирования для текущей записи.  
  
### <a name="remarks"></a>Примечания  
  
|Значение|Описание|  
|-----------|-----------------|  
|**dbEditNone**|Идет операция редактирования.|  
|**dbEditInProgress**|**Изменить** был вызван.|  
|**dbEditAdd**|`AddNew`был вызван.|  
  
 Дополнительные сведения см. в разделе «EditMode свойство» в справке DAO.  
  
##  <a name="getfieldcount"></a>CDaoRecordset::GetFieldCount  
 Вызовите эту функцию-член для получения числа полей (столбцов), определенных в наборе записей.  
  
```  
short GetFieldCount();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Число полей в наборе записей.  
  
### <a name="remarks"></a>Примечания  
 Дополнительные сведения см. в разделе «Свойство Count» в справке DAO.  
  
##  <a name="getfieldinfo"></a>CDaoRecordset::GetFieldInfo  
 Вызовите эту функцию-член для получения сведений о полях в набор записей.  
  
```  
void GetFieldInfo(
    int nIndex,  
    CDaoFieldInfo& fieldinfo,  
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

 
void GetFieldInfo(
    LPCTSTR lpszName,  
    CDaoFieldInfo& fieldinfo,  
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
```  
  
### <a name="parameters"></a>Параметры  
 `nIndex`  
 Отсчитываемый от нуля индекс в коллекции полей набора записей, для поиска по индексу предопределенные поля.  
  
 `fieldinfo`  
 Ссылку на [CDaoFieldInfo](../../mfc/reference/cdaofieldinfo-structure.md) структуры.  
  
 `dwInfoOptions`  
 Параметры, определяющие, какой набор записей для извлечения. Доступные параметры перечислены здесь и что они могут вызывать функцию возврата. Для наилучшей производительности получите уровень нужной информации:  
  
- `AFX_DAO_PRIMARY_INFO`(По умолчанию) Имя, тип, размер, атрибуты  
  
- `AFX_DAO_SECONDARY_INFO`Сведения об основном, а также: порядковый номер позиции, необходимости разрешить нулевой длины, порядок сортировки, имя внешнего, исходное поле исходной таблицы  
  
- `AFX_DAO_ALL_INFO`Основной и дополнительной информации, а также: значение по умолчанию, правила проверки, сообщение об ошибке  
  
 `lpszName`  
 Имя поля.  
  
### <a name="remarks"></a>Примечания  
 Одна версия функции позволяет искать поле по индексу. Другая версия позволяет искать поле по имени.  
  
 Описание сведений, возвращаемых в разделе [CDaoFieldInfo](../../mfc/reference/cdaofieldinfo-structure.md) структуры. Эта структура содержит члены, которые соответствуют элементам данных, перечисленные выше в описании `dwInfoOptions`. При запросе информации на одном уровне, вы получите сведения всех предыдущих уровней.  
  
 Дополнительные сведения см. в разделе «Атрибуты свойства» в справке DAO.  
  
##  <a name="getfieldvalue"></a>CDaoRecordset::GetFieldValue  
 Вызовите эту функцию-член для получения данных в набор записей.  
  
```  
virtual void GetFieldValue(
    LPCTSTR lpszName,  
    COleVariant& varValue);

 
virtual void GetFieldValue(
    int nIndex,  
    COleVariant& varValue);
 
virtual COleVariant GetFieldValue(LPCTSTR lpszName); 
virtual COleVariant GetFieldValue(int nIndex);
```  
  
### <a name="parameters"></a>Параметры  
 `lpszName`  
 Указатель на строку, содержащую имя поля.  
  
 `varValue`  
 Ссылку на `COleVariant` объект, который будет хранить значение поля.  
  
 `nIndex`  
 Отсчитываемый от нуля индекс поля в коллекцию полей набора записей, для поиска по индексу.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Две версии `GetFieldValue` , которые возвращают значение возвращаемого [COleVariant](../../mfc/reference/colevariant-class.md) объект, содержащий значение поля.  
  
### <a name="remarks"></a>Примечания  
 Поля можно искать по имени или по порядковому номеру.  
  
> [!NOTE]
>  Более эффективно для вызова одной из версий эта функция-член, принимающий `COleVariant` ссылку на объект как параметр, а не версию, которая возвращает вызов `COleVariant` объекта. Более поздние версии этой функции сохраняются для обеспечения обратной совместимости.  
  
 Используйте `GetFieldValue` и [SetFieldValue](#setfieldvalue) динамически привязывать поля во время выполнения, а не статически привязки столбцов с помощью [DoFieldExchange](#dofieldexchange) механизм.  
  
 `GetFieldValue`и `DoFieldExchange` механизм могут быть объединены для повышения производительности. Например, используйте `GetFieldValue` получить значение, которое нужно только по запросу, и назначить этот вызов к кнопке «Дополнительная информация» в интерфейсе.  
  
 Дополнительные сведения см. в разделах «Поле Object» и «Значение свойства» в справке DAO.  
  
##  <a name="getindexcount"></a>CDaoRecordset::GetIndexCount  
 Вызовите эту функцию-член для определения количества индексов, доступных для объекта recordset типа таблицы.  
  
```  
short GetIndexCount();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Количество индексов в таблице типа записей.  
  
### <a name="remarks"></a>Примечания  
 `GetIndexCount`полезно для перебора всех индексов в наборе записей. Для этой цели используйте `GetIndexCount` в сочетании с [GetIndexInfo](#getindexinfo). При вызове функции-члена для динамического или записей типа снимка, MFC создает исключение.  
  
 Дополнительные сведения см. в разделе «Атрибуты свойства» в справке DAO.  
  
##  <a name="getindexinfo"></a>CDaoRecordset::GetIndexInfo  
 Вызовите эту функцию-член для получения различных типов сведений об индексе, определенные в базовой таблице набор записей.  
  
```  
void GetIndexInfo(
    int nIndex,  
    CDaoIndexInfo& indexinfo,  
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

 
void GetIndexInfo(
    LPCTSTR lpszName,  
    CDaoIndexInfo& indexinfo,  
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
```  
  
### <a name="parameters"></a>Параметры  
 `nIndex`  
 Отсчитываемый от нуля индекс в коллекции индексов таблицы, для поиска по числовой позиции.  
  
 `indexinfo`  
 Ссылку на [CDaoIndexInfo](../../mfc/reference/cdaoindexinfo-structure.md) структуры.  
  
 `dwInfoOptions`  
 Параметры, определяющие, какие индекса для извлечения. Доступные параметры перечислены здесь и что они могут вызывать функцию возврата. Для наилучшей производительности получите уровень нужной информации:  
  
- `AFX_DAO_PRIMARY_INFO`(По умолчанию) Имя, сведения о поле, поля  
  
- `AFX_DAO_SECONDARY_INFO`Сведения об основном, плюс: основной, Unique, кластеризованный, IgnoreNulls, необходимые, внешний  
  
- `AFX_DAO_ALL_INFO`Основной и дополнительной информации, а также: числа различных объектов  
  
 `lpszName`  
 Указатель на имя объекта индекса для поиска по имени.  
  
### <a name="remarks"></a>Примечания  
 Одна версия функции позволяет индекса по его позиции в коллекции. Другая версия позволяет искать индекса по имени.  
  
 Описание сведений, возвращаемых в разделе [CDaoIndexInfo](../../mfc/reference/cdaoindexinfo-structure.md) структуры. Эта структура содержит члены, которые соответствуют элементам данных, перечисленные выше в описании `dwInfoOptions`. При запросе информации на одном уровне, вы получите сведения всех предыдущих уровней.  
  
 Дополнительные сведения см. в разделе «Атрибуты свойства» в справке DAO.  
  
##  <a name="getlastmodifiedbookmark"></a>CDaoRecordset::GetLastModifiedBookmark  
 Вызовите эту функцию-член для получения закладки для записи наиболее недавно добавлены или обновлены.  
  
```  
COleVariant GetLastModifiedBookmark();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Объект `COleVariant` с закладкой, указывающее, недавно добавленные или измененные записи.  
  
### <a name="remarks"></a>Примечания  
 При создании или открытии объекта набора записей, каждый из его записи уже есть уникальная закладка если их поддерживает. Вызов [GetBookmark](#getbookmark) , чтобы определить, поддерживает ли набор записей закладки. Если набор записей не поддерживает закладки, `CDaoException` возникает исключение.  
  
 При добавлении записи в конце набора записей и не является текущей записи. Чтобы сделать новую запись текущей, вызовите `GetLastModifiedBookmark` , а затем вызовите `SetBookmark` для возврата вновь добавленной записи.  
  
 Дополнительные сведения см. в разделе «Свойство LastModified» в справке DAO.  
  
##  <a name="getlockingmode"></a>CDaoRecordset::GetLockingMode  
 Вызовите эту функцию-член для определения типа фактически блокировки для набора записей.  
  
```  
BOOL GetLockingMode();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если тип блокировки пессимистическая, в противном случае 0 нежесткой блокировки.  
  
### <a name="remarks"></a>Примечания  
 Когда Пессимистическая блокировка действует, страница данных, содержащая запись, вы изменяете заблокирован сразу после вызова [изменить](#edit) функции-члена. Страницы разблокирован, при вызове [обновление](#update) или [закрыть](#close) функции-члена или любой из операций перемещения и поиска.  
  
 Если оптимистическая блокировка действует страница данных, содержащая запись блокируется только при обновлении записи с **обновление** функции-члена.  
  
 При работе с источниками данных ODBC, режим блокировки всегда является оптимистическим.  
  
 Дополнительные сведения см. в разделах «Свойства LockEdits» и «Блокировки поведение в многопользовательском приложений» в справке DAO.  
  
##  <a name="getname"></a>CDaoRecordset::GetName  
 Вызовите эту функцию-член для извлечения имени набора записей.  
  
```  
CString GetName();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 A `CString` содержащее имя набора записей.  
  
### <a name="remarks"></a>Примечания  
 Имя набора записей должно начинаться с буквы и может содержать не более 40 символов. Он может включать цифры и символы подчеркивания, но не может содержать знаки пунктуации и пробелы.  
  
 Дополнительные сведения см. в разделе «Свойства Name» в справке DAO.  
  
##  <a name="getparamvalue"></a>CDaoRecordset::GetParamValue  
 Вызовите эту функцию-член для получения текущего значения заданного параметра в базовом объекте DAOParameter.  
  
```  
virtual COleVariant GetParamValue(int nIndex);  
virtual COleVariant GetParamValue(LPCTSTR lpszName);
```  
  
### <a name="parameters"></a>Параметры  
 `nIndex`  
 Числовая позиция параметра из базового объекта DAOParameter.  
  
 `lpszName`  
 Имя параметра, значение которого требуется.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Объект класса [COleVariant](../../mfc/reference/colevariant-class.md) , содержащий значение параметра.  
  
### <a name="remarks"></a>Примечания  
 Параметр доступны по имени или его числовую позицию в коллекции.  
  
 Дополнительные сведения см. в разделе «Параметр объект» в справке DAO.  
  
##  <a name="getpercentposition"></a>CDaoRecordset::GetPercentPosition  
 При работе с динамического или статического типа записей, при вызове `GetPercentPosition` до полного заполнения набора записей, объем перемещаемых — по сравнению с числом записей, доступных как указано путем вызова [GetRecordCount](#getrecordcount).  
  
```  
float GetPercentPosition();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Число от 0 до 100, указывающее Приблизительное расположение текущей записи в объекте набора записей на основе процента записей в наборе записей.  
  
### <a name="remarks"></a>Примечания  
 Вы может перейти к последней записи путем вызова [MoveLast](#movelast) для завершения заполнения все наборы записей, но это может занять значительное время.  
  
 Можно вызвать `GetPercentPosition` на всех трех типов объектов наборов записей, включая таблицы без индексов. Тем не менее, нельзя вызвать `GetPercentPosition` однопроходные прокрутки моментальных снимков или в набор записей, открытый в передаваемый запрос к внешней базе данных. Если текущая запись или текущая запись он был удален, `CDaoException` возникает исключение.  
  
 Дополнительные сведения см. в разделе «PercentPosition свойство» в справке DAO.  
  
##  <a name="getrecordcount"></a>CDaoRecordset::GetRecordCount  
 Эта функция члена выяснить обращались количество записей в наборе записей.  
  
```  
long GetRecordCount();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Возвращает количество записей, доступных в объекте набора записей.  
  
### <a name="remarks"></a>Примечания  
 `GetRecordCount`Указывает, сколько записей содержатся в динамического или набора записей типа снимка до обращались все записи. Этого вызова функции-члена может занять значительное время.  
  
 После обращения последней записи возвращаемое значение указывает общее количество неудаленными записей в наборе записей. Чтобы принудительно последней записи для доступа, вызовите `MoveLast` или `FindLast` функция-член набора записей. Число SQL также позволяет определить приблизительное количество записей, которые возвращает запрос.  
  
 Как приложение удаляет записи в наборе записей, возвращаемое значение `GetRecordCount` уменьшается. Тем не менее, записи, удаленные другими пользователями, не отражаются по `GetRecordCount` до текущей записи находится в удаленной записи. Если выполнение транзакции, которая влияет на число записей, а впоследствии откат транзакции, `GetRecordCount` не будет отражать фактическое число оставшихся записей.  
  
 Значение `GetRecordCount` из набора записей статического типа не зависит от изменения в базовых таблицах.  
  
 Значение `GetRecordCount` из типа таблицы набор записей отражает приблизительное количество записей в таблице и немедленно влияет как добавления и удаления записей в таблице.  
  
 Набор записей без записей возвращает значение 0. При работе с таблицами или баз данных ODBC, `GetRecordCount` всегда возвращает – 1. Вызов **Requery** функции-члена для объекта recordset сбрасывает значение `GetRecordCount` как если бы были повторно выполняется запрос.  
  
 Дополнительные сведения см. в разделе «RecordCount свойство» в справке DAO.  
  
##  <a name="getsql"></a>CDaoRecordset::GetSQL  
 Вызовите эту функцию-член для получения инструкции SQL, который использовался для выбора записей набора записей, если он был открыт.  
  
```  
CString GetSQL() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Объект `CString` , содержащий инструкции SQL.  
  
### <a name="remarks"></a>Примечания  
 Обычно это будет SQL **ВЫБЕРИТЕ** инструкции.  
  
 Строка, возвращаемая функцией `GetSQL` обычно отличается от любой строки переданы в набор записей в `lpszSQL` параметр [откройте](#open) функции-члена. Это обусловлено записей создает полная инструкция SQL, в зависимости от того, передается в **откройте**, указанный с помощью классов и то, что указано в [m_strFilter](#m_strfilter) и [m_strSort](#m_strsort) члены данных.  
  
> [!NOTE]
>  Это функция-член вызывается только после вызова метода **откройте**.  
  
 Дополнительные сведения см. в разделе «Свойство SQL» в справке DAO.  
  
##  <a name="gettype"></a>CDaoRecordset::GetType  
 Вызовите эту функцию-член после открытия набора записей, чтобы определить тип объекта набора записей.  
  
```  
short GetType();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Одно из следующих значений, указывающих тип набора записей:  
  
- **dbOpenTable** recordset табличного типа  
  
- **dbOpenDynaset** копирование или изменение  
  
- **dbOpenSnapshot** статического типа набора записей  
  
### <a name="remarks"></a>Примечания  
 Дополнительные сведения см. в разделе «Тип свойства» в справке DAO.  
  
##  <a name="getvalidationrule"></a>CDaoRecordset::GetValidationRule  
 Вызовите эту функцию-член для определения правил, используемый для проверки данных.  
  
```  
CString GetValidationRule();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Объект `CString` объект, содержащий значение, которое проверяет данные в записи, как изменить или добавить в таблицу.  
  
### <a name="remarks"></a>Примечания  
 Это правило выполняется на основе текста и применяется каждый раз при изменении базовой таблицы. Если данные не является допустимым, MFC создает исключение. Сообщения об ошибке является свертыванию базового поля объекта, если указан текст или текст выражения, указанного в свойстве ValidationRule базового объекта поля. Можно вызвать [GetValidationText](#getvalidationtext) для получения текста сообщения об ошибке.  
  
 Например, в поле записи, которая требует дня месяца может быть правило проверки «BETWEEN день 1 и 31.»  
  
 Дополнительные сведения см. в разделе «Свойства ValidationRule» в справке DAO.  
  
##  <a name="getvalidationtext"></a>CDaoRecordset::GetValidationText  
 Вызовите эту функцию-член для получения текста свертыванию базового объекта поля.  
  
```  
CString GetValidationText();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 A `CString` объекта, содержащего текст сообщения, которое отображается, если значение поля не удовлетворяет правило проверки базового объекта поля.  
  
### <a name="remarks"></a>Примечания  
 Дополнительные сведения см. в разделе «Свертыванию» в справке DAO.  
  
##  <a name="isbof"></a>CDaoRecordset::IsBOF  
 Вызов функции-члена до перехода от записи к записи, чтобы узнать, является ли Вы завершили перед первой записью в наборе записей.  
  
```  
BOOL IsBOF() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если набор записей не содержит записей или прокручен назад перед первой записью; в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 Можно также вызвать `IsBOF` вместе с `IsEOF` для определения набора записей содержит только записи, или является пустым. Сразу после вызова **откройте**, если набор записей не содержит записей, `IsBOF` возвращает ненулевое значение. При открытии набора записей, имеет по крайней мере одну запись, первая запись становится текущей записью и `IsBOF` возвращает 0.  
  
 Если первая запись становится текущей записью и вызывается `MovePrev`, `IsBOF` впоследствии возвращает ненулевое значение. Если `IsBOF` возвращает ненулевое значение, при вызове метода `MovePrev`, создается исключение. Если `IsBOF` возвращает ненулевое значение, текущая запись не определена, и любое действие, которое требует текущей записи вызовет исключение.  
  
 Влияние на отдельных методов `IsBOF` и `IsEOF` параметры:  
  
-   Вызов **откройте** внутренне делает первую запись в наборе записей текущей записи путем вызова **MoveFirst**. Таким образом, вызов **откройте** на пустой набор записей причины `IsBOF` и `IsEOF` для возврата ненулевое значение. (См. следующую таблицу для поведения сбоя **MoveFirst** или `MoveLast` вызова.)  
  
-   Все операции перемещения, найдите запись, успешно вызвать оба `IsBOF` и `IsEOF` возвращает значение 0.  
  
-   `AddNew` Вызова, за которым следует **обновление** , добавляет новую запись, успешно вызова `IsBOF` для возврата 0, но только если `IsEOF` уже имеет ненулевое значение. Состояние `IsEOF` всегда остаются неизменными. По определению ядром базы данных Microsoft Jet указатель текущей записи пустой набор записей — это в конце файла, поэтому любой новая запись вставляется после текущей записи.  
  
-   Любой **удаление** вызова, даже если она удаляет только оставшиеся записи из набора записей не изменится значение `IsBOF` или `IsEOF`.  
  
 В этой таблице показано, какие операции перемещения разрешены с различными комбинациями `IsBOF` /  `IsEOF`.  
  
||MoveFirst, MoveLast|MovePrev,<br /><br /> Перемещение< 0></ 0>|Переместить 0|MoveNext,<br /><br /> Перемещение настроек 0|  
|------|-------------------------|-----------------------------|------------|-----------------------------|  
|`IsBOF`= не равен нулю,<br /><br /> `IsEOF`=0|Allowed|Исключение|Исключение|Allowed|  
|`IsBOF`=0,<br /><br /> `IsEOF`ненулевое значение =|Allowed|Allowed|Исключение|Исключение|  
|Оба ненулевое значение|Исключение|Исключение|Исключение|Исключение|  
|Оба 0|Allowed|Allowed|Allowed|Allowed|  
  
 Разрешение операции перемещения не означает операции успешно обнаружит записи. Просто указывает, что попытка выполнить указанную операцию перемещения может и не создаст исключение. Значение `IsBOF` и `IsEOF` член функции могут изменяться в результате попытки перемещения.  
  
 Эффект перемещения операций, которые не удается найти запись на значение `IsBOF` и `IsEOF` параметры, показаны в следующей таблице.  
  
||IsBOF|IsEOF|  
|------|-----------|-----------|  
|**MoveFirst**,`MoveLast`|Ненулевое значение|Ненулевое значение|  
|**Переместить** 0|Без изменений|Без изменений|  
|`MovePrev`, **Move**< 0></ 0>|Ненулевое значение|Без изменений|  
|`MoveNext`, **Move** > 0|Без изменений|Ненулевое значение|  
  
 Дополнительные сведения см. в разделе «BOF, свойства EOF» в справке DAO.  
  
##  <a name="isdeleted"></a>CDaoRecordset::IsDeleted  
 Вызовите эту функцию-член для определения, был ли удален текущей записи.  
  
```  
BOOL IsDeleted() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если набор записей располагается на удаленную запись; в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 Если прокрутить записи и `IsDeleted` возвращает **TRUE** (не равен нулю), затем вы должны перейти к другой записи перед тем как выполнять никакие другие операции набора записей.  
  
> [!NOTE]
>  Не нужно проверять состояние удаленных записей в наборе записей моментальных снимков или тип таблицы. Поскольку записи не будут удалены из моментального снимка, нет необходимости вызывать `IsDeleted`. Для записей типа таблицы удаленных записей на самом деле, удаляются из набора записей. После записи был удален, пользователем, другим пользователем или в другой набор записей, его нельзя прокрутить к этой записи. Таким образом, нет необходимости вызывать `IsDeleted`.  
  
 При удалении записи из подмножества удаляется из набора записей и его нельзя прокрутить назад к этой записи. Тем не менее, если запись в динамический набор будет удален другим пользователем или в другой набор записей, на основе одной таблицы `IsDeleted` вернет **TRUE** при позже переместится к этой записи.  
  
 Дополнительные сведения см. в разделах «Метод Delete», «Свойство LastModified» и «EditMode свойство» в справке DAO.  
  
##  <a name="iseof"></a>CDaoRecordset::IsEOF  
 Вызовите эту функцию-член, как переход от записи к записи, чтобы узнать ли вы прошли после последней записи в наборе записей.  
  
```  
BOOL IsEOF() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если набор записей не содержит записей или выполнен переход за пределы последней записи; в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 Можно также вызвать `IsEOF` для определения набора записей содержит только записи, или является пустым. Сразу после вызова **откройте**, если набор записей не содержит записей, `IsEOF` возвращает ненулевое значение. При открытии набора записей, имеет по крайней мере одну запись, первая запись становится текущей записью и `IsEOF` возвращает 0.  
  
 Если последняя запись становится текущей записью, при вызове `MoveNext`, `IsEOF` впоследствии возвращает ненулевое значение. Если `IsEOF` возвращает ненулевое значение, при вызове метода `MoveNext`, создается исключение. Если `IsEOF` возвращает ненулевое значение, текущая запись не определена, и любое действие, которое требует текущей записи вызовет исключение.  
  
 Влияние на отдельных методов `IsBOF` и `IsEOF` параметры:  
  
-   Вызов **откройте** внутренне делает первую запись в наборе записей текущей записи путем вызова **MoveFirst**. Таким образом, вызов **откройте** на пустой набор записей причины `IsBOF` и `IsEOF` для возврата ненулевое значение. (См. следующую таблицу для поведения сбоя **MoveFirst** вызова.)  
  
-   Все операции перемещения, найдите запись, успешно вызвать оба `IsBOF` и `IsEOF` возвращает значение 0.  
  
-   `AddNew` Вызова, за которым следует **обновление** , добавляет новую запись, успешно вызова `IsBOF` для возврата 0, но только если `IsEOF` уже имеет ненулевое значение. Состояние `IsEOF` всегда остаются неизменными. По определению ядром базы данных Microsoft Jet указатель текущей записи пустой набор записей — это в конце файла, поэтому любой новая запись вставляется после текущей записи.  
  
-   Любой **удаление** вызова, даже если она удаляет только оставшиеся записи из набора записей не изменится значение `IsBOF` или `IsEOF`.  
  
 В этой таблице показано, какие операции перемещения разрешены с различными комбинациями `IsBOF` /  `IsEOF`.  
  
||MoveFirst, MoveLast|MovePrev,<br /><br /> Перемещение< 0></ 0>|Переместить 0|MoveNext,<br /><br /> Перемещение настроек 0|  
|------|-------------------------|-----------------------------|------------|-----------------------------|  
|`IsBOF`= не равен нулю,<br /><br /> `IsEOF`=0|Allowed|Исключение|Исключение|Allowed|  
|`IsBOF`=0,<br /><br /> `IsEOF`ненулевое значение =|Allowed|Allowed|Исключение|Исключение|  
|Оба ненулевое значение|Исключение|Исключение|Исключение|Исключение|  
|Оба 0|Allowed|Allowed|Allowed|Allowed|  
  
 Разрешение операции перемещения не означает операции успешно обнаружит записи. Просто указывает, что попытка выполнить указанную операцию перемещения может и не создаст исключение. Значение `IsBOF` и `IsEOF` член функции могут изменяться в результате попытки перемещения.  
  
 Эффект перемещения операций, которые не удается найти запись на значение `IsBOF` и `IsEOF` параметры, показаны в следующей таблице.  
  
||IsBOF|IsEOF|  
|------|-----------|-----------|  
|**MoveFirst**,`MoveLast`|Ненулевое значение|Ненулевое значение|  
|**Переместить** 0|Без изменений|Без изменений|  
|`MovePrev`, **Move**< 0></ 0>|Ненулевое значение|Без изменений|  
|`MoveNext`, **Move** > 0|Без изменений|Ненулевое значение|  
  
 Дополнительные сведения см. в разделе «BOF, свойства EOF» в справке DAO.  
  
##  <a name="isfielddirty"></a>CDaoRecordset::IsFieldDirty  
 Вызовите эту функцию-член для определения ли член данных заданного поля подмножества помечен как «грязный» (изменить).  
  
```  
BOOL IsFieldDirty(void* pv);
```  
  
### <a name="parameters"></a>Параметры  
 `pv`  
 Указатель на член поля данных, состояние которой требуется проверить, или **NULL** для определения полей «грязные».  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если элемент данных заданного поля помечен как «грязный»; в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 Данные в все измененными элементами данных полей должны быть переданы записи в источнике данных при обновлении текущей записи путем вызова **обновление** функцию-член `CDaoRecordset` (после вызова **изменить** или `AddNew`). Обладая такими сведениями, можно выполнить дополнительные действия, такие как ее снятие члена данных поля для маркировки столбца, чтобы не будут записываться в источник данных.  
  
 `IsFieldDirty`реализуется с помощью `DoFieldExchange`.  
  
##  <a name="isfieldnull"></a>CDaoRecordset::IsFieldNull  
 Вызовите эту функцию-член для определения, помечен ли элемент данных заданного поля набора записей как Null.  
  
```  
BOOL IsFieldNull(void* pv);
```  
  
### <a name="parameters"></a>Параметры  
 `pv`  
 Указатель на член поля данных, состояние которой требуется проверить, или **NULL** для определения, если любое из полей имеют значение Null.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если элемент данных заданного поля помечен как Null; в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 (В терминологии связанных баз данных, значение Null означает «значение не установку» и не совпадает с **NULL** в C++.) Если член поля данных помечен как Null, то он интерпретируется как столбца текущей записи, для которой не имеет смысла.  
  
> [!NOTE]
>  В некоторых случаях с помощью `IsFieldNull` может оказаться неэффективным, как показано в следующем примере кода:  
  
 [!code-cpp[NVC_MFCDatabase&#5;](../../mfc/codesnippet/cpp/cdaorecordset-class_5.cpp)]  
  
> [!NOTE]
>  При использовании динамической привязки записей, без создания класса, производного от `CDaoRecordset`, обязательно используйте **VT_NULL** как показано в примере.  
  
##  <a name="isfieldnullable"></a>CDaoRecordset::IsFieldNullable  
 Вызов этой функции-члена для определения ли член данных заданного поля значение «NULL» (может быть присвоено значение Null; C++ **NULL** не обязательно является Null, что в терминологии связанных баз данных, означает «необходимости нет значения»).  
  
```  
BOOL IsFieldNullable(void* pv);
```  
  
### <a name="parameters"></a>Параметры  
 `pv`  
 Указатель на член поля данных, состояние которой требуется проверить, или **NULL** для определения, если любое из полей имеют значение Null.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если элемент данных заданного поля может быть выполнено Null; в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 Поле, которое не может быть Null должен иметь значение. При попытке такого поля задать значение Null при добавлении или обновлении записи источника данных отклоняет Добавление или обновление, и **обновление** будет выдано исключение. Исключение возникает при вызове **обновление**, не при вызове `SetFieldNull`.  
  
##  <a name="isopen"></a>CDaoRecordset::IsOpen  
 Вызовите эту функцию-член для определения того, открыт ли набор записей.  
  
```  
BOOL IsOpen() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если объекта набора записей **откройте** или **Requery** ранее вызова функции-члена и набор записей не закрыт; в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
  
##  <a name="m_bcheckcachefordirtyfields"></a>CDaoRecordset::m_bCheckCacheForDirtyFields  
 Содержит флаг, указывающий ли кэшированные поля автоматически помечаются как «грязной» (измененного) и Null.  
  
### <a name="remarks"></a>Примечания  
 По умолчанию используется флаг **TRUE**. Параметр в этот элемент данных управляет весь механизм двойной буферизации. Если задан флаг **TRUE**, можно отключить кэширование для поля, с помощью механизма DFX. Если задан флаг **FALSE**, необходимо вызвать `SetFieldDirty` и `SetFieldNull` самостоятельно.  
  
 Значение этого элемента данных, перед вызовом метода **откройте**. Этот механизм используется главным образом для простоты использования. Производительность может быть медленнее из-за двойной буферизации полей при внесении изменений.  
  
##  <a name="m_nfields"></a>CDaoRecordset::m_nFields  
 Содержит количество элементов данных полей в классе записей и число столбцов, выбранных в набор записей из источника данных.  
  
### <a name="remarks"></a>Примечания  
 Конструктор для класса набора записей необходимо инициализировать `m_nFields` с правильным количеством статически связанных полей. ClassWizard записывает это инициализацию при использовании для объявления класса набора записей. Можно также создать его вручную.  
  
 Платформа использует этот номер для управления взаимодействием между элементами данных полей и соответствующих столбцов текущей записи в источнике данных.  
  
> [!NOTE]
>  Это число должно соответствовать количеству выходных столбцов, зарегистрированных в `DoFieldExchange` после вызова `SetFieldType` с параметром **CDaoFieldExchange::outputColumn**.  
  
 Можно привязать столбцы динамически с применением `CDaoRecordset::GetFieldValue` и `CDaoRecordset::SetFieldValue`. Если сделать это, необходимо выполнить приращение счетчика в `m_nFields` с учетом число функция DFX вызовов вашей `DoFieldExchange` функции-члена.  
  
##  <a name="m_nparams"></a>CDaoRecordset::m_nParams  
 Содержит количество элементов данных параметров в классе записей — количество параметров, передаваемый с запроса набора записей.  
  
### <a name="remarks"></a>Примечания  
 Если класс набора записей элементов данных параметров, необходимо инициализировать конструктор для класса `m_nParams` с правильным числом. Значение `m_nParams` по умолчанию равно 0. При добавлении элементов данных параметров — это необходимо сделать вручную — необходимо также вручную добавить инициализацию в конструкторе класса в соответствии с числом параметров (который должен быть по крайней мере количество '' заполнителей в вашего **m_strFilter** или `m_strSort` строки).  
  
 Платформа использует этот номер, когда он выполняет параметризацию запроса набора записей.  
  
> [!NOTE]
>  Этот номер должен соответствовать числу «params», зарегистрированных в `DoFieldExchange` после вызова `SetFieldType` с параметром **CFieldExchange::param**.  
  
 Дополнительные сведения см. в разделе «Параметр объект» в справке DAO.  
  
##  <a name="m_pdaorecordset"></a>CDaoRecordset::m_pDAORecordset  
 Содержит указатель на интерфейс OLE для базового объекта набора записей DAO `CDaoRecordset` объекта.  
  
### <a name="remarks"></a>Примечания  
 Используйте этот указатель, если требуется прямой доступ к интерфейсу DAO.  
  
 Дополнительные сведения см. в разделе «Объект набора записей» в справке DAO.  
  
##  <a name="m_pdatabase"></a>CDaoRecordset::m_pDatabase  
 Содержит указатель на `CDaoDatabase` объект, через который набор записей подключен к источнику данных.  
  
### <a name="remarks"></a>Примечания  
 Эта переменная задается двумя способами. Как правило, передать указатель на уже открытого `CDaoDatabase` объекта при создании объекта набора записей. Если передать **NULL** вместо **CDaoRecordset** создает `CDaoDatabase` объект и открывает его. В любом случае `CDaoRecordset` сохраняет указатель в этой переменной.  
  
 Обычно не требуется напрямую использовать указателем, сохраненным в **m_pDatabase**. При написании собственных расширений для `CDaoRecordset`, однако, может потребоваться использовать указатель. Например, может понадобиться указатель при генерировать собственные `CDaoException`(s).  
  
 Дополнительные сведения см. в разделе «Объект базы данных» в справке DAO.  
  
##  <a name="m_strfilter"></a>CDaoRecordset::m_strFilter  
 Содержит строку, которая используется для создания **ГДЕ** инструкции SQL.  
  
### <a name="remarks"></a>Примечания  
 Отсутствует зарезервированное слово **ГДЕ** для фильтрации набора записей. Использование этого элемента данных не применим для записей типа таблицы. Использование **m_strFilter** не влияет при открытии набора записей с помощью `CDaoQueryDef` указателя.  
  
 Используйте формат даты (месяц день год) США при фильтрации поля, содержащие даты, даже если американская версия ядра базы данных Microsoft Jet, не используются в противном случае данные не может быть отфильтрована, должным образом.  
  
 Дополнительные сведения см. в разделе «Свойства фильтра» в справке DAO.  
  
##  <a name="m_strsort"></a>CDaoRecordset::m_strSort  
 Содержит строку, содержащую **ORDERBY** инструкции SQL без зарезервированных слов **ORDERBY**.  
  
### <a name="remarks"></a>Примечания  
 Можно сортировать на объекты записей типа динамических подмножеств данных и моментальных снимков.  
  
 Не удается отсортировать объекты набора записей тип таблицы. Чтобы определить порядок сортировки recordset табличного типа, вызовите [SetCurrentIndex](#setcurrentindex).  
  
 Использование `m_strSort` не влияет при открытии набора записей с помощью `CDaoQueryDef` указателя.  
  
 Дополнительные сведения см. в разделе «Свойство сортировки» в справке DAO.  
  
##  <a name="move"></a>CDaoRecordset::Move  
 Вызов этой функции-члена для размещения записей `lRows` записей из текущей записи.  
  
```  
virtual void Move(long lRows);
```  
  
### <a name="parameters"></a>Параметры  
 `lRows`  
 Количество записей для перемещения вперед или назад. Положительные значения перемещение вперед, к концу набора записей. Отрицательные значения перемещение назад, к началу.  
  
### <a name="remarks"></a>Примечания  
 Можно перемещаться вперед и назад. `Move( 1 )`эквивалентно `MoveNext`, и `Move( -1 )` эквивалентно `MovePrev`.  
  
> [!CAUTION]
>  Вызов любого из **перемещение** функции вызывает исключение, если набор записей не имеет записей. Как правило, следует вызвать оба метода `IsBOF` и `IsEOF` перед операцией перемещения, чтобы определить, является ли набор записей все записи. После вызова метода **откройте** или **Requery**, либо вызвать `IsBOF` или `IsEOF`.  
  
> [!NOTE]
>  Если выполнен переход за начало или конец набора записей ( `IsBOF` или `IsEOF` возвращает ненулевое значение), вызов **перемещение** вызывает `CDaoException`.  
  
> [!NOTE]
>  Если вызвать любой из **перемещение** функции время текущей записи обновлены или добавлены, обновления будут потеряны без предупреждения.  
  
 При вызове **перемещение** однопроходные прокрутки моментального снимка, `lRows` параметр должен быть положительным целым числом и закладки не допускается, чтобы можно было перейти вперед только.  
  
 Чтобы первой, последней, следующей или предыдущей записи в наборе записей текущей записи, вызов **MoveFirst**, `MoveLast`, `MoveNext`, или `MovePrev` функции-члена.  
  
 Дополнительные сведения см. в разделах «Переместить метод» и «MoveFirst, MoveLast, MoveNext, методы MovePrevious» в справке DAO.  
  
##  <a name="movefirst"></a>CDaoRecordset::MoveFirst  
 Вызовите эту функцию-член вносить первой записи в наборе записей (если таковые имеются) текущей записи.  
  
```  
void MoveFirst();
```  
  
### <a name="remarks"></a>Примечания  
 Необходимо вызвать **MoveFirst** сразу после открытия набора записей. В это время первой записи (если таковые имеются) автоматически является текущей записи.  
  
> [!CAUTION]
>  Вызов любого из **перемещение** функции вызывает исключение, если набор записей не имеет записей. Как правило, следует вызвать оба метода `IsBOF` и `IsEOF` перед операцией перемещения, чтобы определить, является ли набор записей все записи. После вызова метода **откройте** или **Requery**, либо вызвать `IsBOF` или `IsEOF`.  
  
> [!NOTE]
>  Если вызвать любой из **перемещение** функции время текущей записи обновлены или добавлены, обновления будут потеряны без предупреждения.  
  
 Используйте **перемещение** функции для перемещения по записям без применения условия. Используйте операции поиска для поиска записей в наборе или объекта набора записей статического типа, которые удовлетворяют определенному условию. Чтобы найти запись в таблице тип объекта набора записей, вызовите метод `Seek`.  
  
 Если набор записей ссылается recordset табличного типа, перемещение приведены текущего индекса таблицы. Текущий индекс можно задать с помощью свойства индекса базового объекта DAO. Если не задать текущий индекс, не определен порядок возвращаемых записей.  
  
 При вызове метода `MoveLast` объекта набора записей на основе SQL-запроса или querydef, запрос вынужден завершения и объект recordset полностью заполнен.  
  
 Не удается вызвать **MoveFirst** или `MovePrev` функция-член с прокруткой только вперед моментального снимка.  
  
 Чтобы переместить позицию текущего записи в объекте набора записей определенного числа записей вперед или назад, вызовите **перемещение**.  
  
 Дополнительные сведения см. в разделах «Переместить метод» и «MoveFirst, MoveLast, MoveNext, методы MovePrevious» в справке DAO.  
  
##  <a name="movelast"></a>CDaoRecordset::MoveLast  
 Эта функция члена вносить последней записи (если таковые имеются) в наборе записей текущей записи.  
  
```  
void MoveLast();
```  
  
### <a name="remarks"></a>Примечания  
  
> [!CAUTION]
>  Вызов любого из **перемещение** функции вызывает исключение, если набор записей не имеет записей. Как правило, следует вызвать оба метода `IsBOF` и `IsEOF` перед операцией перемещения, чтобы определить, является ли набор записей все записи. После вызова метода **откройте** или **Requery**, либо вызвать `IsBOF` или `IsEOF`.  
  
> [!NOTE]
>  Если вызвать любой из **перемещение** функции время текущей записи обновлены или добавлены, обновления будут потеряны без предупреждения.  
  
 Используйте **перемещение** функции для перемещения по записям без применения условия. Используйте операции поиска для поиска записей в наборе или объекта набора записей статического типа, которые удовлетворяют определенному условию. Чтобы найти запись в таблице тип объекта набора записей, вызовите метод `Seek`.  
  
 Если набор записей ссылается recordset табличного типа, перемещение приведены текущего индекса таблицы. Текущий индекс можно задать с помощью свойства индекса базового объекта DAO. Если не задать текущий индекс, не определен порядок возвращаемых записей.  
  
 При вызове метода `MoveLast` объекта набора записей на основе SQL-запроса или querydef, запрос вынужден завершения и объект recordset полностью заполнен.  
  
 Чтобы переместить позицию текущего записи в объекте набора записей определенного числа записей вперед или назад, вызовите **перемещение**.  
  
 Дополнительные сведения см. в разделах «Переместить метод» и «MoveFirst, MoveLast, MoveNext, методы MovePrevious» в справке DAO.  
  
##  <a name="movenext"></a>CDaoRecordset::MoveNext  
 Вызовите эту функцию-член для следующей записи в текущую запись набора записей.  
  
```  
void MoveNext();
```  
  
### <a name="remarks"></a>Примечания  
 Рекомендуется вызывать `IsBOF` перед повторной попыткой перейти к предыдущей записи. Вызов `MovePrev` вызовет `CDaoException` Если `IsBOF` возвращает ненулевое значение, указывающее, что была выполнена прокрутка перед первой записью или что записи не были выбраны набором записей.  
  
> [!CAUTION]
>  Вызов любого из **перемещение** функции вызывает исключение, если набор записей не имеет записей. Как правило, следует вызвать оба метода `IsBOF` и `IsEOF` перед операцией перемещения, чтобы определить, является ли набор записей все записи. После вызова метода **откройте** или **Requery**, либо вызвать `IsBOF` или `IsEOF`.  
  
> [!NOTE]
>  Если вызвать любой из **перемещение** функции время текущей записи обновлены или добавлены, обновления будут потеряны без предупреждения.  
  
 Используйте **перемещение** функции для перемещения по записям без применения условия. Используйте операции поиска для поиска записей в наборе или объекта набора записей статического типа, которые удовлетворяют определенному условию. Чтобы найти запись в таблице тип объекта набора записей, вызовите метод `Seek`.  
  
 Если набор записей ссылается recordset табличного типа, перемещение приведены текущего индекса таблицы. Текущий индекс можно задать с помощью свойства индекса базового объекта DAO. Если не задать текущий индекс, не определен порядок возвращаемых записей.  
  
 Чтобы переместить позицию текущего записи в объекте набора записей определенного числа записей вперед или назад, вызовите **перемещение**.  
  
 Дополнительные сведения см. в разделах «Переместить метод» и «MoveFirst, MoveLast, MoveNext, методы MovePrevious» в справке DAO.  
  
##  <a name="moveprev"></a>CDaoRecordset::MovePrev  
 Вызовите эту функцию-член для предыдущей записи в текущую запись набора записей.  
  
```  
void MovePrev();
```  
  
### <a name="remarks"></a>Примечания  
 Рекомендуется вызывать `IsBOF` перед повторной попыткой перейти к предыдущей записи. Вызов `MovePrev` вызовет `CDaoException` Если `IsBOF` возвращает ненулевое значение, указывающее, что была выполнена прокрутка перед первой записью или что записи не были выбраны набором записей.  
  
> [!CAUTION]
>  Вызов любого из **перемещение** функции вызывает исключение, если набор записей не имеет записей. Как правило, следует вызвать оба метода `IsBOF` и `IsEOF` перед операцией перемещения, чтобы определить, является ли набор записей все записи. После вызова метода **откройте** или **Requery**, либо вызвать `IsBOF` или `IsEOF`.  
  
> [!NOTE]
>  Если вызвать любой из **перемещение** функции время текущей записи обновлены или добавлены, обновления будут потеряны без предупреждения.  
  
 Используйте **перемещение** функции для перемещения по записям без применения условия. Используйте операции поиска для поиска записей в наборе или объекта набора записей статического типа, которые удовлетворяют определенному условию. Чтобы найти запись в таблице тип объекта набора записей, вызовите метод `Seek`.  
  
 Если набор записей ссылается recordset табличного типа, перемещение приведены текущего индекса таблицы. Текущий индекс можно задать с помощью свойства индекса базового объекта DAO. Если не задать текущий индекс, не определен порядок возвращаемых записей.  
  
 Не удается вызвать **MoveFirst** или `MovePrev` функция-член с прокруткой только вперед моментального снимка.  
  
 Чтобы переместить позицию текущего записи в объекте набора записей определенного числа записей вперед или назад, вызовите **перемещение**.  
  
 Дополнительные сведения см. в разделах «Переместить метод» и «MoveFirst, MoveLast, MoveNext, методы MovePrevious» в справке DAO.  
  
##  <a name="open"></a>CDaoRecordset::Open  
 Необходимо вызвать эту функцию-член для извлечения записей для набора записей.  
  
```  
virtual void Open(
    int nOpenType = AFX_DAO_USE_DEFAULT_TYPE,  
    LPCTSTR lpszSQL = NULL,  
    int nOptions = 0);

 
virtual void Open(
    CDaoTableDef* pTableDef,  
    int nOpenType = dbOpenTable,  
    int nOptions = 0);

 
virtual void Open(
    CDaoQueryDef* pQueryDef,  
    int nOpenType = dbOpenDynaset,  
    int nOptions = 0);
```  
  
### <a name="parameters"></a>Параметры  
 `nOpenType`  
 Одно из следующих значений:  
  
- **dbOpenDynaset** набор записей динамического типа с двунаправленный прокрутки. Это значение по умолчанию.  
  
- **dbOpenTable** recordset табличного типа с двунаправленный прокрутки.  
  
- **dbOpenSnapshot** набор записей типа снимка с двунаправленный прокрутки.  
  
 `lpszSQL`  
 Указатель на строку, содержащую одно из следующих:  
  
-   Объект **NULL** указателя.  
  
-   Имя одной или нескольких tabledefs и querydefs (разделенный запятыми).  
  
-   SQL **ВЫБЕРИТЕ** инструкции (при необходимости с помощью SQL **ГДЕ** или **ORDERBY** предложение).  
  
-   Запрос к серверу.  
  
 `nOptions`  
 Один или несколько из указанных ниже параметров. Значение по умолчанию — 0. Ниже приведены возможные значения.  
  
- **dbAppendOnly** можно только добавить новые записи (только в наборе записей). Этот параметр означает буквально записи добавляются только возможно. Классы баз данных MFC ODBC имеют заполняемом только параметр, разрешающий записей, извлекаются и добавляются.  
  
- **dbForwardOnly** набор записей является снимком прокруткой только вперед.  
  
- **dbSeeChanges** создает исключение, если другой пользователь изменяет редактировании данных.  
  
- **dbDenyWrite** нельзя изменять и добавлять записи другими пользователями.  
  
- **dbDenyRead** другие пользователи не могут просматривать записи (только в табличный тип записей).  
  
- **dbReadOnly** можно только просмотреть записей, другие пользователи могут изменять их.  
  
- **dbInconsistent** несогласованных обновлений разрешены (копирование или изменение только).  
  
- **dbConsistent** только согласованности обновлений разрешены (копирование или изменение только).  
  
> [!NOTE]
>  Константы **dbConsistent** и **dbInconsistent** являются взаимоисключающими. Можно использовать один или другой, но не одновременно в заданном экземпляре **откройте**.  
  
 *pTableDef*  
 Указатель на [CDaoTableDef](../../mfc/reference/cdaotabledef-class.md) объекта. Эта версия предназначена только для записей типа таблицы. При использовании этого параметра `CDaoDatabase` указатель, используемый для создания `CDaoRecordset` не используется; вместо этого используется база данных, в которой находится tabledef.  
  
 *pQueryDef*  
 Указатель на [CDaoQueryDef](../../mfc/reference/cdaoquerydef-class.md) объекта. Эта версия является допустимым только для динамического типа и записей типа снимка. При использовании этого параметра `CDaoDatabase` указатель, используемый для создания `CDaoRecordset` не используется; вместо этого используется база данных, в которой находится querydef.  
  
### <a name="remarks"></a>Примечания  
 Перед вызовом метода **откройте**, необходимо создать объект набора записей. Для этого можно использовать следующие способы.  
  
-   При создании объекта набора записей, передайте указатель на `CDaoDatabase` объект, который уже открыт.  
  
-   При создании объекта набора записей, передайте указатель на `CDaoDatabase` объект, который не был открыт. Открывает набор записей `CDaoDatabase` объекта, но не закрывайте его при закрытии объекта набора записей.  
  
-   При создании объекта набора записей, передайте **NULL** указателя. Набор записей объектов вызывает `GetDefaultDBName` для получения имени Microsoft Access. Откройте файл MDB. Открывает набор записей `CDaoDatabase` объект и сохраняет его открыть, пока открыт набор записей. При вызове **закрыть** для объекта recordset, `CDaoDatabase` объект также закрывается.  
  
    > [!NOTE]
    >  При открытии набора записей `CDaoDatabase` объекта источника данных открывается с совмещаемый доступ.  
  
 Для версии **откройте** , использующий `lpszSQL` параметр, после открытия набора записей для извлечения одним из следующих способов. Первый вариант — использовать функции DFX вашей `DoFieldExchange`. Второй вариант — использовать динамическую привязку путем вызова `GetFieldValue` функции-члена. Эти параметры можно реализовать отдельно или в сочетании. Если они объединяются, необходимо передать в инструкцию SQL самостоятельно при вызове **откройте**.  
  
 При использовании второй версии **откройте** здесь вы отправляете в `CDaoTableDef` объекта, полученные в результате столбцы будут доступны для привязки через `DoFieldExchange` и DFX механизм, или привязка динамически через `GetFieldValue`.  
  
> [!NOTE]
>  Можно вызывать только **откройте** с помощью `CDaoTableDef` объекта для записей типа таблицы.  
  
 При использовании третьей версии **откройте** здесь вы отправляете в `CDaoQueryDef` объекта, что запрос будет выполняться, а полученные столбцы будут доступны для привязки через `DoFieldExchange` и DFX механизм, или привязка динамически через `GetFieldValue`.  
  
> [!NOTE]
>  Можно вызывать только **откройте** с помощью `CDaoQueryDef` объект для динамического типа и записей типа снимка.  
  
 Для первой версии **откройте** , использующий `lpszSQL` параметра записей, выбранных на основе критериев, показано в следующей таблице.  
  
|Значение параметра `lpszSQL`|Определяется выбрано записей|Пример|  
|--------------------------------------|----------------------------------------|-------------|  
|**ЗНАЧЕНИЕ NULL**|Строка, возвращаемая функцией `GetDefaultSQL`.||  
|Разделенный запятыми список из одного или нескольких tabledefs или querydef имен.|Все столбцы представлены в `DoFieldExchange`.|`"Customer"`|  
|**ВЫБЕРИТЕ** список столбцов **из** список таблиц|Указанные столбцы из указанного tabledef(s) или querydef(s).|`"SELECT CustId, CustName`<br /><br /> `FROM Customer"`|  
  
 Обычные процедуры заключается в передаче **NULL** для **откройте**; в этом случае **откройте** вызовов `GetDefaultSQL`, функция-член переопределяемым, ClassWizard приводит к возникновению ошибки при создании `CDaoRecordset`-производного класса. Это значение представляет имена tabledef(s) или querydef, указанной в ClassWizard. Вместо этого можно указать другие сведения в `lpszSQL` параметр.  
  
 Все передаваемые **откройте** создает окончательной строки SQL для запроса (строка может иметь SQL **ГДЕ** и **ORDERBY** добавлено предложения `lpszSQL` вы переданной строки), а затем выполняет запрос. Получившаяся строка можно проверить путем вызова `GetSQL` после вызова метода **откройте**.  
  
 Члены данных полей набора записей класса привязаны к столбцам выбранных данных. Если возвращаются все записи, первая запись становится текущей записью.  
  
 Если требуется задать параметры для набора записей, такие как фильтр или сортировку, задайте `m_strSort` или **m_strFilter** после создания объекта набора записей, но перед вызовом **откройте**. Если вы хотите записей в наборе записей после обновления набора записей уже открыт, вызовите **Requery**.  
  
 При вызове метода **откройте** на динамического или статического типа записей, или если источник данных ссылается на инструкцию SQL или tabledef, представляющий подключенной таблицы, нельзя использовать **dbOpenTable** для аргумента типа; в противном случае MFC создает исключение. Чтобы определить, представляет ли объект tabledef подключенной таблицы, создайте [CDaoTableDef](../../mfc/reference/cdaotabledef-class.md) и вызовите его [GetConnect](../../mfc/reference/cdaotabledef-class.md#getconnect) функции-члена.  
  
 Используйте **dbSeeChanges** флаг предназначается для перехвата изменений, внесенных другим пользователем или другой программой на вашем компьютере, при изменении или удалении ту же запись. Например, если два пользователя начать редактирование ту же запись первого пользователя для вызова **обновление** успешного выполнения функции-члена. Когда **обновление** вызывается второй пользователь `CDaoException` возникает исключение. Аналогично Если второй пользователь пытается обратиться к **удаление** для удаления записи, который уже был изменен пользователем первого `CDaoException` происходит.  
  
 Как правило если пользователь получает это `CDaoException` при обновлении, код должен обновить содержимое полей и получить измененные значения. Если исключение возникает в процессе удаления, код удалось отобразить новых записей данных пользователю и сообщение, указывающее, что недавно изменились данные. На этом этапе ваш код может запросить подтверждение, что по-прежнему пользователю для удаления записи.  
  
> [!TIP]
>  Используйте параметр прокруткой только вперед ( **dbForwardOnly**) для повышения производительности, когда приложение выполняет один проход по набору записей, открытые из источника данных ODBC.  
  
 Дополнительные сведения см. в разделе «Метод OpenRecordset» в справке DAO.  
  
##  <a name="requery"></a>CDaoRecordset::Requery  
 Эта функция члена для перестроения (обновления) набора записей.  
  
```  
virtual void Requery();
```  
  
### <a name="remarks"></a>Примечания  
 Если возвращаются все записи, первая запись становится текущей записью.  
  
 Чтобы набора записей в соответствии с добавления и удаления, вы или другие пользователи, осуществляющие к источнику данных, необходимо перестроить набора записей путем вызова **Requery**. Если набор записей является динамическим подмножеством, он автоматически отражает обновлений, которые вы или другие пользователи его существующие записи (но не дополнения). Если набор записей является моментальным снимком, необходимо вызвать **Requery** для отражения изменений, с другими пользователями, а также добавления и удаления.  
  
 Для динамических подмножеств данных или моментального снимка, вызовите **Requery** любое время, необходимо перестроить набора записей, используя значения параметров. Установить новый фильтр или сортировку, задав [m_strFilter](#m_strfilter) и [m_strSort](#m_strsort) перед вызовом метода **Requery**. Задайте новые параметры, задавая новые значения членов данных параметра перед вызовом метода **Requery**.  
  
 При неудачной попытке повторного построения recordset, закрывается набор записей. Перед вызовом метода **Requery**, можно определить, можно ли опросить набора записей путем вызова [CanRestart](#canrestart) функции-члена. `CanRestart`не гарантирует, что **Requery** будет успешным.  
  
> [!CAUTION]
>  Вызов **Requery** только после вызова **откройте**.  
  
> [!NOTE]
>  Вызов [Requery](#requery) изменяет закладки DAO.  
  
 Не удается вызвать **Requery** динамического типа или типа набора записей, если вызов `CanRestart` возвращает 0, ни его можно использовать для объекта recordset типа таблицы.  
  
 Если оба `IsBOF` и `IsEOF` возвращает ненулевое значение, после вызова метода **Requery**, запрос не вернул ни одной записи и набор записей будет не содержат данных.  
  
 Дополнительные сведения см. в разделе «Повторного» справки DAO.  
  
##  <a name="seek"></a>CDaoRecordset::Seek  
 Вызовите эту функцию-член для обнаружения записи в объекте набора записей индексированных тип таблицы, удовлетворяющей критериям для текущего индекса и убедитесь, что запись текущей записи.  
  
```  
BOOL Seek(
    LPCTSTR lpszComparison,  
    COleVariant* pKey1,  
    COleVariant* pKey2 = NULL,  
    COleVariant* pKey3 = NULL);

 
BOOL Seek(
    LPCTSTR lpszComparison,  
    COleVariant* pKeyArray,  
    WORD nKeys);
```  
  
### <a name="parameters"></a>Параметры  
 `lpszComparison`  
 Один из следующих строковых выражений: «<",></",>\<=», «=», «настроек =», или «настроек».  
  
 `pKey1`  
 Указатель на [COleVariant](../../mfc/reference/colevariant-class.md) , значение которого соответствует первым полем в индексе. Обязательный.  
  
 *pKey2*  
 Указатель на `COleVariant` , значение которого соответствует со вторым полем в индексе, если таковые имеются. По умолчанию **NULL**.  
  
 *pKey3*  
 Указатель на `COleVariant` , значение которого соответствует третьего поля в индексе, если таковые имеются. По умолчанию **NULL**.  
  
 *pKeyArray*  
 Указатель на массив значений типа Variant. Размер массива соответствует числу полей в индексе.  
  
 *nKeys*  
 Целое число, соответствующее размеру массива, то число полей в индексе.  
  
> [!NOTE]
>  Не указывайте подстановочные знаки в разделах реестра. Подстановочные знаки вызовет `Seek` для возврата без совпадающих записей.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если Обнаружены совпадающие записи, в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 Используйте вторую версию (array) `Seek` для обработки индексы четырех полей или более.  
  
 `Seek`включает индекс высокой производительности, поиска записей типа таблицы. Необходимо задать текущий индекс путем вызова `SetCurrentIndex` перед вызовом метода `Seek`. Если индекс определяет неуникальный ключевого поля или поля, `Seek` находит первой записи, которые удовлетворяют условиям. Если индекс не задано, создается исключение.  
  
 Обратите внимание, что если вы не создаете набор записей ЮНИКОДА, `COleVariant` объекты должны быть объявлены явно ANSI. Это можно сделать с помощью [COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** `lpszSrc` **,** `vtSrc` **)** форма конструктора с `vtSrc` значение `VT_BSTRT` (ANSI) или с помощью **COleVariant** функция [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** `lpszSrc` **,** `vtSrc` **)** с `vtSrc` значение `VT_BSTRT`.  
  
 При вызове `Seek`, передать один или несколько значений ключа и оператор сравнения («<",></",>\<=», «=», «настроек =», или «настроек»). `Seek`Ищет указанные ключевые поля и находит первой записи, которая удовлетворяет критериям, заданным `lpszComparison` и `pKey1`. После нахождения `Seek` возвращает ненулевое значение и делает текущей записи. Если `Seek` не может найти совпадение, `Seek` возвращает ноль, а текущая запись не определена. При использовании DAO напрямую, необходимо явно проверить свойство NoMatch.  
  
 Если `lpszComparison` «=», «настроек =», или «настроек», `Seek` начинается с индекса. Если `lpszComparison` — «<" or=""> </"> <=",> </=",> `Seek` начинается в конце индекса и выполняет поиск только при наличии индекса повторяющиеся записи в конце. В этом случае `Seek` начинается с произвольным запись среди индекс повторяющиеся записи в конце индекса.  
  
 Существует не быть текущей записи при использовании `Seek`.  
  
 Чтобы найти запись в динамического или статического типа записей, который удовлетворяет заданному условию, используйте операции поиска. Чтобы включить все записи, не только те, которые удовлетворяют определенному условию, используйте операции перемещения для перемещения по записям.  
  
 Не удается вызвать `Seek` на подключенной таблицы любого типа, так как вложенные таблицы должен быть открыт как динамического или записей типа снимка. Тем не менее при вызове `CDaoDatabase::Open` непосредственно открыть устанавливаемые базы данных ISAM, можно последовательно вызвать методы `Seek` в таблицах этой базы данных, несмотря на то, что производительность может быть медленно.  
  
 Дополнительные сведения см. в разделе «Поиск метода» в справке DAO.  
  
##  <a name="setabsoluteposition"></a>CDaoRecordset::SetAbsolutePosition  
 Задает относительный номер текущей записи объекта набора записей.  
  
```  
void SetAbsolutePosition(long lPosition);
```  
  
### <a name="parameters"></a>Параметры  
 *lPosition*  
 Соответствует порядковой позиции текущей записи в наборе записей.  
  
### <a name="remarks"></a>Примечания  
 Вызов `SetAbsolutePosition` позволяет поместите указатель текущей записи для конкретных записей по его порядковому номеру динамического типа или типа набора записей. Можно также определить номер текущей записи, вызвав [GetAbsolutePosition](#getabsoluteposition).  
  
> [!NOTE]
>  Эта функция-член является допустимым только для динамического типа и записей типа снимка.  
  
 Значение свойства AbsolutePosition базового объекта DAO с нуля; значение 0 относится к первой записи в наборе записей. Установка значения больше, чем количество заполненных записи причины MFC для создания исключения. Можно определить количество заполненных записей в наборе записей, вызвав `GetRecordCount` функции-члена.  
  
 При удалении текущей записи, значение свойства AbsolutePosition не определен и MFC вызывает исключение, если она была вызвана. Новые записи добавляются в конец последовательности.  
  
> [!NOTE]
>  Это свойство не предназначено для использования в качестве номер записи символов-заместителей. Закладки будут по-прежнему рекомендуемый способ сохранения и возврат к заданной позиции и являются единственным способом позицию текущей записи для всех типов объектов набора записей, которые поддерживают закладки. В частности позицию для определенной записи изменяется при удалении записи предшествующего ему. Нет никакой гарантии, что данная запись будет же абсолютное положение, если повторно набора записей создается снова, потому что порядок отдельных записей в наборе записей не обязательно, если он создается с помощью инструкции SQL с помощью **ORDERBY** предложения.  
  
 Дополнительные сведения см. в разделе «AbsolutePosition свойство» в справке DAO.  
  
##  <a name="setbookmark"></a>CDaoRecordset::SetBookmark  
 Вызов этой функции-члена для размещения записей в записи, содержащей указанную закладку.  
  
```  
void SetBookmark(COleVariant varBookmark);
```  
  
### <a name="parameters"></a>Параметры  
 `varBookmark`  
 Объект [COleVariant](../../mfc/reference/colevariant-class.md) объект, содержащий значение для определенной записи.  
  
### <a name="remarks"></a>Примечания  
 При создании или открытии объекта набора записей, каждый из его записи уже есть уникальная закладка. Закладки для текущей записи можно получить, вызвав `GetBookmark` и сохранение значение `COleVariant` объекта. Возможность позже вернуться к этой записи путем вызова `SetBookmark` с помощью значения сохраненные закладки.  
  
> [!NOTE]
>  Вызов [Requery](#requery) изменяет закладки DAO.  
  
 Обратите внимание, что если вы не создаете набор записей ЮНИКОДА, `COleVariant` объекта должны быть объявлены явно ANSI. Это можно сделать с помощью [COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** `lpszSrc` **,** `vtSrc` **)** форма конструктора с `vtSrc` значение `VT_BSTRT` (ANSI) или с помощью **COleVariant** функция [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** `lpszSrc` **,** `vtSrc` **)** с `vtSrc` значение `VT_BSTRT`.  
  
 Дополнительные сведения см. в разделах «Свойства закладки» и свойство Bookmarkable» в справке DAO.  
  
##  <a name="setcachesize"></a>CDaoRecordset::SetCacheSize  
 Вызовите эту функцию-член для задания числа записей, которые будут кэшироваться.  
  
```  
void SetCacheSize(long lSize);
```  
  
### <a name="parameters"></a>Параметры  
 `lSize`  
 Указывает количество записей. Обычно значение — 100. Значение 0 отключает кэширование. Параметр должен быть между 5 и 1200 записей. Значительный объем памяти может использовать кэш.  
  
### <a name="remarks"></a>Примечания  
 Кэш, пробел в локальной памяти, который содержит данные, самое последнее полученное от сервера, в том случае, если данные будет повторно запрошен во время выполнения приложения. Кэширование данных повышает производительность приложения, получающий данные с удаленного сервера через объекты типа динамического набора записей. При запросе данных базы данных Microsoft Jet сначала проверяет кэш для запрошенных данных вместо его получения с сервера, который занимает больше времени. Данные, которые получены не из источника данных ODBC не сохраняется в кэше.  
  
 Любой источник данных ODBC, например вложенные таблицы может иметь локальный кэш. Чтобы создать кэш, открывает объект набора записей из удаленного источника данных, вызов `SetCacheSize` и `SetCacheStart` функции-члены, а затем вызвать `FillCache` функции-члена или шаг по записям с помощью одного из операции перемещения. `lSize` Параметр `SetCacheSize` функция-член может основываться на число записей, ваше приложение может работать с за один раз. Например, если вы используете набор записей в качестве источника данных для отображения на экране, можно передать `SetCacheSize``lSize` параметр как 20 для отображения 20 записей за один раз.  
  
 Дополнительные сведения см. в разделе «CacheSize свойства CacheStart» в справке DAO.  
  
##  <a name="setcachestart"></a>CDaoRecordset::SetCacheStart  
 Вызов этой функции-члена для указания закладки первой записи в наборе записей, кэшируемых.  
  
```  
void SetCacheStart(COleVariant varBookmark);
```  
  
### <a name="parameters"></a>Параметры  
 `varBookmark`  
 Объект [COleVariant](../../mfc/reference/colevariant-class.md) , указывающий закладки первой записи в наборе записей должно кэшироваться.  
  
### <a name="remarks"></a>Примечания  
 Можно использовать значение любой записи для `varBookmark` параметр `SetCacheStart` функции-члена. Сделать запись, необходимо начать с текущей записью кэша, установить закладку для этой записи с помощью [SetBookmark](#setbookmark)и передать значение параметра для `SetCacheStart` функции-члена.  
  
 Ядро базы данных Microsoft Jet запрашивает записей в диапазоне кэша из кэша и записи вне диапазона кэша он запрашивает с сервера.  
  
 Записей, полученных из кэша не отражают изменений, внесенных одновременно с источником данных другим пользователям.  
  
 Чтобы принудительно обновить кэшированные данные, передайте `lSize` параметр `SetCacheSize` 0, вызов `SetCacheSize` снова с размером кэша вы первоначально запрошенную, а затем вызовите `FillCache` функции-члена.  
  
 Обратите внимание, что если вы не создаете набор записей ЮНИКОДА, `COleVariant` объекта должны быть объявлены явно ANSI. Это можно сделать с помощью [COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** `lpszSrc` **,** `vtSrc` **)** форма конструктора с `vtSrc` значение `VT_BSTRT` (ANSI) или с помощью **COleVariant** функция [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** `lpszSrc` **,** `vtSrc` **)** с `vtSrc` значение `VT_BSTRT`.  
  
 Дополнительные сведения см. в разделе CacheSize, свойства CacheStart» в справке DAO.  
  
##  <a name="setcurrentindex"></a>CDaoRecordset::SetCurrentIndex  
 Вызов этой функции-члена следует установить индекс для объекта recordset типа таблицы.  
  
```  
void SetCurrentIndex(LPCTSTR lpszIndex);
```  
  
### <a name="parameters"></a>Параметры  
 `lpszIndex`  
 Указатель, содержащая имя индекса, чтобы задать.  
  
### <a name="remarks"></a>Примечания  
 Записи в базовых таблицах не хранятся в любом порядке. Индекс параметра меняет порядок записей, возвращаемых из базы данных, но не влияет на порядок, в котором хранятся записи. Указанный индекс должен быть уже определен. При попытке использовать объект индекса, не существует или если индекс не установлен, при вызове [Seek](#seek), MFC создает исключение.  
  
 Можно создать новый индекс для таблицы путем вызова [CDaoTableDef::CreateIndex](../../mfc/reference/cdaotabledef-class.md#createindex) и Добавление нового индекса в коллекции индексов базовой tabledef путем вызова [CDaoTableDef::Append](../../mfc/reference/cdaotabledef-class.md#append)и повторно открыть набор записей.  
  
 Только с помощью индексов, определенных для базового tabledef можно заказать записей, возвращаемых recordset табличного типа. Чтобы отсортировать записи в ином порядке, можно открыть динамического или статического типа набора записей с использованием SQL **ORDERBY** предложение хранятся в [CDaoRecordset::m_strSort](#m_strsort).  
  
 Дополнительные сведения см. раздел «Объект индекса» и определение «текущий индекс» в справке DAO.  
  
##  <a name="setfielddirty"></a>CDaoRecordset::SetFieldDirty  
 Вызов этой функции-члена для флага члену данных поля в наборе записей, как измененные или как без изменений.  
  
```  
void SetFieldDirty(
    void* pv,  
    BOOL bDirty = TRUE);
```  
  
### <a name="parameters"></a>Параметры  
 `pv`  
 Содержит адрес члена данных поля в наборе записей или **NULL**. Если **NULL**, помечаются все члены данных полей в наборе записей. (C++ **NULL** не является таким же, как значение Null в терминологии связанных баз данных, что означает «необходимости нет значения».)  
  
 `bDirty`  
 **Значение TRUE,** должен быть помечен как «грязным» (измененного) члена данных поля. В противном случае **FALSE** должен быть помечен как «очистить» (без изменений) члена данных поля.  
  
### <a name="remarks"></a>Примечания  
 Пометка поля как неизмененные гарантирует, что поле не изменяется.  
  
 Метки framework изменить поля элементов данных, чтобы убедиться, что они будут записаны записи в источнике данных с помощью механизма обмена (DFX) полями записей DAO. Как правило, изменение значения поля задает поле «грязные» автоматически, поэтому редко нужно вызывать `SetFieldDirty` самостоятельно, но иногда может потребоваться убедитесь, что столбцы будут быть явным образом обновлены или вставлены независимо от того, какое значение члена данных поля. Механизм DFX также используются использование **PSEUDONULL**. Дополнительные сведения см. в разделе [CDaoFieldExchange::m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).  
  
 Если не используется механизм двойную буферизацию, изменив значение поля не задаются автоматически поля как «грязный». В этом случае будет необходимо явно задать поле как «грязный». Флаг, содержащихся в [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) управляет этого поля автоматической проверки.  
  
> [!NOTE]
>  Вызовите эту функцию-член, только после вызова [изменить](#edit) или [AddNew](#addnew).  
  
 С помощью **NULL** для первого аргумента функции будет применить функцию ко всем **outputColumn** поля не **param** в полях `CDaoFieldExchange`. Например вызов  
  
 [!code-cpp[NVC_MFCDatabase №&6;](../../mfc/codesnippet/cpp/cdaorecordset-class_6.cpp)]  
  
 установит только **outputColumn** полей для **NULL**; **param** полей не затрагиваются.  
  
 Для работы с **param**, необходимо указать фактический адрес отдельные **param** требуется для работы, такие как:  
  
 [!code-cpp[NVC_MFCDatabase&#7;](../../mfc/codesnippet/cpp/cdaorecordset-class_7.cpp)]  
  
 Это означает, что нельзя задать все **param** полей для **NULL**, как и с **outputColumn** полей.  
  
 `SetFieldDirty`реализуется с помощью `DoFieldExchange`.  
  
##  <a name="setfieldnull"></a>CDaoRecordset::SetFieldNull  
 Вызовите эту функцию-член пометки члену данных поля в наборе записей, как Null (в частности наличие никакого значения) или пустым.  
  
```  
void SetFieldNull(
    void* pv,  
    BOOL bNull = TRUE);
```  
  
### <a name="parameters"></a>Параметры  
 `pv`  
 Содержит адрес члена данных поля в наборе записей или **NULL**. Если **NULL**, помечаются все члены данных полей в наборе записей. (C++ **NULL** не является таким же, как значение Null в терминологии связанных баз данных, что означает «необходимости нет значения».)  
  
 `bNull`  
 Ненулевое значение, если член данных поля помечены как имеющие значение (Null) не. В противном случае — 0, если член поля данных помечен как отличных от Null.  
  
### <a name="remarks"></a>Примечания  
 `SetFieldNull`используется для полей, привязанных к `DoFieldExchange` механизм.  
  
 При добавлении новой записи в набор записей, все поля элементов данных изначально присвоено значение Null и помечен как «грязным» (измененного). При извлечении записи из источника данных, ее столбцов либо значения или уже имеют значение Null. Если это не подходят для поля значение Null, [CDaoException](../../mfc/reference/cdaoexception-class.md) возникает исключение.  
  
 При использовании механизм двойную буферизацию, например, при желании специально для назначения поля текущей записи как не имеющий значение, вызов `SetFieldNull` с `bNull` значение **TRUE** чтобы пометить его как Null. Если вы хотите ему присваивается значение поле ранее было помечено как Null, просто установите его новое значение. Необходимо удалить флаг Null с `SetFieldNull`. Чтобы определить, разрешено ли поле иметь значение Null, вызовите [IsFieldNullable](#isfieldnullable).  
  
 Если не используется механизм двойную буферизацию, измените значение поля не задается автоматически поля как «грязный» и отличных от Null. Необходимо специально установить поля «грязные» и отличных от Null. Флаг, содержащихся в [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) управляет этого поля автоматической проверки.  
  
 Использование использует механизм DFX **PSEUDONULL**. Дополнительные сведения см. в разделе [CDaoFieldExchange::m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).  
  
> [!NOTE]
>  Вызовите эту функцию-член, только после вызова [изменить](#edit) или [AddNew](#addnew).  
  
 С помощью **NULL** первый аргумент функции будет применяются только к функции **outputColumn** поля не **param** в полях `CDaoFieldExchange`. Например вызов  
  
 [!code-cpp[NVC_MFCDatabase №&8;](../../mfc/codesnippet/cpp/cdaorecordset-class_8.cpp)]  
  
 установит только **outputColumn** полей для **NULL**; **param** полей не затрагиваются.  
  
##  <a name="setfieldvalue"></a>CDaoRecordset::SetFieldValue  
 Вызовите эту функцию-член для задания значения поля, либо по порядковому номеру, либо путем изменения значения строки.  
  
```  
virtual void SetFieldValue(
    LPCTSTR lpszName,  
    const COleVariant& varValue);

 
virtual void SetFieldValue(
    int nIndex,  
    const COleVariant& varValue);

 
void SetFieldValue(
    LPCTSTR lpszName,  
    LPCTSTR lpszValue);

 
void SetFieldValue(
    int nIndex,  
    LPCTSTR lpszValue);
```  
  
### <a name="parameters"></a>Параметры  
 `lpszName`  
 Указатель на строку, содержащую имя поля.  
  
 `varValue`  
 Ссылку на [COleVariant](../../mfc/reference/colevariant-class.md) объект, содержащий значение поля.  
  
 `nIndex`  
 Целое число, представляющее порядковый номер поля в коллекцию полей набора записей (начиная с нуля).  
  
 `lpszValue`  
 Указатель на строку, содержащую значение поля.  
  
### <a name="remarks"></a>Примечания  
 Используйте `SetFieldValue` и [GetFieldValue](#getfieldvalue) динамически привязывать поля во время выполнения, а не статически привязки столбцов с помощью [DoFieldExchange](#dofieldexchange) механизм.  
  
 Обратите внимание, что если не создается записей Юникод, необходимо использовать либо форма `SetFieldValue` , не содержащий `COleVariant` параметр, или `COleVariant` объекта должны быть объявлены явно ANSI. Это можно сделать с помощью [COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** `lpszSrc` **,** `vtSrc` **)** форма конструктора с `vtSrc` значение `VT_BSTRT` (ANSI) или с помощью **COleVariant** функция [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** `lpszSrc` **,** `vtSrc` **)** с `vtSrc` значение `VT_BSTRT`.  
  
 Дополнительные сведения см. в разделах «Поле Object» и «Значение свойства» в справке DAO.  
  
##  <a name="setfieldvaluenull"></a>CDaoRecordset::SetFieldValueNull  
 Вызовите эту функцию-член, чтобы задать в поле значение Null.  
  
```  
void SetFieldValueNull(int nIndex);  
void SetFieldValueNull(LPCTSTR lpszName);
```  
  
### <a name="parameters"></a>Параметры  
 `nIndex`  
 Индекс поля в наборе записей, для поиска по индексу (с нуля).  
  
 `lpszName`  
 Имя поля в наборе записей, для поиска по имени.  
  
### <a name="remarks"></a>Примечания  
 C++ **NULL** не обязательно является Null, что в терминологии связанных баз данных, означает «необходимости нет значения».  
  
 Дополнительные сведения см. в разделах «Поле Object» и «Значение свойства» в справке DAO.  
  
##  <a name="setlockingmode"></a>CDaoRecordset::SetLockingMode  
 Вызовите эту функцию-член для задания типа блокировки для набора записей.  
  
```  
void SetLockingMode(BOOL bPessimistic);
```  
  
### <a name="parameters"></a>Параметры  
 *bPessimistic*  
 Флаг, указывающий тип блокировки.  
  
### <a name="remarks"></a>Примечания  
 При Пессимистическая блокировка действует, содержащий запись, вы изменяете страниц заблокирован сразу после вызова **изменить** функции-члена. Страницы разблокирован, при вызове **обновление** или **закрыть** функции-члена или любой из операций перемещения и поиска.  
  
 Если оптимистическая блокировка действует 2K страницу, содержащую запись блокируется только при обновлении записи с **обновление** функции-члена.  
  
 Если страница заблокирована, ни одному пользователю можно изменить записей на одной странице. При вызове метода `SetLockingMode` и передать ненулевое значение и другой пользователь уже заблокирован страницы, создается исключение при вызове **изменить**. Другие пользователи могут считывать данные из заблокированных страниц.  
  
 При вызове метода `SetLockingMode` с нулевым значением и более поздних версий, вызовите **обновление** хотя страница заблокирована другим пользователем, возникает исключение. Для просмотра изменений, внесенных другим пользователем для записи (и изменения потеряны), вызовите `SetBookmark` функция-член с значение текущей записи.  
  
 При работе с источниками данных ODBC, режим блокировки всегда является оптимистическим.  
  
##  <a name="setparamvalue"></a>CDaoRecordset::SetParamValue  
 Вызовите эту функцию-член для задания значения параметра в наборе записей во время выполнения.  
  
```  
virtual void SetParamValue(
    int nIndex,  
    const COleVariant& varValue);

 
virtual void SetParamValue(
    LPCTSTR lpszName,  
    const COleVariant& varValue);
```  
  
### <a name="parameters"></a>Параметры  
 `nIndex`  
 Числовая позиция параметра в коллекции параметров querydef.  
  
 `var`  
 Задаваемое значение; см. заметки.  
  
 `lpszName`  
 Имя параметра, значение которого требуется задать.  
  
### <a name="remarks"></a>Примечания  
 Параметр должна быть уже установлена как часть строки SQL набора записей. Параметр доступны по имени или позиции индекса в коллекции.  
  
 Укажите значение, которое задается как `COleVariant` объект. Сведения о настройке нужное значение и тип в вашей `COleVariant` объекта см. в разделе класса [COleVariant](../../mfc/reference/colevariant-class.md). Обратите внимание, что если вы не создаете набор записей ЮНИКОДА, `COleVariant` объекта должны быть объявлены явно ANSI. Это можно сделать с помощью [COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** `lpszSrc` **,** `vtSrc` **)** форма конструктора с `vtSrc` значение `VT_BSTRT` (ANSI) или с помощью **COleVariant** функция [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** `lpszSrc` **,** `vtSrc` **)** с `vtSrc` значение `VT_BSTRT`.  
  
##  <a name="setparamvaluenull"></a>CDaoRecordset::SetParamValueNull  
 Вызов этой функции-члена для присвойте параметру значение Null.  
  
```  
void SetParamValueNull(int nIndex);  
void SetParamValueNull(LPCTSTR lpszName);
```  
  
### <a name="parameters"></a>Параметры  
 `nIndex`  
 Индекс поля в наборе записей, для поиска по индексу (с нуля).  
  
 `lpszName`  
 Имя поля в наборе записей, для поиска по имени.  
  
### <a name="remarks"></a>Примечания  
 C++ **NULL** не обязательно является Null, что в терминологии связанных баз данных, означает «необходимости нет значения».  
  
##  <a name="setpercentposition"></a>CDaoRecordset::SetPercentPosition  
 Вызовите эту функцию-член значение изменяется Приблизительное расположение текущей записи в объекте набора записей на основе процента записей в наборе записей.  
  
```  
void SetPercentPosition(float fPosition);
```  
  
### <a name="parameters"></a>Параметры  
 *fPosition*  
 Число от 0 до 100.  
  
### <a name="remarks"></a>Примечания  
 При работе с динамического или статического типа записей, сначала заполнить набор записей, перемещая последней записи, перед вызовом метода `SetPercentPosition`. При вызове метода `SetPercentPosition` до полного заполнения набора записей, объем перемещаемых — по сравнению с числом записей, доступных, обозначенный значение [GetRecordCount](#getrecordcount). Вы может перейти к последней записи путем вызова `MoveLast`.  
  
 При вызове метода `SetPercentPosition`, текущей становится запись приблизительное позиции, соответствующий этому значению.  
  
> [!NOTE]
>  Вызов `SetPercentPosition` для перемещения текущей записи к определенной записи в наборе записей, не рекомендуется. Вызов [SetBookmark](#setbookmark) вместо этого функция-член.  
  
 Дополнительные сведения см. в разделе «PercentPosition свойство» в справке DAO.  
  
##  <a name="update"></a>CDaoRecordset::Update  
 Это функция-член вызывается после вызова `AddNew` или **изменить** функции-члена.  
  
```  
virtual void Update();
```  
  
### <a name="remarks"></a>Примечания  
 Этот вызов необходим для завершения `AddNew` или **изменить** операции.  
  
 Оба `AddNew` и **изменить** Подготовка буфера редактирования, в который помещается добавленных или измененных данных для сохранения в источнике данных. **Обновление** сохраняет данные. Обновляются только поля, помеченные или обнаружены изменения.  
  
 Если источник данных поддерживает транзакции, можно сделать **обновление** вызова (и соответствующего ему `AddNew` или **изменить** вызова) частью транзакции.  
  
> [!CAUTION]
>  При вызове метода **обновление** без предварительного вызова `AddNew` или **изменить**, **обновление** вызывает `CDaoException`. При вызове метода `AddNew` или **изменить**, необходимо вызвать **обновление** перед вызовом метода [MoveNext](#movenext) или закрыть соединение с источником данных или набора записей. В противном случае изменения будут утеряны без уведомления.  
  
 Объект recordset, заблокированной pessimistically в многопользовательской среде, запись остается заблокированным от времени **изменить** используется до завершения обновления. Если набор записей оптимистически заблокирован, запись заблокирована и по сравнению с предварительно измененной записи непосредственно перед его обновлением базы данных. Если запись была изменена с момента вызова **изменить**, **обновление** завершается с ошибкой и MFC создает исключение. Можно изменить режим блокировки с `SetLockingMode`.  
  
> [!NOTE]
>  Для внешней базы данных форматов, таких как ODBC и устанавливаемый ISAM всегда используется оптимистическая блокировка.  
  
 Дополнительные сведения см. в разделах «Метод AddNew», «Метод CancelUpdate», «Метод Delete», «Свойство LastModified», «Метод Update» и «EditMode свойство» в справке DAO.  
  
## <a name="see-also"></a>См. также  
 [CObject-класс](../../mfc/reference/cobject-class.md)   
 [Диаграмма иерархии](../../mfc/hierarchy-chart.md)   
 [Класс CDaoTableDef](../../mfc/reference/cdaotabledef-class.md)   
 [Класс CDaoWorkspace](../../mfc/reference/cdaoworkspace-class.md)   
 [Класс CDaoDatabase](../../mfc/reference/cdaodatabase-class.md)   
 [Класс CDaoQueryDef](../../mfc/reference/cdaoquerydef-class.md)

