---
title: "Класс CRecordset | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-cpp
ms.tgt_pltfrm: 
ms.topic: reference
f1_keywords:
- CRecordset
- AFXDB/CRecordset
- AFXDB/CRecordset::CRecordset
- AFXDB/CRecordset::AddNew
- AFXDB/CRecordset::CanAppend
- AFXDB/CRecordset::CanBookmark
- AFXDB/CRecordset::Cancel
- AFXDB/CRecordset::CancelUpdate
- AFXDB/CRecordset::CanRestart
- AFXDB/CRecordset::CanScroll
- AFXDB/CRecordset::CanTransact
- AFXDB/CRecordset::CanUpdate
- AFXDB/CRecordset::CheckRowsetError
- AFXDB/CRecordset::Close
- AFXDB/CRecordset::Delete
- AFXDB/CRecordset::DoBulkFieldExchange
- AFXDB/CRecordset::DoFieldExchange
- AFXDB/CRecordset::Edit
- AFXDB/CRecordset::FlushResultSet
- AFXDB/CRecordset::GetBookmark
- AFXDB/CRecordset::GetDefaultConnect
- AFXDB/CRecordset::GetDefaultSQL
- AFXDB/CRecordset::GetFieldValue
- AFXDB/CRecordset::GetODBCFieldCount
- AFXDB/CRecordset::GetODBCFieldInfo
- AFXDB/CRecordset::GetRecordCount
- AFXDB/CRecordset::GetRowsetSize
- AFXDB/CRecordset::GetRowsFetched
- AFXDB/CRecordset::GetRowStatus
- AFXDB/CRecordset::GetSQL
- AFXDB/CRecordset::GetStatus
- AFXDB/CRecordset::GetTableName
- AFXDB/CRecordset::IsBOF
- AFXDB/CRecordset::IsDeleted
- AFXDB/CRecordset::IsEOF
- AFXDB/CRecordset::IsFieldDirty
- AFXDB/CRecordset::IsFieldNull
- AFXDB/CRecordset::IsFieldNullable
- AFXDB/CRecordset::IsOpen
- AFXDB/CRecordset::Move
- AFXDB/CRecordset::MoveFirst
- AFXDB/CRecordset::MoveLast
- AFXDB/CRecordset::MoveNext
- AFXDB/CRecordset::MovePrev
- AFXDB/CRecordset::OnSetOptions
- AFXDB/CRecordset::OnSetUpdateOptions
- AFXDB/CRecordset::Open
- AFXDB/CRecordset::RefreshRowset
- AFXDB/CRecordset::Requery
- AFXDB/CRecordset::SetAbsolutePosition
- AFXDB/CRecordset::SetBookmark
- AFXDB/CRecordset::SetFieldDirty
- AFXDB/CRecordset::SetFieldNull
- AFXDB/CRecordset::SetLockingMode
- AFXDB/CRecordset::SetParamNull
- AFXDB/CRecordset::SetRowsetCursorPosition
- AFXDB/CRecordset::SetRowsetSize
- AFXDB/CRecordset::Update
- AFXDB/CRecordset::m_hstmt
- AFXDB/CRecordset::m_nFields
- AFXDB/CRecordset::m_nParams
- AFXDB/CRecordset::m_pDatabase
- AFXDB/CRecordset::m_strFilter
- AFXDB/CRecordset::m_strSort
dev_langs:
- C++
helpviewer_keywords:
- database records [C++]
- CRecordset class
- ODBC recordsets [C++], CRecordset objects
- sets of records [C++]
ms.assetid: dd89a21d-ef39-4aab-891b-1e373d67c855
caps.latest.revision: 23
author: mikeblome
ms.author: mblome
manager: ghogen
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
translationtype: Machine Translation
ms.sourcegitcommit: 0e0c08ddc57d437c51872b5186ae3fc983bb0199
ms.openlocfilehash: f7a05a5eefd6f55a68c6e9f1726dfb7c29f399f2
ms.lasthandoff: 02/24/2017

---
# <a name="crecordset-class"></a>Класс CRecordset
Представляет набор записей, выбранных из источника данных.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
class CRecordset : public CObject  
```  
  
## <a name="members"></a>Члены  
  
### <a name="public-constructors"></a>Открытые конструкторы  
  
|Имя|Описание|  
|----------|-----------------|  
|[CRecordset::CRecordset](#crecordset)|Создает объект `CRecordset`. Производного класса необходимо указать, вызывающий этот конструктор.|  
  
### <a name="public-methods"></a>Открытые методы  
  
|Имя|Описание|  
|----------|-----------------|  
|[CRecordset::AddNew](#addnew)|Подготавливает для добавления новой записи. Вызов `Update` для завершения добавления.|  
|[CRecordset::CanAppend](#canappend)|Возвращает ненулевое значение, если можно добавить новые записи в набор записей через `AddNew` функции-члена.|  
|[CRecordset::CanBookmark](#canbookmark)|Возвращает ненулевое значение, если набор записей поддерживает закладки.|  
|[CRecordset::Cancel](#cancel)|Отменяет асинхронную операцию или процесс из второго потока.|  
|[CRecordset::CancelUpdate](#cancelupdate)|Отменяет все отложенные обновления из-за `AddNew` или `Edit` операции.|  
|[CRecordset::CanRestart](#canrestart)|Возвращает ненулевое значение, если `Requery` можно вызвать, чтобы снова выполнить запрос набора записей.|  
|[CRecordset::CanScroll](#canscroll)|Возвращает ненулевое значение, если можно прокручивать записи.|  
|[CRecordset::CanTransact](#cantransact)|Возвращает ненулевое значение, если источник данных поддерживает транзакции.|  
|[CRecordset::CanUpdate](#canupdate)|Возвращает ненулевое значение, если можно обновить набор записей (можно добавить, обновить или удалить записи).|  
|[CRecordset::CheckRowsetError](#checkrowseterror)|Вызывается для обработки ошибок, возникающих при выполнении записи выборки.|  
|[CRecordset::Close](#close)|Закрывает набор записей и ODBC **HSTMT** связанные с ним.|  
|[CRecordset::Delete](#delete)|Удаляет текущую запись из набора записей. Явным образом, необходимо перейти к другой записи после удаления.|  
|[CRecordset::DoBulkFieldExchange](#dobulkfieldexchange)|Вызывается для обмена пакетов строк данных из источника данных в набор записей. Реализует блочный обмен полей записей (Bulk RFX).|  
|[CRecordset::DoFieldExchange](#dofieldexchange)|Вызывается для обмена данными (в обоих направлениях) между элементами данных полей набора записей и соответствующей записи в источнике данных. Реализует записи обмен (полями записей RFX).|  
|[CRecordset::Edit](#edit)|Подготавливает для изменения текущей записи. Вызов `Update` для завершения редактирования.|  
|[CRecordset::FlushResultSet](#flushresultset)|Возвращает ненулевое значение, если имеется другой результат, задайте для извлечения, при использовании предопределенного запроса.|  
|[CRecordset::GetBookmark](#getbookmark)|Присваивает значение записи объект параметра.|  
|[CRecordset::GetDefaultConnect](#getdefaultconnect)|Вызывается для получения строки подключения по умолчанию.|  
|[CRecordset::GetDefaultSQL](#getdefaultsql)|Вызывается, чтобы получить строку SQL по умолчанию для выполнения.|  
|[CRecordset::GetFieldValue](#getfieldvalue)|Возвращает значение поля в наборе записей.|  
|[CRecordset::GetODBCFieldCount](#getodbcfieldcount)|Возвращает число полей в наборе записей.|  
|[CRecordset::GetODBCFieldInfo](#getodbcfieldinfo)|Возвращает определенные виды информации о поля в наборе записей.|  
|[CRecordset::GetRecordCount](#getrecordcount)|Возвращает число записей в наборе записей.|  
|[CRecordset::GetRowsetSize](#getrowsetsize)|Возвращает число записей, которые вы хотите получать в ходе одной выборки.|  
|[CRecordset::GetRowsFetched](#getrowsfetched)|Возвращает фактическое число строк, полученных во время выборки.|  
|[CRecordset::GetRowStatus](#getrowstatus)|Возвращает состояние строки после выборки.|  
|[CRecordset::GetSQL](#getsql)|Возвращает строку SQL, используемую для выбора записей для набора записей.|  
|[CRecordset::GetStatus](#getstatus)|Возвращает состояние набора записей: индекс текущей записи и был ли получен окончательное количество записей.|  
|[CRecordset::GetTableName](#gettablename)|Возвращает имя таблицы, на которой основан набор записей.|  
|[CRecordset::IsBOF](#isbof)|Возвращает ненулевое значение, если набор записей был был размещен перед первой записью. Отсутствует запись текущей.|  
|[CRecordset::IsDeleted](#isdeleted)|Возвращает ненулевое значение, если набор записей располагается на удаленную запись.|  
|[CRecordset::IsEOF](#iseof)|Возвращает ненулевое значение, если набор записей расположенных после последней записи. Отсутствует запись текущей.|  
|[CRecordset::IsFieldDirty](#isfielddirty)|Возвращает ненулевое значение, если указанное поле в текущей записи был изменен.|  
|[CRecordset::IsFieldNull](#isfieldnull)|Возвращает ненулевое значение, если указанное поле в текущей записи имеет значение null (не имеет значения).|  
|[CRecordset::IsFieldNullable](#isfieldnullable)|Возвращает ненулевое значение, если указанное поле в текущей записи может быть присвоено значение null (значение не наличие).|  
|[CRecordset::IsOpen](#isopen)|Возвращает ненулевое значение, если `Open` был вызван ранее.|  
|[CRecordset::Move](#move)|Устанавливает набор записей на указанное число записей от текущей записи в любом направлении.|  
|[CRecordset::MoveFirst](#movefirst)|Помещает текущая запись на первой записи в наборе записей. Проверить `IsBOF` первой.|  
|[CRecordset::MoveLast](#movelast)|Помещает текущей записи на последней записи или последнего набора строк. Проверить `IsEOF` первой.|  
|[CRecordset::MoveNext](#movenext)|Помещает текущая запись на следующую запись или следующего набора строк. Проверить `IsEOF` первой.|  
|[CRecordset::MovePrev](#moveprev)|Помещает текущая запись на предыдущую запись или на предыдущих строк. Проверить `IsBOF` первой.|  
|[CRecordset::OnSetOptions](#onsetoptions)|Вызывается для задания параметров (используется для выбора) для указанной инструкции ODBC.|  
|[CRecordset::OnSetUpdateOptions](#onsetupdateoptions)|Вызывается для задания параметров (используется для обновления) для указанной инструкции ODBC.|  
|[CRecordset::Open](#open)|Получение таблицы или выполнять запрос, который представляет набор записей открывает набор записей.|  
|[CRecordset::RefreshRowset](#refreshrowset)|Обновляет данные и статус указанные строки.|  
|[Метод CRecordset::Requery](#requery)|Выполнение запроса набора записей еще раз, чтобы обновить выбранные записи.|  
|[CRecordset::SetAbsolutePosition](#setabsoluteposition)|Устанавливает набор записей на запись, соответствующая номер указанной записи.|  
|[CRecordset::SetBookmark](#setbookmark)|Устанавливает набор записей на записи, указанные на закладки.|  
|[CRecordset::SetFieldDirty](#setfielddirty)|Помечает указанного поля в текущей записи, как измененный.|  
|[CRecordset::SetFieldNull](#setfieldnull)|Задает значение указанного поля в текущей записи со значением null (значение не наличие).|  
|[CRecordset::SetLockingMode](#setlockingmode)|Задает режим блокировки «оптимистичный «блокировка (по умолчанию) или «пессимистической» блокировки. Определяет, как блокировки для обновления записей.|  
|[CRecordset::SetParamNull](#setparamnull)|Присваивает указанному параметру значение null (значение не наличие).|  
|[CRecordset::SetRowsetCursorPosition](#setrowsetcursorposition)|Помещает курсор на заданной строки в наборе строк.|  
|[CRecordset::SetRowsetSize](#setrowsetsize)|Указывает количество записей, которые вы хотите получить во время выборки.|  
|[CRecordset::Update](#update)|Завершает `AddNew` или `Edit` операции путем сохранения новых или измененных данных в источнике данных.|  
  
### <a name="public-data-members"></a>Открытые члены данных  
  
|Имя|Описание|  
|----------|-----------------|  
|[CRecordset::m_hstmt](#m_hstmt)|Содержит дескриптор инструкции ODBC для набора записей. Введите `HSTMT`.|  
|[CRecordset::m_nFields](#m_nfields)|Содержит количество элементов данных полей в наборе записей. Введите `UINT`.|  
|[CRecordset::m_nParams](#m_nparams)|Содержит количество элементов данных параметров в набор записей. Введите `UINT`.|  
|[CRecordset::m_pDatabase](#m_pdatabase)|Содержит указатель на `CDatabase` объект, через который набор записей подключен к источнику данных.|  
|[CRecordset::m_strFilter](#m_strfilter)|Содержит `CString` , указывающий язык структурированных запросов (SQL) `WHERE` предложения. Используется в качестве фильтра для выбора только те записи, которые удовлетворяют определенным критериям.|  
|[CRecordset::m_strSort](#m_strsort)|Содержит `CString` , указывающий SQL `ORDER BY` предложения. Используется для управления, порядок сортировки записей.|  
  
## <a name="remarks"></a>Примечания  
 Известный как «наборы данных», `CRecordset` объекты обычно используются в двух формах: динамические подмножества данных и моментальные снимки. Динамический набор остается синхронизированным с обновлениями данных, внесенных другими пользователями. Моментальный снимок является статическим представлением данных. Каждая форма представляет набор записей, фиксированных во время открытия набора записей, но во время перехода к записи в подмножества, отражает изменения, внесенные в запись впоследствии другими пользователями или другими наборами записей в приложении.  
  
> [!NOTE]
>  Если вы работаете с классами объектов доступа к данным (DAO), а не классы Open Database Connectivity (ODBC), используйте класс [CDaoRecordset](../../mfc/reference/cdaorecordset-class.md) вместо. Дополнительные сведения см. в статье [Обзор: программирования баз данных](../../data/data-access-programming-mfc-atl.md).  
  
 Работать независимо от типа набора записей, вы обычно наборов записей для конкретных приложений создайте класс, производный от `CRecordset`. В наборе записей выборка записей из источника данных, и после этого можно:  
  
-   Прокрутки записей.  
  
-   Обновление записей и указать режим блокировки.  
  
-   Фильтрация записей для ограничения записей происходит выбор из доступных в источнике данных.  
  
-   Сортировка набора записей.  
  
-   Параметризация набора записей можно изменить выбранный для него сведения, которые неизвестны до времени выполнения.  
  
 Чтобы использовать класс, откройте базу данных и создайте объект набора записей, передав конструктору указатель на `CDatabase` объект. Затем вызовите набора записей **откройте** функция-член, где можно указать, является ли объект динамический или статический. Вызов **откройте** выбирает данные из источника данных. После открытия объекта набора записей, используйте его члена функции и данные элементы для прокрутки записей и работать с ними. Доступные операции зависят от того, является ли объект динамический или статический обновляемые или только для чтения (это зависит от возможностей источника данных, Open Database Connectivity (ODBC)), и того, реализуется ли пакетная выборка строк. Для обновления записей, которые могут были изменены или добавлены с момента **откройте** вызова, вызывающие этот объект **Requery** функции-члена. Вызов объекта **закрыть** члена функции и уничтожить объект после завершения работы с его.  
  
 В производном `CRecordset` класса, записывать обмен (полями записей RFX) или блочный обмен полей записей (Bulk RFX) используется для поддержки чтения и обновления поля записи.  
  
 Дополнительные сведения о обмен полей записей и записи, см. в статьях [Обзор: программирования баз данных,](../../data/data-access-programming-mfc-atl.md), [записей (ODBC)](../../data/odbc/recordset-odbc.md), [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md), и [обмен полей записей (RFX)](../../data/odbc/record-field-exchange-rfx.md). Сосредоточиться на подмножества и моментальные снимки, см. в статьях [динамический набор](../../data/odbc/dynaset.md) и [снимка](../../data/odbc/snapshot.md).  
  
## <a name="inheritance-hierarchy"></a>Иерархия наследования  
 [CObject](../../mfc/reference/cobject-class.md)  
  
 `CRecordset`  
  
## <a name="requirements"></a>Требования  
 **Заголовок:** afxdb.h  
  
##  <a name="addnew"></a>CRecordset::AddNew  
 Подготавливает для добавления новой записи в таблицу.  
  
```  
virtual void AddNew();
```  
  
### <a name="remarks"></a>Примечания  
 Необходимо вызвать [Requery](#requery) функции-члена для просмотра вновь добавленной записи. Поля записи первоначально равно Null. (В терминологии связанных баз данных, значение Null означает «значение не установку» и не совпадает с **NULL** в C++.) Чтобы завершить операцию, необходимо вызвать [обновление](#update) функции-члена. **Обновление** сохраняет изменения в источнике данных.  
  
> [!NOTE]
>  Выборка строк реализована, нельзя вызвать `AddNew`. Это приведет к ошибочного утверждения. Хотя класс `CRecordset` не предоставляет механизма обновления пакетов строк данных, можно написать собственные функции с помощью функции API-интерфейса ODBC **SQLSetPos**. Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
 `AddNew`Подготавливает новую, пустую запись, с помощью элементов данных полей набора записей. После вызова метода `AddNew`, задать значения, которые должны в члены данных полей набора записей. (Необходимо вызвать [изменить](#edit) функции-члена для этой цели; используйте **изменить** только для существующих записей.) При последующем вызове **обновление**, измененные значения в поля элементов данных сохраняются в источнике данных.  
  
> [!CAUTION]
>  При переходе к новой записи перед вызовом метода **обновление**, теряется новой записи, а не предупреждение не выдается.  
  
 Если источник данных поддерживает транзакции, можно сделать ваш `AddNew` вызовов, часть транзакции. Дополнительные сведения о транзакциях см. класс [CDatabase](../../mfc/reference/cdatabase-class.md). Обратите внимание, что следует вызывать [CDatabase::BeginTrans](../../mfc/reference/cdatabase-class.md#begintrans) перед вызовом метода `AddNew`.  
  
> [!NOTE]
>  Для динамических подмножеств данных новые записи добавляются в набор записей в качестве последней записи. Добавленных записей не добавляются к моментальным снимкам; необходимо вызвать **Requery** для обновления набора записей.  
  
 Недопустимо для вызова `AddNew` для объекта recordset, **откройте** функции-члена не был вызван. Объект `CDBException` возникает при вызове метода `AddNew` для набора записей, который не может быть добавлен к. Можно определить, является ли набор записей обновляемым путем вызова [CanAppend](#canappend).  
  
 Дополнительные сведения см. в следующих статьях: [набор записей: как наборы записей обновления записей (ODBC)](../../data/odbc/recordset-how-recordsets-update-records-odbc.md), [набор записей: Добавление, обновление и удаление записей (ODBC)](../../data/odbc/recordset-adding-updating-and-deleting-records-odbc.md), и [транзакции (ODBC)](../../data/odbc/transaction-odbc.md).  
  
### <a name="example"></a>Пример  
 См. в статье [транзакции: выполнение транзакции в наборе записей (ODBC)](../../data/odbc/transaction-performing-a-transaction-in-a-recordset-odbc.md).  
  
##  <a name="canappend"></a>CRecordset::CanAppend  
 Определяет, позволяет ли ранее открытый набор записей для добавления новых записей.  
  
```  
BOOL CanAppend() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если набор записей разрешает добавление новых записей; в противном случае — 0. `CanAppend`Возвращает 0 при открытии набора записей, только для чтения.  
  
##  <a name="canbookmark"></a>CRecordset::CanBookmark  
 Определяет, является ли набор записей позволяет помечать записей с помощью закладок.  
  
```  
BOOL CanBookmark() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если набор записей поддерживает закладки; в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 Эта функция не зависит от **CRecordset::useBookmarks** параметр в `dwOptions` параметр [откройте](#open) функции-члена. `CanBookmark`Указывает ли данного драйвера ODBC и курсор типа поддержки закладок. **CRecordset::useBookmarks** ли закладки, будет доступен, если они поддерживаются.  
  
> [!NOTE]
>  Закладки не поддерживаются в наборы записей последовательного доступа.  
  
 Дополнительные сведения о закладок и навигации по набору записей см. в статьях [Recordset: закладки и абсолютные позиции (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md) и [набор записей: прокрутка (ODBC)](../../data/odbc/recordset-scrolling-odbc.md).  
  
##  <a name="cancel"></a>CRecordset::Cancel  
 Запросы, что источник данных отменить асинхронные операции или процесса из второго потока.  
  
```  
void Cancel();
```  
  
### <a name="remarks"></a>Примечания  
 Обратите внимание, что классы MFC ODBC больше не использовать асинхронную обработку; для выполнения асинхронной операции, необходимо непосредственно вызвать функцию ODBC API **SQLSetConnectOption**. Дополнительные сведения см. в разделе «Выполнение функции асинхронно» в *Руководство программиста ODBC SDK*.  
  
##  <a name="cancelupdate"></a>CRecordset::CancelUpdate  
 Отменяет все ожидающие обновления, вызванные [изменить](#edit) или [AddNew](#addnew) операции, прежде чем [обновления](#update) вызывается.  
  
```  
void CancelUpdate();
```  
  
### <a name="remarks"></a>Примечания  
  
> [!NOTE]
>  Эта функция-член не применим к наборы записей, в которых используется выборка строк, поскольку такие наборы записей не может вызвать **изменить**, `AddNew`, или **обновление**. Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
 Если включена проверка автоматического поля «грязный», `CancelUpdate` восстанавливаются значения, которые они имели до переменные-члены, **изменить** или `AddNew` был вызван; в противном случае, останется изменения значений. По умолчанию поле Автоматическая проверка включена при открытии набора записей. Чтобы отключить его, необходимо указать **CRecordset::noDirtyFieldCheck** в `dwOptions` параметр [откройте](#open) функции-члена.  
  
 Дополнительные сведения об обновлении данных см. в статье [набор записей: Добавление, обновление и удаление записей (ODBC)](../../data/odbc/recordset-adding-updating-and-deleting-records-odbc.md).  
  
##  <a name="canrestart"></a>CRecordset::CanRestart  
 Определяет, позволяет ли набор записей перезапуск его запроса (чтобы обновить свои записи) путем вызова **Requery** функции-члена.  
  
```  
BOOL CanRestart() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если разрешено обновление; в противном случае — 0.  
  
##  <a name="canscroll"></a>CRecordset::CanScroll  
 Определяет, позволяет ли прокрутка набора записей.  
  
```  
BOOL CanScroll() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если набор записей допускает прокрутку; в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 Дополнительные сведения о прокрутке см. в статье [набор записей: прокрутка (ODBC)](../../data/odbc/recordset-scrolling-odbc.md).  
  
##  <a name="cantransact"></a>CRecordset::CanTransact  
 Определяет, позволяет ли набор записей транзакций.  
  
```  
BOOL CanTransact() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если набор записей позволяет транзакции; в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 Дополнительные сведения см. в статье [транзакции (ODBC)](../../data/odbc/transaction-odbc.md).  
  
##  <a name="canupdate"></a>CRecordset::CanUpdate  
 Определяет, можно ли обновить набор записей.  
  
```  
BOOL CanUpdate() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если можно обновить набор записей; в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 Набор записей может быть только для чтения, если базовый источник данных доступен только для чтения, или при указании **CRecordset::readOnly** в `dwOptions` параметра при открытии набора записей.  
  
##  <a name="checkrowseterror"></a>CRecordset::CheckRowsetError  
 Вызывается для обработки ошибок, возникающих при выполнении записи выборки.  
  
```  
virtual void CheckRowsetError(RETCODE nRetCode);
```  
  
### <a name="parameters"></a>Параметры  
 `nRetCode`  
 Код возврата функции ODBC API. Дополнительные сведения см. в разделе "Заметки".  
  
### <a name="remarks"></a>Примечания  
 Это виртуальная функция-член обрабатывает ошибки, возникающие при записи получены, и используется во время выборка строк. Вы можете рассмотреть возможность переопределения `CheckRowsetError` для реализации обработки ошибок.  
  
 `CheckRowsetError`вызывается автоматически при выполнении операции навигации курсора, таких как **откройте**, **Requery**, или **перемещение** операции. Он передается возвращаемое значение функции API-интерфейса ODBC **SQLExtendedFetch**. В следующей таблице перечислены возможные значения для `nRetCode` параметр.  
  
|nRetCode|Описание|  
|--------------|-----------------|  
|**ЗНАЧЕНИЕ SQL_SUCCESS**|Функция успешно завершена; Дополнительные сведения недоступны.|  
|**SQL_SUCCESS_WITH_INFO**|Функция успешно завершена, возможно некритичные ошибки. Дополнительные сведения можно получить путем вызова **SQLError**.|  
|**SQL_NO_DATA_FOUND**|Будут выбраны все строки из результирующего набора.|  
|**ЗНАЧЕНИЕ SQL_ERROR**|Сбой функции. Дополнительные сведения можно получить путем вызова **SQLError**.|  
|**SQL_INVALID_HANDLE**|Сбой функции из-за дескриптора недопустимый среды, дескриптор подключения или дескриптор инструкции. Это указывает на программную ошибку. Дополнительные сведения недоступны из **SQLError**.|  
|`SQL_STILL_EXECUTING`|Функция, которая была запущена асинхронно по-прежнему выполняется. Обратите внимание, что по умолчанию MFC никогда не будет передавать значение `CheckRowsetError`; MFC будут по-прежнему вызова **SQLExtendedFetch** пока больше не возвращает `SQL_STILL_EXECUTING`.|  
  
 Дополнительные сведения о **SQLError**, в разделе [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]. Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
##  <a name="close"></a>CRecordset::Close  
 Закрытие набора записей.  
  
```  
virtual void Close();
```  
  
### <a name="remarks"></a>Примечания  
 ODBC **HSTMT** и всей памяти, освобождаются framework, выделенных для набора записей. Обычно после вызова метода **закрыть**, удалить объект recordset C++, если она была выделена с помощью **новый**.  
  
 Можно вызвать **откройте** снова после вызова метода **закрыть**. Это позволяет повторно использовать объект набора записей. Альтернативой является вызов **Requery**.  
  
### <a name="example"></a>Пример  
 [!code-cpp[NVC_MFCDatabase&17;](../../mfc/codesnippet/cpp/crecordset-class_1.cpp)]  
  
##  <a name="crecordset"></a>CRecordset::CRecordset  
 Создает объект `CRecordset`.  
  
```  
CRecordset(CDatabase* pDatabase = NULL);
```  
  
### <a name="parameters"></a>Параметры  
 `pDatabase`  
 Содержит указатель на `CDatabase` объект или значение **NULL**. Если не **NULL** и `CDatabase` объекта **откройте** функции-члена не был вызван соединиться с источником данных, набор записей попытается ее открыть автоматически во время свой собственный **откройте** вызова. Если передать **NULL**, `CDatabase` объект создается и подключение с использованием источника данных, указанного при производного класса набора записей с помощью классов.  
  
### <a name="remarks"></a>Примечания  
 Можно использовать либо `CRecordset` напрямую или являются производными от приложения класса из `CRecordset`. ClassWizard можно использовать для формирования классов набора записей.  
  
> [!NOTE]
>  Производный класс *необходимо* предоставить свой собственный конструктор. В конструкторе производного класса, вызовите конструктор `CRecordset::CRecordset`, передавая ему соответствующие параметры вместе.  
  
 Передайте **NULL** конструктор набора записей для `CDatabase` объект создается и автоматически подключены для вас. Это полезно сокращением, которое требуется для создания и подключения `CDatabase` объекта до создания набора записей.  
  
### <a name="example"></a>Пример  
 Дополнительные сведения см. в статье [набор записей: объявление класса для таблицы (ODBC)](../../data/odbc/recordset-declaring-a-class-for-a-table-odbc.md).  
  
##  <a name="delete"></a>CRecordset::Delete  
 Удаляет текущую запись.  
  
```  
virtual void Delete();
```  
  
### <a name="remarks"></a>Примечания  
 После успешного удаления, элементам данных полей устанавливаются в значение Null, и необходимо явно вызвать один из **перемещение** функции, чтобы отказаться от использования удаленной записи. После перемещения удаленные записи не можно вернуться к нему. Если источник данных поддерживает транзакции, можно сделать **удаление** вызовов, часть транзакции. Дополнительные сведения см. в статье [транзакции (ODBC)](../../data/odbc/transaction-odbc.md).  
  
> [!NOTE]
>  Выборка строк реализована, нельзя вызвать **удаление**. Это приведет к ошибочного утверждения. Хотя класс `CRecordset` не предоставляет механизма обновления пакетов строк данных, можно написать собственные функции с помощью функции API-интерфейса ODBC **SQLSetPos**. Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
> [!CAUTION]
>  Набор записей должен являться обновляемым и должен существовать допустимой записи текущего набора записей при вызове **удаление**; в противном случае, возникает ошибка. Например, если удалить запись, но не прокручиваются новой записи перед вызовом метода **удаление** , **удалить** вызывает [CDBException](../../mfc/reference/cdbexception-class.md).  
  
 В отличие от [AddNew](#addnew) и [изменить](#edit), вызов **удаление** не следуют вызов [обновление](#update). Если **удаление** вызов завершается неудачей, данные поля, элементы остаются без изменений.  
  
### <a name="example"></a>Пример  
 Этот пример набора записей, созданные на кадре функции. В примере предполагается существование `m_dbCust`, переменную-член типа `CDatabase` уже подключен к источнику данных.  
  
 [!code-cpp[NVC_MFCDatabase&18;](../../mfc/codesnippet/cpp/crecordset-class_2.cpp)]  
  
##  <a name="dobulkfieldexchange"></a>CRecordset::DoBulkFieldExchange  
 Вызывается для обмена пакетов строк данных из источника данных в набор записей. Реализует блочный обмен полей записей (Bulk RFX).  
  
```  
virtual void DoBulkFieldExchange(CFieldExchange* pFX);
```  
  
### <a name="parameters"></a>Параметры  
 `pFX`  
 Указатель на [разделе](../../mfc/reference/cfieldexchange-class.md) объекта. Платформа будет уже значение этого объекта для указания контекста для работы exchange поля.  
  
### <a name="remarks"></a>Примечания  
 При реализации выборка строк, платформа вызывает эту функцию-член автоматически передавать данные из источника данных для объекта набора записей. `DoBulkFieldExchange`также привязывает параметризованные члены данных, если таковые имеются, с местозаполнителями параметров в строке инструкции SQL для выбора набора записей.  
  
 Если выборка строк не реализована, платформа вызывает [DoFieldExchange](#dofieldexchange). Чтобы реализовать выборка строк, необходимо указать `CRecordset::useMultiRowFetch` параметр `dwOptions` параметр в [откройте](#open) функции-члена.  
  
> [!NOTE]
> `DoBulkFieldExchange`доступен только в том случае, если вы используете класс, производный от `CRecordset`. При создании объекта набора записей непосредственно из `CRecordset`, необходимо вызвать [GetFieldValue](#getfieldvalue) функции-члена для получения данных.  
  
 Блочный обмен полей записей (Bulk RFX) аналогичен обмен полями записей (RFX). Данные автоматически передаются из источника данных в объект набора записей. Тем не менее, нельзя вызвать `AddNew`, **изменить**, **удаление**, или **обновление** для передачи изменений в источнике данных. Класс `CRecordset` в настоящее время не предоставляет механизма обновления пакетов строк данных; тем не менее, можно написать собственные функции с помощью функции API-интерфейса ODBC **SQLSetPos**.  
  
 Обратите внимание, что ClassWizard не поддерживает блочный обмен полей записей; Таким образом, необходимо переопределить `DoBulkFieldExchange` вручную, вызовы функций Bulk RFX. Дополнительные сведения об этих функциях см. в разделе [функции обмена полями записей](../../mfc/reference/record-field-exchange-functions.md).  
  
 Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md). Дополнительные сведения см. в статье [обмен полей записей (RFX)](../../data/odbc/record-field-exchange-rfx.md).  
  
##  <a name="dofieldexchange"></a>CRecordset::DoFieldExchange  
 Вызывается для обмена данными (в обоих направлениях) между элементами данных полей набора записей и соответствующей записи в источнике данных. Реализует записи обмен (полями записей RFX).  
  
```  
virtual void DoFieldExchange(CFieldExchange* pFX);
```  
  
### <a name="parameters"></a>Параметры  
 `pFX`  
 Указатель на [разделе](../../mfc/reference/cfieldexchange-class.md) объекта. Платформа будет уже значение этого объекта для указания контекста для работы exchange поля.  
  
### <a name="remarks"></a>Примечания  
 Если выборка строк не реализуется, платформа вызывает эту функцию-член автоматически обмен данными между элементами данных полей объекта набора записей и соответствующих столбцов текущей записи в источнике данных. `DoFieldExchange`также привязывает параметризованные члены данных, если таковые имеются, с местозаполнителями параметров в строке инструкции SQL для выбора набора записей.  
  
 Если выборка строк реализована, платформа вызывает [DoBulkFieldExchange](#dobulkfieldexchange). Чтобы реализовать выборка строк, необходимо указать `CRecordset::useMultiRowFetch` параметр `dwOptions` параметр в [откройте](#open) функции-члена.  
  
> [!NOTE]
> `DoFieldExchange`доступен только в том случае, если вы используете класс, производный от `CRecordset`. При создании объекта набора записей непосредственно из `CRecordset`, необходимо вызвать [GetFieldValue](#getfieldvalue) функции-члена для получения данных.  
  
 Обмен данными полей, называется обмен полями записей (RFX) работает в обоих направлениях: от элементов данных полей объекта набора записей в поля записи в источнике данных и записи в источнике данных в объект набора записей.  
  
 Только действие, обычно необходимо выполнить для реализации `DoFieldExchange` для набора записей производный класс является создание класса с помощью классов и укажите имена и типы данных элементов данных полей. Можно также добавить код, что записывает классов для указания элементов данных параметров или иметь дело с любой динамическая привязка столбцов. Дополнительные сведения см. в статье [набор записей: динамически привязки данных столбцов (ODBC)](../../data/odbc/recordset-dynamically-binding-data-columns-odbc.md).  
  
 При объявлении класса производного набора записей с помощью классов, мастер создает переопределение метода `DoFieldExchange` , который напоминает приведенный ниже:  
  
 [!code-cpp[NVC_MFCDatabase&19;](../../mfc/codesnippet/cpp/crecordset-class_3.cpp)]  
  
 Дополнительные сведения о функциях RFX см. в разделе [функции обмена полями записей](../../mfc/reference/record-field-exchange-functions.md).  
  
 Дополнительные примеры и сведения о `DoFieldExchange`, см. в статье [обмен полями записей: принцип работы RFX](../../data/odbc/record-field-exchange-how-rfx-works.md). Общие сведения о RFX см. в статье [обмен полями записей](../../data/odbc/record-field-exchange-rfx.md).  
  
##  <a name="edit"></a>CRecordset::Edit  
 Позволяет вносить изменения в текущей записи.  
  
```  
virtual void Edit();
```  
  
### <a name="remarks"></a>Примечания  
 После вызова метода **изменить**, элементами данных полей можно изменить непосредственно сбросив их значения. При последующем вызове завершения операции [обновление](#update) функции-члена для сохранения изменений в источнике данных.  
  
> [!NOTE]
>  Выборка строк реализована, нельзя вызвать **изменить**. Это приведет к ошибочного утверждения. Хотя класс `CRecordset` не предоставляет механизма обновления пакетов строк данных, можно написать собственные функции с помощью функции API-интерфейса ODBC **SQLSetPos**. Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
 **Изменить** сохраняет значения членов данных набора записей. При вызове метода **изменить**, внесите изменения, затем вызовите **изменить** , восстанавливаются значения записи он находился перед первым **изменить** вызова.  
  
 В некоторых случаях может потребоваться обновить столбец, делая Null (содержащий нет данных). Для этого нужно вызвать [метод SetFieldNull](#setfieldnull) с параметром **TRUE** пометить поле Null; это также вызовет обновляемого столбца. Если необходимо добавить поле к записи в источнике данных, несмотря на то, что его значение не изменилось, вызовите метод [SetFieldDirty](#setfielddirty) с параметром **TRUE**. Это работает, даже если оно имело значение Null.  
  
 Если источник данных поддерживает транзакции, можно сделать **изменить** вызовов, часть транзакции. Обратите внимание, что следует вызывать [CDatabase::BeginTrans](../../mfc/reference/cdatabase-class.md#begintrans) перед вызовом метода **изменить** и после открытия набора записей. Также Обратите внимание, что вызов [CDatabase::CommitTrans](../../mfc/reference/cdatabase-class.md#committrans) не является заменой вызова **обновление** для завершения **изменить** операции. Дополнительные сведения о транзакциях см. класс [CDatabase](../../mfc/reference/cdatabase-class.md).  
  
 В зависимости от текущего режима блокировки обновляемой записи может быть заблокирован **изменить** до вызова метода **обновление** или прокрутки к другой записи или может быть заблокирована только во время **изменить** вызова. Можно изменить режим блокировки с [SetLockingMode](#setlockingmode).  
  
 При переходе к новой записи до вызова метода восстанавливается предыдущее значение текущей записи **обновление**. Объект `CDBException` возникает при вызове метода **изменить** для записей, который не может быть обновлен или текущая запись.  
  
 Дополнительные сведения см. в статьях [транзакции (ODBC)](../../data/odbc/transaction-odbc.md) и [набор записей: Блокировка записей (ODBC)](../../data/odbc/recordset-locking-records-odbc.md).  
  
### <a name="example"></a>Пример  
 [!code-cpp[NVC_MFCDatabase&20;](../../mfc/codesnippet/cpp/crecordset-class_4.cpp)]  
  
##  <a name="flushresultset"></a>CRecordset::FlushResultSet  
 Извлекает следующий набор результатов из предопределенного запроса (хранимой процедуры), если существует несколько результирующих наборов.  
  
```  
BOOL FlushResultSet();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если имеются дополнительные результирующие наборы, требуется получить; в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 Следует вызвать `FlushResultSet` только по окончании полностью с курсором на текущем результирующем наборе. Обратите внимание, что при извлечении к следующему результирующему набору, вызвав `FlushResultSet`, курсор не является допустимым для этого результирующего набора; следует вызывать [MoveNext](#movenext) после вызова функции-члена `FlushResultSet`.  
  
 Если предопределенного запроса используется выходной параметр или входные и выходные параметры, необходимо вызвать `FlushResultSet` до его возврата `FALSE` (значение 0), чтобы получить эти значения параметров.  
  
 `FlushResultSet`вызывает функцию ODBC API `SQLMoreResults`. Если `SQLMoreResults` возвращает `SQL_ERROR` или `SQL_INVALID_HANDLE`, затем `FlushResultSet` будет выдано исключение. Дополнительные сведения о `SQLMoreResults`, в разделе [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
 Хранимой процедуре необходимо привязаны поля, если вы хотите вызвать `FlushResultSet`.  
  
### <a name="example"></a>Пример  
 В следующем коде предполагается, что `COutParamRecordset` — `CRecordset`-производного объекта на основании предопределенного запроса с входным и выходным параметром и наличие нескольких результирующих наборов. Обратите внимание, структура [DoFieldExchange](#dofieldexchange) переопределить.  
  
 [!code-cpp[NVC_MFCDatabase&#21;](../../mfc/codesnippet/cpp/crecordset-class_5.cpp)]  
  
 [!code-cpp[NVC_MFCDatabase&#22;](../../mfc/codesnippet/cpp/crecordset-class_6.cpp)]  
  
##  <a name="getbookmark"></a>CRecordset::GetBookmark  
 Получает значение закладки для текущей записи.  
  
```  
void GetBookmark(CDBVariant& varBookmark);
```  
  
### <a name="parameters"></a>Параметры  
 `varBookmark`  
 Ссылку на [CDBVariant](../../mfc/reference/cdbvariant-class.md) объект, представляющий закладку на текущей записи.  
  
### <a name="remarks"></a>Примечания  
 Чтобы определить, поддерживаются ли закладки для объекта recordset, вызовите [CanBookmark](#canbookmark). Для закладки сделать доступным, если они поддерживаются, необходимо установить **CRecordset::useBookmarks** параметр в `dwOptions` параметр [откройте](#open) функции-члена.  
  
> [!NOTE]
>  Если закладок не поддерживается или недоступен, вызов `GetBookmark` приведет к возникновению исключения. Закладки не поддерживаются в наборы записей последовательного доступа.  
  
 `GetBookmark`присваивает значение закладки для текущей записи `CDBVariant` объекта. Чтобы вернуться к этой записи в любое время после перехода к другой записи, вызовите [SetBookmark](#setbookmark) с соответствующим `CDBVariant` объекта.  
  
> [!NOTE]
>  После проведения определенных операций набора записей закладки больше не могут быть допустимы. Например, при вызове `GetBookmark` следуют **Requery**, вы не сможете вернуться к записи с `SetBookmark`. Вызов [CDatabase::GetBookmarkPersistence](../../mfc/reference/cdatabase-class.md#getbookmarkpersistence) для проверки, можно ли безопасно вызов `SetBookmark`.  
  
 Дополнительные сведения о закладок и навигации по набору записей см. в статьях [Recordset: закладки и абсолютные позиции (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md) и [набор записей: прокрутка (ODBC)](../../data/odbc/recordset-scrolling-odbc.md).  
  
##  <a name="getdefaultconnect"></a>CRecordset::GetDefaultConnect  
 Вызывается для получения строки подключения по умолчанию.  
  
```  
virtual CString GetDefaultConnect();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Объект `CString` , содержащий строку соединения по умолчанию.  
  
### <a name="remarks"></a>Примечания  
 Платформа вызывает эту функцию-член для получения строки подключения по умолчанию для источника данных, на котором основан набор записей. ClassWizard реализует эту функцию можно, указав тот же источник данных, используемого в классов для получения сведений о таблицах и столбцах. Вам будет, вероятно, будет удобнее полагаться на это подключение по умолчанию при разработке приложения. Но подключения по умолчанию может не подходить для пользователей приложения. Если это так, следует воссоздать эту функцию удаления классов в версии. Дополнительные сведения о строках соединения см. в статье [источников данных (DSN)](../../data/odbc/data-source-odbc.md).  
  
##  <a name="getdefaultsql"></a>CRecordset::GetDefaultSQL  
 Вызывается, чтобы получить строку SQL по умолчанию для выполнения.  
  
```  
virtual CString GetDefaultSQL();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Объект `CString` , содержащий инструкцию SQL по умолчанию.  
  
### <a name="remarks"></a>Примечания  
 Платформа вызывает эту функцию-член для получения оператора SQL по умолчанию, лежащие в основе набора записей. Это может быть имя таблицы или SQL **ВЫБЕРИТЕ** инструкции.  
  
 Косвенно определить инструкцию SQL по умолчанию путем объявления класса набора записей с помощью классов и ClassWizard выполняет эту задачу за вас.  
  
 Если требуется строка инструкции SQL для собственного использования, вызвать `GetSQL`, которая возвращает инструкцию SQL, используемую для выбора записей набора записей, когда он был открыт. Можно изменить строку SQL по умолчанию в ваш класс переопределение `GetDefaultSQL`. Например, можно указать вызов предопределенного запроса с помощью **ВЫЗОВ** инструкции. (Обратите внимание, однако, если изменить `GetDefaultSQL`, необходимо также изменить `m_nFields` соответствует количеству столбцов в источнике данных.)  
  
 Дополнительные сведения см. в статье [набор записей: объявление класса для таблицы (ODBC)](../../data/odbc/recordset-declaring-a-class-for-a-table-odbc.md).  
  
> [!CAUTION]
>  Имя таблицы будет пустым, если платформа не удалось определить имя таблицы, если указано несколько имен таблиц или **ВЫЗОВ** инструкция не может быть интерпретирован. Обратите внимание, что при использовании **вызвать** инструкции, не должен вставить пробел между фигурными скобками и **вызвать** ключевое слово, и не следует вставлять пробелы перед фигурная скобка или перед **ВЫБЕРИТЕ** ключевое слово в **ВЫБЕРИТЕ** инструкции.  
  
##  <a name="getfieldvalue"></a>CRecordset::GetFieldValue  
 Извлекает данные поля в текущей записи.  
  
```  
void GetFieldValue(
    LPCTSTR lpszName,  
    CDBVariant& varValue,  
    short nFieldType = DEFAULT_FIELD_TYPE);

 
void GetFieldValue(
    short nIndex,  
    CDBVariant& varValue,  
    short nFieldType = DEFAULT_FIELD_TYPE);

 
void GetFieldValue(
    short nIndex,  
    CStringA& strValue);

 
void GetFieldValue(
    short nIndex,  
    CStringW& strValue);
```  
  
### <a name="parameters"></a>Параметры  
 `lpszName`  
 Имя поля.  
  
 *varValu*e  
 Ссылку на [CDBVariant](../../mfc/reference/cdbvariant-class.md) объекта, в которой будут храниться в поле значение.  
  
 `nFieldType`  
 Тип данных ODBC C поля. Используется значение по умолчанию **DEFAULT_FIELD_TYPE**, принудительно `GetFieldValue` для определения типа данных C из типа данных SQL на основе приведенной ниже таблице. В противном случае можно указать данные непосредственно введите или выберите совместимый тип данных; Например, можно хранить любого типа данных в **SQL_C_CHAR**.  
  
|Тип данных C|Тип данных SQL|  
|-----------------|-------------------|  
|**SQL_C_BIT**|**SQL_BIT**|  
|**SQL_C_UTINYINT**|**SQL_TINYINT**|  
|**SQL_C_SSHORT**|**SQL_SMALLINT**|  
|**SQL_C_SLONG**|**SQL_INTEGER**|  
|**SQL_C_FLOAT**|**SQL_REAL**|  
|**SQL_C_DOUBLE**|**SQL_FLOATSQL_DOUBLE**|  
|**SQL_C_TIMESTAMP**|**SQL_DATESQL_TIMESQL_TIMESTAMP**|  
|**SQL_C_CHAR**|**SQL_NUMERICSQL_DECIMALSQL_BIGINTSQL_CHARSQL_VARCHARSQL_LONGVARCHAR**|  
|**SQL_C_BINARY**|**SQL_BINARYSQL_VARBINARYSQL_LONGVARBINARY**|  
  
 Дополнительные сведения о типах данных ODBC см. в разделах «Типы данных SQL» и «Типы данных C» в приложении D [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
 `nIndex`  
 Отсчитываемый от нуля индекс поля.  
  
 `strValue`  
 Ссылку на [CString](../../atl-mfc-shared/reference/cstringt-class.md) объекта, в которой будут храниться в поле значение преобразуется в текст, независимо от типа данных поля.  
  
### <a name="remarks"></a>Примечания  
 Поля можно искать по имени или по индексу. Значение поля можно хранить в любом `CDBVariant` объекта или `CString` объекта.  
  
 Если выборка строк реализована, текущая запись всегда располагается на первой записи в наборе строк. Для использования `GetFieldValue` записи в рамках определенного набора строк, необходимо вызвать [SetRowsetCursorPosition](#setrowsetcursorposition) функцию-член, чтобы переместить курсор в нужную строку в пределах данного набора строк. Затем вызовите `GetFieldValue` для этой строки. Чтобы реализовать выборка строк, необходимо указать `CRecordset::useMultiRowFetch` параметр `dwOptions` параметр в [откройте](#open) функции-члена.  
  
 Можно использовать `GetFieldValue` для динамического извлечения полей во время выполнения, а не их статически привязки во время разработки. Например, если был объявлен непосредственно из объекта набора записей `CRecordset`, необходимо использовать `GetFieldValue` для извлечения полей данных; обмен полями записей (RFX) или блочный обмен полей записей (Bulk RFX), не реализованы.  
  
> [!NOTE]
>  При объявлении объекта набора записей не на основе `CRecordset`, не имеют загрузки библиотеки курсоров ODBC. Библиотека курсоров требует, чтобы набор записей по крайней мере один связанный столбец; Тем не менее, при использовании `CRecordset` связаны напрямую, ни один из столбцов. Функции-члены [CDatabase::OpenEx](../../mfc/reference/cdatabase-class.md#openex) и [CDatabase::Open](../../mfc/reference/cdatabase-class.md#open) управления, будут ли загружать библиотеку курсоров.  
  
 `GetFieldValue`вызывает функцию ODBC API **SQLGetData**. Если драйвер выдает значение **SQL_NO_TOTAL** в течение фактическое значение поля `GetFieldValue` приводит к возникновению исключения. Дополнительные сведения о **SQLGetData**, в разделе [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
### <a name="example"></a>Пример  
 В следующем примере кода показано, как `GetFieldValue` для объекта набора записей, объявленные непосредственно из `CRecordset`.  
  
 [!code-cpp[NVC_MFCDatabase&#23;](../../mfc/codesnippet/cpp/crecordset-class_7.cpp)]  
  
> [!NOTE]
>  В отличие от классов DAO `CDaoRecordset`, `CRecordset` не поддерживает `SetFieldValue` функцию-член. При создании объекта напрямую из `CRecordset`, он фактически только для чтения.  
  
 Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
##  <a name="getodbcfieldcount"></a>CRecordset::GetODBCFieldCount  
 Получает общее количество полей объекта набора записей.  
  
```  
short GetODBCFieldCount() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Число полей в наборе записей.  
  
### <a name="remarks"></a>Примечания  
 Дополнительные сведения о создании наборов записей см. в статье [набор записей: Создание и закрытие наборов записей (ODBC)](../../data/odbc/recordset-creating-and-closing-recordsets-odbc.md).  
  
##  <a name="getodbcfieldinfo"></a>CRecordset::GetODBCFieldInfo  
 Получает сведения о полях в набор записей.  
  
```  
void GetODBCFieldInfo(
    LPCTSTR lpszName,  
    CODBCFieldInfo& fieldinfo);

 
void GetODBCFieldInfo(
    short nIndex,  
    CODBCFieldInfo& fieldinfo);
```  
  
### <a name="parameters"></a>Параметры  
 `lpszName`  
 Имя поля.  
  
 `fieldinfo`  
 Ссылку на `CODBCFieldInfo` структуры.  
  
 `nIndex`  
 Отсчитываемый от нуля индекс поля.  
  
### <a name="remarks"></a>Примечания  
 Одна версия функции позволяет искать поле по имени. Другая версия позволяет искать поле по индексу.  
  
 Описание сведений, возвращаемых в разделе [CODBCFieldInfo](../../mfc/reference/codbcfieldinfo-structure.md) структуры.  
  
 Дополнительные сведения о создании наборов записей см. в статье [набор записей: Создание и закрытие наборов записей (ODBC)](../../data/odbc/recordset-creating-and-closing-recordsets-odbc.md).  
  
##  <a name="getrecordcount"></a>CRecordset::GetRecordCount  
 Определяет размер набора записей.  
  
```  
long GetRecordCount() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Число записей в наборе записей; 0, если набор записей не содержит записей; или -1, если число записей не может быть определено.  
  
### <a name="remarks"></a>Примечания  
  
> [!CAUTION]
>  Число записей как «верхнего предела, «запись с наибольшим номером еще видно при перемещении по записям. Общее число записей известен только после пользователь был перемещен за пределы последней записи. Для повышения производительности, счетчик не обновляется при вызове `MoveLast`. Чтобы подсчитать записи самостоятельно, вызовите `MoveNext` пока `IsEOF` возвращает ненулевое значение. Добавление записи через **CRecordset:AddNew** и **обновление** увеличивает счетчик; удаление записи через `CRecordset::Delete` уменьшает значение счетчика.  
  
##  <a name="getrowsetsize"></a>CRecordset::GetRowsetSize  
 Получает текущее значение для числа строк, которые вы хотите получить во время операции выборки.  
  
```  
DWORD GetRowsetSize() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Число строк для получения во время операции выборки.  
  
### <a name="remarks"></a>Примечания  
 Если используется выборка строк, размер набора строк по умолчанию при открытии набора записей — 25. в противном случае —-1.  
  
 Чтобы реализовать выборка строк, необходимо указать `CRecordset::useMultiRowFetch` параметр в `dwOptions` параметр [откройте](#open) функции-члена. Чтобы изменить параметр размера набора строк, вызвать [SetRowsetSize](#setrowsetsize).  
  
 Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
##  <a name="getrowsfetched"></a>CRecordset::GetRowsFetched  
 Определяет, сколько записей было в действительности извлечено после выборки.  
  
```  
DWORD GetRowsFetched() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Число строк, полученных из источника данных после операции выборки.  
  
### <a name="remarks"></a>Примечания  
 Это полезно при реализации выборка строк. Размер набора строк обычно указывает, сколько строк будет получен из выборки; Однако общее число строк в наборе записей также влияет на сколько строк будет получен в наборе строк. Например, если набор записей содержит 10 записей по размер набора строк, равным 4, затем обход набора записей путем вызова `MoveNext` приведет к окончательного набора строк, наличие только двух записей.  
  
 Чтобы реализовать выборка строк, необходимо указать `CRecordset::useMultiRowFetch` параметр в `dwOptions` параметр [откройте](#open) функции-члена. Чтобы определить размер набора строк, вызовите [SetRowsetSize](#setrowsetsize).  
  
 Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
### <a name="example"></a>Пример  
 [!code-cpp[NVC_MFCDatabase&#24;](../../mfc/codesnippet/cpp/crecordset-class_8.cpp)]  
  
##  <a name="getrowstatus"></a>CRecordset::GetRowStatus  
 Получает состояние для строки в текущем наборе строк.  
  
```  
WORD GetRowStatus(WORD wRow) const;  
```  
  
### <a name="parameters"></a>Параметры  
 `wRow`  
 Единицы позиция строки в текущем наборе строк. Это значение находится в диапазоне от 1 до размера набора строк.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Значение состояния для строки. Дополнительные сведения см. в разделе "Заметки".  
  
### <a name="remarks"></a>Примечания  
 `GetRowStatus`Возвращает значение, указывающее, любое изменение в состоянии, чтобы строка с момента его последнего, полученных из источника данных, или нет соответствующей строки в `wRow` , которые были выбраны. В следующей таблице перечислены возможные возвращаемые значения.  
  
|Значение состояния|Описание|  
|------------------|-----------------|  
|`SQL_ROW_SUCCESS`|Строка не изменяется.|  
|`SQL_ROW_UPDATED`|Строка была обновлена.|  
|`SQL_ROW_DELETED`|Строка была удалена.|  
|`SQL_ROW_ADDED`|Строка была добавлена.|  
|`SQL_ROW_ERROR`|Строки не удается извлечь из-за ошибки.|  
|`SQL_ROW_NOROW`|Нет строк, соответствующий `wRow`.|  
  
 Дополнительные сведения см. в разделе функции ODBC API **SQLExtendedFetch** в [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
##  <a name="getstatus"></a>CRecordset::GetStatus  
 Определяет индекс текущей записи в набор записей и наблюдалась ли последней записи.  
  
```  
void GetStatus(CRecordsetStatus& rStatus) const;  
```  
  
### <a name="parameters"></a>Параметры  
 `rStatus`  
 Ссылку на **CRecordsetStatus** объекта. Дополнительные сведения см. в разделе "Примечания".  
  
### <a name="remarks"></a>Примечания  
 `CRecordset`пытается отслеживать индекс, но в некоторых случаях это может быть невозможно. В разделе [GetRecordCount](#getrecordcount) объяснение.  
  
 **CRecordsetStatus** структура имеет следующий вид:  
  
 `struct CRecordsetStatus`  
  
 `{`  
  
 `long m_lCurrentRecord;`  
  
 `BOOL m_bRecordCountFinal;`  
  
 `};`  
  
 Два члена **CRecordsetStatus** имеют следующий смысл:  
  
- **m_lCurrentRecord** содержит отсчитываемый от нуля индекс текущей записи в наборе записей, если он известен. Если индекс не может определить, этот член содержит **AFX_CURRENT_RECORD_UNDEFINED** – (2). Если `IsBOF` — **TRUE** (пустой набор записей или попытка просмотра до первой записи), затем **m_lCurrentRecord** равен **AFX_CURRENT_RECORD_BOF** (–&1;). Если на первой записи, затем он равен 0, второй записи 1 и так далее.  
  
- **m_bRecordCountFinal** ненулевое значение, если было определено общее число записей в наборе записей. Обычно это необходимо сделать, начиная с первого набора записей и вызов `MoveNext` до `IsEOF` возвращает ненулевое значение. Если этот элемент равен нулю, запись числа, возвращенный `GetRecordCount`, если только «максимального уровня» число записей не –&1;.  
  
##  <a name="getsql"></a>CRecordset::GetSQL  
 Вызовите эту функцию-член для получения инструкции SQL, который использовался для выбора записей набора записей, если он был открыт.  
  
```  
const CString& GetSQL() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Объект **const** ссылку на `CString` , содержащий инструкции SQL.  
  
### <a name="remarks"></a>Примечания  
 Обычно это будет SQL **ВЫБЕРИТЕ** инструкции. Строка, возвращаемая функцией `GetSQL` доступно только для чтения.  
  
 Строка, возвращаемая функцией `GetSQL` обычно отличается от любой строки переданы в набор записей в `lpszSQL` параметр **откройте** функции-члена. Это, поскольку набор записей создает полная инструкция SQL, в зависимости от того, передается в **откройте**, указанный с помощью классов, как указано в **m_strFilter** и `m_strSort` элементы данных, а также параметры, может быть указано. Сведения о как набор записей создает Эта инструкция SQL в статье [набор записей: как наборы записей выберите записей (ODBC)](../../data/odbc/recordset-how-recordsets-select-records-odbc.md).  
  
> [!NOTE]
>  Это функция-член вызывается только после вызова метода [откройте](#open).  
  
##  <a name="gettablename"></a>CRecordset::GetTableName  
 Возвращает имя таблицы SQL, на котором основан запрос набора записей.  
  
```  
const CString& GetTableName() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Объект **const** ссылку на `CString` , содержащую таблицу, имя, если набор записей, в зависимости от таблицы, в противном случае — пустая строка.  
  
### <a name="remarks"></a>Примечания  
 `GetTableName`допустимо, только если набор записей основан на таблице, без объединения нескольких таблиц или предопределенного запроса (хранимой процедуры). Имя доступно только для чтения.  
  
> [!NOTE]
>  Это функция-член вызывается только после вызова метода [откройте](#open).  
  
##  <a name="isbof"></a>CRecordset::IsBOF  
 Возвращает ненулевое значение, если набор записей был был размещен перед первой записью. Отсутствует запись текущей.  
  
```  
BOOL IsBOF() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если набор записей не содержит записей или прокручен назад перед первой записью; в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 Вызов функции-члена до перехода от записи к записи, чтобы узнать, является ли Вы завершили перед первой записью в наборе записей. Можно также использовать `IsBOF` вместе с `IsEOF` для определения набора записей содержит только записи, или является пустым. Сразу после вызова **откройте**, если набор записей не содержит записей, `IsBOF` возвращает ненулевое значение. При открытии набора записей, имеет по крайней мере одну запись, первая запись становится текущей записью и `IsBOF` возвращает 0.  
  
 Если первая запись становится текущей записью и вызывается `MovePrev`, `IsBOF` впоследствии возвращает ненулевое значение. Если `IsBOF` возвращает ненулевое значение, при вызове метода `MovePrev`, возникает ошибка. Если `IsBOF` возвращает ненулевое значение, текущая запись не определена, и любое действие, которое требует текущей записи приведет к ошибке.  
  
### <a name="example"></a>Пример  
 В этом примере используется `IsBOF` и `IsEOF` для определения границ набора записей, как код выполняет прокрутку записей в обоих направлениях.  
  
 [!code-cpp[NVC_MFCDatabase&#25;](../../mfc/codesnippet/cpp/crecordset-class_9.cpp)]  
  
##  <a name="isdeleted"></a>CRecordset::IsDeleted  
 Определяет, была ли текущая запись удалена.  
  
```  
BOOL IsDeleted() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если набор записей располагается на удаленную запись; в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 Если прокрутить записи и `IsDeleted` возвращает **TRUE** (не равен нулю), затем вы должны перейти к другой записи перед тем как выполнять никакие другие операции набора записей.  
  
 Результат `IsDeleted` , зависит от многих факторов, таких как типа записей, ли набор записей обновляемым, является ли указанный **CRecordset::skipDeletedRecords** параметр при набор записей, открыт ли своих пакетов драйверов удаленных записей, и нужно ли несколько пользователей.  
  
 Дополнительные сведения о **CRecordset::skipDeletedRecords** и упаковки, драйвер [откройте](#open) функции-члена.  
  
> [!NOTE]
>  Если вы реализовали выборка строк, не следует вызывать `IsDeleted`. Вместо этого необходимо вызвать [GetRowStatus](#getrowstatus) функции-члена. Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
##  <a name="iseof"></a>CRecordset::IsEOF  
 Возвращает ненулевое значение, если набор записей расположенных после последней записи. Отсутствует запись текущей.  
  
```  
BOOL IsEOF() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если набор записей не содержит записей или выполнен переход за пределы последней записи; в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 Вызовите эту функцию-член, как переход от записи к записи, чтобы узнать ли вы прошли после последней записи в наборе записей. Можно также использовать `IsEOF` для определения набора записей содержит только записи, или является пустым. Сразу после вызова **откройте**, если набор записей не содержит записей, `IsEOF` возвращает ненулевое значение. При открытии набора записей, имеет по крайней мере одну запись, первая запись становится текущей записью и `IsEOF` возвращает 0.  
  
 Если последняя запись становится текущей записью, при вызове `MoveNext`, `IsEOF` впоследствии возвращает ненулевое значение. Если `IsEOF` возвращает ненулевое значение, при вызове метода `MoveNext`, возникает ошибка. Если `IsEOF` возвращает ненулевое значение, текущая запись не определена, и любое действие, которое требует текущей записи приведет к ошибке.  
  
### <a name="example"></a>Пример  
 В примере показано [IsBOF](#isbof).  
  
##  <a name="isfielddirty"></a>CRecordset::IsFieldDirty  
 Определяет, был ли изменен элемент данных заданного поля с момента [изменить](#edit) или [AddNew](#addnew) был вызван.  
  
```  
BOOL IsFieldDirty(void* pv);
```  
  
### <a name="parameters"></a>Параметры  
 `pv`  
 Указатель на член поля данных, состояние которой требуется проверить, или **NULL** для определения полей «грязные».  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если элемент данных заданного поля изменились по сравнению с вызовом `AddNew` или **изменить**; в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 Данные в все измененными элементами данных полей должны быть переданы записи в источнике данных при обновлении текущей записи путем вызова [обновление](#update) функцию-член `CRecordset` (после вызова **изменить** или `AddNew`).  
  
> [!NOTE]
>  Эта функция-член не применим на наборы записей, в которых используется выборка строк. Если применяется выборка строк, затем `IsFieldDirty` всегда будет возвращать **FALSE** и вызовет сбой утверждения. Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
 Вызов `IsFieldDirty` приведет к сбросу эффектов предыдущих вызовов [SetFieldDirty](#setfielddirty) так, как «грязный» состояние поля вычисляется повторно. В `AddNew` случае, если текущее значение поля отличается от значения null псевдо, поле задано состояние «грязных». В **изменить** случае, если значение поля отличается от кэшированное значение, то поле имеет статус «грязные».  
  
 `IsFieldDirty`реализуется с помощью [DoFieldExchange](#dofieldexchange).  
  
 Дополнительные сведения о "грязный" флаг см. в статье [набор записей: как наборы записей выберите записей (ODBC)](../../data/odbc/recordset-how-recordsets-select-records-odbc.md).  
  
##  <a name="isfieldnull"></a>CRecordset::IsFieldNull  
 Возвращает ненулевое значение, если указанное поле в текущей записи имеет значение Null (не имеет значения).  
  
```  
BOOL IsFieldNull(void* pv);
```  
  
### <a name="parameters"></a>Параметры  
 `pv`  
 Указатель на член поля данных, состояние которой требуется проверить, или **NULL** для определения, если любое из полей имеют значение Null.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если элемент данных заданного поля помечен как Null; в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 Вызовите эту функцию-член для определения, помечен ли элемент данных заданного поля набора записей как Null. (В терминологии связанных баз данных, значение Null означает «значение не установку» и не совпадает с **NULL** в C++.) Если член поля данных помечен как Null, то он интерпретируется как столбца текущей записи, для которой не имеет смысла.  
  
> [!NOTE]
>  Эта функция-член не применим на наборы записей, в которых используется выборка строк. Если применяется выборка строк, затем `IsFieldNull` всегда будет возвращать **FALSE** и вызовет сбой утверждения. Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
 `IsFieldNull`реализуется с помощью [DoFieldExchange](#dofieldexchange).  
  
##  <a name="isfieldnullable"></a>CRecordset::IsFieldNullable  
 Возвращает ненулевое значение, если указанное поле в текущей записи может иметь значение Null (значение не наличие).  
  
```  
BOOL IsFieldNullable(void* pv);
```  
  
### <a name="parameters"></a>Параметры  
 `pv`  
 Указатель на член поля данных, состояние которой требуется проверить, или **NULL** для определения, если любое из полей может быть присвоено значение Null.  
  
### <a name="remarks"></a>Примечания  
 Вызов этой функции-члена для определения ли член данных заданного поля значение «NULL» (может быть присвоено значение Null; C++ **NULL** не обязательно является Null, что в терминологии связанных баз данных, означает «необходимости нет значения»).  
  
> [!NOTE]
>  Выборка строк реализована, нельзя вызвать `IsFieldNullable`. Вместо этого необходимо вызвать [GetODBCFieldInfo](#getodbcfieldinfo) функции-члена для определения, является ли поле может быть присвоено значение Null. Обратите внимание, что всегда можно вызвать `GetODBCFieldInfo`, независимо от того, реализуется ли пакетная выборка строк. Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
 Поле, которое не может быть Null должен иметь значение. При попытке такого поля задать значение Null при добавлении или обновлении записи источника данных отклоняет Добавление или обновление, и [обновление](#update) будет выдано исключение. Исключение возникает при вызове **обновление**, не при вызове [метод SetFieldNull](#setfieldnull).  
  
 С помощью **NULL** первый аргумент функции будет применяются только к функции **outputColumn** поля не **param** полей. Например вызов  
  
 [!code-cpp[NVC_MFCDatabase&#26;](../../mfc/codesnippet/cpp/crecordset-class_10.cpp)]  
  
 установит только **outputColumn** полей для **NULL**; **param** полей не затрагиваются.  
  
 Для работы с **param** поля, необходимо указать фактический адрес отдельные **param** требуется для работы, такие как:  
  
 [!code-cpp[NVC_MFCDatabase&#27;](../../mfc/codesnippet/cpp/crecordset-class_11.cpp)]  
  
 Это означает, что нельзя задать все **param** полей для **NULL**, как и с **outputColumn** полей.  
  
 `IsFieldNullable`реализуется с помощью [DoFieldExchange](#dofieldexchange).  
  
##  <a name="isopen"></a>CRecordset::IsOpen  
 Определяет, если набор записей уже открыт.  
  
```  
BOOL IsOpen() const;  
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если объекта набора записей [откройте](#open) или [Requery](#requery) ранее вызова функции-члена и набор записей не закрыт; в противном случае — 0.  
  
##  <a name="m_hstmt"></a>CRecordset::m_hstmt  
 Содержит дескриптор ODBC инструкции структура данных, тип **HSTMT**, связанных с набором данных.  
  
### <a name="remarks"></a>Примечания  
 Каждый запрос к источнику данных ODBC, связанные с **HSTMT**.  
  
> [!CAUTION]
>  Не используйте **m_hstmt** перед [откройте](#open) был вызван.  
  
 Обычно не требуется доступ к **HSTMT** напрямую, но которые могут потребоваться для прямого выполнения инструкций SQL. `ExecuteSQL` Функции-члена класса `CDatabase` приведен пример использования **m_hstmt**.  
  
##  <a name="m_nfields"></a>CRecordset::m_nFields  
 Содержит количество элементов данных полей в классе набора записей. то есть, количество столбцов, выбранных в набор записей из источника данных.  
  
### <a name="remarks"></a>Примечания  
 Конструктор для класса набора записей необходимо инициализировать `m_nFields` с правильным числом. Если групповая выборка строк не реализована, ClassWizard записывает это инициализацию при использовании для объявления класса набора записей. Можно также создать его вручную.  
  
 Платформа использует этот номер для управления взаимодействием между элементами данных полей и соответствующих столбцов текущей записи в источнике данных.  
  
> [!CAUTION]
>  Это число должно соответствовать числу «выходные столбцы», зарегистрированных в `DoFieldExchange` или `DoBulkFieldExchange` после вызова [SetFieldType](../../mfc/reference/cfieldexchange-class.md#setfieldtype) с параметром **CFieldExchange::outputColumn**.  
  
 Можно привязать столбцы динамически, как описано в статье «набор записей: динамически столбцы привязки данных.» Если сделать это, необходимо увеличить число в `m_nFields` с учетом число функции RFX и Bulk RFX вызовов вашей `DoFieldExchange` или `DoBulkFieldExchange` функции-члена для динамически связанных столбцов.  
  
 Дополнительные сведения см. в статьях [набор записей: динамически привязки данных столбцов (ODBC)](../../data/odbc/recordset-dynamically-binding-data-columns-odbc.md) и [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
### <a name="example"></a>Пример  
 См. в статье [обмен полями записей: использование RFX](../../data/odbc/record-field-exchange-using-rfx.md).  
  
##  <a name="m_nparams"></a>CRecordset::m_nParams  
 Содержит количество элементов данных параметров в классе набора записей. число параметров, передаче с запросом набора записей.  
  
### <a name="remarks"></a>Примечания  
 Если класс набора записей элементов данных параметров, необходимо инициализировать конструктор для класса `m_nParams` с правильным числом. Значение `m_nParams` по умолчанию равно 0. При добавлении элементов данных параметров (которые необходимо сделать вручную) необходимо также вручную добавить инициализацию в конструкторе класса в соответствии с числом параметров (который должен быть по крайней мере количество '' заполнителей в ваш **m_strFilter** или `m_strSort` строка).  
  
 Платформа использует этот номер, когда он выполняет параметризацию запроса набора записей.  
  
> [!CAUTION]
>  Этот номер должен соответствовать числу «params», зарегистрированных в `DoFieldExchange` или `DoBulkFieldExchange` после вызова [SetFieldType](../../mfc/reference/cfieldexchange-class.md#setfieldtype) со значением параметра **CFieldExchange::inputParam**, **CFieldExchange::param**, **CFieldExchange::outputParam**, или **CFieldExchange::inoutParam**.  
  
### <a name="example"></a>Пример  
  См. в статьях [набор записей: Параметризация набора записей (ODBC)](../../data/odbc/recordset-parameterizing-a-recordset-odbc.md) и [обмен полями записей: использование RFX](../../data/odbc/record-field-exchange-using-rfx.md).  
  
##  <a name="m_pdatabase"></a>CRecordset::m_pDatabase  
 Содержит указатель на `CDatabase` объект, через который набор записей подключен к источнику данных.  
  
### <a name="remarks"></a>Примечания  
 Эта переменная задается двумя способами. Как правило, передать указатель на уже подключенного `CDatabase` объекта при создании объекта набора записей. Если передать **NULL** вместо `CRecordset` создает `CDatabase` объекта для вас и подключает его. В любом случае `CRecordset` сохраняет указатель в этой переменной.  
  
 Обычно не требуется напрямую использовать указателем, сохраненным в **m_pDatabase**. При написании собственных расширений для `CRecordset`, однако, может потребоваться использовать указатель. Например, может понадобиться указатель при генерировать собственные `CDBException`s. Или он может понадобиться, если вам нужно сделать что-нибудь, используя тот же `CDatabase` объекта, например выполняющихся транзакций, Настройка времени ожидания или вызова `ExecuteSQL` функции-члена класса `CDatabase` для выполнения инструкций SQL непосредственно.  
  
##  <a name="m_strfilter"></a>CRecordset::m_strFilter  
 После создания объекта набора записей, но перед вызовом его **откройте** член функции, используйте данные-член для хранения `CString` содержащий SQL **ГДЕ** предложения.  
  
### <a name="remarks"></a>Примечания  
 Набор записей эта строка используется для ограничения (или фильтр) выбирается во время записи **откройте** или **Requery** вызова. Это полезно для выбора подмножества записей, например «всех менеджеров по продажам из Калифорнии» («состояние = ЦС»). Синтаксис ODBC SQL **ГДЕ** предложение  
  
 `WHERE search-condition`  
  
 Обратите внимание, что вы не включите **ГДЕ** ключевое слово в строке. Инфраструктура предоставляет его.  
  
 Также можно параметризовать строку фильтра, поместив '' заполнители, объявление элемента данных параметра в классе для каждого местозаполнителя и передачи параметров в набор записей во время выполнения. Это позволяет создавать фильтра во время выполнения. Дополнительные сведения см. в статье [набор записей: Параметризация набора записей (ODBC)](../../data/odbc/recordset-parameterizing-a-recordset-odbc.md).  
  
 Дополнительные сведения о SQL **ГДЕ** предложений, см. в статье [SQL](../../data/odbc/sql.md). Дополнительные сведения о выборе и фильтрации записей, см. в статье [набор записей: фильтрация записей (ODBC)](../../data/odbc/recordset-filtering-records-odbc.md).  
  
### <a name="example"></a>Пример  
 [!code-cpp[NVC_MFCDatabase&#30;](../../mfc/codesnippet/cpp/crecordset-class_12.cpp)]  
  
##  <a name="m_strsort"></a>CRecordset::m_strSort  
 После создания объекта набора записей, но перед вызовом его **откройте** член функции, используйте данные-член для хранения `CString` содержащий SQL **ORDER BY** предложения.  
  
### <a name="remarks"></a>Примечания  
 Набор записей эта строка используется для сортировки записей во время выбирается **откройте** или **Requery** вызова. Эту функцию можно использовать для сортировки набора записей на один или несколько столбцов. Синтаксис ODBC SQL **ORDER BY** предложение  
  
 `ORDER BY sort-specification [, sort-specification]...`  
  
 где спецификации сортировки — целое число или имя столбца. Можно также указать порядок сортировки по возрастанию или по убыванию (порядок по возрастанию по умолчанию) путем добавления «ASC» или «DESC» список столбцов в строке сортировки. Выбранные записи сортируются сначала по первому столбцу в списке, а затем второй и т. д. Например могут заказать набор записей «Customers» по фамилии, а затем имя. Число столбцов, которые можно вывести список зависит от источника данных. Дополнительные сведения см. в разделе [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)] *.*  
  
 Обратите внимание, что вы не включите **ORDER BY** ключевое слово в строке. Инфраструктура предоставляет его.  
  
 Дополнительные сведения о предложениях SQL см. в статье [SQL](../../data/odbc/sql.md). Дополнительные сведения о сортировке записей, см. в статье [набор записей: сортировка записей (ODBC)](../../data/odbc/recordset-sorting-records-odbc.md).  
  
### <a name="example"></a>Пример  
 [!code-cpp[NVC_MFCDatabase&#31;](../../mfc/codesnippet/cpp/crecordset-class_13.cpp)]  
  
##  <a name="move"></a>CRecordset::Move  
 Перемещает указатель текущей записи в наборе записей, либо вперед или назад.  
  
```  
virtual void Move(
    long nRows,  
    WORD wFetchType = SQL_FETCH_RELATIVE);
```  
  
### <a name="parameters"></a>Параметры  
 `nRows`  
 Число строк для перемещения вперед или назад. Положительные значения перемещение вперед, к концу набора записей. Отрицательные значения перемещение назад, к началу.  
  
 `wFetchType`  
 Определяет набор строк, **перемещение** будет получена. Дополнительные сведения см. в разделе "Заметки".  
  
### <a name="remarks"></a>Примечания  
 Если передать значение 0 для `nRows`, **перемещение** обновляет текущую запись; **Перемещение** завершается любой текущий `AddNew` или **изменить** режиме и будет восстановить значение текущей записи перед `AddNew` или **изменить** был вызван.  
  
> [!NOTE]
>  При перемещении по набору записей нельзя пропустить удаленных записей. В разделе [CRecordset::IsDeleted](#isdeleted) для получения дополнительной информации. При открытии `CRecordset` с **skipDeletedRecords** параметр, **перемещение** утверждает, если `nRows` параметр равен 0. Это предотвращает обновление строк другими клиентскими приложениями, с помощью тех же данных. В разделе `dwOption` параметр в [откройте](#open) описание **skipDeletedRecords**.  
  
 **Переместить** перемещают набор записей по наборы строк. На основе значений для `nRows` и `wFetchType`, **перемещение** извлекает набор строк, соответствующих и затем делает первую запись в этот набор строк текущей записи. Если выборка строк не реализована, размер набора строк всегда равен 1. При получении набора строк, **перемещение** непосредственно вызывает [CheckRowsetError](#checkrowseterror) обработать все ошибки, возникающие в результате fetch функция-член.  
  
 В зависимости от значений, можно передать **перемещение** эквивалентен других `CRecordset` функции-члены. В частности, значение `wFetchType` может указывать на функцию-член, более интуитивно понятный и часто предпочтительный метод для перемещения к текущей записи.  
  
 В следующей таблице перечислены возможные значения для `wFetchType`, набор строк, **перемещение** будет получена на основе `wFetchType` и `nRows`и любые эквивалентный член функции, соответствующей `wFetchType`.  
  
|wFetchType|Извлеченных строк|Эквивалентный член функции|  
|----------------|--------------------|--------------------------------|  
|`SQL_FETCH_RELATIVE`(значение по умолчанию)|Начальный набор строк `nRows` строк из первой строки в текущем наборе строк.||  
|`SQL_FETCH_NEXT`|Далее строк; `nRows` игнорируется.|[MoveNext](#movenext)|  
|`SQL_FETCH_PRIOR`|Предыдущих строк; `nRows` игнорируется.|[MovePrev](#moveprev)|  
|`SQL_FETCH_FIRST`|Первый набор строк в наборе записей; `nRows` игнорируется.|[MoveFirst](#movefirst)|  
|`SQL_FETCH_LAST`|Последний полный набор строк в наборе записей; `nRows` игнорируется.|[MoveLast](#movelast)|  
|`SQL_FETCH_ABSOLUTE`|Если `nRows` настроек 0, набор строк, начинающийся `nRows` строк от начала набора записей. Если `nRows` < 0,="" the="" rowset="" starting=""> `nRows` строк из конца набора данных. Если `nRows` = 0, то возвращается условия начала файла (BOF).|[SetAbsolutePosition](#setabsoluteposition)|  
|`SQL_FETCH_BOOKMARK`|Набор строк, начиная со строки, значение которого закладки соответствует `nRows`.|[SetBookmark](#setbookmark)|  
  
> [!NOTE]
>  Для однонаправленного наборов записей **перемещение** допустимо только значение `SQL_FETCH_NEXT` для `wFetchType`.  
  
> [!CAUTION]
>  Вызов **перемещение** вызывает исключение, если набор записей не имеет записей. Чтобы определить, является ли набор записей все записи, вызовите [IsBOF](#isbof) и [IsEOF](#iseof).  
  
> [!NOTE]
>  Если выполнен переход за начало или конец набора записей ( `IsBOF` или `IsEOF` возвращает ненулевое значение), вызов **перемещение** возможно вызовет функцию `CDBException`. Например если `IsEOF` возвращает ненулевое значение и `IsBOF` не так, то `MoveNext` вызовет исключение, но `MovePrev` не будет.  
  
> [!NOTE]
>  При вызове метода **перемещение** время текущей записи обновлены или добавлены, обновления будут потеряны без предупреждения.  
  
 Дополнительные сведения о перемещении по набору записей см. в статьях [набор записей: прокрутка (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) и [Recordset: закладки и абсолютные позиции (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md). Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md). Дополнительные сведения см. в разделе функции ODBC API **SQLExtendedFetch** в [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
### <a name="example"></a>Пример  
 [!code-cpp[NVC_MFCDatabase&#28;](../../mfc/codesnippet/cpp/crecordset-class_14.cpp)]  
  
##  <a name="movefirst"></a>CRecordset::MoveFirst  
 Делает первую запись в первый набор строк текущей записи.  
  
```  
void MoveFirst();
```  
  
### <a name="remarks"></a>Примечания  
 Независимо от того, является ли выборка строк реализована это всегда будет первой записи в наборе записей.  
  
 Необходимо вызвать **MoveFirst** сразу после открытия набора записей. В это время первой записи (если таковые имеются) автоматически является текущей записи.  
  
> [!NOTE]
>  Эта функция-член не является допустимым для наборы записей последовательного доступа.  
  
> [!NOTE]
>  При перемещении по набору записей нельзя пропустить удаленных записей. В разделе [IsDeleted](#isdeleted) функции-члена для сведения.  
  
> [!CAUTION]
>  Вызов любого из **перемещение** функции вызывает исключение, если набор записей не имеет записей. Чтобы определить, является ли набор записей все записи, вызовите `IsBOF` и `IsEOF`.  
  
> [!NOTE]
>  Если вызвать любой из **перемещение** функции время текущей записи обновлены или добавлены, обновления будут потеряны без предупреждения.  
  
 Дополнительные сведения о перемещении по набору записей см. в статьях [набор записей: прокрутка (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) и [Recordset: закладки и абсолютные позиции (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md). Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
### <a name="example"></a>Пример  
  В примере показано [IsBOF](#isbof).  
  
##  <a name="movelast"></a>CRecordset::MoveLast  
 Делает первую запись последней полный набор строк текущей записи.  
  
```  
void MoveLast();
```  
  
### <a name="remarks"></a>Примечания  
 Если выборка строк не реализована, набор записей имеет размер набора строк, равным 1, поэтому `MoveLast` просто переходит на последнюю запись в наборе записей.  
  
> [!NOTE]
>  Эта функция-член не является допустимым для наборы записей последовательного доступа.  
  
> [!NOTE]
>  При перемещении по набору записей нельзя пропустить удаленных записей. В разделе [IsDeleted](#isdeleted) функции-члена для сведения.  
  
> [!CAUTION]
>  Вызов любого из **перемещение** функции вызывает исключение, если набор записей не имеет записей. Чтобы определить, является ли набор записей все записи, вызовите `IsBOF` и `IsEOF`.  
  
> [!NOTE]
>  Если вызвать любой из **перемещение** функции время текущей записи обновлены или добавлены, обновления будут потеряны без предупреждения.  
  
 Дополнительные сведения о перемещении по набору записей см. в статьях [набор записей: прокрутка (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) и [Recordset: закладки и абсолютные позиции (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md). Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
### <a name="example"></a>Пример  
  В примере показано [IsBOF](#isbof).  
  
##  <a name="movenext"></a>CRecordset::MoveNext  
 Делает первую запись следующего набора строк текущей записи.  
  
```  
void MoveNext();
```  
  
### <a name="remarks"></a>Примечания  
 Если выборка строк не реализована, набор записей имеет размер набора строк, равным 1, поэтому `MoveNext` просто переходит к следующей записи.  
  
> [!NOTE]
>  При перемещении по набору записей нельзя пропустить удаленных записей. В разделе [IsDeleted](#isdeleted) функции-члена для сведения.  
  
> [!CAUTION]
>  Вызов любого из **перемещение** функции вызывает исключение, если набор записей не имеет записей. Чтобы определить, является ли набор записей все записи, вызовите `IsBOF` и `IsEOF`.  
  
> [!NOTE]
>  Кроме того, рекомендуется вызывать `IsEOF` перед вызовом метода `MoveNext`. Например, если выполнен переход за конец набора записей `IsEOF` возвращает ненулевое значение; в последующем вызове `MoveNext` выдаст исключение.  
  
> [!NOTE]
>  Если вызвать любой из **перемещение** функции время текущей записи обновлены или добавлены, обновления будут потеряны без предупреждения.  
  
 Дополнительные сведения о перемещении по набору записей см. в статьях [набор записей: прокрутка (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) и [Recordset: закладки и абсолютные позиции (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md). Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
### <a name="example"></a>Пример  
  В примере показано [IsBOF](#isbof).  
  
##  <a name="moveprev"></a>CRecordset::MovePrev  
 Делает первую запись в предыдущих строк текущей записи.  
  
```  
void MovePrev();
```  
  
### <a name="remarks"></a>Примечания  
 Если выборка строк не реализована, набор записей имеет размер набора строк, равным 1, поэтому `MovePrev` просто перемещается к предыдущей записи.  
  
> [!NOTE]
>  Эта функция-член не является допустимым для наборы записей последовательного доступа.  
  
> [!NOTE]
>  При перемещении по набору записей нельзя пропустить удаленных записей. В разделе [IsDeleted](#isdeleted) функции-члена для сведения.  
  
> [!CAUTION]
>  Вызов любого из **перемещение** функции вызывает исключение, если набор записей не имеет записей. Чтобы определить, является ли набор записей все записи, вызовите `IsBOF` и `IsEOF`.  
  
> [!NOTE]
>  Кроме того, рекомендуется вызывать `IsBOF` перед вызовом метода `MovePrev`. Например, если переход выполнен набор записей `IsBOF` возвращает ненулевое значение; в последующем вызове `MovePrev` выдаст исключение.  
  
> [!NOTE]
>  Если вызвать любой из **перемещение** функции время текущей записи обновлены или добавлены, обновления будут потеряны без предупреждения.  
  
 Дополнительные сведения о перемещении по набору записей см. в статьях [набор записей: прокрутка (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) и [Recordset: закладки и абсолютные позиции (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md). Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
### <a name="example"></a>Пример  
  В примере показано [IsBOF](#isbof).  
  
##  <a name="onsetoptions"></a>CRecordset::OnSetOptions  
 Вызывается для задания параметров (используется для выбора) для указанной инструкции ODBC.  
  
```  
virtual void OnSetOptions(HSTMT hstmt);
```  
  
### <a name="parameters"></a>Параметры  
 `hstmt`  
 **HSTMT** инструкции ODBC, параметры которого должны быть заданы.  
  
### <a name="remarks"></a>Примечания  
 Вызов `OnSetOptions` для установки параметров (используется для выбора) для указанной инструкции ODBC. Платформа вызывает эту функцию-член для задания начальных параметров набора записей. `OnSetOptions`Определяет источник данных поддерживает прокручиваемые курсоры и параллелизм курсоров и соответствующим образом настраивает параметры набора записей. (В то время как `OnSetOptions` используется для выбора операций, `OnSetUpdateOptions` используется для операций обновления.)  
  
 Переопределение `OnSetOptions` Чтобы установить параметры для драйвера или источника данных. Например, если источник данных поддерживает открытие для монопольного доступа, могут переопределить `OnSetOptions` преимуществами эту возможность.  
  
 Дополнительные сведения о курсорах см. в статье [ODBC](../../data/odbc/odbc-basics.md).  
  
##  <a name="onsetupdateoptions"></a>CRecordset::OnSetUpdateOptions  
 Вызывается для задания параметров (используется для обновления) для указанной инструкции ODBC.  
  
```  
virtual void OnSetUpdateOptions(HSTMT hstmt);
```  
  
### <a name="parameters"></a>Параметры  
 `hstmt`  
 **HSTMT** инструкции ODBC, параметры которого должны быть заданы.  
  
### <a name="remarks"></a>Примечания  
 Вызов `OnSetUpdateOptions` для установки параметров (используется для обновления) для указанной инструкции ODBC. После создания HSTMT для обновления записей в наборе записей, платформа вызывает эту функцию-член. (В то время как `OnSetOptions` используется для выбора операций, `OnSetUpdateOptions` используется для операций обновления.) `OnSetUpdateOptions` определяет источник данных поддерживает прокручиваемые курсоры и параллелизме курсоров и соответствующим образом настраивает параметры набора записей.  
  
 Переопределение `OnSetUpdateOptions` для настройки параметров инструкции ODBC до этот оператор используется для доступа к базе данных.  
  
 Дополнительные сведения о курсорах см. в статье [ODBC](../../data/odbc/odbc-basics.md).  
  
##  <a name="open"></a>CRecordset::Open  
 Получение таблицы или выполнять запрос, который представляет набор записей открывает набор записей.  
  
```  
virtual BOOL Open(
    UINT nOpenType = AFX_DB_USE_DEFAULT_TYPE,  
    LPCTSTR lpszSQL = NULL,  
    DWORD dwOptions = none);
```  
  
### <a name="parameters"></a>Параметры  
 `nOpenType`  
 Примите значение по умолчанию **AFX_DB_USE_DEFAULT_TYPE**, или используйте одно из следующих значений из **enum OpenType**:  
  
- **CRecordset::dynaset** набор записей с двунаправленным прокрутки. Членство и порядок записей определяются при открытии набора записей, но изменения, внесенные другими пользователями для значения данных отображаются следующие операции выборки. Динамические подмножества данных называются также наборы записей, управляемых набором ключей.  
  
- **CRecordset::snapshot** статический набор записей с двунаправленным прокрутки. Членство и порядок записей определяется при открытии набора записей; значения данных, определяются при записи. Изменения, внесенные другими пользователями, не видны, пока не будет закрыто и повторно открыть набор записей.  
  
- **CRecordset::dynamic** набор записей с двунаправленным прокрутки. Изменения, внесенные другими пользователями членства, упорядочение и данные значения отображаются следующие операции выборки. Обратите внимание, что многие драйверы ODBC не поддерживают этот тип набора записей.  
  
- **CRecordset::forwardOnly** набор только для чтения записей с прокруткой только вперед.  
  
     Для `CRecordset`, значение по умолчанию — **CRecordset::snapshot**. Значение по умолчанию механизм позволяет мастеров Visual C++ для взаимодействия с и ODBC `CRecordset` и DAO `CDaoRecordset`, которые имеют различные значения по умолчанию.  
  
 Дополнительные сведения об этих типах записей см. в статье [записей (ODBC)](../../data/odbc/recordset-odbc.md). Дополнительные сведения см. в статье «Использование блока и Прокручиваемые курсоры» в [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)].  
  
> [!CAUTION]
>  Если запрашиваемый тип не поддерживается, платформа создает исключение.  
  
 `lpszSQL`  
 Указатель на строку, содержащую одно из следующих:  
  
-   Объект **NULL** указателя.  
  
-   Имя таблицы.  
  
-   SQL **ВЫБЕРИТЕ** инструкции (при необходимости с помощью SQL **ГДЕ** или **ORDER BY** предложение).  
  
-   Объект **ВЫЗОВ** инструкцию, указав имя предопределенного запроса (хранимой процедуры). Будьте осторожны, не вставляйте пробелы между фигурными скобками и **ВЫЗОВ** ключевое слово.  
  
 Дополнительные сведения о данной строки см. в таблице и описание роли ClassWizard под замечаниями.  
  
> [!NOTE]
>  Порядок столбцов в результирующий набор должен соответствовать порядку RFX или вызовы функций Bulk RFX вашей [DoFieldExchange](#dofieldexchange) или [DoBulkFieldExchange](#dobulkfieldexchange) переопределение функции.  
  
 `dwOptions`  
 Битовая маска, который определяется сочетанием значений, перечисленных ниже. Некоторые из них являются взаимоисключающими. Значение по умолчанию — **нет**.  
  
- **CRecordset::none** параметры не заданы. Значение этого параметра является взаимоисключающим с другими значениями. По умолчанию, можно обновить набор записей с [изменить](#edit) или [удаление](#delete) и добавления новых записей с [AddNew](#addnew). Возможность обновления зависит от источника данных а также в `nOpenType` указать параметр. Оптимизация массового добавления не доступен. Выборка строк не реализована. Удаленные записи не пропускаются при перемещении по набору записей. Закладки недоступны. Проверка автоматического поля «грязные» реализовано.  
  
- **CRecordset::appendOnly** не допускают **изменить** или **удаление** на набор записей. Разрешить `AddNew` только. Этот параметр является взаимоисключающим с **CRecordset::readOnly**.  
  
- **CRecordset::readOnly** откройте набор записей только для чтения. Этот параметр является взаимоисключающим с **CRecordset::appendOnly**.  
  
- **CRecordset::optimizeBulkAdd** использовать подготовленную инструкцию SQL для оптимизации, добавление нескольких записей одновременно. Применяется только в том случае, если вы не используете функцию ODBC API **SQLSetPos** для обновления набора записей. Первое обновление определяет, какие поля отмечаются как грязные. Этот параметр является взаимоисключающим с `CRecordset::useMultiRowFetch`.  
  
- `CRecordset::useMultiRowFetch`Реализуйте пакетную выборку строк, чтобы разрешить несколько строк, извлекаемых в операции одной выборки. Это дополнительная функция, предназначенный для повышения производительности; Однако блочный обмен полей записей не поддерживается классов. Этот параметр является взаимоисключающим с **CRecordset::optimizeBulkAdd**. Обратите внимание, что при указании `CRecordset::useMultiRowFetch`, затем параметр **CRecordset::noDirtyFieldCheck** будет включен автоматически (двойной буферизации будет недоступен); на наборы записей последовательного доступа, параметр **CRecordset::useExtendedFetch** будет включен автоматически. Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
- **CRecordset::skipDeletedRecords** пропуск всех удаленных записей при навигации по набору записей. Это приводит к снижению производительности в некоторых относительный выборки. Этот параметр не действует в наборы записей последовательного доступа. При вызове метода [перемещение](#move) с `nRows` параметра значение 0 и **CRecordset::skipDeletedRecords** параметр, **переместить** будет assert. Обратите внимание, что **CRecordset::skipDeletedRecords** аналогичен *упаковки драйвера*, который означает, что удаленные строки удаляются из набора записей. Тем не менее если драйвер пакетов записей, затем он будет пропускать только те записи, которые можно удалить; он не будет пропускать записи, удаленные другими пользователями, пока открыт набор записей. **CRecordset::skipDeletedRecords** будет пропускать строки, удаленные другим пользователям.  
  
- **CRecordset::useBookmarks** можно использовать закладки для объекта recordset, если поддерживается. Закладки медленно извлечения данных, но также повысить производительность для перемещения данных. Не является допустимым в наборы записей последовательного доступа. Дополнительные сведения см. в статье [Recordset: закладки и абсолютные позиции (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md).  
  
- **CRecordset::noDirtyFieldCheck** отключить автоматическое поля «грязные» проверки (двойная буферизация). Это улучшит производительность; Тем не менее, необходимо вручную пометить поля как «грязное» путем вызова `SetFieldDirty` и `SetFieldNull` функции-члены. Обратите внимание, что двойной буферизации в классе `CRecordset` аналогичен двойной буферизации в классе `CDaoRecordset`. Однако в `CRecordset`, невозможно включить двойную буферизацию для отдельных полей, можно включить ее для всех полей или отключить для всех полей. Обратите внимание, что при использовании параметра `CRecordset::useMultiRowFetch`, затем **CRecordset::noDirtyFieldCheck** включается автоматически, однако `SetFieldDirty` и `SetFieldNull` не может использоваться с наборами записей, выборка строк.  
  
- **CRecordset::executeDirect** не использовать несколько подготовленных инструкций SQL. Для повышения производительности, укажите этот параметр, если **Requery** функция-член не будет вызываться.  
  
- **CRecordset::useExtendedFetch** реализовать **SQLExtendedFetch** вместо **SQLFetch**. Эта возможность предназначена для реализации выборка строк на наборы последовательного доступа. Если задан параметр `CRecordset::useMultiRowFetch` для однонаправленного объекта recordset, затем **CRecordset::useExtendedFetch** будет включен автоматически.  
  
- **CRecordset::userAllocMultiRowBuffers** пользователь выделяет буферы хранения для данных. Используйте этот параметр в сочетании с `CRecordset::useMultiRowFetch` Если нужно выделить хранилища; в противном случае — платформа будет автоматически выделить хранилище. Дополнительные сведения см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md). Обратите внимание, что если указать **CRecordset::userAllocMultiRowBuffers** без указания `CRecordset::useMultiRowFetch` приведет к ошибочного утверждения.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если `CRecordset` объект был успешно открыт; в противном случае — 0, если [CDatabase::Open](../../mfc/reference/cdatabase-class.md#open) (если вызывается) возвращает значение 0.  
  
### <a name="remarks"></a>Примечания  
 Необходимо вызвать эту функцию-член для выполнения запроса определяется набор записей. Перед вызовом метода **откройте**, необходимо создать объект набора записей.  
  
 Соединение этого набора записей в источнике данных зависит от того, как построить записей до вызова метода **откройте**. Если передать [CDatabase](../../mfc/reference/cdatabase-class.md) объект recordset конструктор, который не был подключен к источнику данных использует эту функцию-член [GetDefaultConnect](#getdefaultconnect) попытка открыть объект базы данных. Если передать **NULL** конструктор набора записей, конструктор создает `CDatabase` объекта, и **откройте** пытается подключиться с объектом базы данных. Дополнительные сведения о закрытии набора записей и связи в этих различных условиях см [закрыть](#close).  
  
> [!NOTE]
>  Доступ к источнику данных через `CRecordset` всегда имеет доступ к объекту. В отличие от `CDaoRecordset` , нельзя использовать `CRecordset` объект, чтобы открыть источник данных с монопольным доступом.  
  
 При вызове **откройте**, запрос обычно SQL **ВЫБЕРИТЕ** инструкция, выбирает записи на основе критерия, показано в следующей таблице.  
  
|Значение параметра lpszSQL|Определяется выбрано записей|Пример|  
|------------------------------------|----------------------------------------|-------------|  
|**ЗНАЧЕНИЕ NULL**|Строка, возвращаемая функцией `GetDefaultSQL`.||  
|Имя таблицы SQL|Все столбцы в таблице перечислены в `DoFieldExchange` или `DoBulkFieldExchange`.|`"Customer"`|  
|Имя предопределенного запроса (хранимой процедуры)|Столбцы, которые определен запрос для возврата.|`"{call OverDueAccts}"`|  
|**ВЫБЕРИТЕ** список столбцов **из** список таблиц|Указанные столбцы из указанной таблицы.|`"SELECT CustId, CustName FROM`<br /><br /> `Customer"`|  
  
> [!CAUTION]
>  Будьте осторожны, не вставляйте лишних пробелов в строке SQL. Например, если вставить пробел между фигурными скобками и **вызвать** ключевое слово, MFC будут неправильно интерпретировать строку SQL, как имя таблицы и включить его в **ВЫБЕРИТЕ** инструкцию, которая приведет к возникновению исключения. Аналогичным образом, если ваш предопределенного запроса используется выходной параметр, не вставляйте пробелы между фигурными скобками и '' символ. Наконец, не следует вставить пробелы перед фигурная скобка в **ВЫЗОВ** инструкции или до **ВЫБЕРИТЕ** ключевое слово в **ВЫБЕРИТЕ** инструкции.  
  
 Обычные процедуры заключается в передаче **NULL** для **откройте**; в этом случае **откройте** вызовов [GetDefaultSQL](#getdefaultsql). Если вы используете производный `CRecordset` класс, **GetDefaultSQL** предоставляет имена таблицы, указанной в ClassWizard. Вместо этого можно указать другие сведения в `lpszSQL` параметр.  
  
 Все передаваемые **откройте** создает окончательной строки SQL для запроса (строка может иметь SQL **ГДЕ** и **ORDER BY** добавлено предложения `lpszSQL` вы переданной строки), а затем выполняет запрос. Получившаяся строка можно проверить путем вызова [GetSQL](#getsql) после вызова метода **откройте**. Дополнительные сведения об инструкции SQL набора записей и выбирает записи, в статье [набор записей: как наборы записей выберите записей (ODBC)](../../data/odbc/recordset-how-recordsets-select-records-odbc.md).  
  
 Члены данных полей набора записей класса привязаны к столбцам выбранных данных. Если возвращаются все записи, первая запись становится текущей записью.  
  
 Если требуется задать параметры для набора записей, такие как фильтр или сортировку, укажите их после создания объекта набора записей, но перед вызовом **откройте**. Если вы хотите записей в наборе записей после обновления набора записей уже открыт, вызовите [Requery](#requery).  
  
 Дополнительные сведения, включая дополнительные примеры см. в статьях [записей (ODBC)](../../data/odbc/recordset-odbc.md), [набор записей: как наборы записей выберите записей (ODBC)](../../data/odbc/recordset-how-recordsets-select-records-odbc.md), и [набор записей: Создание и закрытие наборов записей (ODBC)](../../data/odbc/recordset-creating-and-closing-recordsets-odbc.md).  
  
### <a name="example"></a>Пример  
 В следующих примерах кода показаны различных форм **откройте** вызова.  
  
 [!code-cpp[NVC_MFCDatabase №&16;](../../mfc/codesnippet/cpp/crecordset-class_15.cpp)]  
  
##  <a name="refreshrowset"></a>CRecordset::RefreshRowset  
 Обновляет данные и состояние для строки в текущем наборе строк.  
  
```  
void RefreshRowset(
    WORD wRow,  
    WORD wLockType = SQL_LOCK_NO_CHANGE);
```  
  
### <a name="parameters"></a>Параметры  
 `wRow`  
 Единицы позиция строки в текущем наборе строк. Это значение может изменяться от нуля до размера набора строк.  
  
 `wLockType`  
 Значение, указывающее способ блокировки строки после его обновления. Дополнительные сведения см. в разделе "Заметки".  
  
### <a name="remarks"></a>Примечания  
 Если передается нулевое значение для `wRow`, будет обновляться каждой строки в наборе строк.  
  
 Для использования `RefreshRowset`, должны реализован выборка строк, указав **CRecordset::useMulitRowFetch** параметр в [откройте](#open) функции-члена.  
  
 `RefreshRowset`вызывает функцию ODBC API **SQLSetPos**. `wLockType` Указывает состояние блокировки строки после **SQLSetPos** выполнен. В следующей таблице описаны возможные значения для `wLockTyp`e.  
  
|wLockType|Описание|  
|---------------|-----------------|  
|`SQL_LOCK_NO_CHANGE`(значение по умолчанию)|Драйвер или источник данных гарантирует строки в том же состоянии заблокирован или разблокирован как до `RefreshRowset` был вызван.|  
|`SQL_LOCK_EXCLUSIVE`|Драйвер или источник данных исключительно блокирует строку. Этот тип блокировки поддерживаются не всеми источниками данных.|  
|`SQL_LOCK_UNLOCK`|Драйвер или источник данных снимает блокировку строки. Этот тип блокировки поддерживаются не всеми источниками данных.|  
  
 Дополнительные сведения о **SQLSetPos**, в разделе [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]. Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
##  <a name="requery"></a>Метод CRecordset::Requery  
 Перестраивает (обновления) набора записей.  
  
```  
virtual BOOL Requery();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если набор записей был успешно перестроен; в противном случае — 0.  
  
### <a name="remarks"></a>Примечания  
 Если возвращаются все записи, первая запись становится текущей записью.  
  
 Чтобы набора записей в соответствии с добавления и удаления, вы или другие пользователи, осуществляющие к источнику данных, необходимо перестроить набора записей путем вызова **Requery**. Если набор записей является динамическим подмножеством, он автоматически отражает обновлений, которые вы или другие пользователи его существующие записи (но не дополнения). Если набор записей является моментальным снимком, необходимо вызвать **Requery** для отражения изменений, с другими пользователями, а также добавления и удаления.  
  
 Для динамических подмножеств данных или моментального снимка, вызовите **Requery** любое время, необходимо перестроить набора записей с помощью нового фильтра или сортировки или новые значения параметров. Задайте свойства нового фильтра или сортировки задание новых значений для **m_strFilter** и `m_strSort` перед вызовом метода **Requery**. Задайте новые параметры, задавая новые значения членов данных параметра перед вызовом метода **Requery**. Фильтрация и сортировка строк остаются без изменений, можно повторно использовать запрос, который повышает производительность.  
  
 При неудачной попытке повторного построения recordset, закрывается набор записей. Перед вызовом метода **Requery**, можно определить, можно ли опросить набора записей путем вызова `CanRestart` функции-члена. `CanRestart`не гарантирует, что **Requery** будет успешным.  
  
> [!CAUTION]
>  Вызов **Requery** только после вызова [откройте](#open).  
  
### <a name="example"></a>Пример  
 В этом примере перестраивается набор записей, чтобы применить другой порядок сортировки.  
  
 [!code-cpp[NVC_MFCDatabase&#29;](../../mfc/codesnippet/cpp/crecordset-class_16.cpp)]  
  
##  <a name="setabsoluteposition"></a>CRecordset::SetAbsolutePosition  
 Устанавливает набор записей на запись, соответствующая номер указанной записи.  
  
```  
void SetAbsolutePosition(long nRows);
```  
  
### <a name="parameters"></a>Параметры  
 `nRows`  
 Единицы порядковый номер для текущей записи в наборе записей.  
  
### <a name="remarks"></a>Примечания  
 `SetAbsolutePosition`Перемещает указатель текущей записи на основе этого порядковый номер позиции.  
  
> [!NOTE]
>  Эта функция-член не является допустимым наборы последовательного доступа.  
  
 Для наборы записей ODBC равным 1, абсолютное положение относится к первой записи в наборе записей; значение 0 указывает позицию (BOF) начала файла.  
  
 Можно также передать отрицательные значения для `SetAbsolutePosition`. В этом случае позиции в наборе записей вычисляется из конца набора данных. Например `SetAbsolutePosition( -1 )` перемещает указатель текущей записи к последней записи в наборе записей.  
  
> [!NOTE]
>  Абсолютное положение не предназначен для использования в качестве номер записи символов-заместителей. Закладки-это по-прежнему рекомендуемый способ сохранения и возврат к заданной позиции, с момента изменения позиции записи при удалении предыдущего записей. Кроме того, вы не может быть уверен, что данная запись будет же абсолютное положение, если повторно набора записей создается снова, потому что порядок отдельных записей в наборе записей не обязательно, если он создается с помощью инструкции SQL с помощью **ORDER BY** предложения.  
  
 Дополнительные сведения о перемещении по набору записей и закладок см. в статьях [набор записей: прокрутка (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) и [Recordset: закладки и абсолютные позиции (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md).  
  
##  <a name="setbookmark"></a>CRecordset::SetBookmark  
 Устанавливает набор записей на запись, содержащую указанную закладку.  
  
```  
void SetBookmark(const CDBVariant& varBookmark);
```  
  
### <a name="parameters"></a>Параметры  
 `varBookmark`  
 Ссылку на [CDBVariant](../../mfc/reference/cdbvariant-class.md) объект, содержащий значение для определенной записи.  
  
### <a name="remarks"></a>Примечания  
 Чтобы определить, поддерживаются ли закладки для объекта recordset, вызовите [CanBookmark](#canbookmark). Для закладки сделать доступным, если они поддерживаются, необходимо установить **CRecordset::useBookmarks** параметр в `dwOptions` параметр [откройте](#open) функции-члена.  
  
> [!NOTE]
>  Если закладок не поддерживается или недоступен, вызов `SetBookmark` приведет к возникновению исключения. Закладки не поддерживаются в наборы записей последовательного доступа.  
  
 Для извлечения закладки для текущей записи, вызовите [GetBookmark](#getbookmark), который сохраняет значение закладки для `CDBVariant` объекта. Позже можно вернуться к этой записи, вызвав `SetBookmark` с помощью значения сохраненные закладки.  
  
> [!NOTE]
>  После проведения определенных операций набор записей, следует проверить сохраняемости закладки перед вызовом метода `SetBookmark`. Например, если получение закладки с `GetBookmark` , а затем вызвать **Requery**, закладки могут не сохраниться. Вызов [CDatabase::GetBookmarkPersistence](../../mfc/reference/cdatabase-class.md#getbookmarkpersistence) для проверки, можно ли безопасно вызов `SetBookmark`.  
  
 Дополнительные сведения о закладок и навигации по набору записей см. в статьях [Recordset: закладки и абсолютные позиции (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md) и [набор записей: прокрутка (ODBC)](../../data/odbc/recordset-scrolling-odbc.md).  
  
##  <a name="setfielddirty"></a>CRecordset::SetFieldDirty  
 Флаги члену данных поля в наборе записей, изменяются или как неизмененные.  
  
```  
void SetFieldDirty(void* pv, BOOL bDirty = TRUE);
```  
  
### <a name="parameters"></a>Параметры  
 `pv`  
 Содержит адрес члена данных поля в наборе записей или **NULL**. Если **NULL**, помечаются все члены данных полей в наборе записей. (C++ **NULL** не является таким же, как значение Null в терминологии связанных баз данных, что означает «необходимости нет значения».)  
  
 `bDirty`  
 **Значение TRUE,** должен быть помечен как «грязным» (измененного) члена данных поля. В противном случае **FALSE** должен быть помечен как «очистить» (без изменений) члена данных поля.  
  
### <a name="remarks"></a>Примечания  
 Пометка поля как неизмененные гарантирует поля не обновляется и создает меньше трафика SQL.  
  
> [!NOTE]
>  Эта функция-член не применим на наборы записей, в которых используется выборка строк. Если применяется выборка строк, затем `SetFieldDirty` приведет к ошибочного утверждения. Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
 Метки framework изменить поля элементов данных, чтобы убедиться, что они будут записаны записи в источнике данных с помощью механизма обмена (полями записей RFX) поле записи. Как правило, изменение значения поля задает поле «грязные» автоматически, поэтому редко нужно вызывать `SetFieldDirty` самостоятельно, но иногда может потребоваться убедитесь, что столбцы будут быть явным образом обновлены или вставлены независимо от того, какое значение члена данных поля.  
  
> [!CAUTION]
>  Вызовите эту функцию-член, только после вызова [изменить](#edit) или [AddNew](#addnew).  
  
 С помощью **NULL** первый аргумент функции будет применяются только к функции **outputColumn** поля не **param** полей. Например вызов  
  
 [!code-cpp[NVC_MFCDatabase&#26;](../../mfc/codesnippet/cpp/crecordset-class_10.cpp)]  
  
 установит только **outputColumn** полей для **NULL**; **param** полей не затрагиваются.  
  
 Для работы с **param** поля, необходимо указать фактический адрес отдельные **param** требуется для работы, такие как:  
  
 [!code-cpp[NVC_MFCDatabase&#27;](../../mfc/codesnippet/cpp/crecordset-class_11.cpp)]  
  
 Это означает, что нельзя задать все **param** полей для **NULL**, как и с **outputColumn** полей.  
  
##  <a name="setfieldnull"></a>CRecordset::SetFieldNull  
 Флаги члену данных поля в наборе записей, как Null (в частности наличие никакого значения) или пустым.  
  
```  
void SetFieldNull(void* pv, BOOL bNull = TRUE);
```  
  
### <a name="parameters"></a>Параметры  
 `pv`  
 Содержит адрес члена данных поля в наборе записей или **NULL**. Если **NULL**, помечаются все члены данных полей в наборе записей. (C++ **NULL** не является таким же, как значение Null в терминологии связанных баз данных, что означает «необходимости нет значения».)  
  
 `bNull`  
 Ненулевое значение, если член данных поля помечены как имеющие значение (Null) не. В противном случае — 0, если член поля данных помечен как отличных от Null.  
  
### <a name="remarks"></a>Примечания  
 При добавлении новой записи в набор записей, все поля элементов данных изначально присвоено значение Null и помечен как «грязным» (измененного). При извлечении записи из источника данных, ее столбцов либо значения или уже имеют значение Null.  
  
> [!NOTE]
>  Не следует вызывать функции-члена с наборами записей, в которых используется выборка строк. Если выборка строк реализована, вызов `SetFieldNull` приводит ошибочного утверждения. Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
 При желании специально для назначения поля текущей записи как не имеющий значение, вызов `SetFieldNull` с `bNull` значение **TRUE** чтобы пометить его как Null. Если вы хотите ему присваивается значение поле ранее было помечено как Null, просто установите его новое значение. Необходимо удалить флаг Null с `SetFieldNull`. Чтобы определить, разрешено ли поле иметь значение Null, вызовите `IsFieldNullable`.  
  
> [!CAUTION]
>  Вызовите эту функцию-член, только после вызова [изменить](#edit) или [AddNew](#addnew).  
  
 С помощью **NULL** первый аргумент функции будет применяются только к функции **outputColumn** поля не **param** полей. Например вызов  
  
 [!code-cpp[NVC_MFCDatabase&#26;](../../mfc/codesnippet/cpp/crecordset-class_10.cpp)]  
  
 установит только **outputColumn** полей для **NULL**; **param** полей не затрагиваются.  
  
 Для работы с **param** поля, необходимо указать фактический адрес отдельные **param** требуется для работы, такие как:  
  
 [!code-cpp[NVC_MFCDatabase&#27;](../../mfc/codesnippet/cpp/crecordset-class_11.cpp)]  
  
 Это означает, что нельзя задать все **param** полей для **NULL**, как и с **outputColumn** полей.  
  
> [!NOTE]
>  При задании параметров NULL, вызов `SetFieldNull` до открытых результатов в утверждение набора записей. В этом случае вызывать [члена SetParamNull](#setparamnull).  
  
 `SetFieldNull`реализуется с помощью [DoFieldExchange](#dofieldexchange).  
  
##  <a name="setlockingmode"></a>CRecordset::SetLockingMode  
 Задает режим блокировки «оптимистичный «блокировка (по умолчанию) или «пессимистической» блокировки. Определяет, как блокировки для обновления записей.  
  
```  
void SetLockingMode(UINT nMode);
```  
  
### <a name="parameters"></a>Параметры  
 `nMode`  
 Содержит одно из следующих значений из **перечисления LockMode**:  
  
- **оптимистичный** оптимистическая блокировка блокировки записи, которая обновляется только при вызове **обновление**.  
  
- **пессимистичный** пессимистической блокировки запись блокируется по мере **изменить** вызывается и останется заблокированным до **обновление** завершения вызова или переместить в новую запись.  
  
### <a name="remarks"></a>Примечания  
 Вызовите эту функцию-член, если необходимо указать, какие две стратегии блокировки записей набор записей используется для обновления. По умолчанию является режим блокировки набора записей **оптимистичный**. Можно изменить, особенно осторожны **пессимистичный** стратегия блокировки. Вызов `SetLockingMode` после создания и открытия объекта набора записей, но перед вызовом **изменить**.  
  
##  <a name="setparamnull"></a>CRecordset::SetParamNull  
 Флаги параметра как Null (в частности наличие никакого значения) или пустым.  
  
```  
void SetParamNull(
    int nIndex,  
    BOOL bNull = TRUE);
```  
  
### <a name="parameters"></a>Параметры  
 `nIndex`  
 Отсчитываемый с нуля индекс параметра.  
  
 `bNull`  
 Если **TRUE** (значение по умолчанию), параметр помечен как Null. В противном случае — параметр помечен как отличных от Null.  
  
### <a name="remarks"></a>Примечания  
 В отличие от [метод SetFieldNull](#setfieldnull), можно вызвать `SetParamNull` перед открытии набора записей.  
  
 `SetParamNull`обычно используется с предопределенные запросы (хранимые процедуры).  
  
##  <a name="setrowsetcursorposition"></a>CRecordset::SetRowsetCursorPosition  
 Перемещает курсор на строку в текущем наборе строк.  
  
```  
void SetRowsetCursorPosition(WORD wRow, WORD wLockType = SQL_LOCK_NO_CHANGE);
```  
  
### <a name="parameters"></a>Параметры  
 `wRow`  
 Единицы позиция строки в текущем наборе строк. Это значение находится в диапазоне от 1 до размера набора строк.  
  
 `wLockType`  
 Значение, указывающее способ блокировки строки после его обновления. Дополнительные сведения см. в разделе "Заметки".  
  
### <a name="remarks"></a>Примечания  
 При реализации групповой выборки строк, извлекаемых записей наборы строк, где первой записи в наборе строк, выбранных на текущей записи. Чтобы сделать еще одну запись в наборе строк текущей записи, вызовите `SetRowsetCursorPosition`. Например, можно объединить `SetRowsetCursorPosition` с [GetFieldValue](#getfieldvalue) функции-члена для динамического извлечения данных из любой записи из набора записей.  
  
 Для использования `SetRowsetCursorPosition`, должны реализован выборка строк, указав `CRecordset::useMultiRowFetch` параметр `dwOptions` параметр в [откройте](#open) функции-члена.  
  
 `SetRowsetCursorPosition`вызывает функцию ODBC API **SQLSetPos**. `wLockType` Указывает состояние блокировки строки после **SQLSetPos** выполнен. В следующей таблице описаны возможные значения для `wLockTyp`e.  
  
|wLockType|Описание|  
|---------------|-----------------|  
|`SQL_LOCK_NO_CHANGE`(значение по умолчанию)|Драйвер или источник данных гарантирует строки в том же состоянии заблокирован или разблокирован как до `SetRowsetCursorPosition` был вызван.|  
|`SQL_LOCK_EXCLUSIVE`|Драйвер или источник данных исключительно блокирует строку. Этот тип блокировки поддерживаются не всеми источниками данных.|  
|`SQL_LOCK_UNLOCK`|Драйвер или источник данных снимает блокировку строки. Этот тип блокировки поддерживаются не всеми источниками данных.|  
  
 Дополнительные сведения о **SQLSetPos**, в разделе [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]. Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
##  <a name="setrowsetsize"></a>CRecordset::SetRowsetSize  
 Указывает количество записей, которые вы хотите получить во время выборки.  
  
```  
virtual void SetRowsetSize(DWORD dwNewRowsetSize);
```  
  
### <a name="parameters"></a>Параметры  
 *dwNewRowsetSize*  
 Число строк для получения во время операции выборки.  
  
### <a name="remarks"></a>Примечания  
 Это виртуальная функция-член указывает, сколько строк необходимо получить во время одной выборки при использовании выборка строк. Чтобы реализовать выборка строк, необходимо задать `CRecordset::useMultiRowFetch` параметр в `dwOptions` параметр [откройте](#open) функции-члена.  
  
> [!NOTE]
>  Вызов `SetRowsetSize` без реализации массовая выборка строк приведет к ошибочного утверждения.  
  
 Вызов `SetRowsetSize` перед вызовом метода **откройте** изначально задать размер набора строк для набора записей. Размер набора строк по умолчанию, при реализации выборка строк — 25.  
  
> [!NOTE]
>  Соблюдайте осторожность при вызове `SetRowsetSize`. Если вручную, выделяют хранилище для данных (как указано в **CRecordset::userAllocMultiRowBuffers** параметр dwOptions параметра в **откройте**), следует проверить, требуется ли перераспределять буфер хранения после вызова метода `SetRowsetSize`, но перед выполнением любой операции перемещения курсора.  
  
 Чтобы получить текущее значение размера набора строк, вызвать [GetRowsetSize](#getrowsetsize).  
  
 Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
##  <a name="update"></a>CRecordset::Update  
 Завершает `AddNew` или **изменить** операции путем сохранения новых или измененных данных в источнике данных.  
  
```  
virtual BOOL Update();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если одна запись успешно обновлен; в противном случае — 0, если столбцы не были изменены. Если записи не были обновлены или если более одной записи был обновлен, создается исключение. Исключение вызывается также для любой другой ошибки в источнике данных.  
  
### <a name="remarks"></a>Примечания  
 Это функция-член вызывается после вызова [AddNew](#addnew) или [изменить](#edit) функции-члена. Этот вызов необходим для завершения `AddNew` или **изменить** операции.  
  
> [!NOTE]
>  Выборка строк реализована, нельзя вызвать **обновление**. Это приведет к ошибочного утверждения. Хотя класс `CRecordset` не предоставляет механизма обновления пакетов строк данных, можно написать собственные функции с помощью функции API-интерфейса ODBC **SQLSetPos**. Дополнительные сведения о групповой выборке строк см. в статье [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
 Оба `AddNew` и **изменить** Подготовка буфера редактирования, в который помещается добавленных или измененных данных для сохранения в источнике данных. **Обновление** сохраняет данные. Обновляются только поля, помеченные или обнаружены изменения.  
  
 Если источник данных поддерживает транзакции, можно сделать **обновление** вызова (и соответствующего ему `AddNew` или **изменить** вызова) частью транзакции. Дополнительные сведения о транзакциях см. в статье [транзакции (ODBC)](../../data/odbc/transaction-odbc.md).  
  
> [!CAUTION]
>  При вызове метода **обновление** без предварительного вызова `AddNew` или **изменить**, **обновление** вызывает `CDBException`. При вызове метода `AddNew` или **изменить**, необходимо вызвать **обновление** перед вызовом метода **перемещение** операции или до закрытия соединения с источником данных или набора записей. В противном случае изменения будут утеряны без уведомления.  
  
 Дополнительные сведения об обработке **обновление** сбоев, см. в статье [набор записей: как наборы записей обновления записей (ODBC)](../../data/odbc/recordset-how-recordsets-update-records-odbc.md).  
  
### <a name="example"></a>Пример  
 См. в статье [транзакции: выполнение транзакции в наборе записей (ODBC)](../../data/odbc/transaction-performing-a-transaction-in-a-recordset-odbc.md).  
  
## <a name="see-also"></a>См. также  
 [CObject-класс](../../mfc/reference/cobject-class.md)   
 [Диаграмма иерархии](../../mfc/hierarchy-chart.md)   
 [CDatabase-класс](../../mfc/reference/cdatabase-class.md)   
 [CRecordView-класс](../../mfc/reference/crecordview-class.md)

