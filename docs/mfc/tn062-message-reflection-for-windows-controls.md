---
title: "TN062. Отражение сообщений для элементов управления окнами | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "vc.controls.messages"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "отражение сообщения"
  - "уведомляющие сообщения"
  - "ON_CONTROL_REFLECT - макрос"
  - "ON_CONTROL_REFLECT_EX - макрос"
  - "ON_NOTIFY - сообщение"
  - "ON_NOTIFY_REFLECT - сообщение"
  - "ON_NOTIFY_REFLECT_EX - сообщение"
  - "ON_UPDATE_COMMAND_UI_REFLECT - макрос"
  - "ON_WM_CHARTOITEM_REFLECT - макрос"
  - "ON_WM_COMPAREITEM_REFLECT - макрос"
  - "ON_WM_CTLCOLOR_REFLECT - макрос"
  - "ON_WM_DELETEITEM_REFLECT - макрос"
  - "ON_WM_DRAWITEM_REFLECT - макрос"
  - "ON_WM_HSCROLL_REFLECT - макрос"
  - "ON_WM_MEASUREITEM_REFLECT - макрос"
  - "ON_WM_PARENTNOTIFY_REFLECT - макрос"
  - "ON_WM_VKEYTOITEM_REFLECT - макрос"
  - "ON_WM_VSCROLL_REFLECT - макрос"
  - "TN062"
  - "WM_COMMAND"
  - "WM_CTLCOLOR - сообщение"
  - "WM_NOTIFY - сообщение"
ms.assetid: 53efb0ba-fcda-4fa0-a3c7-14e0b78fb494
caps.latest.revision: 9
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 5
---
# TN062. Отражение сообщений для элементов управления окнами
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

> [!NOTE]
>  Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию.  В результате некоторые процедуры и разделы могут быть устаревшими или неверными.  Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.  
  
 Это техническое примечание описывает отражение сообщения, новую функцию в MFC 4.0.  Он также содержит направления для многократного создания простого элемента управления, который использует отражение сообщения.  
  
 Это техническом примечании обсуждаются отражение сообщения, как оно применяется к ранее называемых элементами управления ActiveX \(элементами управления OLE\).  См. [Элементы управления ActiveX. Создание подкласса для элемента управления Windows](../mfc/mfc-activex-controls-subclassing-a-windows-control.md) статьи.  
  
 **Отражение, что сообщения?**  
  
 Элементы управления Windows часто отправляют сообщения уведомления к их родительскому окна.  Например, многие элементы управления отправляет сообщение уведомления цвета элемента управления \(`WM_CTLCOLOR` или одного из его вариантов\) к их родительскому элементу, чтобы разрешить родительский для предоставления кисть фона для заливки фона элемента управления.  
  
 В Windows и в MFC до версии 4.0, родительское окно, часто диалоговое окно, отвечает за обработку этих сообщений.  Это означает, что код для обработки сообщения должны быть в классе родительского окна и что он должен быть дублирован в каждом классе, который должен обрабатывать его.  В рассмотренном выше случае каждое диалоговое окно, что требуется элементы управления с пользовательскими фонами для обработки сообщений уведомлений цвета элемента управления.  Будет гораздо проще повторного использования кода, если класс элемента управления может быть записан, который корректно обрабатывает бы свой собственный цвет фона.  
  
 В MFC 4.0, старые механизм все еще работает — родительского окна могут обрабатывать сообщения уведомления.  Кроме того, однако MFC 4.0 облегчает повторное использование, предоставляя функцию «отражением сообщения», который позволяет эти сообщения уведомлений, которые необходимо обрабатывать в окне дочернего элемента управления или родительском окне или в обоих.  В примере цвета фона элемента управления, теперь можно написать класс элемента управления, который задает собственный цвет фона при обработке отраженное сообщение `WM_CTLCOLOR` — без использования в родительском элементе. \(Обратите внимание, что поскольку отражение сообщения реализуется MFC, не Windows, класс должен быть производным от родительского окна `CWnd` для отражения сообщения для работы\).  
  
 Более ранние версии MFC сделать что\-то подобное к отражению сообщения, предоставляя виртуальные функции для нескольких сообщений, такие как сообщения для определяемых пользователем списков \(`WM_DRAWITEM` и т д\).  Новый механизм отражения сообщения обобщен и согласован.  
  
 Отражение сообщения предусмотрена обратная совместимость на код, написанный для версий MFC до 4.0.  
  
 Если указанное обработчик для определенного сообщения, или для диапазона сообщений, в классе своего родительского окна, переопределяет отразил обработчик сообщений для одного и того же сообщения, автоматически не вызывает функцию обработчика событий базового класса в своем обработчике.  Например, при обработке `WM_CTLCOLOR` в классе диалогового окна, и его обработка переопределяет все отраженные обработчик сообщений.  
  
 Если в классе родительского окна, указывается обработчик для конкретного сообщения **WM\_NOTIFY** или диапазона сообщений **WM\_NOTIFY**, то обработчик вызывается только если дочерний элемент управления отправя эти сообщения не имеет отраженный обработчик сообщений через **ON\_NOTIFY\_REFLECT\(\)**.  При использовании атрибута **ON\_NOTIFY\_REFLECT\_EX\(\)** в схеме сообщений, обработчик сообщений может и не может разрешить родительское окно для обработки сообщения.  Если обработчик возвращает **ЛОЖЬ**, будет также сообщение обрабатывается родительским элементом, пока вызов, который возвращает **TRUE** не позволяет родительский для обработки его.  Обратите внимание, что отраженное сообщение обрабатывается перед сообщением уведомления.  
  
 Когда отправляется сообщение **WM\_NOTIFY**, первый элемент управления предоставляют возможность обработки.  Если какое\-либо другое отраженное сообщение отправляется, родительское окно первый имеет возможность обработать его и элемент управления отраженное получит сообщение.  Чтобы сделать это, ему требует функцию обработчика событий и соответствующую запись в схеме сообщений класса элемента управления.  
  
 Макрос для сопоставления сообщений отраженных сообщений немного отличается от для обычных уведомлений: он содержит **\_REFLECT**, добавленный к обычному его имени.  Например, для обработки сообщение **WM\_NOTIFY** в родительском элементе, используется макрос `ON_NOTIFY` в схеме сообщений родительского элемента.  Для обработки отраженное сообщение в дочернем элементе управления используйте макрос **ON\_NOTIFY\_REFLECT** в схеме сообщений дочернего элемента управления.  В некоторых случаях другие параметры, также.  Обратите внимание, что обычно ClassWizard может добавить записи сопоставления сообщений автоматически и представить каркасные реализации функции с правильными параметрами.  
  
 В разделе [TN061: Сообщения ON\_NOTIFY и WM\_NOTIFY](../mfc/tn061-on-notify-and-wm-notify-messages.md) сведения о новом сообщение **WM\_NOTIFY**.  
  
 **Записи сопоставления сообщений и прототипы функций обработчика для отраженных сообщений**  
  
 Для обработки отраженное сообщение уведомления элемента управления используйте перечисленные макросы сопоставления сообщений и прототипы функций в таблице ниже.  
  
 ClassWizard обычно может добавить эти записи сопоставления сообщений автоматически и представить каркасные реализации функции.  В разделе [Определение обработчика сообщений для отраженных сообщений](../mfc/reference/defining-a-message-handler-for-a-reflected-message.md) сведения о том, как определить обработчики для отраженных сообщений.  
  
 Для преобразования из имени сообщения в отраженному имени макроса добавьте в начале **ON\_** и **\_REFLECT**.  Например, `WM_CTLCOLOR` будет **ON\_WM\_CTLCOLOR\_REFLECT**. \(Чтобы увидеть, какие сообщения можно увидеть выполните противоположное преобразование в записях макроса в таблице ниже\).  
  
 3 Исключения из правила выше следующим образом:  
  
-   Макрос для уведомлений **WM\_COMMANDON\_CONTROL\_REFLECT**.  
  
-   Макрос для отражений **WM\_NOTIFYON\_NOTIFY\_REFLECT**.  
  
-   Макрос для отражений `ON_UPDATE_COMMAND_UI`**ON\_UPDATE\_COMMAND\_UI\_REFLECT**.  
  
 В каждом из описанных выше особых случаев необходимо указать имя функции\-члена обработчика.  В других случаях следует использовать стандартное имя для функции обработчика.  
  
 Значения параметров и возвращаемых значений функций описаны в или имени функции или функции с **On**; их имена предваряются словами.  Например, **CtlColor** документировано в `OnCtlColor`.  Несколько обработчиков отраженных сообщений требуется меньшее количество параметров, чем аналогичные обработчики в родительском окне.  Только совпадение с именами в следующей таблице перечислены с именами формальных параметров в документации.  
  
|Запись сопоставления|Прототип функции|  
|--------------------------|----------------------|  
|**ON\_CONTROL\_REFLECT\(  ,**  `memberFxn`  **\)** `wNotifyCode`|**void afx\_msg**  `memberFxn`  **\( \);**|  
|**ON\_NOTIFY\_REFLECT\(  ,**  `memberFxn`  **\)** `wNotifyCode`|*результат*  **\);** `pNotifyStruct` **, LRESULT\*   \(NMHDR \*  void afx\_msg**  `memberFxn`|  
|**\) ON\_UPDATE\_COMMAND\_UI\_REFLECT\(**  `memberFxn`|**void afx\_msg**  `memberFxn`  **\(CCmdUI\***  `pCmdUI`  **\);**|  
|**ON\_WM\_CTLCOLOR\_REFLECT \(\)**|**afx\_msg HBRUSH CtlColor \(CDC\***  `pDC` **, UINT**  `nCtlColor`  **\);**|  
|**ON\_WM\_DRAWITEM\_REFLECT \(\)**|**afx\_msg пустое DrawItem \(LPDRAWITEMSTRUCT**  `lpDrawItemStruct`  **\);**|  
|**ON\_WM\_MEASUREITEM\_REFLECT \(\)**|**afx\_msg пустое MeasureItem \(LPMEASUREITEMSTRUCT**  `lpMeasureItemStruct`  **\);**|  
|**ON\_WM\_DELETEITEM\_REFLECT \(\)**|**afx\_msg пустое \(LPDELETEITEMSTRUCT DeleteItem**  `lpDeleteItemStruct`  **\);**|  
|**ON\_WM\_COMPAREITEM\_REFLECT \(\)**|**afx\_msg int CompareItem \(LPCOMPAREITEMSTRUCT**  `lpCompareItemStruct`  **\);**|  
|**ON\_WM\_CHARTOITEM\_REFLECT \(\)**|**afx\_msg int CharToItem \(UINT**  `nKey` **, UINT**  `nIndex`  **\);**|  
|**ON\_WM\_VKEYTOITEM\_REFLECT \(\)**|**afx\_msg int VKeyToItem \(UINT**  `nKey` **, UINT**  `nIndex`  **\);**|  
|**ON\_WM\_HSCROLL\_REFLECT \(\)**|**afx\_msg пустое HScroll \(UINT**  `nSBCode` **, UINT**  `nPos`  **\);**|  
|**ON\_WM\_VSCROLL\_REFLECT \(\)**|**afx\_msg пустое VScroll \(UINT**  `nSBCode` **, UINT**  `nPos`  **\);**|  
|**ON\_WM\_PARENTNOTIFY\_REFLECT \(\)**|**afx\_msg пустое ParentNotify \(UINT**  `message` **LPARAM,**  `lParam`  **\);**|  
  
 Макросы **ON\_NOTIFY\_REFLECT** и **ON\_CONTROL\_REFLECT** имеют варианты, которые являются более одного объекта \(например, от элемента управления и его родительским\) для обработки заданного сообщения.  
  
|Запись сопоставления|Прототип функции|  
|--------------------------|----------------------|  
|**ON\_NOTIFY\_REFLECT\_EX\(  ,**  `memberFxn`  **\)** `wNotifyCode`|*результат*  **\);** `pNotifyStruct` **, LRESULT\*   \(NMHDR \*  afx\_msg BOOL**  `memberFxn`|  
|**ON\_CONTROL\_REFLECT\_EX\(  ,**  `memberFxn`  **\)** `wNotifyCode`|**afx\_msg BOOL**  `memberFxn`  **\( \);**|  
  
## Обработка отраженные сообщения: Пример элемента управления представляют собой  
 В этом примере создается повторно с простой элемент управления `CYellowEdit`.  Элемент управления работает так же, как обычный элемент управления "Поле ввода", за исключением того, что он отображает черный текст в желтом фоне.  Будет легко добавить функции\-члены, которые могут позволить вредоносным веб\-страницам, элемент управления `CYellowEdit` к цветам отображения другим.  
  
#### Затем пример создает элемент управления, повторно  
  
1.  Создайте новое диалоговое окно в существующих приложениях.  Дополнительные сведения см. в разделе [редактор диалоговых окон](../mfc/dialog-editor.md).  
  
     Необходимо иметь приложения, в котором для многократного использования пользовательского элемента управления.  При отсутствии существующих приложений, необходимо создать приложение на основе диалоговых окон с помощью AppWizard.  
  
2.  После создания проекта, загруженный в Visual C\+\+, используйте ClassWizard, чтобы создать новый класс с именем `CYellowEdit` на основе `CEdit`.  
  
3.  Добавьте переменную\-член 3 к классу `CYellowEdit`.  Первые 2 будут переменными **COLORREF** для хранения цвет текста и цвет фона.  Третий будет объектом `CBrush`, содержащая кисть фона для заливки фона.  Объект `CBrush` позволяет создать кисть раз, он просто ссылающийся после этого и удалить кисть автоматически, когда элемент `CYellowEdit` уничтожается.  
  
4.  Инициализируйте переменные членов, используя конструктор следующим образом:  
  
    ```  
    CYellowEdit::CYellowEdit()  
    {  
       m_clrText = RGB( 0, 0, 0 );  
       m_clrBkgnd = RGB( 255, 255, 0 );  
       m_brBkgnd.CreateSolidBrush( m_clrBkgnd );  
    }  
    ```  
  
5.  Использование ClassWizard, добавьте обработчик для отраженных сообщений `WM_CTLCOLOR` к классу `CYellowEdit`.  Обратите внимание, что знак равенства перед именем сообщения в списке сообщений можно обработать означает, что сообщение будет отображаться.  Это описано в разделе [Определение обработчика сообщений для отраженных сообщений](../mfc/reference/defining-a-message-handler-for-a-reflected-message.md).  
  
     ClassWizard добавляет следующую функцию макроса сопоставления сообщений и схемы автоматически:  
  
    ```  
    ON_WM_CTLCOLOR_REFLECT()  
  
    // Note: other code will be in between....  
  
    HBRUSH CYellowEdit::CtlColor(CDC* pDC, UINT nCtlColor)   
    {  
       // TODO: Change any attributes of the DC here  
  
       // TODO: Return a non-NULL brush if the  
       //   parent's handler should not be called  
       return NULL;  
    }  
    ```  
  
6.  Замените текст функции следующим кодом.  Код определяет цвет фона текста, цвет текста и цвет фона для остальной части элемента управления.  
  
    ```  
    pDC->SetTextColor( m_clrText );   // text  
    pDC->SetBkColor( m_clrBkgnd );   // text bkgnd  
    return m_brBkgnd;            // ctl bkgnd  
    ```  
  
7.  Создание элемента управления "Поле ввода" в диалоговом окне, а затем вложите его в переменные\-члену, дважды щелкнув элемент управления "Поле ввода" при удержащ нажмите стрелку вниз.  В диалоговом окне добавления переменной\-члена, введите имя переменной и выберите «элемент управления» для категории, затем «CYellowEdit» для типа переменной.  Не забудьте задать последовательность табуляции в диалоговом окне.  Кроме того, необходимо включить файл заголовка для управления `CYellowEdit` в файле заголовка диалогового окна.  
  
8.  Скомпонуйте и запустите приложение.  Элемент управления "Поле ввода" будет иметь желтый фон.  
  
## См. также  
 [Технические примечания по номеру](../mfc/technical-notes-by-number.md)   
 [Технические примечания по категории](../mfc/technical-notes-by-category.md)