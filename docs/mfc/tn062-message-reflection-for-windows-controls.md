---
title: 'TN062: Сообщения, отражение для элементов управления Windows | Документы Microsoft'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-mfc
ms.topic: conceptual
f1_keywords:
- vc.controls.messages
dev_langs:
- C++
helpviewer_keywords:
- ON_WM_VKEYTOITEM_REFLECT macro [MFC]
- ON_WM_DRAWITEM_REFLECT macro [MFC]
- ON_WM_VSCROLL_REFLECT macro [MFC]
- ON_NOTIFY_REFLECT message [MFC]
- ON_CONTROL_REFLECT_EX macro [MFC]
- ON_UPDATE_COMMAND_UI_REFLECT macro [MFC]
- ON_NOTIFY_REFLECT_EX message [MFC]
- ON_WM_HSCROLL_REFLECT macro [MFC]
- message reflection [MFC]
- ON_WM_COMPAREITEM_REFLECT macro [MFC]
- ON_WM_MEASUREITEM_REFLECT macro [MFC]
- ON_NOTIFY message [MFC]
- WM_COMMAND [MFC]
- WM_CTLCOLOR message [MFC]
- TN062 [MFC]
- ON_WM_CHARTOITEM_REFLECT macro [MFC]
- ON_WM_CTLCOLOR_REFLECT macro [MFC]
- ON_WM_DELETEITEM_REFLECT macro [MFC]
- notification messages [MFC]
- ON_WM_PARENTNOTIFY_REFLECT macro [MFC]
- WM_NOTIFY message [MFC]
- ON_CONTROL_REFLECT macro
ms.assetid: 53efb0ba-fcda-4fa0-a3c7-14e0b78fb494
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: ba8e9cac3b7f7997da8c620966234a630b9b9fbd
ms.sourcegitcommit: 76b7653ae443a2b8eb1186b789f8503609d6453e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
ms.locfileid: "33384968"
---
# <a name="tn062-message-reflection-for-windows-controls"></a>TN062. Отражение сообщений для элементов управления окнами
> [!NOTE]
>  Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.  
  
 Это техническое Примечание описывает отражение сообщения, появившаяся в версии MFC 4.0. Он также содержит инструкции по созданию простого для повторного использования элемента управления, который использует отражение сообщений.  
  
 Это техническое Примечание не рассматриваются отражение сообщения применительно к элементам управления ActiveX (ранее — элементы управления OLE). Обратитесь к статье [элементы управления ActiveX: Создание подкласса элемента управления Windows Forms](../mfc/mfc-activex-controls-subclassing-a-windows-control.md).  
  
 **Что такое отражение сообщения**  
  
 Элементы управления Windows часто отправки сообщений уведомления их родительского окна. Например, многие элементы управления отправить сообщение уведомления цвет элемента управления (`WM_CTLCOLOR` или одного из его вариантов) их родительскому элементу, чтобы разрешить родительским для предоставления кисть рисования фона элемента управления.  
  
 В Windows и MFC до версии 4.0 родительского окна, часто диалогового окна, отвечает за обработку этих сообщений. Это означает, что код для обработки такого сообщения должен находиться в классе родительского окна, и оно должно дублироваться в каждом классе, для обработки этого сообщения. В приведенном выше случае каждом диалоговом окне, элементы управления с собственным фоном необходимо было бы обрабатывать сообщения уведомления цвет элемента управления. Было бы гораздо проще, если класс элемента управления может быть записан, который будет обрабатывать цвет фона, повторное использование кода.  
  
 В версии MFC 4.0 старый механизм по-прежнему работает — родительские окна может обрабатывать сообщения уведомления. Кроме того, тем не менее, MFC 4.0 облегчает повторное использование, предоставляя называемую «сообщений отражения», позволяющий обрабатываться в дочернее окно элемента управления или родительского окна, или в обоих этих уведомлений. В примере цвет фона элемента управления, теперь можно написать класс элемента управления, которое задает цвет фона, обрабатывая отраженный `WM_CTLCOLOR` сообщения — все это, не полагаясь на родительский объект. (Обратите внимание, что с момента реализуемый отражение сообщений MFC, не операционной системой Windows, родительский класс окна должен быть производным от `CWnd` для отражение сообщений для работы.)  
  
 Более старые версии MFC не то, что аналогично отражение сообщений за счет виртуальных функций несколько сообщений, таких как сообщения для списков — определяемый владельцем (`WM_DRAWITEM`и так далее). Новый механизм отражения сообщение обобщенной и согласованность.  
  
 Отражение сообщения имеет обратную совместимость с кода, написанного для версии MFC до 4.0.  
  
 Если вы задали обработчик для конкретного сообщения или диапазона сообщения в классе родительского окна, оно переопределит отражены обработчики сообщений для того же сообщения предоставляемых не вызывайте функцию-обработчик базового класса в собственный обработчик. Например, если вы обрабатываете `WM_CTLCOLOR` в классе диалогового окна, собственной обработки переопределит все обработчики отраженных сообщений.  
  
 Если в вашем классе родительского окна, вы предоставляете обработчик для конкретного **WM_NOTIFY** сообщения или диапазон **WM_NOTIFY** сообщений, ваш обработчик будет вызываться только в том случае, если дочерний элемент управления, отправки этих сообщений не имеет обработчика, отраженного сообщения через **ON_NOTIFY_REFLECT()**. Если вы используете **ON_NOTIFY_REFLECT_EX()** на карте сообщение Ваш обработчик сообщений может или не может разрешить родительского окна для обработки сообщения. Если обработчик возвращает **FALSE**, сообщение будет обрабатываться родительским, при вызов, возвращающий **TRUE** не допускает родительского его обработать. Обратите внимание, отраженного сообщения обрабатывается перед сообщения уведомления.  
  
 Когда **WM_NOTIFY** отправляется сообщение, элемент управления будет предлагаться первый сможет обработать его. Если отраженное сообщение отправляется, родительское окно имеет первый сможет обработать его, и элемент управления будет получать отраженного сообщения. Чтобы сделать это, он будет нужен функцию обработчика событий и соответствующей записи в схеме сообщений для класса элемента управления.  
  
 Макрос схемы сообщений для отраженного сообщения несколько отличаются от обычных уведомлений: он имеет **_REFLECT** добавляется к обычным имени. Например для обработки **WM_NOTIFY** сообщения в родительском объекте, используйте макрос `ON_NOTIFY` в схеме сообщений родительского элемента. Чтобы обработать отраженного сообщения в дочерний элемент управления, используйте **ON_NOTIFY_REFLECT** макрос в схеме сообщений дочернего элемента управления. В некоторых случаях параметры, также отличаются. Обратите внимание, что мастер классов можно обычно добавьте записи схемы сообщений автоматически предоставляют реализации каркас функции с правильными параметрами.  
  
 В разделе [tn061 сообщения: ON_NOTIFY и Wm_notify](../mfc/tn061-on-notify-and-wm-notify-messages.md) сведения на новом **WM_NOTIFY** сообщения.  
  
 **Записи схемы сообщений и обработчика прототипы для отраженные сообщения**  
  
 Для обработки отраженный управляющее сообщение уведомления, используйте макросы сопоставления сообщений и прототипы функций, перечисленных в следующей таблице.  
  
 Мастер классов обычно можно добавить эти записи схемы сообщений для вас и предоставляют реализации каркас функции. В разделе [определение обработчика сообщений для сообщения отражены](../mfc/reference/defining-a-message-handler-for-a-reflected-message.md) сведения об определении обработчики для отраженного сообщения.  
  
 Чтобы преобразовать имя сообщения имя макроса отраженный, можно добавить в начало **ON_** и добавления **_REFLECT**. Например `WM_CTLCOLOR` становится **ON_WM_CTLCOLOR_REFLECT**. (Чтобы увидеть, какие сообщения могут быть отражены, сделать противоположное преобразование в операциях макрос в следующей таблице).  
  
 Ниже приведены три исключения из правила выше.  
  
-   Макрос для **WM_COMMAND** уведомления о **ON_CONTROL_REFLECT**.  
  
-   Макрос для **WM_NOTIFY** — отражений **ON_NOTIFY_REFLECT**.  
  
-   Макрос для `ON_UPDATE_COMMAND_UI` — отражений **ON_UPDATE_COMMAND_UI_REFLECT**.  
  
 В каждом из вышеперечисленных случаев специальные необходимо указать имя функции-члена обработчика. В других случаях необходимо использовать стандартное имя функции обработчика.  
  
 Значения параметров и возвращаемых значений функций приведен в имя функции или имени функции с **на** префиксом. Например **CtlColor** описана в `OnCtlColor`. Несколько обработчиков отраженного сообщения требуется меньшее количество параметров, чем аналогичные обработчики в родительском окне. Просто совпадать с именами в таблице ниже имена формальных параметров в документации.  
  
|Элемент карты|Прототип функции|  
|---------------|------------------------|  
|**ON_CONTROL_REFLECT (** `wNotifyCode` **,** `memberFxn` **)**|**afx_msg void** `memberFxn` **();**|  
|**ON_NOTIFY_REFLECT (** `wNotifyCode` **,** `memberFxn` **)**|**afx_msg void** `memberFxn` **(NMHDR \***  `pNotifyStruct` **, LRESULT\***  *результат* **);**|  
|**ON_UPDATE_COMMAND_UI_REFLECT (** `memberFxn` **)**|**afx_msg void** `memberFxn` **(CCmdUI\***  `pCmdUI` **);**|  
|**ON_WM_CTLCOLOR_REFLECT)**|**HBRUSH CtlColor afx_msg (CDC\***  `pDC` **, UINT** `nCtlColor` **);**|  
|**ON_WM_DRAWITEM_REFLECT)**|**afx_msg void DrawItem (LPDRAWITEMSTRUCT** `lpDrawItemStruct` **);**|  
|**ON_WM_MEASUREITEM_REFLECT)**|**afx_msg void MeasureItem (LPMEASUREITEMSTRUCT** `lpMeasureItemStruct` **);**|  
|**ON_WM_DELETEITEM_REFLECT)**|**afx_msg void DeleteItem (LPDELETEITEMSTRUCT** `lpDeleteItemStruct` **);**|  
|**ON_WM_COMPAREITEM_REFLECT)**|**afx_msg int CompareItem (LPCOMPAREITEMSTRUCT** `lpCompareItemStruct` **);**|  
|**ON_WM_CHARTOITEM_REFLECT)**|**afx_msg int CharToItem (UINT** `nKey` **, UINT** `nIndex` **);**|  
|**ON_WM_VKEYTOITEM_REFLECT)**|**afx_msg int VKeyToItem (UINT** `nKey` **, UINT** `nIndex` **);**|  
|**ON_WM_HSCROLL_REFLECT)**|**afx_msg void HScroll (UINT** `nSBCode` **, UINT** `nPos` **);**|  
|**ON_WM_VSCROLL_REFLECT)**|**afx_msg void VScroll (UINT** `nSBCode` **, UINT** `nPos` **);**|  
|**ON_WM_PARENTNOTIFY_REFLECT)**|**afx_msg void ParentNotify (UINT** `message` **, LPARAM** `lParam` **);**|  
  
 **ON_NOTIFY_REFLECT** и **ON_CONTROL_REFLECT** макросы имеют вариации, которые позволяют обработать данное сообщение только один объект (например, элемент управления и его родительским элементом).  
  
|Элемент карты|Прототип функции|  
|---------------|------------------------|  
|**ON_NOTIFY_REFLECT_EX (** `wNotifyCode` **,** `memberFxn` **)**|**afx_msg BOOL** `memberFxn` **(NMHDR \***  `pNotifyStruct` **, LRESULT\***  *результат* **);**|  
|**ON_CONTROL_REFLECT_EX (** `wNotifyCode` **,** `memberFxn` **)**|**afx_msg BOOL** `memberFxn` **();**|  
  
## <a name="handling-reflected-messages-an-example-of-a-reusable-control"></a>Обработка сообщений отражен: Пример элемента управления для повторного использования  
 Этот простой пример создает элемент управления для повторного использования с именем `CYellowEdit`. Элемент управления работает таким же, как регулярное изменение элемента управления, за исключением того, что отображается черный текст на желтом фоне. Было бы легко добавлять функции-члены, так что `CYellowEdit` элемента управления для отображения различных цветов.  
  
#### <a name="to-try-the-example-that-creates-a-reusable-control"></a>Для проверки примера, который создает повторно используемый элемент управления  
  
1.  Создание нового диалогового окна в существующее приложение. Дополнительные сведения см. в разделе [редактор диалоговых окон](../windows/dialog-editor.md) раздела.  
  
     Необходимо иметь приложение, в котором для разработки многократно используемых элементов управления. Если у вас нет существующего приложения для использования, создания мастером приложений с помощью приложения на основе диалогового окна.  
  
2.  В проекте, загружаются в Visual C++, используйте мастер классов для создания новый класс с именем `CYellowEdit` на основе `CEdit`.  
  
3.  Добавьте три переменные-члены для вашего `CYellowEdit` класса. Первые два будет **COLORREF** переменных для хранения цвет текста и цвет фона. Третий будет `CBrush` объекта, который будет содержать кисть рисования фона. `CBrush` Объектов позволяет создать кисть, один раз, а просто ссылки на него после этого и для уничтожения кисть автоматически при `CYellowEdit` управления удаляется.  
  
4.  Инициализируйте переменные-члены, написав конструктор следующим образом:  
  
 ```  
    CYellowEdit::CYellowEdit() 
 {  
    m_clrText = RGB(0,
    0,
    0);

    m_clrBkgnd = RGB(255,
    255,
    0);

    m_brBkgnd.CreateSolidBrush(m_clrBkgnd);

 }  
 ```  
  
5.  С помощью классов, добавьте обработчик для отраженного `WM_CTLCOLOR` сообщения к вашей `CYellowEdit` класса. Обратите внимание, знак равенства перед именем сообщение в списке сообщений, которые могут быть обработаны отражали сообщения. Это описывается в [определение обработчика сообщений для сообщения отражены](../mfc/reference/defining-a-message-handler-for-a-reflected-message.md).  
  
     Мастер классов добавляет следующую функцию макрос и структуру схемы сообщений:  
  
 ```  
    ON_WM_CTLCOLOR_REFLECT() 
 *// Note: other code will be in between....  
 
    HBRUSH CYellowEdit::CtlColor(CDC* pDC, UINT nCtlColor)   
 { *// TODO: Change any attributes of the DC here  
 *// TODO: Return a non-NULL brush if the *//   parent's handler should not be called  
    return NULL;  
 }  
 ```  
  
6.  Замените следующий код тела функции. Код определяет цвет текста, цвет фона текста и цвет фона для остальной части элемента управления.  
  
 ```  
    pDC->SetTextColor(m_clrText);
*// text  
    pDC->SetBkColor(m_clrBkgnd);
*// text bkgnd  
    return m_brBkgnd;            // ctl bkgnd  
 ```  
  
7.  Создание элемента управления диалогового окна, а затем присоединить ее к переменной-члена, дважды щелкнув элемент управления для редактирования при нажатой клавишей элемента управления. В диалоговом окне добавления переменной-члена Готово имя переменной и выберите «Элемент управления» для категории, а затем «CYellowEdit» для типа переменной. Не забудьте задать последовательность перехода в диалоговом окне. Кроме того, необходимо включить файл заголовка для `CYellowEdit` элемента управления в файле заголовка диалогового окна.  
  
8.  Скомпонуйте и запустите приложение. Элемент управления для редактирования будет желтым фоном.  
  
## <a name="see-also"></a>См. также  
 [Технические примечания по номеру](../mfc/technical-notes-by-number.md)   
 [Технические примечания по категории](../mfc/technical-notes-by-category.md)

