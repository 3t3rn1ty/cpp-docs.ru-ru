---
title: "Точки подключения | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "IConnectionPoint"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "CCmdTarget - класс, и точки подключения"
  - "COM, точки подключения"
  - "точки подключения [C++]"
  - "подключения, точки подключения"
  - "IConnectionPoint - интерфейс"
  - "интерфейсы, IConnectionPoint"
  - "MFC [C++], поддержка COM"
  - "MFC COM, точки подключения"
  - "OLE COM - точки подключения"
  - "приемники, точки подключения"
ms.assetid: bc9fd7c7-8df6-4752-ac8c-0b177442c88d
caps.latest.revision: 10
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 6
---
# Точки подключения
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

В этой статье описывается, как реализовать точки подключения \(ранее называвшихся серверами OLE точки подключения\) с помощью классов `CCmdTarget` и `CConnectionPoint` MFC.  
  
 В прошлом, модель COM \(COM\) определять общий механизм \(**IUnknown::QueryInterface**\), разрешившего объекты для реализации и предоставить функцию в интерфейсах.  Однако соответствующий механизм, разрешившего объекты, чтобы сделать их возможность вызова определенных интерфейсов не был задан.  То есть, указанное в модели COM как входящие указателей на объекты \(указателям к интерфейсам этого объекта\), обрабатываются, но он не имеют точную модель для исходящих интерфейсов \(объект содержат указатели на другие объекты интерфейсы\).  Модель COM теперь содержит модель, которая точками подключения, которая поддерживает эту функцию.  
  
 Подключение состоит из 2 частей: объект, вызывающий интерфейс с именем источника, а объект, реализующий интерфейс, называемый приемником.  Точка подключения интерфейс предоставленный источником.  Можно предоставлять точку подключения, источник приемников позволяет задавать подключения на себя \(источник\).  С помощью другого механизма точки подключения \(интерфейс **IConnectionPoint** \), указатель на интерфейс приемника передается в исходный объект.  Этот указатель предоставляет источника с доступом к реализации приемника набора функции\-члены.  Например, порождения события, приемником, источник может вызвать соответствующий метод реализации приемника.  На следующем рисунке показана описанную точку подключения только.  
  
 ![Реализованная точка подключения](../mfc/media/vc37lh1.png "vc37LH1")  
, Реализованная точка подключения  
  
 MFC реализует эту модель в классах [CConnectionPoint](../Topic/CConnectionPoint%20Class.md) и [CCmdTarget](../Topic/CCmdTarget%20Class.md).  Классы, производные от **CConnectionPoint**  реализует интерфейс **IConnectionPoint**, используется для предоставления точки подключения к другим объектам.  Классы, производные от `CCmdTarget` реализует интерфейс **IConnectionPointContainer**, который перечисляет все точки подключения объекта, или найти конкретную точку подключения.  
  
 Для каждой точки подключения, реализуемой в классе, необходимо объявить часть подключения, которая реализует точку подключения.  При реализации один или более точек подключения, необходимо также объявить одно сопоставление подключения в классе.  Сопоставление подключения таблице точек подключения поддерживаемых элементов управления ActiveX.  
  
 В следующих примерах показано простое сопоставление подключения и одну точку подключения.  В первом примере объявляется и сопоставление точки подключения; второй пример реализует сопоставление и точку.  Обратите внимание, что `CMyClass`  должно быть `CCmdTarget`\- производным классом.  В первом примере код вставляется в объявление класса, в разделе **protected** .  
  
 [!code-cpp[NVC_MFCConnectionPoints#1](../mfc/codesnippet/CPP/connection-points_1.h)]  
  
 `BEGIN_CONNECTION_PART` и макросы **END\_CONNECTION\_PART**  объявлен вложенный класс, `XSampleConnPt` \(производное от `CConnectionPoint`\), который реализует эту заданной точки подключения.  Если требуется переопределить какие\-либо функции\-члены `CConnectionPoint` или добавить функции\-члены, следует объявить их между этими 2 макросами.  Например, `CONNECTION_IID` переопределяет макрос функцию\-член `CConnectionPoint::GetIID` стоя между этими 2 макросами.  
  
 Во втором примере код вставляется в файле реализации \(cpp\-файл\).  Этот код реализует сопоставление подключения, содержит точку подключения, `SampleConnPt`:  
  
 [!code-cpp[NVC_MFCConnectionPoints#2](../mfc/codesnippet/CPP/connection-points_2.cpp)]  
  
 Если класс имеет более одной точки подключения, введите дополнительные `BEGIN_CONNECTION_MAP` и макросы `CONNECTION_PART` между макросами `END_CONNECTION_MAP`.  
  
 Наконец, добавьте вызов `EnableConnections` в конструкторе класса.  Примеры.  
  
 [!code-cpp[NVC_MFCConnectionPoints#3](../mfc/codesnippet/CPP/connection-points_3.cpp)]  
  
 После этого код был представлен, в `CCmdTarget`\- производный класс предоставляет точку подключения для интерфейса **ISampleSink** .  На следующем рисунке показаны в этом примере.  
  
 ![Точка подключения, реализованная с помощью MFC](../mfc/media/vc37lh2.png "vc37LH2")  
Точка подключения, реализованная с MFC  
  
 Как правило, точки подключения поддерживают «multicasting» — возможность широковещательной передачи в нескольких приемникам подключенным к одному и тому же интерфейс.  В следующем примере показано, как выполнить фрагмент Групповой передачи с помощью итерации каждый приемник в точке подключения:  
  
 [!code-cpp[NVC_MFCConnectionPoints#4](../mfc/codesnippet/CPP/connection-points_4.cpp)]  
  
 Этот пример возвращает текущий набор подключений в точке подключения `SampleConnPt` с вызовом `CConnectionPoint::GetConnections`.  Затем просматривает подключения и вызывает метод **ISampleSink::SinkFunc** для каждого активного подключения.  
  
## См. также  
 [MFC COM](../mfc/mfc-com.md)