---
title: "Tn026: процедуры DDX и DDV подпрограммы | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords:
- DDX
- DDV
dev_langs: C++
helpviewer_keywords:
- DDX (dialog data exchange), procedures
- TN026
- DDV (dialog data validation), procedures
ms.assetid: c2eba87a-4b47-4083-b28b-e2fa77dfb4c4
caps.latest.revision: "10"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: 15c2309e8080892bdca2753c1ea6128ce419862f
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="tn026-ddx-and-ddv-routines"></a>TN026. Процедуры DDX и DDV
> [!NOTE]
>  Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.  
  
 Эта заметка описывает обмен данными (диалоговых окон DDX) и архитектура (DDV) проверки данных диалогового окна. Он также описывает, как создавать DDX_ или DDV_ процедуры и как можно расширить ClassWizard для использования вашей процедур.  
  
## <a name="overview-of-dialog-data-exchange"></a>Общие сведения о обмен данными диалоговых окон  
 Все функции данных диалогового окна осуществляется с кодом C++. Отсутствуют специальные ресурсы или magic макросы. Основой механизма — это виртуальная функция, которая переопределяется в каждом классе диалоговое окно, обмена данными диалогового окна и проверки. Он всегда находится в этой форме:  
  
```  
void CMyDialog::DoDataExchange(CDataExchange* pDX)  
{  
    CDialog::DoDataExchange(pDX);
*// call base class  
 *//{{AFX_DATA_MAP(CMyDialog)  
 <data_exchange_function_call>  
 <data_validation_function_call> *//}}AFX_DATA_MAP  
}  
```  
  
 Комментарии AFX специальный формат разрешить ClassWizard для поиска и редактирования кода в рамках данной функции. Код, который не совместим с ClassWizard должны располагаться за пределами комментарии специальный формат.  
  
 В приведенном выше примере < data_exchange_function_call > находится в форме:  
  
```  
DDX_Custom(pDX,
    nIDC,
    field);
```  
  
 и < data_validation_function_call > является необязательным и находится в форме:  
  
```  
DDV_Custom(pDX,
    field, ...);
```  
  
 Несколько пар DDX_/DDV_ могут быть включены в каждом `DoDataExchange` функции.  
  
 Список всех программы обмена данных диалоговых окон и программы проверки данных диалоговых окон, в MFC. в разделе «afxdd_.h».  
  
 Данные диалогового окна, является: данные-члены в **объектом CMyDialog произведет** класса. Он не сохраняется в структуре или ничего подобного.  
  
## <a name="notes"></a>Примечания  
 Несмотря на то, что мы называем «данных диалогового окна», все функции доступны в любом классе, производном от `CWnd` и не ограничиваются только диалоговые окна.  
  
 Начальные значения данных задаются в конструкторе standard C++ обычно в блоке с `//{{AFX_DATA_INIT` и `//}}AFX_DATA_INIT` комментарии.  
  
 `CWnd::UpdateData`Операция, которая выполняет инициализации и вокруг вызова обработки ошибок `DoDataExchange`.  
  
 Можно вызвать `CWnd::UpdateData` в любое время для выполнения обмена данными и проверки. По умолчанию `UpdateData`(TRUE), вызывается в значение по умолчанию `CDialog::OnOK` обработчика и `UpdateData`(FALSE) вызывается в значение по умолчанию `CDialog::OnInitDialog`.  
  
 Подпрограмма DDV_ должен следовать непосредственно за DDX_ подпрограммы для этого *поля*.  
  
## <a name="how-does-it-work"></a>Как это работает  
 Необходимо принять во внимание следующие для использования данных диалогового окна. Однако основные сведения о том, как это работает в фоновом поможет вам создать собственную процедуру exchange или проверки.  
  
 `DoDataExchange` Функция-член является очень похоже на `Serialize` функция-член - он отвечает за получения или задания данных, в/из внешних формы (в этом случае элементы управления в диалоговом окне) на данные-члены в класс. `pDX` Параметр контекст для выполнения обмена данными и похож на `CArchive` параметр `CObject::Serialize`. `pDX` ( `CDataExchange` Объекта) имеет направление флаг подобно проводнику `CArchive` имеет флаг направления:  
  
-   Если **! m_bSaveAndValidate**, затем загрузить состояние данных в элементах управления.  
  
-   Если `m_bSaveAndValidate`, затем задайте состояние данных от элементов управления.  
  
 Проверка происходит только при `m_bSaveAndValidate` имеет значение. Значение `m_bSaveAndValidate` определяется параметром BOOL в `CWnd::UpdateData`.  
  
 Существует три других интересных `CDataExchange` члены:  
  
- `m_pDlgWnd`: Окно (обычно диалоговое окно), содержащий элементы управления. Это предотвращает вызывающих объектов глобальные функции DDX_ и DDV_ от необходимости передавать «this» каждые DDX/DDV подпрограмму.  
  
- `PrepareCtrl`, и `PrepareEditCtrl`: подготавливает управления диалогового окна для обмена данными. Сохраняет дескриптор элемента управления для фокусировки, если проверка не пройдена. `PrepareCtrl`используется для элементов управления nonedit и `PrepareEditCtrl` используется для редактирования.  
  
- **Сбой**: вызывается после переноса выводится сообщение, информирующее пользователя ошибок на входе. Эта процедура приведет к восстановлению фокуса на последний элемент управления (последнего вызова `PrepareCtrl` / `PrepareEditCtrl`) и создает исключение. Эта функция-член может вызываться из процедур DDX_ и DDV_.  
  
## <a name="user-extensions"></a>Пользовательские расширения  
 Существует несколько способов для расширения стандартного механизма DDX/DDV. Можно выполнить следующие действия.  
  
-   Добавление новых типов данных.  
  
 ```  
    CTime 
 ```  
  
-   Добавьте новые процедуры exchange (DDX_).  
  
 ```  
    void PASCAL DDX_Time(CDataExchange* pDX,
    int nIDC,
    CTime& tm);

 ```  
  
-   Добавьте новые процедуры проверки (DDV_).  
  
 ```  
    void PASCAL DDV_TimeFuture(CDataExchange* pDX,
    CTime tm,
    BOOL bFuture);
*// make sure time is in the future or past  
 ```  
  
-   Передайте произвольных выражений процедуры проверки.  
  
 ```  
    DDV_MinMax(pDX,
    age,
    0,
    m_maxAge);

 ```  
  
    > [!NOTE]
    >  Такие произвольного выражения не может редактировать ClassWizard и таким образом, должны быть перемещены за пределами специальный формат комментарии (/ / {{AFX_DATA_MAP(CMyClass)).  
  
 У **DoDialogExchange** функции-члена включают условные выражения или любые другие допустимые операторы C++ с смешанные вызовы функций обмена и проверки.  
  
```  
//{{AFX_DATA_MAP(CMyClass)  
DDX_Check(pDX,
    IDC_SEX,
    m_bFemale);

DDX_Text(pDX,
    IDC_EDIT1,
    m_age);

//}}AFX_DATA_MAP  
if (m_bFemale)  
    DDV_MinMax(pDX,
    age,
    0,
    m_maxFemaleAge);

else  
    DDV_MinMax(pDX,
    age,
    0,
    m_maxMaleAge);
```  
  
> [!NOTE]
>  Как показано выше, такой код не может редактировать ClassWizard и должен использоваться только за пределами комментарии специальный формат.  
  
## <a name="classwizard-support"></a>Мастер классов поддержки  
 Мастер классов поддерживает подмножество DDX/DDV настроек, позволяя интегрировать собственные подпрограммы DDX_ и DDV_ в пользовательском интерфейсе классов. Это имеет стоимость полезным, если планируется повторно использовать определенные процедуры DDX и DDV, в проекте или во многих проектах.  
  
 Чтобы сделать это, специальные записи выполняются в DDX. CLW (предыдущих версий Visual C++ хранятся эти данные в APSTUDIO. INI) или в своем проекте. Файл CLW. Специальные операции могут быть введены в разделе [Общие сведения] вашего проекта. Файл CLW или в разделе [ExtraDDX] DDX. Файл CLW в каталоге \Program Files\Microsoft Visual Studio\Visual C ++ \bin. Может потребоваться создать DDX. CLW файл, если он еще не существует. Если планируется использовать пользовательские процедуры DDX_/DDV_ только в определенных проекте, добавьте записи в раздел [Общие сведения] проекта. Вместо этого файла CLW. Если вы планируете использовать подпрограммы на множество проектов, добавьте записи в раздел [ExtraDDX] DDX. CLW.  
  
 Эти специальные записи общие выглядит следующим образом:  
  
```  
ExtraDDXCount=n  
```  
  
 где n — число строк ExtraDDX следовать  
  
```  
ExtraDDX=<keys>;<vb-keys>; <prompt>; <type>; <initValue>; <DDX_Proc>  
[;<DDV_Proc>; <prompt1>; <arg1>; [<prompt2>; <fmt2>]]  
```  
  
 где — номер 1 - n, позволяющее определить, какой тип DDX в списке, который определяется.  
  
 Каждое поле отделяется символом «;». Ниже приводится описание полей и их назначение.  
  
 \<ключи >  
 = Список отдельных символов, указывающее, для которых элементов управления диалоговых окон разрешено переменных этого типа.  
  
 E = Правка  
  
 C = флажок двумя состояниями  
  
 c = флажок тремя состояниями  
  
 R = первого переключателя в группе  
  
 L = возврат неупорядоченного списка  
  
 l = отсортированного списка.  
  
 M = списком (с изменение элементов)  
  
 N = несортированные раскрывающийся список  
  
 n = отсортированный раскрывающийся список  
  
 1 = Если DDX insert должны быть добавлены в заголовке списка (по умолчанию добавить заключительного) обычно используется для подпрограмм DDX, передающие свойство «Доступ».  
  
 \<ключи VB >  
 Это поле используется только в 16-разрядную версию продукта для элементов управления VBX (VBX элементы управления не поддерживаются в 32-разрядную версию продукта)  
  
 \<строка >  
 Строка для размещения в поле со списком свойств (без кавычек)  
  
 \<type>  
 Один идентификатор типа для передачи в файле заголовка. В нашем примере выше с DDX_Time устанавливается для CTime.  
  
 \<ключи VB >  
 В этой версии не используется и всегда должно быть пустым.  
  
 \<начального значения >  
 Начальное значение — 0 или пустым. Если поле пусто, строка инициализации не будут записаны в разделе //{{AFX_DATA_INIT файла реализации. Пустая запись следует использовать для объектов C++ (такие как `CString`, `CTime`и так далее), имеют конструкторы, которые гарантируют правильную инициализацию.  
  
 < DDX_Proc >  
 Один идентификатор DDX_ процедуры. Имя функции C++ должно начинаться с «DDX_», но не включает «DDX_» в идентификатор < DDX_Proc >. В приведенном выше примере идентификатор < DDX_Proc > будет время. Когда ClassWizard записывает вызов функции в файл реализации {{AFX_DATA_MAP раздел, он добавляет это имя DDX_, таким образом, поступающих в DDX_Time.  
  
 \<комментарий >  
 Комментарий для отображения в диалоговом окне для переменной с этой DDX. Поместите хотелось бы здесь и обычно предоставляют что-нибудь текст, описывающий операцию, выполняемую парой DDX/DDV.  
  
 < DDV_Proc >  
 DDV часть операции является необязательным. Не все подпрограммы DDX имеют соответствующие DDV подпрограммы. Часто более удобно для включения на этапе проверки как неотъемлемой частью передачи. Это часто так при DDV подпрограмма не требует параметров, поскольку ClassWizard не поддерживает DDV процедуры без параметров.  
  
 \<arg >  
 Один идентификатор DDV_ процедуры. Имя функции C++ должно начинаться с «DDV_», но не включайте в < DDX_Proc > идентификатор «DDX_».  
  
 следуют args DDV 1 или 2.  
  
 \<promptX >  
 Строка для размещения выше изменение элементов (с & для сочетаний клавиш)  
  
 \<fmtX >  
 Символ формата для типа arg, один из  
  
 d = int  
  
 u = число без знака  
  
 D = long int (то есть, long)  
  
 U = long без знака (то есть DWORD)  
  
 f = число с плавающей запятой  
  
 F = double  
  
 s = строка  
  
## <a name="see-also"></a>См. также  
 [Технические примечания по номеру](../mfc/technical-notes-by-number.md)   
 [Технические примечания по категории](../mfc/technical-notes-by-category.md)

