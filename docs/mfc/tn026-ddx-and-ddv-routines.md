---
title: 'Tn026: процедуры DDX и DDV подпрограммы | Документы Microsoft'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-mfc
ms.topic: conceptual
f1_keywords:
- DDX
- DDV
dev_langs:
- C++
helpviewer_keywords:
- DDX (dialog data exchange), procedures
- TN026
- DDV (dialog data validation), procedures
ms.assetid: c2eba87a-4b47-4083-b28b-e2fa77dfb4c4
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 44a946b21908f45b595056a956c75b234fdbb886
ms.sourcegitcommit: 76b7653ae443a2b8eb1186b789f8503609d6453e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
---
# <a name="tn026-ddx-and-ddv-routines"></a>TN026. Процедуры DDX и DDV
> [!NOTE]
>  Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.  
  
 Эта заметка описывает архитектуру обмена данными (DDX) и проверки данных (DDV) диалоговых окон. Она также описывает как создавать DDX_ или DDV_ процедуры и как можно расширить ClassWizard для использования ваших процедур.
  
## <a name="overview-of-dialog-data-exchange"></a>Общие сведения об обмене данными диалоговых окон  
 Все функции работы с данными диалогового окна выполняются в коде C++. Отсутствуют специальные ресурсные или магические макросы. Основа механизма — это виртуальная функция, которая переопределяется в каждом классе диалогового окна, осуществляющего обмен и проверки данных. Она всегда находится в такой форме:  
  
```  
void CMyDialog::DoDataExchange(CDataExchange* pDX)  
{  
    CDialog::DoDataExchange(pDX);
*// call base class  
 *//{{AFX_DATA_MAP(CMyDialog)  
 <data_exchange_function_call>  
 <data_validation_function_call> *//}}AFX_DATA_MAP  
}  
```  
  
 Комментарии специального формата AFX позволяют мастеру ClassWizard искать и редактировать код в рамках данной функции. Код, который не совместим с ClassWizard, должен располагаться за пределами этих комментариев специального формата.  
  
 В приведенном выше примере < data_exchange_function_call > находится в форме:  
  
```  
DDX_Custom(pDX,
    nIDC,
    field);
```  
  
 и < data_validation_function_call > является необязательным и находится в форме:  
  
```  
DDV_Custom(pDX,
    field, ...);
```  
  
 Несколько пар DDX_/DDV_ могут быть включены в каждой функции `DoDataExchange`.  
  
 Список всех программ обмена данными диалоговых окон и программ проверки данных диалоговых окон находится в MFC в файле «afxdd_.h».  
  
 Данные диалогового окна - это данные-члены в классе **CMyDialog**. Они не сохраняются в структуре или чем-то подобном.  
 
## <a name="notes"></a>Примечания  
 Несмотря на то, что мы называем это «данные диалогового окна», все функции доступны в любом классе, производном от `CWnd` и не ограничиваются только диалоговыми окнами.  
  
 Начальные значения данных задаются в обычном конструкторе C++, обычно в блоке между комментариями `//{{AFX_DATA_INIT` и `//}}AFX_DATA_INIT`.  
  
 `CWnd::UpdateData` это операция, которая выполняет инициализацию и обработку ошибок вокруг вызова `DoDataExchange`.  
  
 Можно вызвать `CWnd::UpdateData` в любое время для выполнения обмена данными и проверки. По умолчанию `UpdateData`(TRUE), вызывается в стандартной реализации обработчика `CDialog::OnOK`, а `UpdateData`(FALSE) вызывается в стандартной реализации `CDialog::OnInitDialog`.  
  
 Подпрограмма DDV_ должна следовать непосредственно за подпрограммой DDX_ для этого *поля*.  
  
## <a name="how-does-it-work"></a>Как это работает  
 Чтобы использовать данные диалоговых окон нет необходимости понимать то, что написано ниже. Однако понимание того, как это работает, поможет вам создать собственные процедуры обмена или проверки.  
  
 `DoDataExchange` Функция-член очень похожа на функцию-член `Serialize` - она отвечает за получение или установку данных в/из внешних форм (в данном случае элементов управления в диалоговом окне) из/в данные-члены класса. `pDX` Параметр контекста для выполнения обмена данными, похож на параметр `CArchive` функции-члена `CObject::Serialize`. `pDX` (объект класса `CDataExchange`) имеет флаг направления подобно `CArchive`:  
  
-   Если **! m_bSaveAndValidate**, то необходимо загрузить состояние данных в элементы управления.  
  
-   Если `m_bSaveAndValidate`, то необходимо задать состояние данных из элементов управления.  
  
 Проверка происходит только когда `m_bSaveAndValidate` установлено. Значение `m_bSaveAndValidate` определяется параметром BOOL в `CWnd::UpdateData`.  
  
 Есть три других интересных члена `CDataExchange`:  
  
- `m_pDlgWnd`: Окно (обычно диалоговое окно), содержащее элементы управления. Этот указатель необходим для того, чтобы объекты, вызывавющие глобальные функции DDX_ и DDV_, не передавали «this» каждой подпрограмме DDX/DDV.  
  
- `PrepareCtrl`, и `PrepareEditCtrl`: подготавливают элементы управления диалогового окна для обмена данными. Сохраняет дескриптор элемента управления для фокусировки на нем, если проверка не пройдена. `PrepareCtrl` используется для нередактируемых элементов управления, а `PrepareEditCtrl` используется для редактируемых элементов управления.  
  
- **Fail**: вызывается после вывода сообщения, информирующего пользователя об ошибках при вводе данных. Эта процедура приведет к восстановлению фокуса на последний элемент управления (последнего вызова `PrepareCtrl` / `PrepareEditCtrl`) и создаст исключение. Эта функция-член может вызываться из процедур DDX_ и DDV_.  
  
## <a name="user-extensions"></a>Пользовательские расширения  
 Существует несколько способов для расширения стандартного механизма DDX/DDV. Можно выполнить следующие действия:  
  
-   Добавить новый типо данных.  
  
 ```  
    CTime 
 ```  
  
-   Добавить новые процедуры обмена (DDX_).  
  
 ```  
    void PASCAL DDX_Time(CDataExchange* pDX,
    int nIDC,
    CTime& tm);

 ```  
  
-   Добавить новые процедуры проверки (DDV_).  
  
 ```  
    void PASCAL DDV_TimeFuture(CDataExchange* pDX,
    CTime tm,
    BOOL bFuture);
*// make sure time is in the future or past  
 ```  
  
-   Передать произвольные выражения в процедуры проверки.  
  
 ```  
    DDV_MinMax(pDX,
    age,
    0,
    m_maxAge);

 ```  
  
    > [!NOTE]
    >  Такие произвольные выражения не могуть быть отредактированы мастером ClassWizard, поэтому должны быть перемещены за пределами комментариев в специальном формате (// {{AFX_DATA_MAP(CMyClass)).  
  
- Создать функцию-член **DoDialogExchange**, включающую условные выражения или любые другие допустимые операторы C++ со смешанными вызовами функций обмена и проверки.  
  
```  
//{{AFX_DATA_MAP(CMyClass)  
DDX_Check(pDX,
    IDC_SEX,
    m_bFemale);

DDX_Text(pDX,
    IDC_EDIT1,
    m_age);

//}}AFX_DATA_MAP  
if (m_bFemale)  
    DDV_MinMax(pDX,
    age,
    0,
    m_maxFemaleAge);

else  
    DDV_MinMax(pDX,
    age,
    0,
    m_maxMaleAge);
```  
  
> [!NOTE]
>  Как указано выше такой код не может быть отредактирован мастером ClassWizard и должен указываться только за пределами комментариев в специальном формате.   
  
## <a name="classwizard-support"></a>Мастер классов поддержки  
 Мастер классов поддерживает подмножество DDX/DDV настроек, позволяя интегрировать собственные подпрограммы DDX_ и DDV_ в пользовательский интерфейс мастера классов. Это может быть полезным, если планируется повторно использовать определенные процедуры DDX и DDV, в одном или нескольких проектах.  
  
 Чтобы добиться этого необходимо добавить специальные записи в файл DDX.CLW (в предыдущих версиях Visual C++ эти данные хранятся в APSTUDIO.INI) или в файле <ваш проект>.CLW. Специальные записи могут быть введены в раздел [General Info] файла <ваш проект>.CLW или в разделе [ExtraDDX] файла DDX.CLW, который находится в каталоге \Program Files\Microsoft Visual Studio\Visual C ++ \bin. Может потребоваться создать файл DDX.CLW, если он еще не существует. Если планируется использовать пользовательские процедуры DDX_/DDV_ только в определенных проекте, то лучше добавьте записи в раздел [General Info] файла <ваш проект>.CLW. Если вы планируете использовать подпрограммы на множество проектов, добавьте записи в раздел [ExtraDDX] файла DDX.CLW.  
  
 Эти специальные записи общие выглядит следующим образом:  
  
```  
ExtraDDXCount=n  
```  
  
 где n — число строк ExtraDDX, которые будут указаны далее 
  
```  
ExtraDDX=<keys>;<vb-keys>; <prompt>; <type>; <initValue>; <DDX_Proc>  
[;<DDV_Proc>; <prompt1>; <arg1>; [<prompt2>; <fmt2>]]  
```  
  
 где число 1 - n указывает, какой тип DDX в списке определяется.  
  
 Каждое поле отделяется символом «;». Ниже приводится описание полей и их назначение.  
  
 \<keys>  
 = Список отдельных символов, указывающее, для каких типов элементов управления диалогового окна разрешено использование переменных этого типа.  
  
 E = редактируемое поле  
  
 C = флажок двумя состояниями  
  
 c = флажок тремя состояниями  
  
 R = первый переключатель в группе радио-кнопок 
  
 L = неупорядоченный список  
  
 l = упорядоченный список  
  
 M = комбинированный список (раскрывающийся список с редактируемым полем)  
  
 N = неупорядоченный раскрывающийся список  
  
 n = упорядоченный раскрывающийся список  
  
 1 = Если вставка DDX должна выполняться в начало списка (по умолчанию выполняется в конец списка). Обычно используется для подпрограмм DDX, передающих свойство «Control».  
  
 \<vb-keys>  
 Это поле используется только в 16-разрядной версии продукта для элементов управления VBX (VBX элементы управления не поддерживаются в 32-разрядной версии продукта)  
  
 \<prompt>  
 Строка для размещения в поле со списком свойств (без кавычек)  
  
 \<type>  
 Один идентификатор типа для передачи в заголовочный файл. В нашем примере выше для DDX_Time устанавливается CTime.  
  
 \<vb-keys>  
 В этой версии не используется и всегда должно быть пустым.  
  
 \<initValue>  
 Начальное значение — 0 или пусто. Если поле пусто, строка инициализации не будет записана в разделе //{{AFX_DATA_INIT файла реализации. Пустую запись следует использовать для объектов C++ (такие как `CString`, `CTime`и так далее), имеющих конструкторы, которые гарантируют правильную инициализацию.  
  
 < DDX_Proc >  
 Единый идентификатор DDX_ процедуры. Имя функции C++ должно начинаться с «DDX_», но не должно включать «DDX_» в идентификатор < DDX_Proc >. В приведенном выше примере идентификатор < DDX_Proc > будет Time. Когда ClassWizard записывает вызов функции в файл реализации в раздел {{AFX_DATA_MAP, он добавляет к этому идентификатору префикс DDX_, таким образом получая DDX_Time.  
  
 \<comment>  
 Комментарий для отображения в диалоговом окне для переменной с этой DDX. Поместите любой текст, который хочется; обычно предоставляют текст, описывающий операцию, выполняемую парой DDX/DDV.  
  
 < DDV_Proc >  
 DDV часть записи является необязательной. Не все подпрограммы DDX имеют соответствующие DDV подпрограммы. Часто более удобно включать этап проверки как неотъемлемую часть передачи. Это часто бывает, когда DDV подпрограмма не требует параметров, поскольку ClassWizard не поддерживает DDV процедуры без параметров.  
  
 \<arg >  
 Единый идентификатор DDV_ процедуры. Имя функции C++ должно начинаться с «DDV_», но не должно включать в < DDX_Proc > идентификатор «DDX_».  
  
 за аргументом <arg> следуют один или два аргумента DDV.  
  
 \<promptX >  
 Строка для размещения над редактируемым элементом (с & для сочетаний клавиш)  
  
 \<fmtX >  
 Символ формата для типа arg, один из  
  
 d = int  
  
 u = число без знака  
  
 D = long int (то есть, long)  
  
 U = long без знака (то есть DWORD)  
  
 f = число с плавающей запятой  
  
 F = double  
  
 s = строка  
  
## <a name="see-also"></a>См. также  
 [Технические примечания по номеру](../mfc/technical-notes-by-number.md)   
 [Технические примечания по категории](../mfc/technical-notes-by-category.md)

