---
title: 'TN045: Поддержка баз данных MFC для типов Long Varchar — Varbinary | Документы Microsoft'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-mfc
ms.topic: conceptual
f1_keywords:
- vc.mfc.data
dev_langs:
- C++
helpviewer_keywords:
- TN045
- Varbinary data type
- Varchar data type
ms.assetid: cf572c35-5275-45b5-83df-5f0e36114f40
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 1454be53dce60f5e84e03b895575c480d972c4c0
ms.sourcegitcommit: c6b095c5f3de7533fd535d679bfee0503e5a1d91
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/26/2018
ms.locfileid: "36956880"
---
# <a name="tn045-mfcdatabase-support-for-long-varcharvarbinary"></a>TN045. Поддержка MFC и баз данных для типов Long Varchar и Varbinary
> [!NOTE]
>  Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.  
  
 Эта заметка описывает способ получения и отправки ODBC **SQL_LONGVARCHAR** и **SQL_LONGVARBINARY** типов данных с помощью MFC базы данных классов.  
  
## <a name="overview-of-long-varcharvarbinary-support"></a>Общие сведения о поддержке Long Varchar и Varbinary  
 ODBC **SQL_LONG_VARCHAR** и **SQL_LONGBINARY** (Далее как длинные столбцы данных) типы данных могут содержать огромные объемы данных. Эти данные можно обрабатывать 3 способами.  
  
-   Привяжите его к `CString` / `CByteArray`.  
  
-   Привяжите его к `CLongBinary`.  
  
-   Не привязать его вообще и извлечь и отправить данные большой длины значение вручную, независимо от классов базы данных.  
  
 Каждый из трех способов имеет свои преимущества и недостатки.  
  
 Столбцы данных большой длины не поддерживаются для параметров для запроса. Они поддерживаются только для outputColumns.  
  
## <a name="binding-a-long-data-column-to-a-cstringcbytearray"></a>Привязка данных большой длины столбца CString/CByteArray  
 Преимущества:  
  
 Этот подход является простым для понимания и работы с знакомые классы. Платформа предоставляет `CFormView` поддержка `CString` с `DDX_Text`. У вас есть большое количество общие функциональные возможности строки или коллекции с `CString` и `CByteArray` классов и можно управлять объемом памяти, выделенной локально для хранения значения данных. Платформа поддерживает старая копия поля данных во время `Edit` или `AddNew` вызовы функций и framework может автоматически обнаруживает изменения в данные самостоятельно.  
  
> [!NOTE]
>  Поскольку `CString` предназначен для работы в символьные данные и `CByteArray` для работы на двоичные данные, рекомендуется помещать символьных данных (**SQL_LONGVARCHAR**) в `CString`и двоичные данные ( **SQL_LONGVARBINARY**) в `CByteArray`.  
  
 Функции RFX для `CString` и `CByteArray` имеет дополнительный аргумент, который позволяет переопределить размер выделенной памяти для хранения извлеченных значения для столбца данных по умолчанию. Примечание аргумент nMaxLength в следующих объявлениях функций.  
  
```  
void AFXAPI RFX_Text(CFieldExchange* pFX,
    const char *szName,  
    CString& value,
    int nMaxLength = 255,
    int nColumnType = 
    SQL_VARCHAR);

 
void AFXAPI RFX_Binary(CFieldExchange* pFX,
    const char *szName,   
    CByteArray& value,
    int nMaxLength = 255);
```  
  
 При получении данных большой длины столбца `CString` или `CByteArray`, максимально возвращается объем данных, по умолчанию 255 байт. Все содержимое сверх этого пропускается. В этом случае платформа вызовет исключение **AFX_SQL_ERROR_DATA_TRUNCATED**. К счастью, можно явным образом увеличить nMaxLength больше значения до **MAXINT**.  
  
> [!NOTE]
>  Значение nMaxLength используется MFC для задания локального буфера из `SQLBindColumn` функции. Это локальный буфер для хранения данных, в действительности не влияют объем данных, возвращаемых драйвером ODBC. `RFX_Text` и `RFX_Binary` только сделать одно вызовы с использованием `SQLFetch` для извлечения данных из базы данных серверной части. Каждый драйвер ODBC имеет другой ограничение на объем данных, которые могут вернуть в одну операцию выборки. Это ограничение может быть гораздо меньше, чем значение nMaxLength, в этом случае исключение **AFX_SQL_ERROR_DATA_TRUNCATED** будет создано. При этих обстоятельствах переключиться на использование `RFX_LongBinary` вместо `RFX_Text` или `RFX_Binary` , чтобы можно было получить все данные.  
  
 Выполняет привязку ClassWizard **SQL_LONGVARCHAR** для `CString`, или **SQL_LONGVARBINARY** для `CByteArray` для вас. Если требуется выделить более 255 байт, в которые получения длинных данных столбца, можно затем предоставить явное значение nMaxLength.  
  
 Если столбец данных long привязан к `CString` или `CByteArray`, обновив поле работает точно так же как при привязке к SQL_**VARCHAR** или SQL_**VARBINARY**. Во время `Edit`, значение кэшируется немедленно и более поздних версиях при сравнении `Update` вызывается для обнаружения изменений данных значение и задайте Dirty и значения Null для столбца соответствующим образом.  
  
## <a name="binding-a-long-data-column-to-a-clongbinary"></a>Привязка данных большой длины столбца CLongBinary  
 Если данные большой длины столбца может содержать несколько **MAXINT** байт данных, возможно, рассмотрите возможность извлечения его в `CLongBinary`.  
  
 Преимущества:  
  
 Это возвращает столбец всей длинных данных до доступной памяти.  
  
 Недостатки:  
  
 Данные содержатся в памяти. Такой подход также дорого стоит для очень больших объемов данных. Необходимо вызвать `SetFieldDirty` для связанных данных члена, чтобы убедиться в поле включено в `Update` операции.  
  
 При получении данных большой длины столбцов в `CLongBinary`, классы базы данных проверьте общий объем данных большой длины столбца, затем выделите `HGLOBAL` сегмента памяти недостаточно велик для хранения его значения типа данных. Классы баз данных извлекают значения типа данных в выделенная `HGLOBAL`.  
  
 Если источник данных не возвращает ожидаемый размер столбца большие объемы данных, платформа вызовет исключение **AFX_SQL_ERROR_SQL_NO_TOTAL**. Если выделить `HGLOBAL` завершается ошибкой, стандартная памяти возникает исключение.  
  
 Выполняет привязку ClassWizard **SQL_LONGVARCHAR** или **SQL_LONGVARBINARY** для `CLongBinary` для вас. Выберите `CLongBinary` как тип переменной, в диалоговом окне Добавление переменной-члена. Затем мы добавим ClassWizard `RFX_LongBinary` вызов вашей `DoFieldExchange` вызова и увеличить общее количество связанных полей.  
  
 Чтобы обновить длинные значения столбцов данных, сначала убедитесь, что выделенная `HGLOBAL` достаточно велик для хранения новых данных, вызвав **:: GlobalSize** на *m_hData* членом `CLongBinary`. Если слишком мало выпуска `HGLOBAL` и выделите одного соответствующего размера. Затем установите *m_dwDataLength* для отражения нового размера.  
  
 В противном случае, если *m_dwDataLength* больше, чем размер данных, замене, можно освободить и перераспределение `HGLOBAL`, или оставить его выделить. Убедитесь в том указать число байтов, фактически используемый в *m_dwDataLength*.  
  
## <a name="how-updating-a-clongbinary-works"></a>Способ обновления CLongBinary работает  
 Необязательно понять, как обновление `CLongBinary` работает, но его можно использовать в качестве примера о том, как отправить данные большого к источнику данных, если вы выберите третий способ, описанный ниже.  
  
> [!NOTE]
>  Чтобы `CLongBinary` поля для включения в обновление, необходимо явно вызывать `SetFieldDirty` для поля. Если при внесении изменений в поле, в том числе установка значения Null, необходимо вызвать `SetFieldDirty`. Кроме того, необходимо вызвать метод `SetFieldNull`, со второй параметр, **FALSE**, чтобы пометить поле как имеющий значение.  
  
 При обновлении `CLongBinary` поле классы базы данных используйте ODBC **DATA_AT_EXEC** механизм (см. в документации ODBC на `SQLSetPos`rgbValue аргумент). Когда платформа подготавливает инструкцию insert или update вместо команды `HGLOBAL` с данными, *адрес* из `CLongBinary` задается как *значение* столбца Вместо этого и признак длины, равным **значение SQL_DATA_AT_EXEC**. Позже, когда инструкция update отправляется к источнику данных `SQLExecDirect` вернет **SQL_NEED_DATA**. Это предупреждение платформу, что значения параметров для этого столбца является фактически адрес `CLongBinary`. Платформа вызывает `SQLGetData` один раз с небольшим буфером, ожидается драйвер возвращает фактическую длину данных. Если драйвер возвращает фактическую длину большой двоичный объект (BLOB), MFC перераспределяет столько же места при необходимости для получения большого двоичного ОБЪЕКТА. Если источник данных возвращает **SQL_NO_TOTAL**, указывающее, что он не может определить размер большого двоичного ОБЪЕКТА, MFC создаст более мелкие блоки. Исходный размер по умолчанию составляет 64 КБ, и последующие блоки будет двойной размер. Например второй будет равен 128 КБ, третий — 256 КБ и т. д. Начальный размер настраивается.  
  
## <a name="not-binding-retrievingsending-data-directly-from-odbc-with-sqlgetdata"></a>Привязки не: Получение и передачу данных непосредственно из ODBC с SQLGetData  
 С помощью этого метода можно полностью обойти классы баз данных и работать со столбцом данных большой длины.  
  
 Преимущества:  
  
 Для кэширования данных на диск при необходимости, и определить динамически объем данных для извлечения.  
  
 Недостатки:  
  
 Вы не получаете framework `Edit` или `AddNew` поддержки и необходимо написать код для выполнения базовых функций (`Delete` работает, поскольку операция уровня столбца не).  
  
 В этом случае данные большой длины столбца должно быть в списке выбора набора записей, но не должны быть привязаны к платформой. Один из способов сделать это — предоставить собственную инструкцию SQL через `GetDefaultSQL` или как аргумент lpszSQL `CRecordset` `Open` функцией и не удается привязать дополнительный столбец с помощью вызова функции RFX_. ODBC требует, что несвязанные поля отображаются справа от связанных полей, поэтому добавьте несвязанного столбца или столбцов в конец списка выбора.  
  
> [!NOTE]
>  Поскольку данные большой длины столбца не привязан платформой, изменения не будут обрабатываться с `CRecordset::Update` вызовов. Необходимо создать и отправить необходимые SQL **вставить** и **обновление** инструкций самостоятельно.  
  
## <a name="see-also"></a>См. также  
 [Технические примечания по номеру](../mfc/technical-notes-by-number.md)   
 [Технические примечания по категории](../mfc/technical-notes-by-category.md)

