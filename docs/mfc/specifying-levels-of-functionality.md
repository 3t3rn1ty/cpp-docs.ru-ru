---
title: "Задание уровней функциональности | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "CObject - класс, добавление функциональности в производные классы"
  - "поддержка динамического создания"
  - "уровни [C++]"
  - "уровни [C++], функциональность в CObject"
  - "среда выполнения [C++], сведения о классах"
  - "класс среды выполнения, информационная поддержка"
  - "сериализация [C++], Cobject"
ms.assetid: 562669ba-c858-4f66-b5f1-b3beeea4f486
caps.latest.revision: 9
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 5
---
# Задание уровней функциональности
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

В этой статье описывается, как добавлять следующие слои функциональности в [CObject](../Topic/CObject%20Class.md)\- производного класса.  
  
-   [Данные класса среды выполнения](#_core_to_add_run.2d.time_class_information)  
  
-   [Динамическая поддержка создания](#_core_to_add_dynamic_creation_support)  
  
-   [Поддержка сериализации](#_core_to_add_serialization_support)  
  
 Для описания общих функций `CObject` см. в статье [Производный класс от CObject](../mfc/deriving-a-class-from-cobject.md).  
  
#### Добавление данных класса среды выполнения  
  
1.  Создайте производный класс от `CObject`, как описано в статье [Производный класс от CObject](../mfc/deriving-a-class-from-cobject.md).  
  
2.  Используйте макрос `DECLARE_DYNAMIC` в объявлении класса, как показано ниже:  
  
     [!code-cpp[NVC_MFCCObjectSample#2](../mfc/codesnippet/CPP/specifying-levels-of-functionality_1.h)]  
  
3.  Используйте макрос `IMPLEMENT_DYNAMIC` в файле реализации \(CPP\) класса.  Этот макрос принимает в качестве аргументов имя класса и его базового класса следующим образом.  
  
     [!code-cpp[NVC_MFCCObjectSample#3](../mfc/codesnippet/CPP/specifying-levels-of-functionality_2.cpp)]  
  
> [!NOTE]
>  Всегда кладите `IMPLEMENT_DYNAMIC` в файле реализации \(CPP\) для класса.  Макрос `IMPLEMENT_DYNAMIC` должен быть вычисляется только один раз во время компиляции и не должен использоваться в файле \(интерфейса. H\), которое может потенциально может быть включен в несколько файлов.  
  
#### Добавление динамической поддержки создания  
  
1.  Создайте производный класс от `CObject`.  
  
2.  Используйте макрос `DECLARE_DYNCREATE` в объявлении класса.  
  
3.  Определите конструктор без аргументов конструктора \(по умолчанию\).  
  
4.  Используйте макрос `IMPLEMENT_DYNCREATE` в файле реализации класса.  
  
#### Добавление поддержки сериализации  
  
1.  Создайте производный класс от `CObject`.  
  
2.  Переопределить функцию\-член `Serialize`.  
  
    > [!NOTE]
    >  При вызове `Serialize` напрямую, то есть, то не требуется сериализовать объект через полиморфный указатель, опущен разделы от 3 до 5.  
  
3.  Используйте макрос `DECLARE_SERIAL` в объявлении класса.  
  
4.  Определите конструктор без аргументов конструктора \(по умолчанию\).  
  
5.  Используйте макрос `IMPLEMENT_SERIAL` в файле реализации класса.  
  
> [!NOTE]
>  Точки «полиморфных указателя» к объекту класса \(вызова его a\) или на объект любого класса, производного от a \(допустим, B\).  Для сериализации с помощью полиморфных указатель платформа должна определить класс объекта среды выполнения она выполняет сериализацию \(B\), поскольку может быть объектом любого производного класса из определенного базового класса \(a\).  
  
 Дополнительные сведения о том, как разрешить сериализацию при наследовании класса из `CObject` см. в статье [Файлы в MFC](../mfc/files-in-mfc.md) и [Сериализация](../Topic/Serialization%20in%20MFC.md).  
  
## См. также  
 [Наследование класса от CObject](../mfc/deriving-a-class-from-cobject.md)