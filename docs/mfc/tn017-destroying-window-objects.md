---
title: 'TN017: Уничтожение объектов окон | Документы Microsoft'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-mfc
ms.topic: conceptual
f1_keywords:
- vc.objects
dev_langs:
- C++
helpviewer_keywords:
- destroying windows
- TN017
- PostNcDestroy method [MFC]
ms.assetid: 5bf208a5-5683-439b-92a1-547c5ded26cd
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: c6bba255403d31e7a1fa03febb0c760d20cdc81c
ms.sourcegitcommit: 76b7653ae443a2b8eb1186b789f8503609d6453e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
ms.locfileid: "33384307"
---
# <a name="tn017-destroying-window-objects"></a>TN017. Уничтожение объектов окон
Эта заметка содержит описание использования [CWnd::PostNcDestroy](../mfc/reference/cwnd-class.md#postncdestroy) метод. Используйте этот метод, если вы хотите сделать настроенные выделение `CWnd`-производных объектов. Эта заметка также объясняется, почему следует использовать [CWnd::DestroyWindow](../mfc/reference/cwnd-class.md#destroywindow) уничтожить объект Windows на C++, а не `delete` оператор.  
  
 Если следовать рекомендациям этого раздела будет иметь несколько проблем очистки. Эти проблемы может быть результатом проблемы, такие как не освобожденный по забывчивости delete/памяти C++, если забыть освободить ресурсы системы, такие как `HWND`s или освобождение объектов слишком много раз.  
  
## <a name="the-problem"></a>Проблема  
 Каждый объект windows (объект класса, производный от `CWnd`) представляет объект C++ и `HWND`. Объекты C++, выделяются в куче приложения и `HWND`s размещаются в системных ресурсов по диспетчера окон. Поскольку существует несколько способов, чтобы удалить объект window, нам необходимо указать набор правил, которые не позволяют системе утечки памяти или ресурсов. Эти правила также предотвратить объекты и дескрипторы Windows от уничтожения более одного раза.  
  
## <a name="destroying-windows"></a>Уничтожение окон  
 Ниже можно двумя способами разрешенных уничтожить объект Windows:  
  
-   Вызов `CWnd::DestroyWindow` или интерфейсом Windows API `DestroyWindow`.  
  
-   Явное удаление с `delete` оператор.  
  
 Первый случай — наиболее распространенные. Этот вариант применяется, даже если ваш код не вызывает `DestroyWindow` напрямую. Когда пользователь непосредственно закрывает окно фрейма, это действие приводит к возникновению ошибки `WM_CLOSE` сообщений и ответ на данное сообщение по умолчанию является вызов `DestroyWindow.` при уничтожении родительского окна Windows вызывает `DestroyWindow` для всех его дочерних узлов.  
  
 Во-вторых, использование `delete` оператора с объектами Windows должна возникать редко. Ниже приведены некоторые случаи, когда с помощью `delete` является правильным выбором.  
  
## <a name="auto-cleanup-with-cwndpostncdestroy"></a>Автоматическая очистка с CWnd::PostNcDestroy  
 Когда система уничтожает окно Windows, — это Windows сообщение отправлено последним в окно `WM_NCDESTROY`. Значение по умолчанию `CWnd` обработчик для сообщения является [CWnd::OnNcDestroy](../mfc/reference/cwnd-class.md#onncdestroy). `OnNcDestroy` отключает `HWND` из C++ объекта и вызов виртуальной функции `PostNcDestroy`. Некоторые классы переопределяют данную функцию для удаления объекта C++.  
  
 Реализация по умолчанию `CWnd::PostNcDestroy` не выполняет никаких действий, который подходит для объектов окна, которые распределены в кадре стека или внедрены в другие объекты. Это не подходит для объектов окна, предназначенные для выделения в куче без любых других объектов. Другими словами не подходит для объектов окна, которые не внедряются в остальных объектов C++.  
  
 Переопределение этих классов, предназначенных для выделения в куче отдельно `PostNcDestroy` способ выполнения `delete this`. Эта инструкция будет освободить память, связанный с объектом C++. Несмотря на то что по умолчанию `CWnd` вызовы деструктора `DestroyWindow` Если `m_hWnd` имеет значение NULL, это не приводит к бесконечной рекурсии, так как дескриптор будет отсоединения и NULL во время фазы очистки.  
  
> [!NOTE]
>  Как правило, система вызывает `CWnd::PostNcDestroy` после обработки Windows `WM_NCDESTROY` сообщений и `HWND` и объектом окна C++ больше не подключены. Система также вызовет `CWnd::PostNcDestroy` в реализации большинство [CWnd::Create](../mfc/reference/cwnd-class.md#create) вызывает в случае сбоя. Далее в этом разделе описываются правила автоматической очистки.  
  
## <a name="auto-cleanup-classes"></a>Классы автоматической очистки  
 Следующие классы не предназначены для автоматической очистки. Обычно они встроены в остальных объектов C++ или в стеке:  
  
-   Все стандартные элементы управления Windows (`CStatic`, `CEdit`, `CListBox`и так далее).  
  
-   Все дочерние окна, полученных непосредственно из `CWnd` (например, пользовательские элементы управления).  
  
-   Окна разделителей (`CSplitterWnd`).  
  
-   По умолчанию панели элементов управления (классы, производные от `CControlBar`, в разделе [Технические заметки 31](../mfc/tn031-control-bars.md) для включения автоматического удаления объекты панели элементов управления).  
  
-   Диалоговые окна (`CDialog`) предназначен для модального диалогового окна в кадре стека.  
  
-   Стандартные диалоговые окна, за исключением `CFindReplaceDialog`.  
  
-   Диалоговые окна по умолчанию, созданных классов.  
  
 Следующие классы предназначены для автоматической очистки. Обычно они выделяются сами по себе в куче:  
  
-   Windows главного фрейма (прямо или косвенно производными `CFrameWnd`).  
  
-   Просмотр windows (прямо или косвенно производными `CView`).  
  
 Если требуется прервать выполнение этих правил, необходимо переопределить `PostNcDestroy` метод в производном классе. Чтобы добавить класс автоматической очистки, вызывайте базового класса, а затем выполните `delete this`. Чтобы удалить автоматической очистки из класса, вызовите `CWnd::PostNcDestroy` напрямую вместо того `PostNcDestroy` метод прямого базового класса.  
  
 Наиболее распространенные изменения поведения автоматической очистки используется для создания немодального диалогового окна, которое может быть распределено в куче.  
  
## <a name="when-to-call-delete"></a>Если для вызова delete  
 Рекомендуется вызывать `DestroyWindow` для уничтожения объекта Windows метод C++ или глобальный `DestroyWindow` API.  
  
 Не вызывайте глобальный `DestroyWindow` API для уничтожения дочернего MDI-окна. Следует использовать виртуальный метод `CWnd::DestroyWindow` вместо него.  
  
 Для объектов, не выполняют автоматической очистки окна C++ с помощью `delete` оператор может вызвать утечку памяти при попытке вызвать `DestroyWindow` в `CWnd::~CWnd` деструктор, если VTBL точки правильно производного класса. Это происходит, поскольку системе не удается найти соответствующий destroy-метод для вызова. С помощью `DestroyWindow` вместо `delete` позволяет избежать этих проблем. Так как это может быть незначительные ошибки, компиляция в режиме отладки создаст следующее предупреждение при работе под угрозой.  
  
```  
Warning: calling DestroyWindow in CWnd::~CWnd  
    OnDestroy or PostNcDestroy in derived class will not be called  
```  
  
 В случае объектов C++ для Windows, которые выполняют автоматической очистки, необходимо вызвать метод `DestroyWindow`. Если вы используете `delete` оператор напрямую, выделение памяти с диагностикой MFC сообщит, что освобождает память, два раза. Два вхождения: вызывал явные и косвенный вызов `delete this` в реализации автоматической очистки `PostNcDestroy`.  
  
 После вызова метода `DestroyWindow` в объекте автоматической очистки объекта C++ по-прежнему будет, но `m_hWnd` будет иметь значение NULL. После вызова метода `DestroyWindow` на объект автоматической очистки объекта C++ будут удалены, освобожден с помощью оператора delete C++ в реализации автоматической очистки `PostNcDestroy`.  
  
## <a name="see-also"></a>См. также  
 [Технические примечания по номеру](../mfc/technical-notes-by-number.md)   
 [Технические примечания по категории](../mfc/technical-notes-by-category.md)

