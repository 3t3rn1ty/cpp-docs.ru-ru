---
title: "TN033: Версия библиотеки DLL MFC | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords: vc.mfc.dll
dev_langs: C++
helpviewer_keywords:
- MFC DLLs [MFC], writing MFC extension DLLS
- AFXDLL library
- DLLs [MFC], MFC
- DLL version of MFC [MFC]
- TN033
ms.assetid: b6f1080b-b66b-4b1e-8fb1-926c5816392c
caps.latest.revision: "13"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.openlocfilehash: fb1fb4094e5a54f82aa6aeebffe576965838cf7e
ms.sourcegitcommit: ebec1d449f2bd98aa851667c2bfeb7e27ce657b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/24/2017
---
# <a name="tn033-dll-version-of-mfc"></a>TN033. Версия библиотеки DLL MFC
Эта заметка описывает, как можно использовать MFCxx.DLL и MFCxxD.DLL (где x является номером версии MFC) библиотек динамической компоновки с приложениями MFC и библиотека DLL-расширения MFC. Дополнительные сведения об обычных библиотек DLL MFC см. в разделе [использование MFC как часть библиотеки DLL](../mfc/tn011-using-mfc-as-part-of-a-dll.md).  
  
 Это техническое Примечание рассматриваются три аспекта библиотек DLL. Последние две предназначены для более опытных пользователей.  
  
- [Как создавать DLL расширения MFC](#_mfcnotes_how_to_write_an_mfc_extension_dll)  
  
- [Как создавать приложения MFC, который использует версию библиотеки DLL MFC](#_mfcnotes_writing_an_application_that_uses_the_dll_version)  
  
- [Реализованы как MFC общие библиотеки динамической компоновки](#_mfcnotes_how_the_mfc30.dll_is_implemented)  
  
 Если вы заинтересованы в создании библиотеки DLL MFC, который может использоваться с не являющимися MFC приложениями (это называется обычной MFC DLL), см. [Технические заметки 11](../mfc/tn011-using-mfc-as-part-of-a-dll.md).  
  
## <a name="overview-of-mfcxxdll-support-terminology-and-files"></a>Общие сведения о поддержке MFCxx.DLL: терминология и файлов  
 **Обычной MFC DLL**: использовать регулярных DLL MFC для создания изолированного библиотеки DLL с помощью некоторых классов MFC. Интерфейсы через границы приложения или DLL являются интерфейсами, «C» и клиентское приложение не обязательно в приложении MFC.  
  
 Это версия DLL поддержки поддерживается в версии 1.0 с MFC. Он описан в [Технические заметки 11](../mfc/tn011-using-mfc-as-part-of-a-dll.md) пример MFC Дополнительные понятия и [DLLScreenCap](../visual-cpp-samples.md).  
  
> [!NOTE]
>  Начиная с Visual C++ версии 4.0 термин **USRDLL** является устаревшим и будет заменен обычной MFC DLL, статически связанной с MFC. Также возможно построить обычной MFC DLL, динамически связанной с MFC.  
  
 MFC 3.0 (и более поздней версии) поддерживает обычные библиотеки DLL MFC с новыми возможностями, включая классы OLE и базы данных.  
  
 **AFXDLL**: это также называют общедоступной версии библиотеки MFC. Это — это поддержка библиотеки DLL, которые добавлены в MFC 2.0. Сама библиотека MFC находится в библиотеках DLL (описаны ниже) и клиентское приложение или библиотека DLL динамически связывает библиотек DLL, которые необходимы. Через границу библиотеки DLL приложения относятся к C + +/ интерфейсы классов MFC. Клиентское приложение должно иметь приложение MFC. Поддерживает все функциональные возможности MFC 3.0 (исключение: Юникод не поддерживается для классов баз данных).  
  
> [!NOTE]
>  Начиная с Visual C++ версии 4.0 такой тип DLL называется «Расширение DLL.»  
  
 Эта заметка будет использовать MFCxx.DLL для ссылки на весь набор MFC DLL, включая:  
  
-   Отладка: MFCxxD.DLL (объединенные) и MFCSxxD.LIB (статический).  
  
-   Выпуск: MFCxx.DLL (объединенные) и MFCSxx.LIB (статический).  
  
-   Отладка Юникода: MFCxxUD.DLL (объединенные) и MFCSxxD.LIB (статический).  
  
-   Выпуск Юникода: MFCxxU.DLL (объединенные) и MFCSxxU.LIB (статический).  
  
> [!NOTE]
>  MFCSxx [U] [D]. Библиотеки LIB используются в сочетании с MFC общих библиотек DLL. Эти библиотеки содержат код, который должен быть статически компонуемые с приложением или библиотекой DLL.  
  
 Ссылки на приложения в соответствующие библиотеки импорта:  
  
-   Отладка: MFCxxD.LIB  
  
-   Выпуск: MFCxx.LIB  
  
-   Unicode Debug: MFCxxUD.LIB  
  
-   Юникод для выпуска: MFCxxU.LIB  
  
 «Библиотека DLL расширения MFC» — это библиотека DLL построено MFCxx.DLL (или другие MFC общих библиотек DLL). Здесь архитектура компонентов MFC будет запущено. Если полезные класс наследуется от класса MFC или другой набор средств MFC в стиле сборки, можно поместить его в библиотеку DLL. Библиотека DLL использует MFCxx.DLL, как и ultimate клиентское приложение. Это позволяет многократно используемых конечных классов, многократно используемые базовые классы и классы многократного использования представления или документов.  
  
## <a name="pros-and-cons"></a>Преимущества и недостатки  
 Почему следует использовать общедоступной версии MFC  
  
-   С помощью общей библиотеки может привести к более мелкие приложений (минимального приложения, которое использует большинство библиотеки MFC — меньше 10 КБ).  
  
-   Общая версия MFC поддерживает библиотек DLL расширения MFC и обычные библиотеки DLL MFC.  
  
-   Создание приложения, использующего общие библиотеки MFC выполняется быстрее, чем построение статически скомпонованной приложение MFC, поскольку нет необходимости связывать саму библиотеку MFC. Это особенно важно в **отладки** построения, где компоновщик выполняет сжатие отладочной информации, путем связывания с библиотекой DLL, которая уже содержит сведения об отладке, имеется меньше отладочную информацию для сжатия в приложении.  
  
 Почему вы не следует использовать общедоступной версии MFC:  
  
-   Доставка приложения, использующего общей библиотеки требует отправки MFCxx.DLL (и других) библиотеки со своей программой. MFCxx.DLL можно свободно распространять, как и многие библиотеки DLL, но вы по-прежнему необходимо установить библиотеку DLL в программу установки. Кроме того необходимо отправить MSVCRTxx.DLL, который содержит библиотеку времени выполнения C, которая используется как программы, а также библиотеки DLL MFC, сами.  
  
##  <a name="_mfcnotes_how_to_write_an_mfc_extension_dll"></a>Способы написания расширения MFC DLL  
 MFC-библиотеки DLL расширения является библиотекой DLL, содержащим классы и функции, написанные для развертывания функциональных возможностей классов MFC. DLL расширения MFC использует общей библиотеки DLL MFC так же, как приложение использует его, с следующее:  
  
-   Процесс построения сходно с построением приложения, использующего общие библиотеки MFC с несколько Дополнительные параметры компилятора и компоновщика.  
  
-   MFC-библиотеки DLL расширения не имеет `CWinApp`-производного класса.  
  
-   MFC-библиотеки DLL расширения необходимо предоставить специальный `DllMain`. Мастер приложений предоставляет `DllMain` функции, которые можно изменить.  
  
-   MFC-библиотеки DLL расширения предоставит процедуры инициализации для создания **CDynLinkLibrary** Если расширения MFC DLL необходимо экспортировать `CRuntimeClass`es или ресурсы в приложение. Производный класс **CDynLinkLibrary** могут быть использованы, если требуется сохранить данные на уровне приложения, библиотеки DLL расширения MFC.  
  
 Эти особенности описаны более подробно ниже. Также см. в образце Дополнительные понятия MFC [DLLHUSK](../visual-cpp-samples.md) , так как он иллюстрирует:  
  
-   Построение приложения с помощью общих библиотек. (DLLHUSK. Exe-ФАЙЛ является приложение MFC, динамически привязано к MFC-библиотеки DLL, а также для других).  
  
-   Построение библиотеки DLL расширения MFC. (Обратите внимание специальные флаги, такие как `_AFXEXT` , которые используются в построении Библиотеки расширения MFC)  
  
-   Далее приводятся два примера MFC библиотеки DLL расширения. Один показана базовая структура DLL расширения MFC с ограниченной экспортов (TESTDLL1) и показывает, экспорт весь класс интерфейса (TESTDLL2).  
  
 Клиентское приложение и все библиотеки DLL расширения MFC необходимо использовать одну и ту же версию MFCxx.DLL. Должно соответствовать соглашению MFC DLL и предоставляет отладочную и Розничная (/ release) версия библиотеки DLL расширения MFC. Это позволяет использовать клиентские программы для построения отладки и розничных версий приложений и связать их с отладки, подходящие или розничную версию DLL-файлов.  
  
> [!NOTE]
>  Поскольку C++ имя изменением и экспортировать проблемы, список экспорта из библиотеки DLL расширения MFC могут различаться между отладочной версии и розничной версии той же библиотеки DLL и библиотеки DLL для различных платформ. Retail MFCxx.DLL около 2000 экспортировал точки входа; Отладка MFCxxD.DLL около 3000 экспортировал точки входа.  
  
### <a name="quick-note-on-memory-management"></a>Короткая заметка на управление памятью  
 В разделе «Управление памятью,» в конце этого техническое Примечание описывается реализация MFCxx.DLL с общедоступной версии MFC. Данные необходимо знать для реализации просто расширение MFC, библиотеки DLL описан в данном разделе.  
  
 MFCxx.DLL и всех библиотек DLL расширения MFC загруженного в адресное пространство клиентского приложения будут использовать же распределитель памяти, загрузка ресурсов и другие состояния «глобальные» MFC, как если бы они находились в одном приложении. Это важно, так как библиотеки MFC DLL и обычных библиотек DLL MFC, статическая компоновка с MFC ведут себя совершенно противоположно и у каждого DLL выделения памяти за пределами пула памяти.  
  
 Если библиотеки DLL расширения MFC выделяет память, что память можно свободно смешивается с любой другой объект, выделенный приложения. Кроме того при сбое приложения, использующего общие библиотеки MFC защиты операционной системы будет поддерживать целостность любого другого приложения MFC DLL.  
  
 Аналогично другие «глобальные» состояния MFC, как текущий исполняемый файл для загрузки ресурсов, также являются общими для клиентского приложения и все библиотеки DLL расширения MFC а также MFCxx.DLL сам.  
  
### <a name="building-an-mfc-extension-dll"></a>Построение библиотеки DLL расширения MFC  
 Мастер приложений можно использовать для создания проекта библиотеки DLL расширения MFC и автоматически создает соответствующие параметры компилятора и компоновщика. Она была значительному `DllMain` функции, которые можно изменить.  
  
 При преобразовании существующего проекта расширения MFC DLL, начните с помощью стандартных правил для создания приложения с помощью общедоступной версии MFC, а затем выполните следующие:  
  
-   Добавить **/D_AFXEXT** флаги компилятора. В диалоговом окне свойств проекта выберите узел C/C++. Выберите категорию препроцессора. Добавить `_AFXEXT` полем определения макросов, разделив каждого элемента точкой с запятой.  
  
-   Удалить **/Gy** переключатель компилятора. В диалоговом окне свойств проекта выберите узел C/C++. Затем выберите категорию, создания кода. Убедитесь, что не установлен флажок «Включить компоновку на уровне функций». Это поможет упростить его процедура экспорта классов, так как компоновщик не удаляет неиспользуемые функции. Если исходный проект используется для создания обычной MFC DLL, статически компонуемые с MFC, изменение **[d] / MT** параметра компилятора **/MD [d]**.  
  
-   Построение библиотеки экспорта с **/DLL** возможность СВЯЗИ. Они задаются при создании новой цели, задания библиотеки динамической компоновки Win32 в качестве целевого типа.  
  
### <a name="changing-your-header-files"></a>Изменение файлов заголовка  
 Библиотеки DLL расширения MFC предназначена обычно Экспорт некоторые общие функциональные возможности для одного или нескольких приложений, которые могут использовать эти функциональные возможности. Это сводится к экспорту классы и глобальные функции, которые доступны для клиентских приложений.  
  
 Для этого следует убедиться, что каждой из функций-членов помечается как импорт или экспорт соответствующим образом. Это требует специальных объявления: **__declspec(dllexport)** и **__declspec(dllimport)**. Когда ваши классы используются клиентскими приложениями, которые им необходимы объявляться как **__declspec(dllimport)**. При построении расширения MFC DLL, они должны быть объявлены как **__declspec(dllexport)**. Кроме того функции необходимо фактически экспортировать, клиентские программы привязать к их во время загрузки.  
  
 Чтобы экспортировать весь класс, используйте **AFX_EXT_CLASS** в определении класса. Этот макрос определяется платформой как **__declspec(dllexport)** при **_AFXDLL** и `_AFXEXT` определен, но определяется как **__declspec(dllimport)** при `_AFXEXT` не определен. `_AFXEXT`как описано выше, определяется только при создании библиотеки DLL расширения MFC. Пример:  
  
```  
class AFX_EXT_CLASS CExampleExport : public CObject  
{ ... class definition ... };  
```  
  
### <a name="not-exporting-the-entire-class"></a>Экспортирует весь класс  
 Иногда требуется экспортировать только отдельные необходимые члены класса. Например, если вы экспортируете `CDialog`-производного класса может потребоваться только для экспорта в конструктор и `DoModal` вызова. Вы можете экспортировать эти элементы с помощью библиотеки DLL. DEF-файл, но можно также использовать **AFX_EXT_CLASS** так же, для отдельных членов, необходимо экспортировать.  
  
 Пример:  
  
```  
class CExampleDialog : public CDialog  
{  
public:  
    AFX_EXT_CLASS CExampleDialog();
AFX_EXT_CLASS int DoModal();
*// rest of class definition  
 .  
 .  
 .  
};  
```  
  
 При этом возможно возникновение дополнительную проблему, так как больше не экспортируются все члены класса. Проблема заключается в способе работы макросов библиотеки MFC. Несколько вспомогательных макросов MFC объявляют или определяют члены данных. Таким образом эти члены данных также необходимо экспортировать из библиотеки DLL.  
  
 Например `DECLARE_DYNAMIC` при создании библиотеки DLL расширения MFC макрос определяется следующим образом:  
  
```  
#define DECLARE_DYNAMIC(class_name) \  
protected: \  
    static CRuntimeClass* PASCAL _GetBaseClass();

\  
    public: \  
    static AFX_DATA CRuntimeClass class##class_name; \  
    virtual CRuntimeClass* GetRuntimeClass() const;

\  
```  
  
 Строка, которая начинается «статический `AFX_DATA`», объявляет статический объект внутри класса. Чтобы правильно экспортировать класс и доступ к данным среды выполнения от клиента. EXE-файла, необходимо экспортировать статический объект. Так как статический объект объявлен с модификатором `AFX_DATA`, необходимо определить `AFX_DATA` быть **__declspec(dllexport)** при построении библиотеки DLL, а также определить как **__declspec(dllimport)** при построении исполняемый файл клиента.  
  
 Как было сказано выше, **AFX_EXT_CLASS** уже определен таким образом. Необходимо повторно определить `AFX_DATA` быть таким же, как **AFX_EXT_CLASS** вокруг его определение.  
  
 Пример:  
  
```  
#undef  AFX_DATA  
#define AFX_DATA AFX_EXT_CLASS  
class CExampleView : public CView  
{  
    DECLARE_DYNAMIC() *// ... class definition ...  
};  
#undef  AFX_DATA  
#define AFX_DATA  
```  
  
 Всегда используется библиотекой MFC `AFX_DATA` символов для элементов данных, он определяет в пределах своего макроса, поэтому этот метод будет работать для всех подобных скриптов. Например, она будет работать для `DECLARE_MESSAGE_MAP`.  
  
> [!NOTE]
>  Если экспортируется весь класс, а не выбранные члены класса, статические члены данных экспортируются автоматически.  
  
 Тот же метод можно использовать для автоматического экспорта `CArchive` оператор извлечения для классов, использующих `DECLARE_SERIAL` и `IMPLEMENT_SERIAL` макросы. Экспортируйте оператор архива, скобок объявления класса (расположенный в. H-файл) с помощью следующего кода:  
  
```  
#undef AFX_API  
#define AFX_API AFX_EXT_CLASS  
 
<your class declarations here>  
 
#undef AFX_API  
#define AFX_API  
```  
  
### <a name="limitations-of-afxext"></a>Ограничения _AFXEXT  
 Можно использовать _**AFXEXT** символ препроцессора для библиотек, при условии, что у вас несколько слоев расширения MFC DLL расширения MFC. При наличии расширения MFC DLL-библиотеки, которые вызывают или являются производными от классов в собственное расширение MFC библиотеки DLL, которые являются производными от классов MFC, необходимо использовать собственную препроцессора во избежание неоднозначности.  
  
 Проблема в том, что в Win32, необходимо явно объявить все данные в виде **__declspec(dllexport)** если экспорт из библиотеки DLL, и **__declspec(dllimport)** при импорте из библиотеки DLL. При определении `_AFXEXT`, заголовки MFC убедитесь, что **AFX_EXT_CLASS** правильно определен.  
  
 Если имеется несколько слоев, один символ например **AFX_EXT_CLASS** недостаточно, так как расширение MFC DLL может экспортировать новые классы, а также импортировать другие классы из другой Библиотеки расширения MFC. Для решения этой проблемы, используйте специальный символ препроцессора, указывающее, вы создаете самой библиотеки DLL и использование библиотеки DLL. Например представьте двух библиотек DLL расширения MFC, A.DLL и B.DLL. Каждая из них экспортирует некоторые классы в файлах A.H и B.H соответственно. B.DLL использует классы из A.DLL. Файлы заголовков будет выглядеть примерно следующим образом:  
  
```  
/* A.H */  
#ifdef A_IMPL  
 #define CLASS_DECL_A   __declspec(dllexport)  
#else  
 #define CLASS_DECL_A   __declspec(dllimport)  
#endif  
 
class CLASS_DECL_A CExampleA : public CObject  
{ ... class definition ... };  
 
/* B.H */  
#ifdef B_IMPL  
 #define CLASS_DECL_B   __declspec(dllexport)  
#else  
 #define CLASS_DECL_B   __declspec(dllimport)  
#endif  
 
class CLASS_DECL_B CExampleB : public CExampleA  
{ ... class definition .. };  
```  
  
 При построении A.DLL построены с **/D A_IMPL** и при построении B.DLL, он создается с **/D B_IMPL**. С помощью отдельных символов для каждой библиотеки DLL, класс CExampleB экспортируется и класс CExampleA импортируется при построении B.DLL. Класс CExampleA экспортируется, когда строится A.DLL и импортируется, когда он используется библиотекой B.DLL (или другим клиентом).  
  
 Такой тип архитектуры не может выполняться при использовании встроенной **AFX_EXT_CLASS** и `_AFXEXT` символы препроцессора. Способ, описанный выше решает эту проблему способом, отличным от используется классами MFC при построении его OLE, базы данных и сети MFC библиотека DLL-расширения.  
  
### <a name="not-exporting-the-entire-class"></a>Экспортирует весь класс  
 Опять же необходимо следить, если не экспортируется весь класс. Необходимо убедиться, корректно экспортированы элементы необходимые данные, создаваемые макросами MFC. Это можно сделать путем повторного определения **AFX_DATA** макрос для вашего конкретного класса. Это следует делать каждый раз, не экспортируется весь класс.  
  
 Например:  
  
```  
// A.H  
#ifdef A_IMPL  
 #define CLASS_DECL_A  _declspec(dllexport)  
#else  
 #define CLASS_DECL_A  _declspec(dllimport)  
 #endif  
 
#undef  AFX_DATA  
#define AFX_DATA CLASS_DECL_A  
 
class CExampleA : public CObject  
{  
    DECLARE_DYNAMIC() 
    CLASS_DECL_A int SomeFunction();
*//class definition   
 .  
 .  
 .  
};  
 
#undef AFX_DATA  
#define AFX_DATA  
```  
  
### <a name="dllmain"></a>DllMain  
 Ниже приведен точный код, который следует поместить в файле основного источника для библиотеки DLL расширения MFC. Он должен иметь после содержат стандартные. Обратите внимание, что при использовании мастером приложений для создания начальный набор файлов для библиотеки DLL расширения MFC предоставляет `DllMain` для вас.  
  
```  
#include "afxdllx.h"  
  
static AFX_EXTENSION_MODULE extensionDLL;  
  
extern "C" int APIENTRY   
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID)  
{  
   if (dwReason == DLL_PROCESS_ATTACH)  
   {  
      // MFC extension DLL one-time initialization   
      if (!AfxInitExtensionModule(  
             extensionDLL, hInstance))  
         return 0;  
  
      // TODO: perform other initialization tasks here  
   }  
   else if (dwReason == DLL_PROCESS_DETACH)  
   {  
      // MFC extension DLL per-process termination  
      AfxTermExtensionModule(extensionDLL);  
  
          // TODO: perform other cleanup tasks here  
   }  
   return 1;   // ok  
}  
```  
  
 Вызов `AfxInitExtensionModule` захватывает модули классов среды выполнения (`CRuntimeClass` структуры) а также производства объектов (`COleObjectFactory` объектов) для использования более поздние версии **CDynLinkLibrary** создан объект. (Необязательно) вызов `AfxTermExtensionModule` используется в MFC для очистки библиотеки DLL расширения MFC после отсоединения всех процессов (что происходит при завершении процесса или при выгрузке библиотеки DLL в результате использования **FreeLibrary** вызова) из библиотеки DLL расширения MFC . Поскольку большинство расширения MFC, библиотеки DLL не загружаются динамически (как правило, они связаны через их библиотеки импорта), вызов `AfxTermExtensionModule` обычно нет необходимости.  
  
 Если приложение загружает и динамически освобождает библиотека DLL-расширения MFC, необходимо вызвать `AfxTermExtensionModule` как показано выше. Кроме того использовать `AfxLoadLibrary` и `AfxFreeLibrary` (вместо функций Win32 **LoadLibrary** и **FreeLibrary**) Если приложение использует несколько потоков или если она динамически загружает MFC библиотеки DLL расширения. С помощью `AfxLoadLibrary` и `AfxFreeLibrary` гарантирует, что код запуска и завершения работы, который выполняется при загрузке и выгрузке библиотеки DLL расширения MFC не приведет к повреждению глобального состояния MFC.  
  
 Файл заголовка AFXDLLX. H содержит специальные определения для структур, используемых в библиотеки DLL расширения MFC, такие как определение `AFX_EXTENSION_MODULE` и **CDynLinkLibrary**.  
  
 Глобальный *extensionDLL* должен быть объявлен как показано. В отличие от 16-разрядной версии MFC, можно выделить память и вызвать функции MFC в течение этого времени, поскольку MFCxx.DLL полностью инициализирован, когда ваш `DllMain` вызывается.  
  
### <a name="sharing-resources-and-classes"></a>Ресурсы и классы для управления доступом  
 Для клиентского приложения и ничего более простой библиотек DLL расширения MFC требуется экспортировать только несколько функций с низкой пропускной способностью. Дополнительные библиотеки DLL служб с интенсивными вычислениями, пользовательского интерфейса может потребоваться экспорт ресурсы и классы C++ клиентскому приложению.  
  
 Экспорт ресурсов осуществляется по списку ресурсов. В каждое приложение — однонаправленный список **CDynLinkLibrary** объектов. При поиске ресурса, большая часть стандартных реализаций MFC, которые загружают ресурсы быть первой в текущем модуле ресурсов (`AfxGetResourceHandle`) и если он не найден обход списка **CDynLinkLibrary** попытка загрузки объектов Запрошенный ресурс.  
  
 Аналогично динамическое создание объектов C++, получает имя класса C++. Механизм десериализации объекта MFC должен иметь все `CRuntimeClass` объекты регистрации, чтобы его можно восстановить путем динамического создания объектов C++ требуемого типа, в зависимости от того, что было сохранено ранее.  
  
 Если требуется, чтобы клиентское приложение для использования классов в библиотеки DLL расширения MFC, которые являются `DECLARE_SERIAL`, будет необходимо экспортировать класс видимым для клиентского приложения. Это делается путем прохода **CDynLinkLibrary** списка.  
  
 В случае с примером MFC Дополнительные понятия [DLLHUSK](../visual-cpp-samples.md), список будет выглядеть примерно так:  
  
```  
head ->   DLLHUSK.EXE   - or -   DLLHUSK.EXE  
 |      |  
    TESTDLL2.DLL TESTDLL2.DLL  
 |      |  
    TESTDLL1.DLL TESTDLL1.DLL  
 |      |  
 |      |  
    MFC90D.DLL MFC90.DLL  
```  
  
 MFCxx.DLL обычно последнего в списке ресурсов и список классов. MFCxx.DLL включает все стандартные ресурсы MFC, в том числе командные строки для всех стандартных идентификаторов команд. Помещения его в конце списка позволяет библиотекам DLL и самим клиентским приложениям не имеет собственную копию стандартные ресурсы MFC, но чтобы полагаться на общие ресурсы в MFCxx.DLL вместо него.  
  
 Объединение ресурсов и имена классов всех библиотек DLL в пространство имен клиентское приложение имеет недостаток, следует соблюдать осторожность какие идентификаторы или имена, которые вам нужно выбрать. Конечно же отключить эту функцию, либо не экспортировав ресурсов или **CDynLinkLibrary** объекта клиентскому приложению. [DLLHUSK](../visual-cpp-samples.md) образец управляет пространством имен общих ресурсов с помощью нескольких файлов заголовков. В разделе [Технические примечания 35](../mfc/tn035-using-multiple-resource-files-and-header-files-with-visual-cpp.md) Дополнительные советы по использованию общих файлов ресурсов.  
  
### <a name="initializing-the-dll"></a>Инициализация библиотеки DLL  
 Как упоминалось выше, обычно необходимо создать **CDynLinkLibrary** объекта, для успешного выполнения экспорта ресурсы и классы клиентскому приложению. Необходимо будет указать точки входа экспортированных для инициализации библиотеки DLL. Как минимум это void подпрограмму, которая не принимает аргументов и не возвращает никаких данных, но он может быть любое.  
  
 Каждое клиентское приложение, которое хочет использовать библиотеки DLL необходимо вызвать эта процедура инициализации, при использовании этого подхода. Также может выделить это **CDynLinkLibrary** объект в вашей `DllMain` сразу после вызова метода `AfxInitExtensionModule`.  
  
 Необходимо создать программа инициализации **CDynLinkLibrary** объекта в куче текущего приложения, с указанным расширения MFC DLL сведения. Это можно сделать с помощью следующего:  
  
```  
extern "C" extern void WINAPI InitXxxDLL()  
{  
    new CDynLinkLibrary(extensionDLL);

}  
```  
  
 Имя подпрограммы, *InitXxxDLL* в этом примере, может быть любым требуется. Он не должен быть `extern "C"`, но делают это делает проще было обслуживать списка экспорта.  
  
> [!NOTE]
>  При использовании библиотеки DLL расширения MFC с обычной MFC DLL, необходимо экспортировать эту функцию инициализации. Эта функция должна вызываться из регулярных MFC DLL, перед использованием какие классы DLL расширения MFC и ресурсы.  
  
### <a name="exporting-entries"></a>Экспорт записей  
 Простой способ экспорта классов является использование **__declspec(dllimport)** и **__declspec(dllexport)** на каждый класс и глобальных функций, которые требуется экспортировать. Это позволяет намного проще, но является менее эффективным, чем именования каждой точки входа (как описано ниже), так как имеется меньше возможностей управления через какие функции экспортируются и его нельзя экспортировать функции по порядковому номеру. Этот метод следует использовать, чтобы экспортировать записи их TESTDLL1 и TESTDLL2.  
  
 Более эффективный метод (и метод, используемый MFCxx.DLL) — экспорт каждой записи вручную путем именования в каждой записи. DEF-файл. Поскольку мы экспорте Выборочный экспорты с динамически подключаемую Библиотеку (то есть не все), нужно определить определенного интерфейсы требуется экспортировать. Это сложная задача, поскольку поврежденных имен компоновщику необходимо указать в виде записи в. DEF-файл. Не экспортировать все классы C++, если действительно требуется символьную ссылку для него.  
  
 Если вы попытались Экспорт C++ классы с. DEF-файла ранее, вы можете разрабатывать средства для автоматического создания этого списка. Это можно сделать с помощью ссылку двухэтапного процесса. Связывать один раз с экспортируемые элементы библиотеки DLL и разрешить компоновщик для создания. Файл Сопоставления. . Файл Сопоставления можно использовать для создания список функций, которые должны быть экспортированы, поэтому с некоторые изменения порядка, он может использоваться для создания записей экспорта для вашего. DEF-файл. Список экспорта для MFCxx.DLL и OLE и библиотек DLL расширения баз данных MFC, нескольких тысяч по числу, был создан с такой процесс (хотя он не является полностью автоматизировать и требует некоторых вручную настройки каждый раз во время).  
  
### <a name="cwinapp-vs-cdynlinklibrary"></a>CWinApp vs. CDynLinkLibrary  
 MFC-библиотеки DLL расширения не имеет `CWinApp`-производный объект свои собственные; вместо этого он должен работать с `CWinApp`-производный объект клиентского приложения. Это означает, что клиентское приложение, является владельцем цикла обработки сообщений цикла простоя и т. д.  
  
 Если библиотеки DLL расширения MFC должен поддерживать дополнительные данные для каждого приложения, можно наследовать новый класс из **CDynLinkLibrary** и создать в InitXxxDLL, подпрограмма описаны выше. При запуске, библиотеки DLL можно проверить список текущего приложения **CDynLinkLibrary** объектов для поиска объекта для конкретной библиотеки DLL расширения MFC.  
  
### <a name="using-resources-in-your-dll-implementation"></a>Использование ресурсов в вашей реализации библиотеки DLL  
 Как упоминалось выше, загрузка ресурсов по умолчанию процедура показывает, как список **CDynLinkLibrary** объектов, поиск первого EXE или DLL, запрошенный ресурс. Все API-интерфейсов MFC, а также все использует внутренний код `AfxFindResourceHandle` чтобы пройти в список ресурсов для поиска любого ресурса, независимо от того, в котором он находится.  
  
 Если необходимо только загрузить ресурсы из определенного места, используйте API-интерфейсы `AfxGetResourceHandle` и `AfxSetResourceHandle` для сохранения старого дескриптора и задания нового. Не забудьте восстановить старый дескриптор ресурсов, прежде чем вернуться к клиентскому приложению. Образец TESTDLL2 используют данный подход для явной загрузки меню.  
  
 Проход по списку имеет недостатки он немного медленнее и требует управления уровнями идентификатора ресурса. Он имеет то преимущество, что клиентское приложение, которое ссылается на несколько библиотек DLL расширения MFC можно использовать любой предоставленный библиотекой DLL ресурс без указания дескриптора экземпляра библиотеки DLL. `AfxFindResourceHandle`интерфейс API используется для прохода в список ресурсов для поиска заданного совпадения. Он принимает имя и тип ресурса и возвращает дескриптор ресурса, где он сначала найден (или NULL).  
  
##  <a name="_mfcnotes_writing_an_application_that_uses_the_dll_version"></a>Написание приложений, использующих версию DLL-Библиотеки  
  
### <a name="application-requirements"></a>Требования приложения  
 Приложение, использующее общедоступной версии MFC необходимо выполнить несколько простых правил.  
  
-   Он должен иметь `CWinApp` объекта и следовать стандартным правилам для обработки сообщений.  
  
-   Его необходимо скомпилировать с набором флагов требуется компиляции (см. ниже).  
  
-   Его необходимо связать с библиотеками импорта MFCxx. Установив необходимые компилятора флаги, заголовки MFC определить во время компоновки библиотеку, в которой приложение, необходимо связать с.  
  
-   Чтобы запустить исполняемый файл, MFCxx.DLL необходимо в пути или в системном каталоге Windows.  
  
### <a name="building-with-the-development-environment"></a>Построение с помощью среды разработки  
 При использовании внутренней makefile с большинством стандартных значения по умолчанию, можно легко изменить проект для построения версия библиотеки DLL.  
  
 Далее предполагается, что правильно работает приложение MFC, связанных с NAFXCWD. LIB (для отладки) и NAFXCW. LIB (для розничной торговли) и вы хотите преобразовать для использования общую версию библиотеки MFC. Выполняются в среде Visual C++ и имеет внутренний проект файла.  
  
1.  На **проекты** меню, нажмите кнопку **свойства**. В **Общие** в разделе **проекта по умолчанию**, равным Microsoft Foundation Classes **использовать MFC в общей DLL** (MFCxx(d).dll).  
  
### <a name="building-with-nmake"></a>Построение с (NMAKE)  
 Если вы используете функцию внешний сборочный файл проекта Visual C++, или используете NMAKE непосредственно, необходимо будет изменить файла makefile для поддержки параметры компилятора и компоновщика  
  
 Обязательные флаги компилятора:  
  
 **/ / MD D_AFXDLL**  
 **/ D_AFXDLL**  
  
 Стандартные заголовки MFC необходимые этот символ определен.  
  
 **/MD**  
 Приложение должно использовать версия DLL библиотеки времени выполнения C  
  
 Все другие флаги компилятора имеют значения по умолчанию MFC (например, _DEBUG для отладки).  
  
 Изменение списка компоновщика библиотек. Изменение NAFXCWD. LIB MFCxxD.LIB и измените NAFXCW. LIB для MFCxx.LIB. Замените LIBC. LIB с MSVCRT. LIB. Как с любой другой библиотеке MFC очень важно, размещена MFCxxD.LIB **перед** все библиотеки времени выполнения C.  
  
 При необходимости добавьте **/D_AFXDLL** для розничной торговли и отладки параметры компилятора ресурсов (того, который фактически компилирует ресурсы с **/R**). Это позволяет сделать конечного исполняемого файла меньше общего доступа к ресурсам, которые присутствуют в библиотеки DLL MFC.  
  
 Полное перестроение требуется после внесения этих изменений.  
  
### <a name="building-the-samples"></a>Построение образцов  
 Большинство программ MFC, образец может быть построено из Visual C++ или из общей MAKEFILE совместимое NMAKE из командной строки.  
  
 Чтобы преобразовать любой из этих примеров, чтобы использовать MFCxx.DLL, можно загрузить. MAK файла в Visual C++ и задать параметры проекта, как описано выше. Если вы используете NMAKE сборки, можно указать «AFXDLL = 1» на основе параметра NMAKE командной строки, которые будет создана образца с использованием общей библиотеки MFC.  
  
 Пример MFC Дополнительные понятия [DLLHUSK](../visual-cpp-samples.md) строится с помощью версии библиотеки DLL MFC. В этом примере не только показано, как выполнить сборку приложения, связанного с MFCxx.DLL, но также показывает другие возможности параметры упаковки MFC DLL, как описано далее в этой заметке о технической библиотеки DLL расширения MFC.  
  
### <a name="packaging-notes"></a>Упаковка заметок  
 Версии библиотек DLL (MFCxx [U]. Библиотека DLL), свободно распространяемый пакет. Отладочная версия библиотеки DLL не свободно распространяемый пакет и должны использоваться только во время разработки приложения.  
  
 Отладочные версии библиотек DLL предоставляются с отладочной информацией. С помощью отладчика Visual C++, можно отслеживать выполнение приложения, а также библиотеки DLL. Версии библиотек DLL (MFCxx [U]. Библиотека DLL) не содержит отладочную информацию.  
  
 Если настроить или Перестройте библиотеки DLL, затем следует вызывать их что-то отличного от файла «MFCxx» MFC SRC MFCDLL. MAK описывает параметры построения и содержит логику для переименования библиотеки DLL. Переименование файлов необходима, поскольку эти библиотеки DLL являются совместно несколькими приложениями MFC. Наличие настроенную версию библиотеки DLL MFC replace они установлены в системе может прерываться другое приложение MFC с помощью общих библиотек DLL MFC.  
  
 Перестроение библиотеки DLL MFC не рекомендуется.  
  
##  <a name="_mfcnotes_how_the_mfc30.dll_is_implemented"></a>Реализации MFCxx.DLL  
 В следующем разделе описаны реализации с библиотекой DLL MFC (MFCxx.DLL и MFCxxD.DLL). Понимание здесь, также не важно, если все, что необходимо сделать является использование библиотеки DLL MFC с приложением. Здесь не нужны для понимания того, как написать DLL расширений MFC, но основные сведения об этой реализации могут помочь вам создавать собственные библиотеки DLL.  
  
### <a name="implementation-overview"></a>Общие сведения о реализации  
 Библиотеки DLL MFC действительно является особым случаем из библиотеки DLL расширения MFC, как описано выше. Он имеет очень большое количество экспортов для большое количество классов. Существует несколько подводные камни, которые мы делаем в библиотеке DLL MFC, благодаря которым она еще более специальных чем регулярных DLL расширений MFC.  
  
### <a name="win32-does-most-of-the-work"></a>Win32 выполняет большую часть работы  
 16-разрядной версии MFC необходимые специальные приемы, включая данные на уровне приложения на сегмент стека, специальные сегментов, созданный код сборки 80 x 86, контексты исключения на уровне процесса и других возможностях. Win32 непосредственно поддерживает данных каждого процесса в библиотеке DLL, который требуется в большинстве случаев. В большинстве случаев MFCxx.DLL является просто NAFXCW. LIB, упакованных в библиотеку DLL. Если взглянуть на исходный код MFC, можно найти очень мало _AFXDLL #ifdef, поскольку существует очень мало особые случаи, которые должны быть выполнены. Особые случаи, которые существуют специально для работы с Win32 на Windows версии 3.1 (также известный как одна из систем Win32). Одна из систем Win32 не не данных на уровне процесса DLL поддержки напрямую, поэтому с библиотекой DLL MFC необходимо использовать локальное хранилище потока (TLS) API-интерфейсов Win32 для получения процесса локальных данных.  
  
### <a name="impact-on-library-sources-additional-files"></a>Влияние на библиотеки источников, дополнительные файлы  
 Влияние **_AFXDLL** версии на обычном источников библиотеки классов MFC и заголовки относительно незначительны. Специальная версия файл (AFXV_DLL. (H), а также дополнительный заголовочный файл (AFXDLL_. H) по основной AFXWIN включены. Заголовок H. AFXDLL_. Включает заголовок H **CDynLinkLibrary** класса и другие сведения о реализации обоих **_AFXDLL** приложениями и библиотеками DLL расширения MFC. AFXDLLX. Заголовок H предоставляется для создания библиотек DLL расширения MFC (см. выше сведения).  
  
 Регулярные источников в библиотеку MFC в MFC SRC имеют условного дополнительный код в разделе **_AFXDLL** #ifdef. Файл дополнительных исходного кода (DLLINIT. CPP) содержит дополнительный код инициализации библиотеки DLL и другие связующего для общедоступной версии MFC.  
  
 Чтобы построить общедоступной версии MFC, предоставляются дополнительные файлы. (См. ниже дополнительные сведения о создании библиотеки DLL.)  
  
-   Два. DEF-файлы используются для экспорта точки входа библиотеки DLL MFC для отладки (MFCxxD.DEF) и окончательную версию библиотеки DLL (MFCxx.DEF).  
  
-   . RC-файле (MFCDLL. Версия-Кандидат) содержит все стандартные ресурсы MFC и ресурсе VERSIONINFO для библиотеки DLL.  
  
-   ОБЪЕКТ. Файл CLW (MFCDLL. Обеспечивает CLW) позволяет использовать MFC Просмотр классов с помощью классов. Примечание: Эта функция не определенной версии библиотеки DLL MFC.  
  
### <a name="memory-management"></a>Управление памятью  
 Приложения с помощью MFCxx.DLL использует общие распределения памяти, предоставляемые MSVCRTxx.DLL общей библиотеки DLL времени выполнения C. Приложение, все библиотеки DLL расширения MFC и библиотеки DLL MFC, сами также используйте этот распределителя общей памяти. С помощью общей библиотеки DLL для выделения памяти, библиотеки DLL MFC можно выделить память, освобождается позже в приложении или наоборот. Так как приложения и библиотеки DLL необходимо использовать одинаковые распределителя, не должен переопределять глобальный C++ `operator new` или `operator delete`. Те же правила применяются к остальным процедур выделения памяти времени выполнения C (такие как `malloc`, `realloc`, **свободного**и другие).  
  
### <a name="ordinals-and-class-declspecdllexport-and-dll-naming"></a>Порядковые номера и __declspec(dllexport) класса и именование библиотеки DLL  
 Корпорация Майкрософт не использовать `class` **__declspec(dllexport)** функциональные возможности компилятора C++. Вместо этого список экспортируемых элементов входит в состав источников библиотека классов (MFCxx.DEF и MFCxxD.DEF). Экспортируются только эти выберите набор точек входа (функциям и данным). Другими символами, например MFC закрытой реализации функций или классов, не экспортируются все экспорты выполняются по порядковому номеру без имени строки в таблице имен резидентным либо без проживания.  
  
 С помощью `class` **__declspec(dllexport)** может быть реальную альтернативу, для создания небольших DLL, но в случае больших DLL, например MFC, значение по умолчанию, экспорт механизм имеет емкость и эффективность ограничения.  
  
 Это значит, все возможности, мы можно упаковать большой объем функциональные возможности выпуска MFCxx.DLL, только около 800 КБ без нарушения много выполнения или скорость загрузки. MFCxx.DLL было бы больше 100 КБ бы этот метод не было использовать. Это также дает возможность добавить дополнительные точки входа в конце. DEF-файл позволяет простое управление версиями без ущерба для эффективности скорость и размер экспорта по порядковому номеру. Основной номер версии редакции в библиотеке классов MFC изменится имя библиотеки. То есть MFC30. Библиотека DLL — распространяемые библиотеки DLL, содержащей библиотеку классов MFC версии 3.0. Обновления этой библиотеки DLL, скажем, в гипотетической 3.1 MFC, библиотеки DLL будет называться MFC31. Библиотека DLL вместо него. Еще раз при изменении исходного кода MFC для создания пользовательской версии библиотеки DLL MFC, используйте другое имя (и лучше всего без «MFC» в имени).  
  
## <a name="see-also"></a>См. также  
 [Технические примечания по номеру](../mfc/technical-notes-by-number.md)   
 [Технические примечания по категории](../mfc/technical-notes-by-category.md)

