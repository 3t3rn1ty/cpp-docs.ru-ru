---
title: "TN053. Пользовательские процедуры DFX для классов баз данных DAO | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "vc.mfc.dfx"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "пользовательские процедуры DFX [C++]"
  - "DAO [C++], классы"
  - "DAO [C++], MFC - библиотека"
  - "классы баз данных [C++], DAO"
  - "DFX (обмен полями записей DAO) [C++]"
  - "DFX (обмен полями записей DAO) [C++], пользовательские процедуры"
  - "MFC [C++], DAO и"
  - "TN053"
ms.assetid: fdcf3c51-4fa8-4517-9222-58aaa4f25cac
caps.latest.revision: 10
caps.handback.revision: 6
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# TN053. Пользовательские процедуры DFX для классов баз данных DAO
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

> [!NOTE]
>  Что касается Visual C\+\+ .NET, то среда и мастера Visual C\+\+ больше не поддерживают DAO \(хотя классы DAO включены и вы по\-прежнему можете их использовать\).  Майкрософт рекомендует использовать [Шаблоны OLE DB](../Topic/OLE%20DB%20Templates.md) или [ODBC и MFC](../data/odbc/odbc-and-mfc.md) для новых проектов.  DAO необходимо использовать только для поддержки существующих приложений.  
  
 Это техническое примечание описывает механизм обмена полями записей \(DAO DFX\).  Помогла понимать, что происходит в процедурах DFX, функция `DFX_Text` будут, подробно рассматриваются в качестве примера.  Как дополнительный источник информации в этот техническому примечанию можно проверить код для другого отдельные функции DFX.  Вероятно, не требуется настраиваемой DFX так часто, как можно настраиваемой RFX \(используемой с классами баз данных ODBC\).  
  
 Это техническом примечании содержит:  
  
-   Общие сведения о DFX  
  
-   [Примеры](#_mfcnotes_tn053_examples) использование обмен полями записей и динамической привязки DAO  
  
-   [Как работает DFX](#_mfcnotes_tn053_how_dfx_works)  
  
-   [, Что настраиваемой DFX.](#_mfcnotes_tn053_what_your_custom_dfx_routine_does)  
  
-   [Сведения DFX\_Text](#_mfcnotes_tn053_details_of_dfx_text)  
  
 **Общие сведения о DFX**  
  
 Механизм обмена данными с полями записей \(DAO DFX\) используется для упрощения процедуры извлечения и обновления данных при использовании класса `CDaoRecordset`.  Процесс упрощен использование элементов данных класса `CDaoRecordset`.  Будучи производным от `CDaoRecordset` можно добавлять элементы данных на производный класс, представляющий каждое поле в таблице или запроса.  Этот механизм «статического связывания» простым, но не может быть методом выборки, обновления данных варианта для всех приложений.  DFX извлекает ограниченное каждое поле при каждом текущей записи.  При разработке производительности параметры приложения, которое не требуется получить каждое поле при изменении, валюта «динамическая привязка» через `CDaoRecordset::GetFieldValue` и `CDaoRecordset::SetFieldValue` могут быть методом доступа к данным вариантов.  
  
> [!NOTE]
>  DFX и динамическая привязка не является взаимоисключающим, поэтому гибридное использование статической и динамической привязки можно использовать.  
  
 **Пример — использование буфера обмена полями записей DAO только**  
  
 \(принимает `CDaoRecordset` — производный класс `CMySet` уже открытое\)  
  
```  
// Add a new record to the customers table  
myset.AddNew();  
myset.m_strCustID = _T("MSFT");  
myset.m_strCustName = _T("Microsoft");  
myset.Update();  
```  
  
 **Пример 2. использование динамической привязки только**  
  
 \(предполагается использование класса `CDaoRecordset`, `rs`, и он уже открыт\)  
  
```  
// Add a new record to the customers table  
COleVariant  varFieldValue1 ( _T("MSFT"), VT_BSTRT );  
//Note: VT_BSTRT flags string type as ANSI, instead of UNICODE default  
COleVariant  varFieldValue2  (_T("Microsoft"), VT_BSTRT );  
rs.AddNew();  
rs.SetFieldValue(_T("Customer_ID"), varFieldValue1);  
rs.SetFieldValue(_T("Customer_Name"), varFieldValue2);  
rs.Update();  
```  
  
 **Пример 3. использование буфера обмена полями записей и динамической привязки DAO**  
  
 \(предполагается просматривать данные с `CDaoRecordset`\- производный класс `emp` сотрудника\)  
  
```  
// Get the employee's data so that it can be displayed  
emp.MoveNext();  
  
// If user wants to see employee's photograph,  
// fetch it  
COleVariant varPhoto;  
if (bSeePicture)  
   emp.GetFieldValue(_T("photo"), varPhoto);  
  
// Display the data  
PopUpEmployeeData(emp.m_strFirstName,  
    emp.m_strLastName, varPhoto);  
```  
  
 **Как работает DFX**  
  
 Механизм DFX работает в подобной таким в механизм обмена полями записей \(RFX\), используемые классами MFC ODBC.  Принципы RFX и DFX одинаково, но множество внутренние различия.  Разработка функций DFX. поэтому практически весь код являются отдельными процедурами DFX.  На уровне DFX только в перечислено несколько действий.  
  
-   DFX создает предложение предложения SQL **выбрать** и **ПАРАМЕТРЫ** SQL соответственно.  
  
-   DFX создает структуры привязки, используемой функцией `GetRows` DAO \(дополнительные сведения об этом далее\).  
  
-   DFX управляет буфером данных, используемых для определения пакостные поля \(если двойной буферизацией используется\),  
  
-   DFX управляет массивы состояния **NULL** и **DIRTY** и значений набора при необходимости по обновлению.  
  
 Является ключевым элементом интерфейса механизма DFX функция `DoFieldExchange` производного класса `CDaoRecordset`.  Вызовы этой функции подготовки к отдельным функциям DFX соответствующего типа операции.  Перед вызовом `DoFieldExchange` внутренними функциями MFC задайте тип операции.  В следующем списке показаны различные типы операций и краткое описание.  
  
|Операция|Описание|  
|--------------|--------------|  
|**AddToParameterList**|Предложение ПАРАМЕТРОВ построений|  
|**AddToSelectList**|Предложение ВЫДЕЛЯТ построения|  
|**BindField**|Настройка структуры привязки|  
|**BindParam**|Устанавливает значения параметров|  
|**Относительной адресной привязки**|Состояние NULL наборов|  
|**AllocCache**|Выделяет кэш для проверки пакостного|  
|**StoreField**|Сохраняет текущую запись в кэш|  
|**LoadField**|Восстановление кэш значения члена|  
|**FreeCache**|Освобождает кэш|  
|`SetFieldNull`|Задает значение & состояния поля значения NULL|  
|**MarkForAddNew**|Помечает поля пакостные при ПСЕВДО NULL|  
|**MarkForEdit**|Помечает поля пакостные, если не соответствует кэш|  
|**SetDirtyField**|Задает значения полей, помеченный как пакостный|  
  
 В следующем разделе, каждая операция будет более подробно объясняется для `DFX_Text`.  
  
 Наиболее важную функцию, необходимо уяснить процессе обмена полями записей DAO, она использует функцию `GetRows` объекта `CDaoRecordset`.  Функция DAO `GetRows` может работать несколькими способами.  Это техническом примечании только кратко опишет `GetRows` как вне области этого технического примечания.  
  
 DAO `GetRows` может работать несколькими способами.  
  
-   Он может получить несколько записей и несколько полей данных одновременно.  Это позволяет для быстрого доступа к данным с усложнением обрабатывать большой структурой данных и соответствующие смещения к каждому полю и для каждой записи данных в структуре.  MFC не использует этого механизма доступа нескольких файлов.  
  
-   Другой способ `GetRows` может разрешить программистам работать для указания адреса привязки для извлеченных данных одной записи для каждого поля данных.  
  
-   DAO конструктор также «вызов» назад в вызывающий объект для столбцов переменной длины, чтобы разрешить вызывающий объект для выделения памяти.  Эта вторая функция имеет преимущество свернуть число копий данных, так и разрешения непосредственно хранилище данных в члены класса \(производного класса `CDaoRecordset` \).  Второй механизм метод MFC использует для привязки к элементам данных в производных классах `CDaoRecordset`.  
  
##  <a name="_mfcnotes_tn053_what_your_custom_dfx_routine_does"></a> , Что настраиваемой DFX.  
 Он явствует из данного материала предполагается, что наиболее важной операции, реализованная в любой функции DFX должна быть возможность настроить необходимые структуры данных успешно для вызова `GetRows`.  Несколько других операций, функция DFX должна поддерживать также, но не в качестве важной или сложное, как правильно подготовка для вызова `GetRows`.  
  
 Использование DFX см. в документации по сети.  По существу, 2 требования.  Во\-первых, необходимо добавить в члены производного класса `CDaoRecordset` для каждого ограниченных поля и параметров.  После этого `CDaoRecordset::DoFieldExchange` должна быть переопределена.  Обратите внимание, что тип данных члена имеет значение.  Он должен соответствовать данным из поля в базе данных или хотя бы быть преобразуемым к этому типу.  Например числовое поле в базе данных, например длинное целое число, всегда можно преобразовать в текст и границе на член `CString`, но текстовое поле в базе данных не обязательно может быть преобразовано в представление цифры, например длинные целое число и ее. длинному члену целые числа.  DAO и ядра СУБД Microsoft Jet за преобразования \(а не MFC\).  
  
##  <a name="_mfcnotes_tn053_details_of_dfx_text"></a> Сведения DFX\_Text  
 Как упоминалось ранее, лучшим способом понять, как работает DFX работать с примерами.  Для этой цели обрабатываться в внутренние составляющие `DFX_Text` должен работать довольно хорошо для упрощения по крайней мере общее представление о DFX.  
  
 **AddToParameterList**  
 Эта операция построения предложения **ПАРАМЕТРЫ** SQL \("`Parameters <param name>, <param type> ... ;`"\) требуется двигателем.  \- И набора каждый параметр \(в соответствии с вызове RFX\).  См. функцию **CDaoFieldExchange::AppendParamType** функции, чтобы увидеть имена отдельных типов.  В случае `DFX_Text`, используемый тип `text`.  
  
 **AddToSelectList**  
 Построения предложения **выбрать** SQL.  Вместо этого осуществляется напрямую, как имя столбца, вызовом DFX просто добавляется \("`SELECT <column name>, ...`"\).  
  
 **BindField**  
 Большинство настолько операций.  Как упоминалось ранее, где этот DAO настраивается привязка, используемая структура `GetRows`.  Как видно из кода в `DFX_Text` типы сведений в структура содержит тип DAO\) \(**DAO\_CHAR** или **DAO\_WCHAR** в случае `DFX_Text`\).  Кроме того, используемый тип привязки также настроен.  В предыдущем разделе `GetRows` было указано только короткое время, но было достаточно понять, что тип привязки, MFC всегда непосредственно привязка адреса \(**DAOBINDING\_DIRECT**\).  Кроме того, для привязки обратного вызова привязку столбцов переменной длины \(например, `DFX_Text`\) используется, чтобы элемент управления чонсервной банкы MFC выделение памяти и указать адрес нужной длины.  Это значит, всегда может говорить MFC DAO «, где» для данных, тем самым, что привязка непосредственно к переменным.  Остальные структуры привязки, в с действиями, например адрес функции обратного вызова выделения памяти и типа привязки столбца именем столбца \(привязки\).  
  
 **BindParam**  
 Это простой операцией, которая вызывает `SetParamValue` с параметром значение, указанных в элементе параметров.  
  
 **Fixup**  
 Заполнение состояние **NULL** для каждого поля.  
  
 `SetFieldNull`  
 Эта операция только помечает каждое состояние поля как **NULL** и присваивает значение переменной в **PSEUDO\_NULL**.  
  
 **SetDirtyField**  
 Вызывает `SetFieldValue` для каждого пакостного отмечена полем.  
  
 Все остальные операции работают только с использованием кэша данных.  Кэш данных дополнительный буфер данных в текущей записи, которая используется для упрощения некоторых действий более простым.  Например, «пакостные» поля можно обнаружить автоматически.  Как описано в сети в документации его можно отключить полностью или на уровне с отвесом.  Реализация буфера использует сопоставление.  Это сопоставление используется для сопоставления с помощью динамически выделенным копирования данных с адресом «привязанного» поля \(или производного `CDaoRecordset` элемента данных\).  
  
 **AllocCache**  
 Динамически выделяет кэшированное значение поля и добавляет ее в сопоставление.  
  
 **FreeCache**  
 Удаляет кэшированное значение поля и удалить его из сопоставления.  
  
 **StoreField**  
 Копирует текущее значение поля в кэш данных.  
  
 **LoadField**  
 Копирует кэшированное значение в члена поля.  
  
 **MarkForAddNew**  
 Проверяет текущее значение поля **NULL**, и помечает пакостное соответственно.  
  
 **MarkForEdit**  
 Сравнивает текущее значение поля, содержащего данных и метки пакостные соответственно.  
  
> [!TIP]
>  Модель пользовательских процедур DFX для существующего процедурах DFX для стандартных типов данных.  
  
## См. также  
 [Технические примечания по номеру](../mfc/technical-notes-by-number.md)   
 [Технические примечания по категории](../mfc/technical-notes-by-category.md)