---
title: 'TN053: Пользовательские процедуры DFX для DAO базы данных классов | Документы Microsoft'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-mfc
ms.topic: conceptual
f1_keywords:
- vc.mfc.dfx
dev_langs:
- C++
helpviewer_keywords:
- MFC, DAO and
- database classes [MFC], DAO
- DAO [MFC], MFC
- DFX (DAO record field exchange) [MFC], custom routines
- TN053
- DAO [MFC], classes
- DFX (DAO record field exchange) [MFC]
- custom DFX routines [MFC]
ms.assetid: fdcf3c51-4fa8-4517-9222-58aaa4f25cac
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 60e42aedd406e7478db83ecddca7d8b82230abc5
ms.sourcegitcommit: c6b095c5f3de7533fd535d679bfee0503e5a1d91
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/26/2018
ms.locfileid: "36951998"
---
# <a name="tn053-custom-dfx-routines-for-dao-database-classes"></a>TN053. Пользовательские процедуры DFX для классов баз данных DAO
> [!NOTE]
>  Среда Visual C++ и мастера не поддерживают DAO (хотя классы DAO включены и их можно по-прежнему использовать). Корпорация Майкрософт рекомендует использовать [шаблонов OLE DB](../data/oledb/ole-db-templates.md) или [ODBC и MFC](../data/odbc/odbc-and-mfc.md) для новых проектов. DAO следует использовать только для поддержки существующих приложений.  
  
 Это техническое Примечание описывает механизм обмена (DFX) полями записей DAO. Чтобы понять, что происходит в процедуры DFX, `DFX_Text` функции, которые будут описаны подробно в качестве примера. Как дополнительный источник данных для этого техническое Примечание можно проверить код для других отдельных функций DFX. Возможно, не потребуется пользовательские процедуры DFX так часто, как может потребоваться создать пользовательскую процедуру RFX (используется с классами баз данных ODBC).  
  
 Данный технический комментарий содержит:  
  
-   Общие сведения о DFX  
  
- [Примеры](#_mfcnotes_tn053_examples) с помощью обмен полями записей DAO и динамические привязки  
  
- [Как работает DFX](#_mfcnotes_tn053_how_dfx_works)  
  
- [Что делает подпрограмма пользовательских DFX](#_mfcnotes_tn053_what_your_custom_dfx_routine_does)  
  
- [Подробные сведения о DFX_Text](#_mfcnotes_tn053_details_of_dfx_text)  
  
 **Общие сведения о DFX**  
  
 Механизм обмена полями записей DAO (DFX) используется для упрощения процедуры извлечения и обновления данных при использовании `CDaoRecordset` класса. Упрощен процесс при помощи элементов данных `CDaoRecordset` класса. Путем наследования от `CDaoRecordset`, добавлении в производный класс, представляющий каждое поле в таблице или запросе элементов данных. Этот механизм «статический привязка» является простой, но может оказаться метод выборки или обновления данных по выбору для всех приложений. DFX извлекает все связанные поля каждый раз при изменении текущей записи. Если вы разрабатываете приложение чувствительных к производительности, которое не требуется получение каждого поля при изменении валюты «динамической привязки» через `CDaoRecordset::GetFieldValue` и `CDaoRecordset::SetFieldValue` может быть лучшим методом доступа к данным.  
  
> [!NOTE]
>  DFX и динамической привязки не являются взаимоисключающими, чтобы можно было использовать комбинированное использование статических и динамических привязки.  
  
## <a name="_mfcnotes_tn053_examples"></a> Пример 1 — Использование обмен полями записей DAO только  
  
 (предполагается `CDaoRecordset` — производный класс `CMySet` уже открыт)  
  
```  
// Add a new record to the customers table  
myset.AddNew();

myset.m_strCustID = _T("MSFT");

myset.m_strCustName = _T("Microsoft");

myset.Update();
```  
  
 **Пример 2 — Использование только динамическое связывание**  
  
 (предполагается использование `CDaoRecordset` класса `rs`, и он открыт)  
  
```  
// Add a new record to the customers table  
COleVariant  varFieldValue1 (_T("MSFT"),
    VT_BSTRT);

//Note: VT_BSTRT flags string type as ANSI,
    instead of UNICODE default  
COleVariant  varFieldValue2  (_T("Microsoft"),
    VT_BSTRT);

rs.AddNew();

rs.SetFieldValue(_T("Customer_ID"),
    varFieldValue1);

rs.SetFieldValue(_T("Customer_Name"),
    varFieldValue2);

rs.Update();
```  
  
 **Пример 3 — Используйте для DAO обмен полями записей и динамической привязки**  
  
 (предполагается, просмотре данных сотрудников с `CDaoRecordset`-производного класса `emp`)  
  
```  
// Get the employee's data so that it can be displayed  
emp.MoveNext();

 
// If user wants to see employee's photograph,  
// fetch it  
COleVariant varPhoto;  
if (bSeePicture)  
    emp.GetFieldValue(_T("photo"),
    varPhoto);

 
// Display the data  
PopUpEmployeeData(emp.m_strFirstName,  
    emp.m_strLastName,
    varPhoto);
```  
  
## <a name="_mfcnotes_tn053_how_dfx_works"></a> Как работает DFX  
  
 Механизм DFX работает таким же образом, чтобы механизм обмена (полями записей RFX) поле записи, используемые классы MFC ODBC. Принципы DFX и RFX одинаковы, но существуют многочисленные определенные внутренние различия. Архитектура функций DFX был таким образом, что практически весь код разделяется на отдельные процедуры DFX. В наивысший уровень DFX только выполняет несколько задач.  
  
-   DFX создает SQL **ВЫБЕРИТЕ** предложения и SQL **параметры** предложение, при необходимости.  
  
-   DFX создает структуры привязки, используемые в DAO `GetRows` функции (Подробнее об этом позже).  
  
-   DFX управляет буфера данных, используемый для определения поля «грязных» (если используется двойную буферизацию)  
  
-   Управляет DFX **NULL** и **DIRTY** состояние массивы, а также задает значения, при необходимости обновления.  
  
 Основа DFX механизм — `CDaoRecordset` класса, производного от `DoFieldExchange` функции. Эта функция отправляет вызовы отдельных функций DFX соответствующую операцию типа. Перед вызовом метода `DoFieldExchange` внутренней функции MFC задают тип операции. Ниже перечислены различные типы операций и краткое описание.  
  
|Операция|Описание:|  
|---------------|-----------------|  
|`AddToParameterList`|Создает предложение параметров|  
|`AddToSelectList`|Предложение SELECT построений|  
|`BindField`|Настраивает привязки структуру|  
|`BindParam`|Задает значения параметров|  
|`Fixup`|Задает допустимость значений NULL|  
|`AllocCache`|Выделяет кэша для "грязные" check|  
|`StoreField`|Сохраняет текущую запись в кэш|  
|`LoadField`|Восстановление кэша для значений элементов|  
|`FreeCache`|Освобождает кэш|  
|`SetFieldNull`|Присваивает полю значение на NULL и состояние|  
|`MarkForAddNew`|Метки поля «грязных», если нет ПСЕВДО NULL|  
|`MarkForEdit`|Метки поля "грязных" if не соответствуют кэша|  
|`SetDirtyField`|Задает значения, которые отмечены как грязные полей|  
  
 В следующем разделе каждой операции будут описаны более подробно `DFX_Text`.  
  
 Наиболее важная функция для понимания процесса обмена полями записей DAO: использование `GetRows` функция `CDaoRecordset` объекта. DAO `GetRows` функция может работать с несколькими способами. Это техническое примечание только кратко описывает `GetRows` как она находится за пределами этой Технические заметки.  
  
 DAO `GetRows` можно работать с несколькими способами.  
  
-   Его можно получить несколько записей и нескольким полям данных за один раз. Это позволяет быстрее доступа к данным с усложнения задач, связанных со структурой большие объемы данных и соответствующие смещения для каждого поля и для каждой записи данных в структуре. MFC не воспользоваться преимуществами нескольких запись выборка механизм.  
  
-   Другим способом `GetRows` можно работы, которую дает программистам возможность указать адресов привязки для полученных данных каждого поля в одной записи данных.  
  
-   DAO будет также «обратный вызов» вызывающего объекта, для столбцов переменной длины, чтобы вызывающий объект для выделения памяти. Этот второй компонент имеет преимущество уменьшает количество копий данных, а также позволяет непосредственно хранилище данных в члены класса ( `CDaoRecordset` производного класса). Этот второй механизм предполагает MFC использует для привязки к элементам данных в метод `CDaoRecordset` производных классов.  
  
##  <a name="_mfcnotes_tn053_what_your_custom_dfx_routine_does"></a> Что делает подпрограмма пользовательских DFX  
 Очевидно, из данного обсуждения, наиболее важные операции, реализуемой в любой функции DFX должно быть возможность устанавливать необходимые структуры данных, для успешного вызова `GetRows`. Существует ряд других операций, которые также должны поддерживать функции DFX, но не как важные или сложными, например правильно Подготовка `GetRows` вызова.  
  
 Использование DFX описан в документации в Интернете. По сути существует два требования. Во-первых, необходимо добавить членов `CDaoRecordset` производного класса для каждого привязанного к нему поля и параметра. После этого `CDaoRecordset::DoFieldExchange` должен быть переопределен. Обратите внимание, что важен тип данных элемента. Он должен совпадают с данными из поля в базе данных или по крайней мере преобразовываться в этот тип. Например числовое поле в базе данных, например целое число типа long, можно всегда преобразованы в текст и привязан к `CString` член, но текстовое поле в базе данных может не всегда преобразуются в числовое представление, такие как длинное целое число и привязан к long интеграция со ER члена. DAO и базы данных Microsoft Jet несут ответственность за преобразование (а не MFC).  
  
##  <a name="_mfcnotes_tn053_details_of_dfx_text"></a> Подробные сведения о DFX_Text  
 Как упоминалось ранее, чтобы объяснить, как работает DFX рекомендуется рассмотрим пример. Для этой цели, проходящий через внутренних `DFX_Text` хорошо подойдут для предоставления по крайней мере основные DFX.  
  
 `AddToParameterList`  
 Эта операция создает SQL **параметры** предложение («`Parameters <param name>, <param type> ... ;`») предусмотренного Jet. Каждый параметр с именем и типизированные (как указано в вызове RFX). В описании функции `CDaoFieldExchange::AppendParamType` функции, чтобы увидеть имена отдельных типов. В случае использования `DFX_Text`, используемый тип **текст**.  
  
 `AddToSelectList`  
 Строит SQL **ВЫБЕРИТЕ** предложения. Это довольно прост, как имя столбца, указанного при вызове DFX, достаточно добавляемое («`SELECT <column name>, ...`»).  
  
 `BindField`  
 Самым сложным операций. Как упоминалось ранее, это происходит, где используется структура привязки DAO `GetRows` настройки. Как видно из кода в `DFX_Text` типов данных в структуру включения DAO типа используется (**DAO_CHAR** или **DAO_WCHAR** в случае использования `DFX_Text`). Кроме того, тип используемой привязки также настраивается. В предыдущем разделе `GetRows` был описано только кратко, но его достаточно объяснить, что используемый тип привязки, используемые MFC является прямая адресация привязки (**DAOBINDING_DIRECT**). В дополнение к этому для привязки столбца переменной длины (например `DFX_Text`), можно контролировать распределение памяти и указать адрес правильную длину MFC используется привязка обратного вызова. Это означает, что MFC всегда узнать DAO «where» поместить данные, позволяя привязку непосредственно к переменных-членов. Остальная часть структуры привязки заносится таких вещей, как адрес функции обратного вызова выделения памяти и тип привязки столбцов (привязки по имени столбца).  
  
 `BindParam`  
 Это простые операции, которая вызывает `SetParamValue` со значением параметра, указанного в параметре-члене.  
  
 `Fixup`  
 Заполняет **NULL** состояния для каждого поля.  
  
 `SetFieldNull`  
 Эту операцию только помечает состояние каждого поля, как **NULL** и переводит значение переменной **PSEUDO_NULL**.  
  
 `SetDirtyField`  
 Вызовы `SetFieldValue` для каждого поля, помеченные как "грязные".  
  
 Все остальные операции работать только с из кэша данных. Кэш данных является данных в текущей записи, которые позволяют упростить некоторые дополнительные буферные. Например, для поля «грязных» можно автоматически обнаружить. Как описано в электронной документации его можно отключить полностью, так и на уровне полей. Реализация буфера использует карты. Это сопоставление используется для сопоставления динамически выделяемый экземпляров данных, если адрес поля «связанный» (или `CDaoRecordset` производный элемент данных).  
  
 `AllocCache`  
 Динамически выделяет значение кэшированных поля и добавляет его к схеме.  
  
 `FreeCache`  
 Удаляет значение кэшированных поля и удаляет его из сопоставления.  
  
 `StoreField`  
 Копирует текущее значение поля в кэше данных.  
  
 `LoadField`  
 Копирует кэшированное значение в поле элемента.  
  
 `MarkForAddNew`  
 Проверяет текущее значение поля не**NULL** и помечает его "грязные" при необходимости.  
  
 `MarkForEdit`  
 Сравнивает текущее значение поля с кэшем данных и помечает "грязные", при необходимости.  
  
> [!TIP]
>  Модели на пользовательские процедуры DFX на существующие процедуры DFX для стандартных типов данных.  
  
## <a name="see-also"></a>См. также  
 [Технические примечания по номеру](../mfc/technical-notes-by-number.md)   
 [Технические примечания по категории](../mfc/technical-notes-by-category.md)

