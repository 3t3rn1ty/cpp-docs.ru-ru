---
title: "TN071: Реализация IOleCommandTarget в MFC | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "IOleCommandTarget"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "IOleCommandTarget - интерфейс"
  - "TN071"
ms.assetid: 3eef571e-6357-444d-adbb-6f734a0c3161
caps.latest.revision: 9
caps.handback.revision: 5
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# TN071: Реализация IOleCommandTarget в MFC
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

> [!NOTE]
>  Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию.  В результате некоторые процедуры и разделы могут быть устаревшими или неверными.  Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.  
  
 Интерфейс `IOleCommandTarget` включает объекты и их контейнеров для отправки команд друг к другу.  Например, панели инструментов объекта могут содержать кнопки для команд **Печать**, например **Предварительный просмотр**, **Сохранить** и **Масштаб**. `New` Если такой объект был вставлен в контейнере, который поддерживает `IOleCommandTarget`, объект может содержать его кнопки и переадресовать команды на контейнер для обработки, когда пользователь нажимает их.  Если контейнер нужна внедренный объект печати, он может сделать этот запрос, отправляя команда через интерфейс `IOleCommandTarget` внедренного объекта.  
  
 `IOleCommandTarget` похожий на интерфейс автоматизации, так как он используется клиентом для вызова методов на сервере.  Однако с помощью `IOleCommandTarget` экономит ресурсы вызовом через интерфейсы автоматизации, поскольку программисты не следует использовать обычно требует метод `Invoke``IDispatch`.  
  
 В MFC, интерфейс `IOleCommandTarget` используется сервера активных документов, чтобы разрешить контейнеров активных документов к командам отправки на сервер.  Класс сервера активных документов, `CDocObjectServerItem`, использует сопоставлений интерфейсов MFC \(см. [TN038: Реализация MFC\/OLE IUnknown](../mfc/tn038-mfc-ole-iunknown-implementation.md)\) для реализации интерфейса `IOleCommandTarget`.  
  
 `IOleCommandTarget` также реализован в классе **COleFrameHook**.  **COleFrameHook** незадокументированный класс MFC, реализующий функциональные возможности контейнеров фреймового окна редактирования локально.  **COleFrameHook** также используется сопоставлений интерфейсов MFC для реализации интерфейса `IOleCommandTarget`.  реализация метода **COleFrameHook**`IOleCommandTarget` переадресует OLE команды в `COleDocObjectItem`\- производные контейнеров активных документов.  При этом любой контейнер активных документов MFC для получения сообщения, который содержат сервера активных документов.  
  
## Сопоставления команды MFC OLE  
 Разработчики могут воспользоваться преимуществами MFC `IOleCommandTarget` с помощью сопоставлений команды MFC OLE.  OLE сопоставления команды как сопоставления сообщений, поскольку они могут быть использованы для сопоставления OLE команды к функциям элемента класса, содержащий сопоставление команды.  Сделать этот работы, макросы места в сопоставлении команды для определения OLE группу в составе команды команду необходимо обработать, OLE команды, и идентификатор группы сообщений [WM\_COMMAND](http://msdn.microsoft.com/library/windows/desktop/ms647591), которое будет отправлена команда будет получена при OLE.  MFC также предоставляет несколько предопределенных макросов OLE для стандартных команд.  Для списка стандартных OLE команды, которые изначально были предназначены для использования в приложениях Microsoft Office см. перечисление OLECMDID, заданному в docobj.h.  
  
 Если команда OLE выполняется приложением MFC OLE, содержащий сопоставление команды, MFC пытается найти команда идентификатор команды и команды для запрошенного команды OLE в сопоставлении команды приложения.  Если обнаружено соответствие, то сообщение **WM\_COMMAND** подготовлено к отправке в приложение, содержащий сопоставление команды с идентификатором запрошенный команды. \(См. описание `ON_OLECMD` ниже\). Таким образом, OLE команды подготовленные к отправке в приложение повернуты сообщения **WM\_COMMAND** в MFC.  Сообщения **WM\_COMMAND** затем направляются через схемы сообщений приложения с помощью архитектуры стандартную MFC [маршрутизация команд](../mfc/command-routing.md).  
  
 В отличие от схемы сопоставления сообщений, команды MFC OLE ClassWizard не поддерживаются.  Разработчики MFC OLE необходимо добавить записи сопоставления поддержки сопоставления команды и команды OLE вручную.  OLE сопоставления команды можно добавить на серверах активных документов MFC в любом классе, в цепочке сообщение\- маршрутизации **WM\_COMMAND** в активный документ на месте активен в контейнере.  Эти классы включают приложения классы, производные от [CWinApp](../mfc/reference/cwinapp-class.md), [CView](../Topic/CView%20Class.md), [CDocument](../Topic/CDocument%20Class.md) и [COleIPFrameWnd](../mfc/reference/coleipframewnd-class.md).  В контейнерах активных документов, OLE сопоставления команды можно добавлять только к [COleDocObjectItem](../Topic/COleDocObjectItem%20Class.md)\- производного класса.  Кроме того, в контейнерах активных документов, сообщения **WM\_COMMAND** только передачей в схеме сообщений в `COleDocObjectItem`\- производного класса.  
  
## Макросы команд сопоставления OLE  
 Используйте следующие макросы для добавления функции сопоставления команды к классу:  
  
```  
  
DECLARE_OLECMD_MAP ()  
  
```  
  
 Этот макрос находится в объявление класса \(обычно в файле заголовка\) класса, содержащий сопоставление команды.  
  
```  
  
BEGIN_OLECMD_MAP(  
theClass  
,   
baseClass  
)  
  
```  
  
 `theClass`  
 Имя класса, который содержит сопоставление команды.  
  
 `baseClass`  
 Имя базового класса, содержащий сопоставление команды.  
  
 Этот макрос обозначает начало сопоставления команды.  Этот макрос в файле реализации класса, содержащего сопоставление команды.  
  
```  
  
END_OLECMD_MAP()  
  
```  
  
 Этот макрос отмечает конец сопоставления команды.  Этот макрос в файле реализации класса, содержащего сопоставление команды.  Этот макрос должен всегда соблюдать макроса **BEGIN\_OLECMD\_MAP**.  
  
```  
  
ON_OLECMD(  
pguid  
,   
olecmdid  
,   
id  
)  
  
```  
  
 `pguid`  
 Указатель на идентификатор GUID группы команды OLE команды.  Этот параметр **NULL** для стандартной OLE группы команд.  
  
 *olecmdid*  
 Идентификатор команды OLE команды вызывается.  
  
 `id`  
 Идентификатор сообщения **WM\_COMMAND** для отправки в приложение, содержащий сопоставление команды при вызове OLE команда будет вызвана функцией.  
  
 Используйте макрос `ON_OLECMD` в сопоставлении команды для добавления записей для OLE команд необходимо обработать.  Если команды OLE будет получена, они будут преобразованы к конкретному сообщению и **WM\_COMMAND** направляются по схеме сообщений приложения с помощью стандартной архитектуры маршрутизации команд MFC.  
  
## Пример  
 В следующем примере показано добавление OLE команда\- возможность обработки на сервер активных документов MFC OLE обрабатывать команду [OLECMDID\_PRINT](http://msdn.microsoft.com/library/windows/desktop/ms691264).  В этом примере высказывать AppWizard, используемый для создания приложения MFC, сервер активных документов.  
  
1.  В `CView`\- файл заголовка производного класса, добавить макрос `DECLARE_OLECMD_MAP` к объявлению класса.  
  
    > [!NOTE]
    >  Используйте `CView`\- производного класса, поскольку один из классов в сервере активных документов, в цепочке сообщение\- маршрутизации **WM\_COMMAND**.  
  
    ```  
    class CMyServerView : public CView  
    {  
    protected: // create from serialization only  
       CMyServerView();  
       DECLARE_DYNCREATE(CMyServerView)  
       DECLARE_OLECMD_MAP()  
    . . .  
    };  
    ```  
  
2.  В файле реализации `CView`\- производный класс, добавляет макросы `BEGIN_OLECMD_MAP` и `END_OLECMD_MAP`:  
  
    ```  
    BEGIN_OLECMD_MAP(CMyServerView, CView)  
  
    END_OLECMD_MAP()  
    ```  
  
3.  Для обработки стандартная OLE команду на принтер добавьте макрос [ON\_OLECMD](../Topic/ON_OLECMD.md) для сопоставления команды OLE, содержащее идентификатор команды для стандартной команды на принтер и **ID\_FILE\_PRINT** для идентификатора **WM\_COMMAND ID\_FILE\_PRINT** стандартное идентификатор команды на принтер, AppWizard\- создаваемыми приложениями MFC.  
  
    ```  
    BEGIN_OLECMD_MAP(CMyServerView, CView)  
       ON_OLECMD(NULL,OLECMDID_PRINT,ID_FILE_PRINT)  
    END_OLECMD_MAP()  
    ```  
  
 Обратите внимание, что один из стандартных макросов OLE команды, указанный в afxdocob.h, может использоваться вместо макроса `ON_OLECMD`, поскольку **OLECMDID\_PRINT** стандартное OLE идентификатор команды.  Макрос `ON_OLECMD_PRINT` выполняет ту же задачу, что макрос `ON_OLECMD`, показанный выше.  
  
 Если этот сервер контейнерное приложение отправляет команду **OLECMDID\_PRINT** через интерфейс `IOleCommandTarget` сервера, обработчик команды печати MFC будет вызван на сервере, который затем сервер печати приложение.  Код контейнера активных документов, чтобы вызвать команду на принтер доступные в шагах выше будет выглядеть так:  
  
```  
void CContainerCntrItem::DoOleCmd()  
{  
   IOleCommandTarget *pCmd = NULL;  
   HRESULT hr = E_FAIL;  
   OLECMD ocm={OLECMDID_PRINT, 0};  
  
   hr = m_lpObject->QueryInterface(IID_IOleCommandTarget,reinterpret_cast<void**>(&pCmd));  
   if(FAILED(hr))  
      return;  
  
   hr = pCmd->QueryStatus(NULL, 1, &ocm, NULL);  
   if(SUCCEEDED(hr) && (ocm.cmdf & OLECMDF_ENABLED))  
   {  
      //Command is available and enabled so call it  
      COleVariant vIn;  
      COleVariant vOut;  
      hr = pCmd->Exec(NULL, OLECMDID_PRINT,  
 OLECMDEXECOPT_DODEFAULT, &vIn, &vOut);  
      ASSERT(SUCCEEDED(hr));  
   }  
   pCmd->Release();  
}  
```  
  
## См. также  
 [Технические примечания по номеру](../mfc/technical-notes-by-number.md)   
 [Технические примечания по категории](../mfc/technical-notes-by-category.md)