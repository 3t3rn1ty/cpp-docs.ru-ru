---
title: Наследование класса от CObject | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-mfc
ms.topic: conceptual
f1_keywords:
- CObject
dev_langs:
- C++
helpviewer_keywords:
- DECLARE_DYNCREATE macro [MFC]
- DECLARE_SERIAL macro [MFC]
- macros [MFC], serialization
- serialization [MFC], macros
- DECLARE_DYNAMIC macro [MFC]
- derived classes [MFC], from CObject
- CObject class [MFC], deriving serializable classes
- CObject class [MFC], deriving from
ms.assetid: 5ea4ea41-08b5-4bd8-b247-c5de8c152a27
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 2d0b629617c1592387f3f959996fd3e9837242ea
ms.sourcegitcommit: 76b7653ae443a2b8eb1186b789f8503609d6453e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
ms.locfileid: "33349361"
---
# <a name="deriving-a-class-from-cobject"></a>Наследование класса от CObject
В этой статье описаны минимальные шаги, необходимые для наследования от класса [CObject](../mfc/reference/cobject-class.md). Другие `CObject` класс статьи описывают шаги, необходимые для использования определенного `CObject` возможностей, таких как сериализации и диагностики поддержку отладки.  
  
 В обсуждении `CObject`, часто используются термины «интерфейс файл» и «реализация файл». Файл интерфейса (часто называют файл заголовка или. H-файл) содержит объявление класса и другие сведения, необходимые для использования класса. Файл реализации (или. CPP-файл) содержит определения класса, а также код, который реализует функции-члены класса. Например, класс с именем `CPerson`, обычно необходимо создать файл с именем PERSON интерфейса. H и файл реализации с именем пользователя. CPP. Однако для некоторых небольших классов, которые не будут передаваться между приложениями, иногда бывает проще объединять интерфейс и реализацию в один. CPP-файл.  
  
 Можно выбрать из четырех уровней функциональности при наследовании от класса `CObject`:  
  
-   Основные функции: сведения о классе во время выполнения или сериализации не поддерживается, но включает управление диагностики памяти.  
  
-   Информация о классе основные функциональные возможности, а также поддержку во время выполнения.  
  
-   Основные функциональные возможности, а также поддержку времени выполнения класса сведения и динамическое создание.  
  
-   Основные функциональные возможности, а также поддержку времени выполнения класса сведения, динамическое создание и сериализации.  
  
 Классы, предназначенные для повторного использования (те, которые впоследствии будет использоваться в качестве базовых классов) по крайней мере следует во время выполнения класс поддержки и поддержки сериализации, если учтена любого необходимого будущих сериализации.  
  
 Выберите уровень функциональных возможностей с помощью определенных макросов в объявлении и реализации классов являются производными от объявления и реализации `CObject`.  
  
 В следующей таблице показана взаимосвязь между макросы, используемые для поддержки сериализации и данных времени выполнения.  
  
### <a name="macros-used-for-serialization-and-run-time-information"></a>Макросы, используемые для сериализации и данных времени выполнения  
  
|Макросы используются|CObject::IsKindOf|CRuntimeClass::<br /><br /> CreateObject|CArchive::operator >><br /><br /> CArchive::operator <<|  
|----------------|-----------------------|--------------------------------------|-------------------------------------------------------|  
|Основные `CObject` функциональные возможности|Нет|Нет|Нет|  
|`DECLARE_DYNAMIC`|Да|Нет|Нет|  
|`DECLARE_DYNCREATE`|Да|Да|Нет|  
|`DECLARE_SERIAL`|Да|Да|Да|  
  
#### <a name="to-use-basic-cobject-functionality"></a>Чтобы использовать базовую функциональность в CObject  
  
1.  Использование обычного синтаксиса C++ для наследования класса из `CObject` (или из класса, производного от `CObject`).  
  
     В следующем примере показано простейшем случае производный класс от `CObject`:  
  
     [!code-cpp[NVC_MFCCObjectSample#1](../mfc/codesnippet/cpp/deriving-a-class-from-cobject_1.h)]  
  
 Как правило, однако, можно переопределить некоторые `CObject`в функции-члены для обработки особенности к новому классу. Например, обычно можно переопределить `Dump` функции `CObject` для обеспечения содержимое класса выходные данные отладки. Дополнительные сведения о том, как переопределить `Dump`, см. в статье [диагностики: содержимого формирование дампа объекта](http://msdn.microsoft.com/en-us/727855b1-5a83-44bd-9fe3-f1d535584b59). Можно также переопределить `AssertValid` функции `CObject` для предоставления настраиваемые тесты для проверки согласованности данных членов класса объектов. Описание того, как переопределить `AssertValid`, в разделе [MFC ASSERT_VALID и CObject::AssertValid](http://msdn.microsoft.com/en-us/7654fb75-9e9a-499a-8165-0a96faf2d5e6).  
  
 Статья [задание уровней функциональности](../mfc/specifying-levels-of-functionality.md) описывает, как указать другие уровни функциональные возможности, включая сведения о классе во время выполнения, динамическое создание объектов и сериализации.  
  
## <a name="see-also"></a>См. также  
 [Использование CObject](../mfc/using-cobject.md)

