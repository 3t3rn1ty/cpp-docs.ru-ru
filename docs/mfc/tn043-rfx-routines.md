---
title: 'TN043: Процедуры RFX | Документы Microsoft'
ms.custom: ''
ms.date: 06/28/2018
ms.technology:
- cpp-mfc
ms.topic: conceptual
f1_keywords:
- RFX
dev_langs:
- C++
helpviewer_keywords:
- RFX (record field exchange), architecture
- TN043
- RFX (record field exchange)
ms.assetid: f552d0c1-2c83-4389-b472-42c9940aa713
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: f0c53ed2d1f1ab1a965a913287c8b5c171903518
ms.sourcegitcommit: 208d445fd7ea202de1d372d3f468e784e77bd666
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/29/2018
ms.locfileid: "37122775"
---
# <a name="tn043-rfx-routines"></a>TN043. Процедуры RFX

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

Эта заметка описывается архитектура обмена (полями записей RFX) поле записи. Также описывается, как создавать **RFX_** процедуры.

## <a name="overview-of-record-field-exchange"></a>Общие сведения о обмен полями записей

Все функции поле recordset выполняются с кодом C++. Никаких специальных ресурсов или магических макросов не требуется. Основой механизма является виртуальная функция, должен быть переопределен в каждом записей в производном классе. Она всегда представлена в такой форме:

```cpp
void CMySet::DoFieldExchange(CFieldExchange* pFX)
{
    //{{AFX_FIELD_MAP(CMySet)
        <recordset exchange field type call>
        <recordset exchange function call>
    //}}AFX_FIELD_MAP
}
```

Комментарии специального формата AFX позволяют мастеру ClassWizard искать и редактировать код в рамках данной функции. Код, который не совместим с ClassWizard, должен располагаться за пределами этих комментариев специального формата.

В приведенном выше примере < recordset_exchange_field_type_call > находится в форме:

```cpp
pFX->SetFieldType(CFieldExchange::outputColumn);
```

и < recordset_exchange_function_call > находится в форме:

```cpp
RFX_Custom(pFX, "Col2", m_Col2);
```

Большинство **RFX_** функции имеют три аргументы, как показано выше, но некоторые (например `RFX_Text` и `RFX_Binary`) имеют дополнительные необязательные аргументы.

Существует несколько **RFX_** может быть включено в каждом `DoDataExchange` функции.

В разделе «afxdb.h» для получения списка всех записей процедуры обмена полями в MFC.

Вызовы поле Recordset — это способ регистрации областей памяти (как правило, члены данных) для хранения данных поля для `CMySet` класса.

## <a name="notes"></a>Примечания

Функции поле Recordset, предназначены для работы только с `CRecordset` классы. Они не являются пригодной по классов MFC.

Начальные значения данных задаются в обычном конструкторе C++, обычно в блоке между комментариями `//{{AFX_FIELD_INIT(CMylSet)` и `//}}AFX_FIELD_INIT`.

Каждый **RFX_** функции должны поддерживать различные операции, начиная от возвращение "грязных" состояние поля для архивирования поля в процессе подготовки для редактирования поля.

Каждая функция, которая вызывает `DoFieldExchange` (например `SetFieldNull`, `IsFieldDirty`), собственный инициализации вокруг вызова `DoFieldExchange`.

## <a name="how-does-it-work"></a>Как это работает

Необходимо принять во внимание следующие для использования обмен полями записей. Однако основные сведения о том, как это работает в фоновом поможет вам создать собственную процедуру exchange.

`DoFieldExchange` Функция-член является очень похоже на `Serialize` функция-член, он отвечает за получения или задания данных из внешних формы (в столбцах этого варианта из результата запроса ODBC) и член данных в классе. *PFX* параметр контекст для выполнения обмена данными и похож на *CArchive* параметр `CObject::Serialize`. *PFX* ( `CFieldExchange` объекта) имеет индикатора операции, что похоже на, но обобщением *CArchive* флаг направления. Функции RFX может потребоваться поддерживают следующие операции:

- `BindParam` — Указывает, где ODBC должен получать данные параметра

- `BindFieldToColumn` – Указать, где ODBC необходимо извлечь или депозита outputColumn данных

- `Fixup` — Настройте `CString/CByteArray` длины, установить бит допустимость значений NULL

- `MarkForAddNew` — Если значение было изменено, поскольку вызов AddNew "грязный" знак

- `MarkForUpdate` — "Грязный" знак, если значение было изменено с момента вызова редактирования

- `Name` — Добавление имен полей для поля, помеченные как "грязные"

- `NameValue` — Добавление "\<имя столбца > =» для поля, помеченные как" грязные "

- `Value` — Добавление «» следует разделитель, такие как ',' или ' "

- `SetFieldDirty` -Задать состояние "грязного" (т. е. измененной) полем

- `SetFieldNull` -Задать бит состояния, указывающее значение null для поля

- `IsFieldDirty` — Состояние «грязный» бит возвращаемое значение

- `IsFieldNull` — Возвращает значение бита в состоянии null

- `IsFieldNullable` — Возвращает значение TRUE, если поле может содержать значения NULL

- `StoreField` — Значение поля архив

- `LoadField` — Перезагрузить архивировать значение поля

- `GetFieldInfoValue` — Возвращает общие сведения по полю

- `GetFieldInfoOrdinal` — Возвращает общие сведения по полю

## <a name="user-extensions"></a>Пользовательские расширения

Существует несколько способов для расширения стандартного механизма RFX. Можно

- Добавить новые типы данных.  Пример:

    ```cpp
    CBookmark
    ```

- Добавьте новые процедуры exchange (RFX_).

    ```cpp
    void AFXAPI RFX_Bigint(CFieldExchange* pFX,
        const char *szName,
        BIGINT& value);
    ```

- У `DoFieldExchange` функции-члена условно включают дополнительные вызовы RFX или другие допустимые операторы C++.

    ```cpp
    while (posExtraFields != NULL)
    {
        RFX_Text(pFX,
        m_listName.GetNext(posExtraFields),
        m_listValue.GetNext(posExtraValues));
    }
    ```

> [!NOTE]
> Такой код не может редактировать ClassWizard и должен использоваться только за пределами комментарии специальный формат.

## <a name="writing-a-custom-rfx"></a>Написание пользовательских RFX

Для написания собственной функции RFX настраиваемый, рекомендуется скопировать существующей функции RFX и изменить его для использования в личных целях. При выборе правой RFX для копирования делает задания намного проще. Некоторые функции RFX имеют некоторые уникальные свойства, которые следует учитывать при принятии решения, который необходимо скопировать.

`RFX_Long` и `RFX_Int`: это простой функции RFX. Значение данных не обязательно все специальные интерпретации и фиксированный размер данных.

`RFX_Single` и `RFX_Double`: как RFX_Long и RFX_Int выше, эти функции являются простыми и осуществлять широко использовать реализации по умолчанию. Они хранятся в dbflt.cpp вместо dbrfx.cpp, тем не менее, Включение загрузки среды выполнения с плавающей точкой библиотеки только в том случае, если они явным образом являются ссылками.

`RFX_Text` и `RFX_Binary`: эти две функции предварительного выделения статический буфер для хранения строки или двоичного файла сведений и необходимо зарегистрировать эти буферы ODBC SQLBindCol вместо регистрации & значение. По этой причине эти две функции имеют множество особой кода.

`RFX_Date`: ODBC возвращает сведения о дате и времени в структуре данных собственные TIMESTAMP_STRUCT. Эта функция динамически выделяет TIMESTAMP_STRUCT как «прокси» для отправки и получения данных даты-времени. Различные операции необходимо передать данные даты и времени между C++ `CTime` объекта и TIMESTAMP_STRUCT прокси-сервера. Это значительно усложняет эту функцию, но это хороший пример демонстрирует использование учетной записи-посредника для передачи данных.

`RFX_LongBinary`: Это только библиотеки классов RFX-функции, которая не использует привязку столбца для получения и отправки данных. Эта функция не учитывает операции BindFieldToColumn и вместо этого во время операции исправления, выделяется хранилище для хранения входящих данных SQL_LONGVARCHAR или SQL_LONGVARBINARY, а затем выполняет вызов SQLGetData для получения значения в хранилище, выделенное. При подготовке к отправки значений данных обратно в источник данных (например, имя и значение операций), эта функция использует функциональность DATA_AT_EXEC ODBC. В разделе [Технические заметки 45](../mfc/tn045-mfc-database-support-for-long-varchar-varbinary.md) Дополнительные сведения о работе с SQL_LONGVARBINARY и SQL_LONGVARCHARs.

При написании собственного **RFX_** функции, часто можно использовать `CFieldExchange::Default` для реализации данной операции. Посмотрите на реализацию по умолчанию для выполнения запрошенной операции. Если он выполняет операцию пришлось бы написать вашей **RFX_** можно делегировать функцию `CFieldExchange::Default`. Можно просмотреть примеры вызова `CFieldExchange::Default` в dbrfx.cpp

Очень важно вызвать `IsFieldType` в начале функции RFX и возврат немедленно, если она возвращает значение FALSE. Этот механизм сохраняет параметр выполнение операций в на *outputColumns*и наоборот (например вызов `BindParam` на *outputColumn*). Кроме того `IsFieldType` автоматическое отслеживание всех число *outputColumns* (*m_nFields*) и params (*m_nParams*).

## <a name="see-also"></a>См. также

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)  
[Технические примечания по категории](../mfc/technical-notes-by-category.md)  
