---
title: "TN043: Процедуры RFX | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords: RFX
dev_langs: C++
helpviewer_keywords:
- RFX (record field exchange), architecture
- TN043
- RFX (record field exchange)
ms.assetid: f552d0c1-2c83-4389-b472-42c9940aa713
caps.latest.revision: "10"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: 19bb44653c03505d954318a01a6e34c1a297dba7
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="tn043-rfx-routines"></a>TN043. Процедуры RFX
> [!NOTE]
>  Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.  
  
 Эта заметка описывается архитектура обмена (полями записей RFX) поле записи. Также описывается, как создавать **RFX_** процедуры.  
  
## <a name="overview-of-record-field-exchange"></a>Общие сведения о обмен полями записей  
 Все функции поле recordset выполняются с кодом C++. Отсутствуют специальные ресурсы или magic макросы. Основой механизма является виртуальная функция, должен быть переопределен в каждом записей в производном классе. Он всегда находится в этой форме:  
  
```  
void CMySet::DoFieldExchange(CFieldExchange* pFX)  
{ *//{{AFX_FIELD_MAP(CMySet)  
 <recordset exchange field type call>  
 <recordset exchange function call> *//}}AFX_FIELD_MAP  
}  
```  
  
 Комментарии AFX специальный формат разрешить ClassWizard для поиска и редактирования кода в рамках данной функции. Код, который не совместим с ClassWizard должны располагаться за пределами комментарии специальный формат.  
  
 В приведенном выше примере < recordset_exchange_field_type_call > находится в форме:  
  
```  
pFX->SetFieldType(CFieldExchange::outputColumn);
```  
  
 и < recordset_exchange_function_call > находится в форме:  
  
```  
RFX_Custom(pFX, "Col2",
    m_Col2);
```  
  
 Большинство **RFX_** функции имеют три аргументы, как показано выше, но некоторые (например `RFX_Text` и `RFX_Binary`) имеют дополнительные необязательные аргументы.  
  
 Существует несколько **RFX_** может быть включено в каждом `DoDataExchange` функции.  
  
 В разделе «afxdb.h» для получения списка всех записей процедуры обмена полями в MFC.  
  
 Вызовы поле Recordset — это способ регистрации областей памяти (как правило, члены данных) для хранения данных поля для **CMySet** класса.  
  
## <a name="notes"></a>Примечания  
 Функции поле Recordset, предназначены для работы только с `CRecordset` классы. Они не являются пригодной по классов MFC.  
  
 Начальные значения данных задаются в конструкторе standard C++ обычно в блоке с `//{{AFX_FIELD_INIT(CMylSet)` и `//}}AFX_FIELD_INIT` комментарии.  
  
 Каждый **RFX_** функции должны поддерживать различные операции, начиная от возвращение "грязных" состояние поля для архивирования поля в процессе подготовки для редактирования поля.  
  
 Каждая функция, которая вызывает `DoFieldExchange` (например `SetFieldNull`, `IsFieldDirty`), собственный инициализации вокруг вызова `DoFieldExchange`.  
  
## <a name="how-does-it-work"></a>Как это работает  
 Необходимо принять во внимание следующие для использования обмен полями записей. Однако основные сведения о том, как это работает в фоновом поможет вам создать собственную процедуру exchange.  
  
 `DoFieldExchange` Функция-член является очень похоже на `Serialize` функция-член, он отвечает за получения или задания данных из внешних формы (в столбцах этого варианта из результата запроса ODBC) и член данных в классе. `pFX` Параметр контекст для выполнения обмена данными и похож на `CArchive` параметр `CObject::Serialize`. `pFX` ( `CFieldExchange` Объекта) имеет индикатора операции, что похоже на, но обобщением `CArchive` флаг направления. Функции RFX может потребоваться поддерживают следующие операции:  
  
- **BindParam** — укажите, где ODBC должен получать данные параметра  
  
- **BindFieldToColumn** — укажите, где ODBC необходимо извлечь или депозита outputColumn данных  
  
- **Адресная привязка** — задать **CString/CByteArray** длины, установить бит допустимость значений NULL  
  
- **MarkForAddNew** — знак "грязный", если значение было изменено, поскольку вызов AddNew  
  
- **MarkForUpdate** — знак "грязный", если значение было изменено с момента вызова редактирования  
  
- **Имя** — Добавление имен полей для поля, помеченные как "грязные"  
  
- **Имя** — Добавление "\<имя столбца > =» для поля, помеченные как" грязные "  
  
- **Значение** — Append «» следует разделитель, такие как ',' или ' "  
  
- `SetFieldDirty`-Задать состояние "грязного" (т. е. измененной) полем  
  
- `SetFieldNull`-Задать бит состояния, указывающее значение null для поля  
  
- `IsFieldDirty`— Состояние «грязный» бит возвращаемое значение  
  
- `IsFieldNull`— Возвращает значение бита в состоянии null  
  
- `IsFieldNullable`— Возвращает значение TRUE, если поле может содержать значения NULL  
  
- **StoreField** — архивировать значение поля  
  
- **LoadField** — перезагрузить архивировать значение поля  
  
- **GetFieldInfoValue** — возвращать общие сведения по полю  
  
- **GetFieldInfoOrdinal** — возвращать общие сведения по полю  
  
## <a name="user-extensions"></a>Пользовательские расширения  
 Существует несколько способов для расширения стандартного механизма RFX. Можно  
  
-   Добавление новых типов данных. Пример:  
  
 ```  
    CBookmark 
 ```  
  
-   Добавьте новые процедуры exchange (RFX_).  
  
 ```  
    void AFXAPI RFX_Bigint(CFieldExchange* pFX,
    const char *szName,  
    BIGINT& value);

 ```  
  
-   У `DoFieldExchange` функции-члена условно включают дополнительные вызовы RFX или другие допустимые операторы C++.  
  
 ```  
    while (posExtraFields != NULL)  
 {  
    RFX_Text(pFX,
    m_listName.GetNext(posExtraFields),   
    m_listValue.GetNext(posExtraValues));

 }  
 ```  
  
> [!NOTE]
>  Такой код не может редактировать ClassWizard и должен использоваться только за пределами комментарии специальный формат.  
  
## <a name="writing-a-custom-rfx"></a>Написание пользовательских RFX  
 Для написания собственной функции RFX настраиваемый, рекомендуется скопировать существующей функции RFX и изменить его для использования в личных целях. При выборе правой RFX для копирования делает задания намного проще. Некоторые функции RFX имеют некоторые уникальные свойства, которые следует учитывать при принятии решения, который необходимо скопировать.  
  
 **RFX_Long и RFX_Int**:  
 Это простейший функции RFX. Значение данных не обязательно все специальные интерпретации и фиксированный размер данных.  
  
 **RFX_Single и RFX_Double**:  
 Подобно RFX_Long и RFX_Int выше, эти функции являются простыми и осуществлять широко использовать реализации по умолчанию. Они хранятся в dbflt.cpp вместо dbrfx.cpp, тем не менее, Включение загрузки среды выполнения с плавающей точкой библиотеки только в том случае, если они явным образом являются ссылками.  
  
 **RFX_Text и RFX_Binary**:  
 Эти две функции предварительного выделения статический буфер для хранения строки или двоичного файла сведений и необходимо зарегистрировать эти буферы ODBC SQLBindCol вместо регистрации & значение. По этой причине эти две функции имеют множество особой кода.  
  
 `RFX_Date`:  
 ODBC возвращает сведения о дате и времени в своих собственных TIMESTAMP_STRUCT структуры данных. Эта функция динамически выделяет TIMESTAMP_STRUCT как «прокси» для отправки и получения данных даты-времени. Различные операции необходимо передать данные даты и времени между C++ `CTime` объекта и TIMESTAMP_STRUCT прокси-сервера. Это значительно усложняет эту функцию, но это хороший пример демонстрирует использование учетной записи-посредника для передачи данных.  
  
 `RFX_LongBinary`:  
 Это только библиотеки классов RFX-функции, которая не использует привязку столбца для получения и отправки данных. Эта функция не учитывает операции BindFieldToColumn и вместо этого во время операции исправления, выделяется хранилище для хранения входящих данных SQL_LONGVARCHAR или SQL_LONGVARBINARY, а затем выполняет вызов SQLGetData для получения значения в хранилище, выделенное. При подготовке к отправки значений данных обратно в источник данных (например, имя и значение операций), эта функция использует функциональность DATA_AT_EXEC ODBC. В разделе [Технические заметки 45](../mfc/tn045-mfc-database-support-for-long-varchar-varbinary.md) Дополнительные сведения о работе с SQL_LONGVARBINARY и SQL_LONGVARCHARs.  
  
 При написании собственного **RFX_** функции, часто можно использовать **CFieldExchange::Default** для реализации данной операции. Посмотрите на реализацию по умолчанию для выполнения запрошенной операции. Если он выполняет операцию пришлось бы написать вашей **RFX_** можно делегировать функцию **CFieldExchange::Default.** Можно просмотреть примеры вызова **CFieldExchange::Default** в dbrfx.cpp  
  
 Очень важно вызвать `IsFieldType` в начале функции RFX и возврат немедленно, если она возвращает значение FALSE. Этот механизм сохраняет параметр выполнение операций в на **outputColumns**и наоборот (например вызов **BindParam** на **outputColumn**). Кроме того `IsFieldType` автоматическое отслеживание всех число **outputColumns** (`m_nFields`) и params (`m_nParams`).  
  
## <a name="see-also"></a>См. также  
 [Технические примечания по номеру](../mfc/technical-notes-by-number.md)   
 [Технические примечания по категории](../mfc/technical-notes-by-category.md)

