---
title: "Доступ ко всем членам коллекции | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "MFC, коллекции"
  - "перечисления [MFC]"
  - "перечисление коллекций"
  - "коллекции, доступ"
  - "классы коллекций, доступ к членам"
  - "массивы [C++], итерация"
  - "итерация, коллекции"
  - "доступ к членам, коллекции"
  - "итерации коллекции списков"
  - "классы коллекций MFC, доступ к членам"
  - "коллекции, циклический перебор"
  - "циклические структуры, циклический перебор элементов в коллекции"
ms.assetid: 7bbae518-062e-4393-81f9-b22abd2e5f59
caps.latest.revision: 10
caps.handback.revision: 6
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Доступ ко всем членам коллекции
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Для доступа к своим элементам классы коллекций массивов MFC \(как шаблонные, так и нешаблонные\) используют индексы. Для описания в заданной позиции в коллекции классы коллекций списков и схем MFC \(как шаблонные, так и нешаблонные\) используют индикатор типа **POSITION**. Чтобы получить доступ к одному или нескольким членам этих коллекций, сначала следует инициализировать индикатор позиции, а затем повторно передавать эту позицию в коллекцию с запросом на возврат следующего элемента. Коллекция не отвечает за поддержание сведений о состоянии хода выполнения итерации. Эта информация хранится в индикаторе позиции. Однако, принимая во внимание конкретную позицию, коллекция отвечает за возврат следующего элемента.  
  
 В приведенных далее процедурах показана итерация в трех основных типах коллекций в MFC.  
  
-   [Итерация массива](#_core_to_iterate_an_array)  
  
-   [Итерация списка](#_core_to_iterate_a_list)  
  
-   [Итерация схемы](#_core_to_iterate_a_map)  
  
### Итерация массива  
  
1.  Используйте последовательные номера индекса с функцией\-членом `GetAt`.  
  
     [!code-cpp[NVC_MFCCollections#12](../mfc/codesnippet/CPP/accessing-all-members-of-a-collection_1.cpp)]  
  
     В этом примере используется массив типизированных указателей, который содержит указатели на объекты `CPerson`. Массив является производным от класса `CObArray`, одного из нешаблонных предопределенных классов.`CPerson` возвращает указатель на объект `GetAt`. Для классов коллекций типизированных указателей \(массивов или списков\) первый параметр указывает базовый класс, второй параметр указывает тип для хранения.  
  
     Класс `CTypedPtrArray` также перегружает оператор **\[ \]**, поэтому для доступа к элементам массива можно использовать обычный синтаксис индекса массива. Альтернативой инструкции в теле приведенного выше цикла `for` является  
  
     [!code-cpp[NVC_MFCCollections#13](../mfc/codesnippet/CPP/accessing-all-members-of-a-collection_2.cpp)]  
  
     Этот оператор существует как в **константной**, так и в не**константной** версиях.**Константная** версия, которая вызывается для **константных** массивов, может отображаться только в правой части оператора присваивания.  
  
### Итерация списка  
  
1.  Для прохода по списку используйте функции\-члены `GetHeadPosition` и `GetNext`:  
  
     [!code-cpp[NVC_MFCCollections#14](../mfc/codesnippet/CPP/accessing-all-members-of-a-collection_3.cpp)]  
  
     В этом примере используется список типизированных указателей, который содержит указатели на объекты `CPerson`. Объявление списка напоминает объявление для массива в процедуре [Итерация массива](#_core_to_iterate_an_array), но является производным от класса `CObList`.`CPerson` возвращает указатель на объект `GetNext`.  
  
### Итерация схемы  
  
1.  Используйте `GetStartPosition` для перехода в начало схемы и `GetNextAssoc` для повторного получения следующего ключа и значения из схемы, как показано в следующем примере.  
  
     [!code-cpp[NVC_MFCCollections#15](../mfc/codesnippet/CPP/accessing-all-members-of-a-collection_4.cpp)]  
  
     В этом примере применяется шаблон простой схемы \(а не коллекция типизированных указателей\), использующий ключи `CString` и сохраняющий указатели на объекты `CPerson`. При использовании функций доступа, таких как `GetNextAssoc`, класс предоставляет указатели на объекты `CPerson`. При использовании одной из коллекций нешаблонных схем необходимо привести возвращенный указатель `CObject` к указателю на `CPerson`.  
  
    > [!NOTE]
    >  При работе с нешаблонными схемами компилятору требуется ссылка на указатель `CObject` в последнем параметре на `GetNextAssoc`. При воде данных необходимо привести указатели к этому типу, как показано в следующем примере.  
  
     Шаблонное решение проще в использовании и помогает обеспечить более высокий уровень безопасности типов. Как видно из примера ниже, нешаблонный код более сложен.  
  
     [!code-cpp[NVC_MFCCollections#16](../mfc/codesnippet/CPP/accessing-all-members-of-a-collection_5.cpp)]  
  
 Дополнительные сведения см. в разделе [Удаление всех объектов из коллекции CObject](../Topic/Deleting%20All%20Objects%20in%20a%20CObject%20Collection.md).  
  
## См. также  
 [Коллекции](../mfc/collections.md)