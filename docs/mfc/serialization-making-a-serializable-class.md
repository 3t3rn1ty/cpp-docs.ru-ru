---
title: "Сериализация. Создание сериализуемого класса | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "классы [C++], производные"
  - "CObject - класс, наследование сериализуемых классов"
  - "конструкторы [C++], определение без аргументов"
  - "DECLARE_SERIAL - макрос"
  - "конструктор по умолчанию"
  - "по умолчанию [C++], конструктор"
  - "IMPLEMENT_SERIAL - макрос"
  - "без конструктора по умолчанию"
  - "конструктор без аргументов"
  - "сериализуемый класс"
  - "сериализация [C++], сериализуемые классы"
  - "Serialize - метод, переопределение"
  - "VERSIONABLE_SCHEMA - макрос"
ms.assetid: 59a14d32-1cc8-4275-9829-99639beee27c
caps.latest.revision: 10
caps.handback.revision: 6
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Сериализация. Создание сериализуемого класса
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Требуется сделать 5 основных шагов сериализуемый класс.  Они перечислены ниже и пояснения см. в следующих разделах:  
  
1.  [Производный класс от CObject](#_core_deriving_your_class_from_cobject) \(или из определенного класса, производного от `CObject`\).  
  
2.  [Переопределить функцию\-член сериализации](#_core_overriding_the_serialize_member_function).  
  
3.  [Использование макроса DECLARE\_SERIAL](#_core_using_the_declare_serial_macro) в объявлении класса.  
  
4.  [Определение конструктор, который не принимает аргументов](#_core_defining_a_constructor_with_no_arguments).  
  
5.  [Использование макроса IMPLEMENT\_SERIAL в файле реализации](#_core_using_the_implement_serial_macro_in_the_implementation_file) для класса.  
  
 При вызове `Serialize` напрямую, а не через \>\> и \<\< операторы [CArchive](../mfc/reference/carchive-class.md), то последние 3 шагов необходимы для сериализации.  
  
##  <a name="_core_deriving_your_class_from_cobject"></a> Производный класс от CObject  
 Базовые протокола и функция сериализации определяется в классе `CObject`.  Создавая производный класс из `CObject` \(или из производного класса из `CObject`\), как показано в следующем объявлении класса `CPerson`, можно получить доступ к протоколу сериализации и функции `CObject`.  
  
##  <a name="_core_overriding_the_serialize_member_function"></a> Переопределить функцию\-член сериализации  
 Функция\-член `Serialize`, определенный в классе `CObject`, отвечает за фактическое сериализовать данные, необходимые захватывал текущее состояние объекта.  Функция `Serialize` имеет аргумент `CArchive`, используются для чтения и записи данных объекта.  Объект [CArchive](../mfc/reference/carchive-class.md) содержит функцию\-член, `IsStoring`, означающая, сохраняет ли `Serialize` \(запись данных\) или загрузить \(считывание данных\).  Использование результатов `IsStoring` руководством необходимо или вставке данных выбранного объекта в объект `CArchive` с помощью оператора вставки \(**\<\<**\) или извлечь данные с помощью оператора извлечения \(**\>\>**\).  
  
 Рассмотрим класс, производный от `CObject` и содержит 2 новых переменной\-члена, типов `CString` и **word**.  В следующем фрагменте объявления классов отображает новые переменные\-члены класса и объявления для переопределенного функции\-члена `Serialize`:  
  
 [!code-cpp[NVC_MFCSerialization#1](../mfc/codesnippet/CPP/serialization-making-a-serializable-class_1.h)]  
  
#### Переопределить функцию\-член сериализации  
  
1.  Вызовите версии базового класса `Serialize`, чтобы убедиться, что издана сериализации, частью объекта.  
  
2.  Вставьте или извлечь переменные\-члены, относящиеся к классу.  
  
     Вставка и операторы извлечения взаимодействуют с классом архива для чтения и записи данных.  В следующем примере показана реализация `Serialize` для класса `CPerson` объявленного выше:  
  
     [!code-cpp[NVC_MFCSerialization#2](../mfc/codesnippet/CPP/serialization-making-a-serializable-class_2.cpp)]  
  
 Можно также использовать функции\-члены [CArchive::Read](../Topic/CArchive::Read.md) и [CArchive::Write](../Topic/CArchive::Write.md) для чтения и записи нетипизированный больших объемов данных.  
  
##  <a name="_core_using_the_declare_serial_macro"></a> Использование макроса DECLARE\_SERIAL  
 Макрос `DECLARE_SERIAL` используется в объявлении классов, поддерживали сериализации, как показано ниже:  
  
 [!code-cpp[NVC_MFCSerialization#3](../mfc/codesnippet/CPP/serialization-making-a-serializable-class_3.h)]  
  
##  <a name="_core_defining_a_constructor_with_no_arguments"></a> Определение конструктор без аргументов  
 MFC требуется конструктор по умолчанию, когда он повторно создает объекты по мере их выполнения \(загружается с диска\).  В процессе десериализации заполняет все переменные\-члены со значениями, необходимые воссоздал объект.  
  
 Этот конструктор может быть объявленной публикой, защищенный, либо закрытым.  Если вы делаете это защищенное или частное, позволяет убедиться, что он будет использоваться только функциями сериализации.  Конструктор должен поместить объект в состояние, которое позволяет его, для удаления при необходимости.  
  
> [!NOTE]
>  Если вы хотите сделать определить конструктор без аргументов в классе, использующий макросы `DECLARE_SERIAL` и `IMPLEMENT_SERIAL` будет получено «\- конструктора по умолчанию на» предупреждение компилятора линии, макрос `IMPLEMENT_SERIAL` используется.  
  
##  <a name="_core_using_the_implement_serial_macro_in_the_implementation_file"></a> Использование макроса IMPLEMENT\_SERIAL в файле реализации  
 Макрос `IMPLEMENT_SERIAL` используется для определения различных функций требуется при наследовании сериализуемый класс из `CObject`.  Используется макрос в файле реализации \(CPP\) для класса.  Первые 2 аргумента макросу имя класса и имя его непосредственного базового класса.  
  
 Третий аргумент в этот макрос номер схемы.  Номер схемы — номер версии для объектов класса.  Использование целого числа больше или приравнивайте значение 0 для номера схемы. \(Не путайте этот номер схемы с терминологией базы данных\).  
  
 Этот код сериализации MFC номер схемы при чтении объекты в память.  Если число схемы объекта на диске не соответствует номеру схемы классов в памяти, библиотека создает `CArchiveException`, предотвращая программы из считывания неверную версию объекта.  
  
 Если требуется, чтобы функции\-члена `Serialize` возможность считывать несколько версий, т е файлы, написанные с разными версиями приложения — можно использовать значение **VERSIONABLE\_SCHEMA** в качестве аргумента макроса `IMPLEMENT_SERIAL`.  Для данных потребления и пример см. в описании функции\-члена `GetObjectSchema` класса `CArchive`.  
  
 В следующем примере показано, как использовать `IMPLEMENT_SERIAL` для класса, `CPerson`, наследующий от `CObject`:  
  
 [!code-cpp[NVC_MFCSerialization#4](../mfc/codesnippet/CPP/serialization-making-a-serializable-class_4.cpp)]  
  
 Как только получен сериализуемый класс можно выполнять сериализацию объектов класса, описанное в статье [Сериализация: Сериализации объекта](../Topic/Serialization:%20Serializing%20an%20Object.md).  
  
## См. также  
 [Сериализация](../Topic/Serialization%20in%20MFC.md)