---
title: "TN042. Рекомендации по драйверу ODBC для разработчиков | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "vc.odbc"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "базы данных [C++], ODBC"
  - "драйверы ODBC [C++], написание"
  - "TN042"
ms.assetid: ecc6b5d9-f480-4582-9e22-8309fe561dad
caps.latest.revision: 10
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 6
---
# TN042. Рекомендации по драйверу ODBC для разработчиков
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

> [!NOTE]
>  Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию.  В результате некоторые процедуры и разделы могут быть устаревшими или неверными.  Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.  
  
 Эта заметка описывает правила для модулей записи драйвера ODBC.  Она которых общие требования и функции предполагается, что классы ODBC MFC, так и различных ожидаемого смысловых сведения.  Описывается требуемой функциональности драйвера для поддержки режима 3 `CRecordset` открытых \(**forwardOnly**, **снимок** и **dynaset**\).  
  
## Библиотека курсоров ODBC  
 Классы MFC представляют функциональные возможности пользователя, во многих случаях, превышает функциональные возможности, предоставляемые большинство драйверами ODBC уровня 1.  Удачно, библиотека курсоров ODBC будет уровень сам между классами базы данных и драйвером и автоматически выбирает многие из этой дополнительные функции.  
  
 Например, большинство драйверов 1.0 не поддерживают отсталую прокрутки.  Библиотека курсоров может обнаружить это и кэширование строк из драйверов и представляет их запросе на вызовах FETCH\_PREV в **SQLExtendedFetch**.  
  
 Также важно пример зависимости библиотеки курсоров позиционированные обновления.  Большинство драйверов 1.0 также не имеют позиционированные обновления, но библиотека курсоров создаст выписки обновления, определяющие строку целевого объекта в источнике данных, на основе его текущих значений кэшированных данных или кэшированную значение отметки времени.  
  
 Библиотека классов никогда не использует несколько наборов строк.  Поэтому несколько выписки **SQLSetPos** всегда применяются к строке 1 набора строк.  
  
## CDatabases  
 Каждое `CDatabase` выделяет один **HDBC**. \(Если функция `CDatabase``ExecuteSQL` используется, **HSTMT** временно выделено\). Поэтому, если множественное entity\_CDatabase необходимо, несколько объектов **HDBC** на **HENV**, должны поддерживать.  
  
 Классы базы данных требуют курсоров.  Это будет отображаться в вызове **SQL\_ODBC\_CURSORSSQLSetConnections**, **SQL\_CUR\_USE\_ODBC**.  
  
 **SQLDriverConnect**, **SQL\_DRIVER\_COMPLETE** используется `CDatabase::Open` для установления подключения к источнику данных.  
  
 Драйвер должен поддерживать \= **SQLGetInfo SQL\_ODBC\_API\_CONFORMANCE** \>**SQL\_OAC\_LEVEL1SQLGetInfo**,**SQL\_ODBC\_SQL\_CONFORMANCE** \>\= **SQL\_OSC\_MINIMUM**.  
  
 Для создания транзакции поддержку для `CDatabase` и его зависимых наборов записей **SQLGetInfo**,**SQL\_CURSOR\_COMMIT\_BEHAVIOR** и **SQL\_CURSOR\_ROLLBACK\_BEHAVIOR** должны иметь **SQL\_CR\_PRESERVE**.  В противном случае будут пропущены попытки запуска элемента управления транзакции.  
  
 **SQLGetInfo SQL\_DATA\_SOURCE\_READ\_ONLY** должен поддерживать.  Если возвращается значение «Y», никакие операции обновления не выполняются в источнике данных.  
  
 Если `CDatabase` открыт только для чтения, то попытка задать источник данных только для чтения будет заполнена с **SQLSetConnectOption SQL\_ACCESS\_MODE**, **SQL\_MODE\_READ\_ONLY**.  
  
 Если требуются все значения идентификаторов, эти сведения должны быть возвращены от драйвера с помощью вызова функции **SQLGetInfo SQL\_IDENTIFIER\_QUOTE\_CHAR**.  
  
 Для отладки и **SQLGetInfo SQL\_DBMS\_VERSQL\_DBMS\_NAME** извлекаются из драйвера.  
  
 **SQLSetStmtOption SQL\_QUERY\_TIMEOUT** и **SQL\_ASYNC\_ENABLE** могут быть вызваны в `CDatabase`**HDBC**.  
  
 **SQLError** может быть вызван со всеми аргументами NULL.  
  
 Конечно, **SQLAllocEnv**, **SQLAllocConnect**, **SQLDisconnect** и **SQLFreeConnect**, должны поддерживать.  
  
## ExecuteSQL  
 Помимо выделение и освобождение временное `ExecuteSQL` вызывает **HSTMT**, **SQLExecDirect**, **SQLFetch**, **SQLNumResultCol** и `SQLMoreResults`.  **SQLCancel** может быть вызван на **HSTMT**.  
  
## GetDatabaseName  
 **SQLGetInfo SQL\_DATABASE\_NAME** будет иметь имя.  
  
## BeginTrans, CommitTrans, откат  
 Будут вызваны **SQLSetConnectOption SQL\_AUTOCOMMITSQLTransact** и **SQL\_COMMIT**, **SQL\_ROLLBACK** и **SQL\_AUTOCOMMIT**, если запросы выполняются транзакции.  
  
## CRecordsets  
 **SQLAllocStmt**, **SQLPrepare**, **SQLExecute** \(для **Открыть** и **Requery**\), **SQLExecDirect** \(для операций обновления\), **SQLFreeStmt** должен поддерживать.  **SQLNumResultCols** и **SQLDescribeCol** будут вызваны с результатами, заданного в различные моменты времени.  
  
 **SQLSetParam** широко используется для привязки данных параметры и функции **DATA\_AT\_EXEC**.  
  
 **SQLBindCol** широко используется для регистрации расположения хранилища данных выходного столбца с ODBC.  
  
 2 Вызова **SQLGetData** используются, чтобы получить данные **SQL\_LONG\_VARCHAR** и **SQL\_LONG\_VARBINARY**.  Пытается найти первого вызова общая длина столбца значение путем вызова функции **SQLGetData** с cbMaxValue 0, но с допустимым pcbValue.  Если pcbValue содержит **SQL\_NO\_TOTAL**, создается исключение.  В противном случае `HGLOBAL` выбран, и другой **SQLGetData** вызывается для извлечения весь результат.  
  
## Updating  
 Если пессимистическая запрашивается блокировка, **SQLGetInfo SQL\_LOCK\_TYPES** будет запрошенного.  Если функция **SQL\_LCK\_EXCLUSIVE** не поддерживается, то возникнет исключение.  
  
 Попытки обновления `CRecordset` \(**снимок** или **dynaset**\) вызовут секунду **HSTMT**, выбранным.  Для драйверов не поддерживающих второе **HSTMT**, библиотека курсоров сымитирует эту функцию.  К сожалению, иногда это может означать применить текущий запрос на первом **HSTMT** до полного завершения перед их второй запрос **HSTMT**.  
  
 **SQLFreeStmt SQL\_CLOSESQL\_RESET\_PARAMS** и **SQLGetCursorName** будут вызваны во время операции обновления.  
  
 Если **CLongBinarys** в **outputColumns**, то функции ODBC **DATA\_AT\_EXEC** должен поддерживать.  Это позволяет возвращать **SQL\_NEED\_DATA** из **SQLExecDirect**, **SQLParamData** и **SQLPutData**.  
  
 Метод **SQLRowCount** вызывается после выполнения, чтобы убедиться, что только 1 запись была обновлена **SQLExecDirect**.  
  
## Курсоры последовательного доступа  
 **SQLFetch** Только необходимые для операций **Переместить**.  Обратите внимание, что **forwardOnly** курсоры не поддерживают обновления.  
  
## Курсоры моментального снимка  
 Функция снимка требует поддержки **SQLExtendedFetch**.  Как указано выше, библиотека курсоров ODBC обнаруживает, когда драйвер не поддерживает **SQLExtendedFetch**, и предоставляет необходимую поддержку самостоятельно.  
  
 **SQLGetInfo**, **SQL\_SCROLL\_OPTIONS** должен поддерживать **SQL\_SO\_STATIC**.  
  
## Курсоры динамических подмножеств  
 Ниже минимальная поддержка, необходимые открытый динамические подмножества.  
  
 **SQLGetInfo**, **SQL\_ODBC\_VER** должно возвращать \> «01».  
  
 **SQLGetInfo**, **SQL\_SCROLL\_OPTIONS** должен поддерживать **SQL\_SO\_KEYSET\_DRIVEN**.  
  
 **SQLGetInfo**, **SQL\_ROW\_UPDATES** должно возвращать «Y».  
  
 **SQLGetInfo**, **SQL\_POSITIONED\_UPDATES** должен поддерживать **SQL\_PS\_POSITIONED\_DELETE** и **SQL\_PS\_POSITIONED\_UPDATE**.  
  
 Кроме того, если пессимистическая блокировка запрос, будет сделан вызов irow **SQLSetPos** с 1, fRefresh ЛОЖНОЕ и стадо **SQL\_LCK\_EXCLUSIVE**.  
  
## См. также  
 [Технические примечания по номеру](../mfc/technical-notes-by-number.md)   
 [Технические примечания по категории](../mfc/technical-notes-by-category.md)