---
title: "TN031. Панели элементов управления | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "vc.controls.bars"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "панели элементов управления, стили"
  - "класс CStatusBar, использование технического примечания 31"
  - "класс CControlBar, использование технического примечания 31"
  - "класс CControlBar, производный от"
  - "панели элементов управления, классы"
  - "класс CDialogBar, использование технического примечания 31"
  - "класс CToolBar, использование технического примечания 31"
  - "TN031"
  - "стили, панели элементов управления"
ms.assetid: 8cb895c0-40ea-40ef-90ee-1dd29f34cfd1
caps.latest.revision: 11
caps.handback.revision: 7
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# TN031. Панели элементов управления
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

> [!NOTE]
>  Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.  
  
 В этом примечании содержатся сведения о классах панели элементов управления в MFC: [CControlBar](#_mfcnotes_ccontrolbar), [CStatusBar](#_mfcnotes_cstatusbar), [CToolBar](#_mfcnotes_ctoolbar), [CDialogBar](#_mfcnotes_cdialogbar) и **CDockBar**.  
  
 `CControlBar`  
  
 **ControlBar** — это производный от `CWnd` класс, который:  
  
-   выравнивается по верхней или нижней части окна фрейма;  
  
-   может содержать дочерние элементы, которые являются элементами управления на основе HWND \(например, `CDialogBar`\) или элементами, не основанными на `HWND` \(например, `CToolBar`, `CStatusBar`\).  
  
 Панели элементов управления поддерживают дополнительные стили:  
  
-   `CBRS_TOP` \(по умолчанию\) закрепление панели элементов управления в верхней части;  
  
-   `CBRS_BOTTOM` закрепление панели элементов управления в нижней части;  
  
-   `CBRS_NOALIGN` сохранение положения панели элементов управления при изменении размера родительского элемента.  
  
 Классы, производные от `CControlBar`, предоставляют более интересные реализации:  
  
-   `CStatusBar` строка состояния, элементы являются панелями строки состояния, содержащими текст;  
  
-   `CToolBar` панель инструментов, элементы являются выровненными в строку кнопками с точечными рисунками;  
  
-   `CDialogBar` фрейм в виде панели инструментов, содержащий стандартные элементы управления Windows \(созданные из ресурса шаблона диалоговых окон\);  
  
-   **CDockBar** обобщенная область закрепления для других производных объектов `CControlBar`. Определенные функции\-члены и переменные, доступные в этом классе, могут измениться в будущих версиях.  
  
 Все объекты и окна панели элементов управления будут дочерними по отношению к некоторым родительским окнам фреймов. Обычно они добавляются в клиентскую область фрейма \(например, клиент MDI или представление\) как элементы одного уровня. Важное значение имеет идентификатор дочернего окна панели элементов управления. Макет панели элементов управления по умолчанию применяется только для панелей элементов управления с идентификаторами в диапазоне от **AFX\_IDW\_CONTROLBAR\_FIRST** до **AFX\_IDW\_CONTROLBAR\_LAST**. Обратите внимание, что, несмотря на существование 256 идентификаторов, особыми являются только первые 32 из них, поскольку они напрямую поддерживаются архитектурой предварительного просмотра.  
  
 Класс `CControlBar` предоставляет стандартную реализацию для выполнения следующих задач:  
  
-   выравнивание панели элементов управления по верхней, нижней или любой стороне фрейма;  
  
-   выделение массивов элементов управления;  
  
-   поддержка реализации производных классов.  
  
 Обычно объекты панели элементов управления C\+\+ встраиваются как члены производного класса `CFrameWnd` и удаляются при уничтожении родительского элемента `HWND` и объекта. Если требуется выделить объект панели управления в куче, можно задать для члена **m\_bAutoDestruct** значение **TRUE**, чтобы панель элементов управления выполняла действие **delete this** при удалении `HWND`.  
  
> [!NOTE]
>  При создании собственного класса, производного от `CControlBar`, а не использовании одного из производных классов MFC, такого как `CStatusBar`, `CToolBar` или `CDialogBar`, потребуется задать элемент данных `m_dwStyle`. Это можно сделать в переопределении **Create**:  
  
```  
// CMyControlBar is derived from CControlBar  
BOOL CMyControlBar::Create( CWnd* pParentWnd, DWORD dwStyle, UINT nID )  
{  
   m_dwStyle = dwStyle;  
  
   .  
   .  
   .  
}  
```  
  
 **Алгоритм макета панели элементов управления**  
  
 Алгоритм макета панели управления очень прост. Окно фрейма отправляет сообщение **WM\_SIZEPARENT** всем дочерним элементам в диапазоне панели элементов управления. Вместе с этим сообщением передается указатель на клиентскую область родительского окна. Это сообщение отправляется дочерним элементам в Z\-порядке. Дочерние элементы панели элементов управления используют эту информацию для определения своих положений и уменьшения размера клиентской области родительского окна. Конечная область, которая остается для обычной клиентской области \(меньше панелей элементов управления\), используется для размещения основного окна клиента \(обычно это окно клиента MDI, представления или разделителя\).  
  
 Дополнительные сведения см. в разделах `CWnd::RepositionBars` и `CFrameWnd::RecalcLayout`.  
  
 Закрытые сообщения MFC Windows, включая **WM\_SIZEPARENT**, описаны в [техническом примечании 24](../mfc/tn024-mfc-defined-messages-and-resources.md).  
  
 `CStatusBar`  
  
 Строка состояния представляет собой панель элементов управления со строкой панелей вывода текста. Существует два основных способа использования панелей вывода текста.  
  
-   В качестве строки сообщения  
  
     \(Например, строка сообщения стандартного меню "Справка".\) Как правило, для доступа используется отсчитываемый от нуля индекс.  
  
-   В качестве индикаторов состояния  
  
     \(Например, индикаторы CAP, NUM и SCRL.\) Как правило, для доступа используется идентификатор строки или команды.  
  
 В качестве шрифта строки состояния используется 10\-точечный MS Sans Serif \(согласно руководству по созданию приложений с интерфейсом Windows или программе отображения шрифта лучше всего соответствует 10\-точечный пропорциональный шрифт Swiss\). В некоторых версиях Windows, например для японского языка, применяются другие шрифты.  
  
 Цвета, используемые в строке состояния, также соответствуют рекомендациям в руководстве по созданию приложений с интерфейсом Windows. Эти цвета не являются фиксированными и динамически изменяются согласно пользовательским настройкам на панели управления.  
  
|Элемент|Значение COLOR Windows|RGB по умолчанию|  
|-------------|----------------------------|----------------------|  
|Фон строки состояния|**COLOR\_BTNFACE**|RGB\(192, 192, 192\)|  
|Текст строки состояния|**COLOR\_BTNTEXT**|RGB\(000, 000, 000\)|  
|Верхняя или левая границы строки состояния|**COLOR\_BTNHIGHLIGHT**|RGB\(255, 255, 255\)|  
|Нижняя или правая границы строки состояния|**COLOR\_BTNSHADOW**|RGB\(128, 128, 128\)|  
  
 **Поддержка CCmdUI для CStatusBar**  
  
 Для обновления индикаторов обычно используется механизм `ON_UPDATE_COMMAND_UI`. Во время бездействия строка состояния вызывает обработчик `ON_UPDATE_COMMAND_UI` со строковым идентификатором панели индикаторов.  
  
 Обработчик `ON_UPDATE_COMMAND_UI` может вызвать следующие функции.  
  
-   **Enable**: для включения и отключения панели. Отключенная панель выглядит так же, как включенная, но текст невидим \(то есть отключен индикатор текста\).  
  
-   **SetText**: для изменения текста. Будьте внимательны при использовании этой функции, так как размер панели не меняется автоматически.  
  
 Подробные сведения об API создания и настройки `CStatusBar` см. в описании класса [CStatusBar](../mfc/reference/cstatusbar-class.md) в *справочнике по библиотеке классов*. Большая часть настроек строк состояния должна быть выполнена до их первоначального отображения.  
  
 Строка состояния поддерживает только одну панель растягивания, обычно первую. Размер этой панели фактически является минимальным размером. Если размер строки состояния превышает минимальный размер всех панелей, панели растягивания будет задано дополнительное значение ширины. В приложении по умолчанию со строкой состояния индикаторы для CAP, NUM и SCRL выровнены по правому краю, так как первая панель может растягиваться.  
  
 `CToolBar`  
  
 Панель инструментов представляет собой панель элементов управления со строкой кнопок с точечными рисунками, которые могут содержать разделители. Поддерживаются два стиля кнопок: нажимаемые кнопки и кнопки с флажками. Функция группы переключателей может быть реализована с помощью флажков и `ON_UPDATE_COMMAND_UI`.  
  
 Все кнопки с точечными рисунками на панели инструментов создаются из одного точечного рисунка. Этот рисунок должен содержать одно изображение или глиф для каждой кнопки. Как правило, порядок изображений или глифов в точечном рисунке совпадает с порядком их отображения на экране. \(Его можно изменить с помощью API\-интерфейсов настройки.\)  
  
 Все кнопки должны быть одинакового размера. Размером по умолчанию является стандарт в 24x22 пикселя. Все изображения или глифы должны иметь одинаковый размер и располагаться на точечном рисунке рядом друг с другом. Размер образа и глифов по умолчанию — 16x15 пикселей. Таким образом, для панели инструментов с 10 кнопками \(имеющими стандартные размеры\) потребуется точеный рисунок 160 пикселей в ширину и 15 пикселей в высоту.  
  
 Каждая кнопка имеет только одно изображение или глиф. Разные состояния и стили кнопок \(например, нажата, отключена, включена, нажата и недоступна, не определена\) создаются алгоритмически из этого одного изображения или глифа. Теоретически можно использовать любой цветной точечный рисунок или DIB. Алгоритм создания разных состояний кнопки работает лучше всего, если исходное изображение состоит из оттенков серого. Примеры стандартных кнопок панели инструментов и картинки кнопки панели инструментов см. в примере [CLIPART](../top/visual-cpp-samples.md) MFC.  
  
 Цвета, используемые на панели инструментов, также соответствуют рекомендациям в руководстве по созданию приложений с интерфейсом Windows. Эти цвета не являются фиксированными и динамически изменяются согласно пользовательским настройкам на панели управления.  
  
|Элемент|Значение COLOR Windows|RGB по умолчанию|  
|-------------|----------------------------|----------------------|  
|Фон панели инструментов|**COLOR\_BTNFACE**|RGB\(192,192,192\)|  
|Верхняя и левая границы кнопок панели инструментов|**COLOR\_BTNHIGHLIGHT**|RGB\(255,255,255\)|  
|Нижняя и правая границы кнопок панели инструментов|**COLOR\_BTNSHADOW**|RGB\(128,128,128\)|  
  
 Кроме того, цвет кнопок с точечными рисунками панели инструментов изменен так, как если бы они были стандартными элементами управления кнопок Windows. Изменение цвета происходит при загрузке точечного рисунка из ресурса и в ответ на изменение системных цветов согласно пользовательским настройкам на панели управления. Следующие цвета на точечном рисунке панели инструментов будут изменены автоматически, поэтому их следует использовать с осторожностью. Если вы не хотите изменять цвет части точечного рисунка, используйте цвет, наиболее точно соответствующий сопоставленным значениям RGB. Сопоставление выполняется на основе точных значений RGB.  
  
|Значение RGB|Динамически сопоставленное значение COLOR|  
|------------------|-----------------------------------------------|  
|RGB\(000, 000, 000\)|COLOR\_BTNTEXT|  
|RGB\(128, 128, 128\)|COLOR\_BTNSHADOW|  
|RGB\(192, 192, 192\)|COLOR\_BTNFACE|  
|RGB\(255, 255, 255\)|COLOR\_BTNHIGHLIGHT|  
  
 Подробные сведения об API создания и настройки `CToolBar` см. в описании класса [CToolBar](../mfc/reference/ctoolbar-class.md) в *справочнике по библиотеке классов*. Большая часть настроек панелей инструментов должна быть выполнена до их первоначального отображения.  
  
 API настройки можно использовать для корректировки идентификаторов, стилей, ширины кнопок и выбора изображений или глифов для конкретных кнопок. По умолчанию эти API не требуются.  
  
## Поддержка CCmdUI для CToolBar  
 Обновление кнопок панели инструментов всегда происходит с помощью механизма `ON_UPDATE_COMMAND_UI`. Во время бездействия панель инструментов вызывает обработчик `ON_UPDATE_COMMAND_UI` идентификатором команды этой кнопки.`ON_UPDATE_COMMAND_UI` не вызывается для разделителей, но вызывается для кнопок и флажков.  
  
 Обработчик `ON_UPDATE_COMMAND_UI` может вызвать следующие функции.  
  
-   **Enable**: для включения и отключения кнопки. Она действует одинаково для кнопок и флажков.  
  
-   `SetCheck`: для задания проверки состояния кнопки. При вызове этой функции для кнопки панели инструментов кнопка будет преобразована во флажок.`SetCheck` принимает параметр, который может быть равен 0 \(не установлен\), 1 \(установлен\) или 2 \(не определен\).  
  
-   `SetRadio`: сокращение для `SetCheck`.  
  
 Флажки являются автоматическими, то есть при их установке они сразу же изменяют состояние. Установка — это отпущенное или отключенное состояние. Встроенный в пользовательский интерфейс способ перевода кнопки в неопределенное состояние отсутствует. Для этого нужно написать код.  
  
 API\-интерфейсы настройки позволяют изменять состояние нужной кнопки панели инструментов. Предпочтительным вариантом является изменение этих состояний в обработчике `ON_UPDATE_COMMAND_UI` для команды, которую представляет кнопка панели инструментов. Помните, что обработка бездействия приводит к изменению состояния кнопок панели инструментов с обработчиком `ON_UPDATE_COMMAND_UI`, поэтому любые изменения этих состояний посредством SetButtonStyle могут быть потеряны после следующего периода бездействия.  
  
 Кнопки панели инструментов отправляют сообщения **WM\_COMMAND** как обычные кнопки или пункты меню и обычно обрабатываются с помощью обработчика `ON_COMMAND` в том же классе, который предоставляет обработчик `ON_UPDATE_COMMAND_UI`.  
  
 Существует четыре стиля кнопок панели инструментов \(TBBS\_ \<значения\>\), используемых для отображения состояний.  
  
-   TBBS\_CHECKED: флажок установлен \(нажат\).  
  
-   TBBS\_INDETERMINATE: флажок не определен.  
  
-   TBBS\_DISABLED: кнопка отключена.  
  
-   TBBS\_PRESSED: кнопка нажата.  
  
 Следующие значения TBBS представляют шесть официальных стилей кнопок согласно руководству по созданию приложений с интерфейсом Windows.  
  
-   Кнопка доступна — 0  
  
-   Кнопка мыши нажата — TBBS\_PRESSED \(&#124; любой другой стиль\)  
  
-   Кнопка недоступна — TBBS\_DISABLED  
  
-   Кнопка нажата — TBBS\_CHECKED  
  
-   Кнопка нажата и недоступна — TBBS\_CHECKED &#124; TBBS\_DISABLED  
  
-   Неопределенное состояние кнопки — TBBS\_INDETERMINATE  
  
##  <a name="_mfcnotes_cdialogbar"></a> CDialogBar  
 Диалоговая панель — это панель элементов управления со стандартными элементами управления Windows. Она функционирует аналогично диалоговому окну в том, что она содержит элементы управления и поддерживает переходы между ними. Она также действует как диалоговое окно в том, что для представления панели она использует шаблон диалогового окна.  
  
 `CDialogBar` используется для панели инструментов предварительного просмотра, содержащей стандартные элементы управления кнопок.  
  
 Использование `CDialogBar` аналогично `CFormView`. Необходимо определить шаблон диалогового окна для диалоговой панели и удалить все стили, кроме **WS\_CHILD**. Обратите внимание, что диалоговое окно не должно отображаться.  
  
 Уведомления элементов управления для `CDialogBar` отправляются родительскому элементу панели элементов \(как кнопки панели инструментов\).  
  
## Поддержка CCmdUI для CDialogBar  
 Кнопки диалоговой панели должны обновляться с помощью механизма обработчика `ON_UPDATE_COMMAND_UI`. Во время бездействия диалоговая панель вызывает обработчик `ON_UPDATE_COMMAND_UI` с идентификатором команды всех кнопок с ИД, больше или равным 0x8000 \(то есть в диапазоне идентификаторов\).  
  
 Обработчик `ON_UPDATE_COMMAND_UI` может вызвать следующие функции.  
  
-   Enable: для включения и отключения кнопки.  
  
-   SetText: для изменения текста кнопки.  
  
 Для настройки можно использовать стандартные API\-интерфейсы диспетчера окон.  
  
## См. также  
 [Технические примечания по номеру](../mfc/technical-notes-by-number.md)   
 [Технические примечания по категории](../mfc/technical-notes-by-category.md)