---
title: "TN022: Реализация команды в стандарт | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords:
- vc.commands
dev_langs:
- C++
helpviewer_keywords:
- ID_PREV_PANE command [MFC]
- ID_APP_EXIT command [MFC]
- ID_NEXT_PANE command [MFC]
- ID_INDICATOR_REC command [MFC]
- ID_WINDOW_SPLIT command [MFC]
- ID_FILE_PRINT_PREVIEW command [MFC]
- ID_WINDOW_CASCADE command [MFC]
- ID_FILE_CLOSE command [MFC]
- ID_FILE_SAVE_COPY_AS command [MFC]
- ID_WINDOW_ARRANGE command [MFC]
- ID_EDIT_FIND command [MFC]
- ID_FILE_OPEN command [MFC]
- ID_FILE_PAGE_SETUP command [MFC]
- ID_OLE_VERB_FIRST command [MFC]
- ID_EDIT_UNDO command [MFC]
- ID_EDIT_CLEAR command [MFC]
- ID_INDICATOR_CAPS command [MFC]
- ID_HELP_INDEX command [MFC]
- commands [MFC], standard
- ID_FILE_PRINT_SETUP command [MFC]
- ID_DEFAULT_HELP command [MFC]
- ID_INDICATOR_SCRL command [MFC]
- ID_FILE_PRINT command [MFC]
- ID_INDICATOR_OVR command [MFC]
- ID_INDICATOR_KANA command [MFC]
- ID_EDIT_COPY command [MFC]
- ID_EDIT_REDO command [MFC]
- ID_EDIT_PASTE command [MFC]
- ID_OLE_INSERT_NEW command [MFC]
- ID_OLE_EDIT_LINKS command [MFC]
- ID_EDIT_PASTE_SPECIAL command [MFC]
- ID_INDICATOR_EXT command [MFC]
- ID_HELP_USING command [MFC]
- standard commands
- ID_VIEW_STATUS_BAR command [MFC]
- ID_FILE_SAVE_AS command [MFC]
- ID_EDIT_CLEAR_ALL command [MFC]
- ID_WINDOW_NEW command [MFC]
- ID_CONTEXT_HELP command [MFC]
- ID_EDIT_REPLACE command [MFC]
- ID_WINDOW_TILE_HORZ command [MFC]
- ID_APP_ABOUT command [MFC]
- TN022
- ID_VIEW_TOOLBAR command [MFC]
- ID_HELP command [MFC]
- ID_WINDOW_TILE_VERT command [MFC]
- ID_EDIT_CUT command [MFC]
- ID_FILE_UPDATE command [MFC]
- ID_EDIT_REPEAT command [MFC]
- ID_FILE_SAVE command [MFC]
- ID_EDIT_PASTE_LINK command [MFC]
- ID_EDIT_SELECT_ALL command [MFC]
- ID_FILE_NEW command [MFC]
- ID_INDICATOR_NUM command
ms.assetid: a7883b46-23f7-4870-ac3a-804aed9258b5
caps.latest.revision: 
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: 05e5e927ebfcb1584913d6415349c473bde4463c
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="tn022-standard-commands-implementation"></a>TN022. Реализация стандартных команд
> [!NOTE]
>  Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.  
  
 Эта заметка описывает стандартную команду, реализованных в MFC 2.0. Чтение [Технические заметки 21](../mfc/tn021-command-and-message-routing.md) первого, так как он описывает механизмы, используемые для реализации многих стандартных команд.  
  
 Это описание предполагает знаний архитектурах, API-интерфейсы и распространенная практика программирования MFC. Документированные, а также недокументированные» только реализации», описываются API-интерфейсы. Это не место для начала изучения функции или как программировать в MFC. Общие сведения и подробности документированные API-интерфейсов см Visual C++.  
  
## <a name="the-problem"></a>Проблема  
 MFC определяет многие стандартные идентификаторы команд в файле заголовка AFXRES. З. Поддержка Framework этих команд зависит от. Понимание того, где и как классы framework обрабатывать эти команды не только покажу, как работает внутри платформы, но позволяют получить полезную информацию о том, как настроить стандартные реализации и изучаются несколько методов для реализации собственные обработчики команд.  
  
## <a name="contents-of-this-technical-note"></a>Содержимое этого техническое Примечание  
 В двух разделах описан каждый идентификатор команды:  
  
-   Заголовок: символическое имя идентификатора команды (например, **ID_FILE_SAVE**) следуют назначение команды (например, «сохранение текущего документа»), разделенных точкой с запятой.  
  
-   Один или несколько абзацев, описывающий классов, которые реализуют команду и реализация по умолчанию не  
  
 Большинство реализаций команды по умолчанию являются prewired в схеме сообщений framework базового класса. Существуют некоторые реализации команды, которым требуется явное, написанного в производном классе. Они описаны в разделе «Примечания». Если выбрана правой параметры в мастере приложений, эти обработчики по умолчанию будет подключен автоматически созданного каркас приложения.  
  
## <a name="naming-convention"></a>Соглашение об именовании  
 Стандартные команды выполните простой соглашение об именовании, мы рекомендуем по возможности используйте. Большинство стандартных команд, находятся в стандартных мест в строке меню приложения. Символическое имя команды начинается с «ID_», за которым следует имя стандартного всплывающих меню, за которым следует имя элемента меню. Символическое имя — в верхнем регистре с разрывы слов подчеркивания. Для команды, которые не имеют имен элемента меню «Стандартная», определяется имя логического команды начиная с «ID_» (например, **ID_NEXT_PANE**).  
  
 Мы используем префикс «ID_» для указания команды, которые предназначены для привязываться к пунктов меню, кнопки панели инструментов или других объектов пользовательского интерфейса команд. Обработчики команд, обработка команд «ID_» следует использовать `ON_COMMAND` и `ON_UPDATE_COMMAND_UI` механизмы MFC команды архитектуры.  
  
 Мы рекомендуем использовать стандартного префикса «IDM_» для пунктов меню, не выполните команду архитектуры, требуется код для включения и отключения их меню. Конечно количество определенных команд меню должен быть небольшой, так как следующая команда архитектуры MFC не только делает более мощных обработчики команд (поскольку они будут работать с панелью инструментов), но делает код обработчика команд для повторного использования.  
  
## <a name="id-ranges"></a>Диапазоны Идентификаторов  
 Обратитесь к [техническое Примечание 20](../mfc/tn020-id-naming-and-numbering-conventions.md) Дополнительные сведения об использовании диапазоны Идентификаторов в MFC.  
  
 Стандартные команды MFC, попадают в диапазон 0xE000 для 0xEFFF. Пожалуйста не следует полагаться на конкретные значения этих идентификаторов, так как они могут измениться в будущих версиях библиотеки.  
  
 Приложение должно определить команд в диапазоне от 0x8000 до 0xDFFF.  
  
## <a name="standard-command-ids"></a>Стандартные идентификаторы команд  
 Для каждого идентификатора команды нет стандартных сообщений запроса строки, можно найти в файле ЗАПРОСАХ. ВЕРСИЯ-КАНДИДАТ. Идентификатор строки для этой строки меню должно быть так же, как идентификатор команды.  
  
-   ID_FILE_NEW создается новый и пустой документ.  
  
    > [!NOTE]
    >  Необходимо подключить этот параметр, чтобы ваш `CWinApp`-производного класса схему сообщений, чтобы включить эту функцию.  
  
     `CWinApp::OnFileNew`реализует этой команды по-разному в зависимости от количества шаблонов документов в приложении. Если имеется только один `CDocTemplate`, `CWinApp::OnFileNew` создаст новый документ этого типа, а также соответствующий класс фрейма и представления.  
  
     Если имеется более одного `CDocTemplate`, `CWinApp::OnFileNew` запросит у пользователя с помощью диалогового окна (**AFX_IDD_NEWTYPEDLG**). Однако Выбор используемого типа документа. Выбранный `CDocTemplate` используется для создания документа.  
  
     Одной из частых настроек из `ID_FILE_NEW` — предоставить другой и графический широкий выбор типов документов. В этом случае можно реализовать собственный **CMyApp::OnFileNew** и поместите его на карте сообщения вместо `CWinApp::OnFileNew`. Нет необходимости для вызова реализации базового класса.  
  
     Еще одним вариантом Общие настройки из `ID_FILE_NEW` для предоставления отдельную команду для создания каждого типа документа. В этом случае необходимо определить новые идентификаторы команд, например ID_FILE_NEW_CHART и ID_FILE_NEW_SHEET.  
  
-   ID_FILE_OPEN открывает существующий документ.  
  
    > [!NOTE]
    >  Необходимо подключить этот параметр, чтобы ваш `CWinApp`-производного класса схему сообщений, чтобы включить эту функцию.  
  
     `CWinApp::OnFileOpen`имеет очень простая реализация вызова **CWinApp::DoPromptFileName** следуют `CWinApp::OpenDocumentFile` с именем файла, чтобы открыть файл или путь. `CWinApp` Реализацию подпрограмма **DoPromptFileName** появится стандартное диалоговое окно FileOpen и заполняет его расширения имен файлов, полученные из текущего шаблонов документов.  
  
     Одной из частых настроек из `ID_FILE_OPEN` является настройка FileOpen диалогового окна или добавление дополнительного файла фильтры. Для настройки этого рекомендуется заменить реализация по умолчанию собственные FileOpen диалоговое окно и вызова `CWinApp::OpenDocumentFile` с именем файла или пути документа. Нет необходимости вызывать базовый класс.  
  
-   ID_FILE_CLOSE закрывает текущий документ.  
  
     **CDocument::OnFileClose** вызовы `CDocument::SaveModified` чтобы предложить пользователю сохранить документ в том случае, если он был изменен, а затем вызывает `OnCloseDocument`. Закрытие логику, включая удаления самого документа выполняется в `OnCloseDocument` подпрограммы.  
  
    > [!NOTE]
    >  **ID_FILE_CLOSE** работает иначе из `WM_CLOSE` сообщения или **SC_CLOSE** системы команды, отправленной в фрейме окна документов. Закрытие окна приведет к закрытию документа, только в том случае, если это последний фрейм окна, отображаются в документе. Закрытие документа с **ID_FILE_CLOSE** только не закроет документ, но завершает работу всех фреймов, показывающая документа.  
  
-   ID_FILE_SAVE Сохранение текущего документа.  
  
     Реализация использует вспомогательная подпрограмма **CDocument::DoSave** используемым как для **OnFileSave** и **OnFileSaveAs**. При сохранении документа, не была сохранена ранее (то есть, он не имеет имени пути в случае FileNew) или считанный из документа только для чтения, **OnFileSave** будет играть роль логику **ID_FILE_SAVE_AS** команды и попросите пользователя, укажите новое имя файла. Фактический процесс открытия файла и сохранение это делается с помощью виртуальной функции `OnSaveDocument`.  
  
     Существуют две распространенные причины для настройки **ID_FILE_SAVE**. Для документов, не сохранять, просто удалите **ID_FILE_SAVE** пункты меню и кнопки панели инструментов из интерфейса пользователя. Также убедитесь, что никогда не измененные документа (то есть, никогда не вызывают `CDocument::SetModifiedFlag`) и платформу никогда не вызывает сохраняемый документ. Для документов, куда-нибудь сохранить файл на диске определите новую команду для этой операции.  
  
     В случае использования `COleServerDoc`, **ID_FILE_SAVE** используется для сохранения файла (для обычных документов) и обновление файла (для внедренных документов).  
  
     Если документ данные хранятся в отдельные файлы, но вы не хотите использовать значение по умолчанию **CDocument** сериализации реализацию, должны переопределять `CDocument::OnSaveDocument` вместо **OnFileSave**.  
  
-   ID_FILE_SAVE_AS сохраняет текущий документ в файле с другим именем.  
  
     **CDocument::OnFileSaveAs** реализация использует тот же самый **CDocument::DoSave** вспомогательная подпрограмма как **OnFileSave**. **OnFileSaveAs** команда обрабатывается так же, как **ID_FILE_SAVE** Если имя файла не до сохранения документов. **COleServerDoc::OnFileSaveAs** реализует логику для сохранения файла данных обычный документ или сохранить серверный документ, представляющий объект OLE, внедренных в другом приложении в отдельном файле.  
  
     Если вы настраиваете логику **ID_FILE_SAVE**, может потребоваться настроить **ID_FILE_SAVE_AS** в точно так же или операцию «Сохранить как» не может применяться к документу. Можно удалить элемент меню из строки меню, если оно не требуется.  
  
-   ID_FILE_SAVE_COPY_AS сохраняет копию текущего документа под новым именем.  
  
     **COleServerDoc::OnFileSaveCopyAs** реализации очень похож на **CDocument::OnFileSaveAs**, за исключением того, что объект документа «присоединен» в базовый файл после сохранения. То есть если документа в памяти» изменена» до сохранения, он по-прежнему» изменяется». Кроме того, это команда не оказывает влияния на имя пути или заголовок, хранящийся в документе.  
  
-   ID_FILE_UPDATE уведомляет контейнера для сохранения внедренного документа.  
  
     `COleServerDoc::OnUpdateDocument` Реализация notifiies просто контейнер, в котором следует сохранить внедрение. Контейнер вызывает соответствующие API-интерфейсы OLE для сохранения внедренного объекта.  
  
-   ID_FILE_PAGE_SETUP вызывает диалоговое окно установки/макета страницы конкретного приложения.  
  
     В настоящее время отсутствует стандарт для этого диалога и платформу, у которого нет реализации по умолчанию этой команды.  
  
     Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.  
  
-   ID_FILE_PRINT_SETUP вызова стандартное диалоговое окно Параметры печати.  
  
    > [!NOTE]
    >  Необходимо подключить этот параметр, чтобы ваш `CWinApp`-производного класса схему сообщений, чтобы включить эту функцию.  
  
     Эта команда вызывает диалоговом окне стандартные настройки печати, которое позволяет пользователю настроить принтер и параметры печати для по крайней мере в этом документе или максимум на все документы в этом приложении. Чтобы изменить настройки принтера по умолчанию для всей системы, необходимо использовать панель управления.  
  
     `CWinApp::OnFilePrintSetup`имеет очень простая реализация создание `CPrintDialog` объекта и вызывая метод **CWinApp::DoPrintDialog** реализацию функции. Таким образом задается принтера и параметров приложения.  
  
     Требуется настройка этой команды является предоставление для параметры принтера на уровне документа, которые должны храниться вместе с документом при сохранении. Для этого следует добавить обработчик схемы сообщений в вашей **CDocument** класс, который создает `CPrintDialog` объекта, инициализирует его с атрибутами принтера (обычно **hDevMode** и **hDevNames**), вызовите **CPrintDialog::DoModal,** и сохранить измененные принтера. Для реализации надежной, следует обратить внимание на реализацию **CWinApp::DoPrintDialog** для обнаружения ошибок и **CWinApp::UpdatePrinterSelection** для задействования допустимых значений по умолчанию и Отслеживание изменений принтера во всей системе.  
  
-   Стандартная ID_FILE_PRINT Печать текущего документа  
  
    > [!NOTE]
    >  Необходимо подключить этот параметр, чтобы ваш `CView`-производного класса схему сообщений, чтобы включить эту функцию.  
  
     Эта команда выводит текущий документ или более правильно запускает процесс печати, которая включает в себя вызов стандартное диалоговое окно печати и запуска печати механизма.  
  
     **CView::OnFilePrint** реализует эту команду и основной цикл печати. Он вызывает виртуальный `CView::OnPreparePrinting` запрос пользователя с помощью диалогового окна печати. Затем он подготавливает выходные данные контроллера домена для перехода к принтеру, появится диалоговое окно печати хода выполнения (**AFX_IDD_PRINTDLG**) и отправляет `StartDoc` escape на принтер. **CView::OnFilePrint** также содержит основной цикл печати печати. Для каждой страницы вызывает виртуальный `CView::OnPrepareDC` следуют `StartPage` escape и вызов виртуальной `CView::OnPrint` для данной страницы. По завершении, виртуальный `CView::OnEndPrinting` вызывается, и закрывается диалоговое окно печати хода выполнения.  
  
     Архитектура печати MFC позволяет подключить различными способами, для печати и предварительного просмотра. Вы найдете обычно различных `CView` переопределяемые функции подходит для работы с любой печати задания печати. Только в случае приложение, использующее принтера для невыгружаемый ориентированного выходных данных, следует найти необходимость замены **ID_FILE_PRINT** реализации.  
  
-   Введите ID_FILE_PRINT_PREVIEW режим предварительного просмотра перед печатью для текущего документа.  
  
    > [!NOTE]
    >  Необходимо подключить этот параметр, чтобы ваш `CView`-производного класса схему сообщений, чтобы включить эту функцию.  
  
     **CView::OnFilePrintPreview** запускается режим предварительного просмотра путем вызова документированные вспомогательной функции **CView::DoPrintPreview**. **CView::DoPrintPreview** является основным механизмом для предварительного просмотра печати цикла, так же как и **OnFilePrint** является основным механизмом для печати цикла.  
  
     Режим предварительного просмотра операции можно настраивать различными способами, передавая различные параметры для **DoPrintPreview**. Обратитесь к [Технические заметки 30](../mfc/tn030-customizing-printing-and-print-preview.md), обсуждаются некоторые детали предварительного просмотра печати и способ его настройки.  
  
-   **ID_FILE_MRU_FILE1**... **FILE16** диапазона идентификаторов команд для Открытие документа `list`.  
  
     **CWinApp::OnUpdateRecentFileMenu** является обработчик пользовательского интерфейса команды update, который является одним из дополнительных областей применения `ON_UPDATE_COMMAND_UI` механизм. В ресурсе меню, только необходимо определить отдельный элемент меню с Идентификатором **ID_FILE_MRU_FILE1**. Этот элемент меню изначально отключены.  
  
     Как MRU список растет дополнительные меню, элементы добавляются в список. Стандартные `CWinApp` реализацию по умолчанию используется стандартная ограничение в четыре последних использовавшихся файлов. Значение по умолчанию можно изменить с помощью `CWinApp::LoadStdProfileSettings` со значением больше или меньше. Список последних выбиравшихся файлов хранится в приложения. INI-файл. Загрузить список в вашем приложении `InitInstance` работать при вызове метода `LoadStdProfileSettings`и сохраняется при завершении работы приложения. Обработчик MRU команды обновления пользовательского интерфейса также преобразует абсолютные пути для относительных путей для отображения в меню «файл».  
  
     **CWinApp::OnOpenRecentFile** — `ON_COMMAND` обработчик, который выполняет фактическое команды. Просто получает имя файла из списка последних выбиравшихся файлов и вызовы `CWinApp::OpenDocumentFile`, который выполняет всю работу при открытии файла и обновлять список последних выбиравшихся файлов.  
  
     Настройки этого обработчика команды не рекомендуется.  
  
-   ID_EDIT_CLEAR отменяет текущее выделение  
  
     В настоящее время отсутствует Стандартная реализация для этой команды. Это должен быть реализован для каждого `CView`-производного класса.  
  
     `CEditView`предоставляет реализацию этой команды с помощью `CEdit::Clear`. Команда будет отключен, если нет текущего выделенного фрагмента.  
  
     Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.  
  
-   ID_EDIT_CLEAR_ALL очищает весь документ.  
  
     В настоящее время отсутствует Стандартная реализация для этой команды. Это должен быть реализован для каждого `CView`-производного класса.  
  
     Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды. См. в образце MFC учебника [SCRIBBLE](../visual-cpp-samples.md) пример внедрения.  
  
-   ID_EDIT_COPY копирует текущее выделение в буфер обмена.  
  
     В настоящее время отсутствует Стандартная реализация для этой команды. Это должен быть реализован для каждого `CView`-производного класса.  
  
     `CEditView`предоставляет реализацию этой команды, которая копирует выделенный текст в буфер обмена, как с помощью CF_TEXT `CEdit::Copy`. Команда будет отключен, если нет текущего выделенного фрагмента.  
  
     Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.  
  
-   ID_EDIT_CUT Вырезать текущее выделение в буфер обмена.  
  
     В настоящее время отсутствует Стандартная реализация для этой команды. Это должен быть реализован для каждого `CView`-производного класса.  
  
     `CEditView`предоставляет реализацию этой команды, которая вырезает выделенный текст в буфер обмена, как с помощью CF_TEXT `CEdit::Cut`. Команда будет отключен, если нет текущего выделенного фрагмента.  
  
     Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.  
  
-   ID_EDIT_FIND начинается операция поиска, появится диалоговое окно поиска без режима.  
  
     В настоящее время отсутствует Стандартная реализация для этой команды. Это должен быть реализован для каждого `CView`-производного класса.  
  
     `CEditView`предоставляет реализацию этой команды, которая вызывает вспомогательную функцию реализацию **OnEditFindReplace** и сохранить предыдущие параметры поиска и замены в закрытой реализации переменных. `CFindReplaceDialog` Класс используется для управления немодального диалогового окна для запроса пользователя.  
  
     Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.  
  
-   ID_EDIT_PASTE вставляет текущее содержимое буфера обмена.  
  
     В настоящее время отсутствует Стандартная реализация для этой команды. Это должен быть реализован для каждого `CView`-производного класса.  
  
     `CEditView`предоставляет реализацию этой команды, которая копирует текущие данные буфера обмена, Замена выделенного текста с использованием `CEdit::Paste`. Команда будет отключен, если имеется не **CF_TEXT** в буфере обмена.  
  
     **COleClientDoc** просто предоставляет обработчик пользовательского интерфейса команды обновления для этой команды. Если буфер обмена не содержит встраиваемая элемента или объекта OLE, команда будет отключена. Вы несете ответственность за создание обработчика для фактического команду, чтобы выполнить фактическую вставку. Если OLE приложения также можно вставить в другие форматы, следует предоставить собственный обработчик пользовательского интерфейса обновления команды в представлении или документа (то есть, где-нибудь перед **COleClientDoc** в целевой маршрутизация команд).  
  
     Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.  
  
     Для замены стандартную реализацию OLE, используйте `COleClientItem::CanPaste`.  
  
-   ID_EDIT_PASTE_LINK Вставка ссылки на текущее содержимое буфера обмена.  
  
     В настоящее время отсутствует Стандартная реализация для этой команды. Это должен быть реализован для каждого `CView`-производного класса.  
  
     `COleDocument`просто предоставляет обработчик пользовательского интерфейса команды обновления для этой команды. Если буфер обмена не содержит ссылок на основе элемента или объекта OLE, команда будет отключена. Вы несете ответственность за создание обработчика для фактического команду, чтобы выполнить фактическую вставку. Если OLE приложения также можно вставить в другие форматы, следует предоставить собственный обработчик пользовательского интерфейса обновления команды в представлении или документа (то есть, где-нибудь перед `COleDocument` в целевой маршрутизация команд).  
  
     Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.  
  
     Для замены стандартную реализацию OLE, используйте `COleClientItem::CanPasteLink`.  
  
-   ID_EDIT_PASTE_SPECIAL вставляет текущее содержимое буфера обмена с параметрами.  
  
     В настоящее время отсутствует Стандартная реализация для этой команды. Это должен быть реализован для каждого `CView`-производного класса. MFC предоставляет это диалоговое окно.  
  
     Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.  
  
-   ID_EDIT_REPEAT повторяет последнюю операцию.  
  
     В настоящее время отсутствует Стандартная реализация для этой команды. Это должен быть реализован для каждого `CView`-производного класса.  
  
     `CEditView`предоставляет реализацию этой команды повторите последнюю операцию поиска. Используются переменные закрытой реализации для поиска. Команда будет отключен, если удалось выполнить операцию поиска.  
  
     Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.  
  
-   ID_EDIT_REPLACE начинается операция замены, появится диалоговое окно без режима замены.  
  
     В настоящее время отсутствует Стандартная реализация для этой команды. Это должен быть реализован для каждого `CView`-производного класса.  
  
     `CEditView`предоставляет реализацию этой команды, которая вызывает вспомогательную функцию реализацию **OnEditFindReplace** и сохранить предыдущие параметры поиска и замены в закрытой реализации переменных. `CFindReplaceDialog` Класс используется для управления немодального диалогового окна, которое запрашивает у пользователя.  
  
     Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.  
  
-   ID_EDIT_SELECT_ALL выделяет весь документ.  
  
     В настоящее время отсутствует Стандартная реализация для этой команды. Это должен быть реализован для каждого `CView`-производного класса.  
  
     `CEditView`предоставляет реализацию этой команды, которая выделяет весь текст в документе. Команда будет отключен, если нет текста для выбора.  
  
     Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.  
  
-   ID_EDIT_UNDO отменяет последнюю операцию.  
  
     В настоящее время отсутствует Стандартная реализация для этой команды. Это должен быть реализован для каждого `CView`-производного класса.  
  
     `CEditView`предоставляет реализацию этого с помощью `CEdit::Undo`. Команда будет отключен, если `CEdit::CanUndo` возвращает значение FALSE.  
  
     Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.  
  
-   ID_EDIT_REDO Повтор последней операции.  
  
     В настоящее время отсутствует Стандартная реализация для этой команды. Это должен быть реализован для каждого `CView`-производного класса.  
  
     Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.  
  
-   ID_WINDOW_NEW Открытие другого окна для активного документа.  
  
     **CMDIFrameWnd::OnWindowNew** реализует это эффективное средство, с помощью шаблона документа текущего документа для создания другой кадр, содержащий другое представление текущего документа.  
  
     Как и большинство нескольких документов интерфейса (MDI) окно команд меню команда будет отключен, если нет active дочерние окна MDI.  
  
     Настройки этого обработчика команды не рекомендуется. Необходимо указать команду, которая создает дополнительные представления и окна фрейма, возможно, лучше изобретать собственные команды. Можно клонировать код из **CMDIFrameWnd::OnWindowNew** и измените его на определенных кадров и представление классов желанию.  
  
-   ID_WINDOW_ARRANGE упорядочивает значки в нижней части окна MDI.  
  
     `CMDIFrameWnd`реализует это стандартная команда MDI в реализации вспомогательную функцию **OnMDIWindowCmd**. Этот вспомогательный сопоставляет идентификаторы команд MDI-окна сообщения и поэтому можно совместно большого объема кода.  
  
     Как и большинство команд меню MDI-окна команда будет отключен, если нет active дочерние окна MDI.  
  
     Настройки этого обработчика команды не рекомендуется.  
  
-   Каскадные ID_WINDOW_CASCADE windows, поэтому они перекрываются.  
  
     `CMDIFrameWnd`реализует это стандартная команда MDI в реализации вспомогательную функцию **OnMDIWindowCmd**. Этот вспомогательный сопоставляет идентификаторы команд MDI-окна сообщения и поэтому можно совместно большого объема кода.  
  
     Как и большинство команд меню MDI-окна команда будет отключен, если нет active дочерние окна MDI.  
  
     Настройки этого обработчика команды не рекомендуется.  
  
-   ID_WINDOW_TILE_HORZ плитки windows по горизонтали.  
  
     Эта команда реализована в `CMDIFrameWnd` так же, как **ID_WINDOW_CASCADE**, но используются разные MDI-окна сообщения для операции.  
  
     Направление по умолчанию плитки должны быть выбраны для вашего приложения. Это можно сделать, изменив их либо код для данного элемента меню окна «Плитку» **ID_WINDOW_TILE_HORZ** или **ID_WINDOW_TILE_VERT**.  
  
-   ID_WINDOW_TILE_VERT плитки windows по вертикали.  
  
     Эта команда реализована в `CMDIFrameWnd` так же, как **ID_WINDOW_CASCADE**, но используются разные MDI-окна сообщения для операции.  
  
     Направление по умолчанию плитки должны быть выбраны для вашего приложения. Это можно сделать, изменив их либо код для данного элемента меню окна «Плитку» **ID_WINDOW_TILE_HORZ** или **ID_WINDOW_TILE_VERT**.  
  
-   Интерфейс клавиатуры ID_WINDOW_SPLIT разделителем.  
  
     `CView`обрабатывает эту команду для `CSplitterWnd` реализации. Если представление является частью окна-разделителя, эта команда будут делегировать реализацию функции `CSplitterWnd::DoKeyboardSplit`. Это будет помещать разделителя в режим, который позволит пользователям клавиатуры разделить или отменить Разделение окна-разделителя.  
  
     Эта команда недоступна, если представление не разделителя.  
  
     Настройки этого обработчика команды не рекомендуется.  
  
-   ID_APP_ABOUT вызывает диалоговое окно «о программе».  
  
     Отсутствует реализация стандартные приложения об поля. Приложение, созданное мастером приложений по умолчанию будет создать класс настраиваемое диалоговое окно для приложения и использовать его в качестве приставкой об. Мастер приложений будет также создан обработчик тривиальные команда обрабатывает эту команду, и вызов диалогового окна.  
  
     Эта команда, почти всегда будет реализовать.  
  
-   ID_APP_EXIT работу приложения.  
  
     **CWinApp::OnAppExit** обрабатывает эту команду, отправляя `WM_CLOSE` сообщения для главного окна приложения. Standard, завершение работы приложения (запрос «грязных» файлов и т. д) обрабатывается `CFrameWnd` реализации.  
  
     Настройки этого обработчика команды не рекомендуется. Переопределение `CWinApp::SaveAllModified` или `CFrameWnd` логики закрытия, рекомендуется.  
  
     Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.  
  
-   ID_HELP_INDEX перечислены справки разделов. Файл HLP.  
  
    > [!NOTE]
    >  Необходимо подключить этот параметр, чтобы ваш `CWinApp`-производного класса схему сообщений, чтобы включить эту функцию.  
  
     `CWinApp::OnHelpIndex`обрабатывает эту команду, просто вызвав `CWinApp::WinHelp`.  
  
     Настройки этого обработчика команды не рекомендуется.  
  
-   ID_HELP_USING Вывод справочных сведений о том, как использовать справку.  
  
    > [!NOTE]
    >  Необходимо подключить этот параметр, чтобы ваш `CWinApp`-производного класса схему сообщений, чтобы включить эту функцию.  
  
     `CWinApp::OnHelpUsing`обрабатывает эту команду, просто вызвав `CWinApp::WinHelp`.  
  
     Настройки этого обработчика команды не рекомендуется.  
  
-   Режим справки F1-ID_CONTEXT_HELP вводит SHIFT.  
  
    > [!NOTE]
    >  Необходимо подключить этот параметр, чтобы ваш `CWinApp`-производного класса схему сообщений, чтобы включить эту функцию.  
  
     `CWinApp::OnContextHelp`Эта команда обрабатывает, устанавливает курсор режим справки, введя модального цикла и ожидание пользователю выбрать окно, чтобы получить справку по. Обратитесь к [Технические заметки 28](../mfc/tn028-context-sensitive-help-support.md) Дополнительные сведения о реализации MFC справки.  
  
     Настройки этого обработчика команды не рекомендуется.  
  
-   Предоставляет ID_HELP справки в текущем контексте  
  
    > [!NOTE]
    >  Необходимо подключить этот параметр, чтобы ваш `CWinApp`-производного класса схему сообщений, чтобы включить эту функцию.  
  
     `CWinApp::OnHelp`Эта команда обрабатывает, получении контекста справку для текущего контекста приложения. Обрабатывает простой Справка F1, получить справку в окнах сообщений и т. д. Обратитесь к [Технические заметки 28](../mfc/tn028-context-sensitive-help-support.md) Дополнительные сведения о MFC помощи реализации.  
  
     Настройки этого обработчика команды не рекомендуется.  
  
-   ID_DEFAULT_HELP отображает справку по умолчанию для контекста  
  
    > [!NOTE]
    >  Необходимо подключить этот параметр, чтобы ваш `CWinApp`-производного класса схему сообщений, чтобы включить эту функцию.  
  
     Эта команда обычно сопоставляется с `CWinApp::OnHelpIndex`.  
  
     Обработчик различные команды могут быть предоставлены при желании различие между справки по умолчанию и указателя справки.  
  
-   ID_NEXT_PANE переходит к следующей панели  
  
     `CView`обрабатывает эту команду для `CSplitterWnd` реализации. Если представление является частью окна-разделителя, эта команда будут делегировать реализацию функции **CSplitterWnd::OnNextPaneCmd**. Активное представление будет перенесена в следующую область в разделителя.  
  
     Эта команда недоступна, если представление не разделителя или не следующей панели, чтобы перейти к.  
  
     Настройки этого обработчика команды не рекомендуется.  
  
-   ID_PREV_PANE переходит к предыдущей области  
  
     `CView`обрабатывает эту команду для `CSplitterWnd` реализации. Если представление является частью окна-разделителя, эта команда будут делегировать реализацию функции **CSplitterWnd::OnNextPaneCmd**. Активное представление будет перенесена в предыдущую область в разделителя.  
  
     Эта команда недоступна, если представление не разделителя или нет предыдущей области, чтобы перейти к.  
  
     Настройки этого обработчика команды не рекомендуется.  
  
-   ID_OLE_INSERT_NEW вставляет новый объект OLE  
  
     В настоящее время отсутствует Стандартная реализация для этой команды. Необходимо реализовать для вашего `CView`-производный класс для вставки нового элемента OLE-объекта в текущее выделение.  
  
     Все клиентские приложения OLE, должны применять эту команду. Мастер приложений, с параметром OLE создаст схему реализации **OnInsertObject** в классе представления, которые необходимо выполнить.  
  
     См. Образец MFC OLE [OCLIENT](../visual-cpp-samples.md) примере полную реализацию этой команды.  
  
-   ID_OLE_EDIT_LINKS изменяет OLE ссылки  
  
     `COleDocument`Эта команда обрабатывает с помощью MFC реализация стандартное диалоговое окно ссылок OLE. Реализация этого диалогового окна осуществляется с помощью `COleLinksDialog` класса. Если текущий документ не содержит ни одной связи, команда отключена.  
  
     Настройки этого обработчика команды не рекомендуется.  
  
-   ID_OLE_VERB_FIRST... Последний диапазон Идентификаторов для команды OLE  
  
     `COleDocument`использует этот диапазон Идентификаторов команд для команды, поддерживаемые выбранного элемента OLE-объекта. Это должно быть диапазоном, поскольку данного типа элемента или объекта OLE может поддерживать пользовательские команды ноль или более. В меню приложения должны иметь один элемент меню с Идентификатором **ID_OLE_VERB_FIRST**. При запуске программы, меню будет обновляться описание команд меню, соответствующие (или всплывающего меню со многих команд). Управление меню OLE обрабатывается `AfxOleSetEditMenu`, выполняются в обработчик пользовательского интерфейса команды обновления для этой команды.  
  
     Существуют обработчики нет явной команды для обработки каждого идентификатора команды в этом диапазоне. **COleDocument::OnCmdMsg** переопределяется для перехвата всех идентификаторов команд в этом диапазоне, включить их в числа (с нуля) команды и запустить сервер для этой команды (с помощью `COleClientItem::DoVerb`).  
  
     Не рекомендуется настройки или используют этот диапазон Идентификаторов команд для других целей.  
  
-   ID_VIEW_TOOLBAR включает панель инструментов и выключает  
  
     `CFrameWnd`обрабатывает эту команду и обработчик пользовательского интерфейса команды update, чтобы переключать состояние отображается на панели инструментов. Панели инструментов должен быть дочерним окном кадра с Идентификатором дочернего окна `AFX_IDW_TOOLBAR`. Обработчик команд фактически переключает видимость окна инструментов. `CFrameWnd::RecalcLayout`используется для перерисовки фрейм окна с помощью панели инструментов в его нового состояния. Обработчик пользовательского интерфейса команды update проверяет элемент меню, панели инструментов отображается, когда.  
  
     Настройки этого обработчика команды не рекомендуется. Если вы хотите добавить дополнительные панели инструментов, необходимо клонировать и изменить обработчик команд и обработчик пользовательского интерфейса команды update для этой команды.  
  
-   ID_VIEW_STATUS_BAR включает строку состояния и выключает  
  
     Эта команда реализована в `CFrameWnd` так же, как **ID_VIEW_TOOLBAR**, за исключением идентификатор различных дочернего окна (**AFX_IDW_STATUS_BAR**) используется.  
  
## <a name="update-only-command-handlers"></a>Обработчики команд только для обновления  
 Некоторые стандартные идентификаторы команд, используются в качестве индикаторов в строке состояния. Эти с одними команды обновления пользовательского интерфейса, механизм обработки для отображения их текущее состояние visual во время простоя приложения. Так как они не могут быть выбраны пользователем (то есть невозможно принудительно отправить панели строки состояния), то нет смысла иметь `ON_COMMAND` обработчик для этих идентификаторов команд.  
  
-   **ID_INDICATOR_CAPS** : индикатор КОНЦА блокировки.  
  
-   **ID_INDICATOR_NUM** : индикатор NUM lock.  
  
-   **ID_INDICATOR_SCRL** : SCRL индикатор блокировки.  
  
-   **ID_INDICATOR_KANA** : Индикатор блокировки КАНЫ (применимо только к системам на японском языке).  
  
 Все три реализованы в **CFrameWnd::OnUpdateKeyIndicator**, помощник реализации, который использует идентификатор команды для сопоставления соответствующих виртуальная клавиша. Общая Реализация включает или отключает (отключено панелях состояния = нет текста) `CCmdUI` объекта в зависимости от того, было ли соответствующие виртуальная клавиша заблокирован.  
  
 Настройки этого обработчика команды не рекомендуется.  
  
-   **ID_INDICATOR_EXT: EXT**завершается Выбор индикатора.  
  
-   **ID_INDICATOR_OVR: ЭТИМ**e**R**соблюсти индикатора.  
  
-   **ID_INDICATOR_REC: REC**ording индикатора.  
  
 В настоящее время отсутствует Стандартная реализация для этих индикаторов.  
  
 Если вы решили реализовать эти индикаторы, рекомендуется использовать эти идентификаторы индикатора и сохранению порядка индикаторы в строке состояния (то есть в следующем порядке: EXT CAP, NUM, SCRL, ЗАМ, REC).  
  
## <a name="see-also"></a>См. также  
 [Технические примечания по номеру](../mfc/technical-notes-by-number.md)   
 [Технические примечания по категории](../mfc/technical-notes-by-category.md)

