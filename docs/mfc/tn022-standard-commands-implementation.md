---
title: "TN022. Реализация стандартных команд | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "vc.commands"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "команды, стандартные"
  - "ID_APP_ABOUT - команда"
  - "ID_APP_EXIT - команда"
  - "ID_CONTEXT_HELP - команда"
  - "ID_DEFAULT_HELP - команда"
  - "ID_EDIT_CLEAR - команда"
  - "ID_EDIT_CLEAR_ALL - команда"
  - "ID_EDIT_COPY - команда"
  - "ID_EDIT_CUT - команда"
  - "ID_EDIT_FIND - команда"
  - "ID_EDIT_PASTE - команда"
  - "ID_EDIT_PASTE_LINK - команда"
  - "ID_EDIT_PASTE_SPECIAL - команда"
  - "ID_EDIT_REDO - команда"
  - "ID_EDIT_REPEAT - команда"
  - "ID_EDIT_REPLACE - команда"
  - "ID_EDIT_SELECT_ALL - команда"
  - "ID_EDIT_UNDO - команда"
  - "ID_FILE_CLOSE - команда"
  - "ID_FILE_NEW - команда"
  - "ID_FILE_OPEN - команда"
  - "ID_FILE_PAGE_SETUP - команда"
  - "ID_FILE_PRINT - команда"
  - "ID_FILE_PRINT_PREVIEW - команда"
  - "ID_FILE_PRINT_SETUP - команда"
  - "ID_FILE_SAVE - команда"
  - "ID_FILE_SAVE_AS - команда"
  - "ID_FILE_SAVE_COPY_AS - команда"
  - "ID_FILE_UPDATE - команда"
  - "ID_HELP - команда"
  - "ID_HELP_INDEX - команда"
  - "ID_HELP_USING - команда"
  - "ID_INDICATOR_CAPS - команда"
  - "ID_INDICATOR_EXT - команда"
  - "ID_INDICATOR_KANA - команда"
  - "ID_INDICATOR_NUM - команда"
  - "ID_INDICATOR_OVR - команда"
  - "ID_INDICATOR_REC - команда"
  - "ID_INDICATOR_SCRL - команда"
  - "ID_NEXT_PANE - команда"
  - "ID_OLE_EDIT_LINKS - команда"
  - "ID_OLE_INSERT_NEW - команда"
  - "ID_OLE_VERB_FIRST - команда"
  - "ID_PREV_PANE - команда"
  - "ID_VIEW_STATUS_BAR - команда"
  - "ID_VIEW_TOOLBAR - команда"
  - "ID_WINDOW_ARRANGE - команда"
  - "ID_WINDOW_CASCADE - команда"
  - "ID_WINDOW_NEW - команда"
  - "ID_WINDOW_SPLIT - команда"
  - "ID_WINDOW_TILE_HORZ - команда"
  - "ID_WINDOW_TILE_VERT - команда"
  - "стандартные команды"
  - "TN022"
ms.assetid: a7883b46-23f7-4870-ac3a-804aed9258b5
caps.latest.revision: 10
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 6
---
# TN022. Реализация стандартных команд
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

> [!NOTE]
>  Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию.  В результате некоторые процедуры и разделы могут быть устаревшими или неверными.  Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.  
  
 Эта заметка описание реализации стандартной команды предусмотренные MFC 2.0.  Ознакомьтесь с разделом [Техническое примечание 21](../mfc/tn021-command-and-message-routing.md), поскольку она описывает механизмы, используемые для реализации многих стандартных команд.  
  
 Описание принципов принимает архитектур MFC, API, и общего стиля программирования.  Описаны документированные, так и незадокументированные «API реализации только».  Это не места для запуска дополнительными сведениями о функциях или программировании на MFC.  В разделе Visual C\+\+ дополнительные общие сведения и дополнительные сведения, описанных API.  
  
## Проблема  
 MFC определяет множество стандартных идентификаторов команд в файле заголовка AFXRES.H.  Поддержка платформы .NET Framework для этих команд зависит.  Понимание места и способа классы платформы обрабатывают эти команды не только отображается, как платформа работает. но предоставит полезные сведения о том, как настраивать стандартные реализации и научить требуется несколько методов для реализации собственных обработчиков команд.  
  
## Содержимое этого технического примечания  
 Каждый идентификатор команды 2 см. в разделах:  
  
-   Заголовок: символическое имя идентификатор команды \(например, **ID\_FILE\_SAVE**\) с целью команды \(например, «сохраняет текущий документ»\) через двоеточие.  
  
-   Один или несколько абзацев, классы, реализующие команды, а реализация по умолчанию.  
  
 Большинство реализации команд по умолчанию prewired сообщений в схеме базового класса платформы.  Некоторые реализации команды, которые требуется явная написанного в производном классе.  Они описаны в разделе «заметкой».  Если выбран правильные параметры в AppWizard, эти обработчики по умолчанию будут подключены автоматически созданного выше приложении.  
  
## Соглашение об именовании  
 Стандартные команды используется простое соглашение об именах, рекомендуется использовать, если это возможно.  Наиболее стандартные команды расположены в стандартных местах в строке меню приложения.  Символическое имя начинается с «ID\_ команды», за которой следует стандартным именем контекстного меню, меню, за которым следует имя пункта меню.  Символическое имя в верхний случае с переносами слов подчеркивания.  Для команд, которые содержат стандартные имена пункта меню, логическое имя команды, начинающихся с «ID\_» \(например, **ID\_NEXT\_PANE**\).  
  
 Мы используем префикс «ID\_», чтобы указать команды, которые должны быть привязанным к пунктам меню, кнопки панели инструментов, или другие объекты пользовательского интерфейса команды.  Обработчиков команд обработки команды «ID\_» необходимо использовать механизмы `ON_COMMAND` и `ON_UPDATE_COMMAND_UI` архитектуры команды MFC.  
  
 Рекомендуется выполнять используется стандартный префикс «IDM\_» для пунктов меню, не соответствующие архитектура команды и не требуют код возврата для включения и отключения их.  Хотя номер меню определенные команды должны быть небольшими с момента применения архитектуры команды MFC не только в обработчиков команд более мощным \(поскольку они работали с инструментами\), но делает код обработчика команды повторно используемым.  
  
## Диапазоны идентификаторов  
 См. [Техническое примечание 20](../mfc/tn020-id-naming-and-numbering-conventions.md) более подробные сведения об использовании диапазонов идентификаторов в MFC.  
  
 Стандартные команды MFC находятся в диапазоне 0xE000 в 0xEFFF.  Рекомендуется не следует полагаться на определенных значений этих идентификаторов, поскольку они могут изменяться в будущих версиях библиотеки.  
  
 Приложение должно определить его команды в диапазоне 0x8000 в 0xDFFF.  
  
## Стандартных идентификаторов команд  
 Для каждого идентификатора команды строка запроса линии стандартного сообщения, можно найти в файле PROMPTS.RC.  Идентификатор строки меню для запроса должен быть таким же, как для идентификатора команды  
  
-   Создает новый ID\_FILE\_NEW\/пустого документа.  
  
    > [!NOTE]
    >  Необходимо подключить в `CWinApp`\- это схема сообщений производного класса, чтобы включить эту функцию.  
  
     `CWinApp::OnFileNew` реализует эту команду по\-разному в зависимости от количества шаблонов документов в приложении.  Если только один `CDocTemplate`, `CWinApp::OnFileNew` создает новый документ, типа, так и правильные кадр и класс представления.  
  
     Если более одного `CDocTemplate`, `CWinApp::OnFileNew` запрашивает у пользователя с диалоговое окно \(**AFX\_IDD\_NEWTYPEDLG**\), позволяя им выбор типа документа, который будет использоваться.  Объект `CDocTemplate` используется для создания документа.  
  
     Одной из распространенных настройки `ID_FILE_NEW` предоставить другой, более графический выбор типов документов.  В этом случае можно реализовать собственное **CMyApp::OnFileNew** и поместите его в схеме сообщений вместо `CWinApp::OnFileNew`.  Необходимость вызова реализации базового класса.  
  
     Другая общая настройки `ID_FILE_NEW` предоставить отдельную команду для создания документа каждого типа.  В этом случае необходимо определить новые идентификаторы команд, например ID\_FILE\_NEW\_CHART и ID\_FILE\_NEW\_SHEET.  
  
-   ID\_FILE\_OPEN открытия существующего документа.  
  
    > [!NOTE]
    >  Необходимо подключить в `CWinApp`\- это схема сообщений производного класса, чтобы включить эту функцию.  
  
     `CWinApp::OnFileOpen` имеет очень простую реализацию метода **CWinApp::DoPromptFileName** с `CWinApp::OpenDocumentFile` с файлом или путем открытия файла.  Реализация регулярная **DoPromptFileName**`CWinApp` перемещение вверх стандартное диалоговое окно FileOpen и заполняет его с расширений файлов, полученные из шаблонов текущего документа.  
  
     Одной из распространенных настройки `ID_FILE_OPEN` настраивать диалоговое окно FileOpen или добавить дополнительные фильтры файлов.  Рекомендуется настраивать это заменить реализацию по умолчанию с пользовательским диалоговым окном FileOpen и вызывает `CWinApp::OpenDocumentFile` с фаилом документа или путем.  Необходимость вызова базового класса.  
  
-   ID\_FILE\_CLOSE закроет открытые в данный момент документ.  
  
     **CDocument::OnFileClose** вызывает `CDocument::SaveModified` для запроса на ввод пользователем сохранить документ, если он был изменен, а затем вызывает метод `OnCloseDocument`.  Заключительная всю логику, включая удалить документ, выполняется в процедуре `OnCloseDocument`.  
  
    > [!NOTE]
    >  **ID\_FILE\_CLOSE** действует иначе, чем сообщением `WM_CLOSE` или группе системы **SC\_CLOSE** отправленными в фреймовому окно документов.  Закрыть окно закрывает документ только если последнее фреймовое окно, указывающее документ.  Закрыть документ с **ID\_FILE\_CLOSE** не только закрывает документ, но закрывает все фреймовые вниз окна, документ.  
  
-   ID\_FILE\_SAVE сохраняет текущий документ.  
  
     Реализация использует вспомогательную процедуру **CDocument::DoSave**, которая используется как для **OnFileSave**, так и для **OnFileSaveAs**.  Если сохранить документ, не сохраняет перед \(то есть он отсутствует путь, как в случае FileNew\), или прочитал из только для чтения документа, то логика **OnFileSave** будет использоваться как команда **ID\_FILE\_SAVE\_AS** и затем, что пользователь подал новое имя файла.  Фактический процесс открытия файла и создание сбережения выполняется через виртуальную функцию `OnSaveDocument`.  
  
     2 Распространенной причиной настраивать **ID\_FILE\_SAVE**.  Для документов не сохраняют, просто удалите пункты меню и кнопки панели инструментов **ID\_FILE\_SAVE** из интерфейса пользователя.  Кроме того, необходимо никогда пакостные документа \(т е никогда не вызывается `CDocument::SetModifiedFlag`\) и платформа никогда не будет вызывать документ сохранены.  Для документов сохраняются в в расположении, отличном от дискового файла укажите новую команду для этой операции.  
  
     В случае `COleServerDoc`, **ID\_FILE\_SAVE** используется как для сохранения файла \(для обычных документов\), так и для обновления файла \(для внедренных документов\).  
  
     Если данные по документа хранятся в отдельных дисковых файлов, но нет необходимости использовать значение по умолчанию **CDocument** отдельной сериализации поведение, необходимо переопределить `CDocument::OnSaveDocument` вместо **OnFileSave**.  
  
-   ID\_FILE\_SAVE\_AS сохраняет текущий документ под другим именем файла.  
  
     Реализация метода **CDocument::OnFileSaveAs** использует ту же вспомогательной процедуры **CDocument::DoSave** и **OnFileSave**.  Команда **OnFileSaveAs** обрабатывается как **ID\_FILE\_SAVE**, если отсутствуют документы отсутствует имя файла перед спасением.  **COleServerDoc::OnFileSaveAs** реализует логику для сохранения обычный файл данных документа или сохранения документа серверного объекта OLE, внедренный в каком\-либо другом приложении в отдельный файл.  
  
     Если настраивается логика **ID\_FILE\_SAVE**, возможно, потребуется настраивать **ID\_FILE\_SAVE\_AS** в подобной таким или операция «сохранить как» не может применяться к документу.  Можно удалить пункт меню в строки меню, если оно не требуется.  
  
-   ID\_FILE\_SAVE\_COPY\_AS сохраняет текущий документ копирования под новым именем.  
  
     Реализация метода **COleServerDoc::OnFileSaveCopyAs** похожа на **CDocument::OnFileSaveAs**, за исключением того, что объект документа «» не подключен к базовому файлу после сохранения.  То есть, если документ в памяти «был изменен», прежде чем сохранить она по\-прежнему «будет изменено».  Кроме того, эта команда не влияет на пути или заголовок, хранящиеся в документе.  
  
-   ID\_FILE\_UPDATE уведомляет контейнер для сохранения внедренного документа.  
  
     `COleServerDoc::OnUpdateDocument` реализации notifiies является контейнером, внедрение должен быть сохранен.  Контейнер затем вызывает соответствующие OLE API для сохранения внедренного объекта.  
  
-   ID\_FILE\_PAGE\_SETUP вызывает конкретного приложения диалоговое окно "параметры страницы" макета.  
  
     В настоящее время не стандартно этого диалогового окна, и среда не имеет реализации по умолчанию этой команды.  
  
     Если решено реализовать эту команду, рекомендуется выполнять используется это идентификатор команды.  
  
-   ID\_FILE\_PRINT\_SETUP вызывают стандартное диалоговое окно настройки печати.  
  
    > [!NOTE]
    >  Необходимо подключить в `CWinApp`\- это схема сообщений производного класса, чтобы включить эту функцию.  
  
     Эта команда вызывает стандартное диалоговое окно настройки печати, который позволяет пользователю настраивать параметры принтера и печати по крайней мере для данного документа или не более всех документов в приложении.  Необходимо использовать панель управления, чтобы изменить параметры принтера по умолчанию для всей системы.  
  
     `CWinApp::OnFilePrintSetup` имеет очень простую реализацию создать объект `CPrintDialog` и реализации при вызове функции **CWinApp::DoPrintDialog**.  Задает настройки принтера по умолчанию приложения.  
  
     Общая потребность в настраивать эта команда разрешения для параметров для каждого принтера документа, следует сохранить с документом сохраненный.  Для этого необходимо добавить обработчик сообщений схемы в классе **CDocument**, создает объект `CPrintDialog`, инициализирует его с соответствующими атрибутами принтера \(обычно это **hDevMode** и **hDevNames**\), вызывается метод **CPrintDialog::DoModal,** и сохранить измененные параметры принтера.  Для реализации надежной следует использовать реализацию **CWinApp::DoPrintDialog** для обнаружения ошибок **CWinApp::UpdatePrinterSelection** и работы с здравыми умолчаниями и печать всей системы отслеживания изменений.  
  
-   Печать ID\_FILE\_PRINT стандартная текущего документа  
  
    > [!NOTE]
    >  Необходимо подключить в `CView`\- это схема сообщений производного класса, чтобы включить эту функцию.  
  
     Эта команда печать текущего документа или более правильно, запускается процесс печати, что позволяет вызывать стандартные диалоговое окно печати и запускать обработчик печати.  
  
     **CView::OnFilePrint** реализует эту команду и главный цикл печати.  Он вызывает виртуальный `CView::OnPreparePrinting` в запрос пользователя с помощью диалогового окна печати.  Затем подготавливает выходные данные DC для перехода на принтер, перемещение вверх диалоговое окно хода выполнения печати \(**AFX\_IDD\_PRINTDLG**\) и отправляет escape\-последовательности `StartDoc` на принтер.  **CView::OnFilePrint** также содержит основной ориентированных на странице цикла печати.  Для каждой страницы он вызывает виртуальное `CView::OnPrepareDC` за escape\-последовательности `StartPage` и вызова виртуального `CView::OnPrint` для данной страницы.  При полной, виртуальный `CView::OnEndPrinting` вызван, и диалоговое окно хода выполнения печати закрыто.  
  
     Архитектура печати предназначена MFC в обработчик различными способами для печати и предварительного просмотра.  Обычно найдете различные функции переопределяемого метода `CView` соответствующих для всех ориентированных на странице задач печати.  Только в случае приложения, использующего принтер не для страницы ориентировал результаты, если обнаружится, что заменить реализация метода **ID\_FILE\_PRINT**.  
  
-   Режим предварительного просмотра ID\_FILE\_PRINT\_PREVIEW входных данных для текущего документа.  
  
    > [!NOTE]
    >  Необходимо подключить в `CView`\- это схема сообщений производного класса, чтобы включить эту функцию.  
  
     **CView::OnFilePrintPreview** начинает режим предварительного просмотра путем вызова документированная вспомогательной функцией **CView::DoPrintPreview**.  **CView::DoPrintPreview** : обработчик для цикла предварительного просмотра, так как **OnFilePrint** является основной обработчик для цикла печати.  
  
     Операция предварительного просмотра можно настраивать различными способами, передавая различные параметры для **DoPrintPreview**.  См. [Техническое примечание 30](../mfc/tn030-customizing-printing-and-print-preview.md), которые рассматриваются некоторые сведения предварительного просмотра и, как настраивать его.  
  
-   Диапазон **ID\_FILE\_MRU\_FILE1**…**FILE16**  a идентификаторы команд для файла MRU `list`.  
  
     **CWinApp::OnUpdateRecentFileMenu** обработчика пользовательского интерфейса команды обновления, одно из предварительного использует механизм `ON_UPDATE_COMMAND_UI`.  В диалоговом окне меню, необходимо задать только один пункт меню с идентификатором **ID\_FILE\_MRU\_FILE1**.  Пункт меню, остается исходного запретило.  
  
     Как список последних выбиравшихся увеличивается, нескольких пунктов меню добавляются в список.  Стандартная реализация `CWinApp` по умолчанию в стандартный ограничение 4 последних использовавшийся ся файлов.  По умолчанию можно изменить путем вызова `CWinApp::LoadStdProfileSettings` с большим или более маленьким значение.  Список последних выбиравшихся хранится в INI\-файле приложения.  Список загружается в функции `InitInstance` приложения при вызове `LoadStdProfileSettings` и сохраняется, когда приложение не влияет.  Обработчик пользовательского интерфейса команды обновления MRU также преобразования абсолютные пути к относительным пути для отображения в меню файла.  
  
     **CWinApp::OnOpenRecentFile** `ON_COMMAND`, обработчик выполняет фактическую команды.  Он просто получает имя файла из списка MRU и вызывает `CWinApp::OpenDocumentFile`. это позволяет полностью рабочего открытия файла и обновить список последних выбиравшихся.  
  
     Настройка этого обработчика команды не рекомендуется.  
  
-   ID\_EDIT\_CLEAR снимает текущее выделение  
  
     В настоящее время нет стандартная реализация для этой команды.  Необходимо реализовать это для каждого `CView`\- производного класса.  
  
     `CEditView` предоставляет реализацию этой команды с помощью `CEdit::Clear`.  Если команда причиной текущего выделения.  
  
     Если решено реализовать эту команду, рекомендуется выполнять используется это идентификатор команды.  
  
-   ID\_EDIT\_CLEAR\_ALL очищает весь документ.  
  
     В настоящее время нет стандартная реализация для этой команды.  Необходимо реализовать это для каждого `CView`\- производного класса.  
  
     Если решено реализовать эту команду, рекомендуется выполнять используется это идентификатор команды.  В примере MFC [Образец SCRIBBLE](../top/visual-cpp-samples.md) консультационный пример реализации.  
  
-   ID\_EDIT\_COPY копирует текущее выделение в буфер обмена.  
  
     В настоящее время нет стандартная реализация для этой команды.  Необходимо реализовать это для каждого `CView`\- производного класса.  
  
     `CEditView` предоставляет реализацию этой команды, которая копирует текущий выбранный текст в буфер обмена в виде CF\_TEXT с помощью `CEdit::Copy`.  Если команда причиной текущего выделения.  
  
     Если решено реализовать эту команду, рекомендуется выполнять используется это идентификатор команды.  
  
-   ID\_EDIT\_CUT кэширование текущее выделение в буфер обмена.  
  
     В настоящее время нет стандартная реализация для этой команды.  Необходимо реализовать это для каждого `CView`\- производного класса.  
  
     `CEditView` предоставляет реализацию этой команды, которая в данный момент вырезает выделенный текст в буфер обмена в виде CF\_TEXT с помощью `CEdit::Cut`.  Если команда причиной текущего выделения.  
  
     Если решено реализовать эту команду, рекомендуется выполнять используется это идентификатор команды.  
  
-   ID\_EDIT\_FIND начинается операция поиска, перемещение вверх безрежимное диалоговое окно поиска.  
  
     В настоящее время нет стандартная реализация для этой команды.  Необходимо реализовать это для каждого `CView`\- производного класса.  
  
     `CEditView` предоставляет реализацию этой команды, которая вызывает вспомогательную функцию **OnEditFindReplace** реализации для использования и хранения предыдущей найти и заменить переменные закрытых дверях при реализации параметров.  Класс `CFindReplaceDialog` используется для управления безрежимное диалоговое окно для отображения запросов для пользователя.  
  
     Если решено реализовать эту команду, рекомендуется выполнять используется это идентификатор команды.  
  
-   ID\_EDIT\_PASTE вставляет текущее содержимое буфера обмена.  
  
     В настоящее время нет стандартная реализация для этой команды.  Необходимо реализовать это для каждого `CView`\- производного класса.  
  
     `CEditView` предоставляет реализацию этой команды, которая копирует текущие данные обмена заменить выделенный текст, `CEdit::Paste`.  Если команда запрещена **CF\_TEXT** в буфер обмена.  
  
     **COleClientDoc** просто предоставляет обработчик пользовательского интерфейса команды обновления для этой команды.  Если набор не содержит embeddable элемент OLE\/объект, команда будет запрещена.  Ответственность за написать обработчик для фактических задач команды фактический вставить.  Если приложение OLE может также вставить другие форматы, необходимо указать собственный обработчик пользовательского интерфейса команды обновления по в представлении или документ \(то есть **COleClientDoc** перед где\-то в маршрутизации конечного команды\).  
  
     Если решено реализовать эту команду, рекомендуется выполнять используется это идентификатор команды.  
  
     Для замены стандартная реализация OLE используйте `COleClientItem::CanPaste`.  
  
-   ID\_EDIT\_PASTE\_LINK содержит ссылку из текущего содержимого буфера обмена.  
  
     В настоящее время нет стандартная реализация для этой команды.  Необходимо реализовать это для каждого `CView`\- производного класса.  
  
     `COleDocument` просто предоставляет обработчик пользовательского интерфейса команды обновления для этой команды.  Если набор не содержит linkable элемент OLE\/объект, команда будет запрещена.  Ответственность за написать обработчик для фактических задач команды фактический вставить.  Если приложение OLE может также вставить другие форматы, необходимо указать собственный обработчик пользовательского интерфейса команды обновления по в представлении или документ \(т е где\-то перед `COleDocument` в маршрутизации конечного команды\).  
  
     Если решено реализовать эту команду, рекомендуется выполнять используется это идентификатор команды.  
  
     Для замены стандартная реализация OLE используйте `COleClientItem::CanPasteLink`.  
  
-   ID\_EDIT\_PASTE\_SPECIAL вставляет текущее содержимое буфера обмена с параметрами.  
  
     В настоящее время нет стандартная реализация для этой команды.  Необходимо реализовать это для каждого `CView`\- производного класса.  MFC не предоставляет это диалоговое окно.  
  
     Если решено реализовать эту команду, рекомендуется выполнять используется это идентификатор команды.  
  
-   ID\_EDIT\_REPEAT повторяющейся последняя операция.  
  
     В настоящее время нет стандартная реализация для этой команды.  Необходимо реализовать это для каждого `CView`\- производного класса.  
  
     `CEditView` предоставляет реализацию этой команды итерации последней операции поиска.  Закрытые переменные используются для реализации последней поиска.  Если команда запрещена находку нельзя пытаться.  
  
     Если решено реализовать эту команду, рекомендуется выполнять используется это идентификатор команды.  
  
-   ID\_EDIT\_REPLACE начинает операцию замены, перемещение вверх заменяет безрежимное диалоговое окно.  
  
     В настоящее время нет стандартная реализация для этой команды.  Необходимо реализовать это для каждого `CView`\- производного класса.  
  
     `CEditView` предоставляет реализацию этой команды, которая вызывает вспомогательную функцию **OnEditFindReplace** реализации для использования и хранения предыдущей найти и заменить переменные закрытых дверях при реализации параметров.  Класс `CFindReplaceDialog` используется для управления безрежимное диалоговое окно, в котором пользователь.  
  
     Если решено реализовать эту команду, рекомендуется выполнять используется это идентификатор команды.  
  
-   ID\_EDIT\_SELECT\_ALL выделяет весь документ.  
  
     В настоящее время нет стандартная реализация для этой команды.  Необходимо реализовать это для каждого `CView`\- производного класса.  
  
     `CEditView` предоставляет реализацию этой команды, которая выбирает весь текст в документе.  Команда запрещена, если текст, который необходимо выбрать.  
  
     Если решено реализовать эту команду, рекомендуется выполнять используется это идентификатор команды.  
  
-   ID\_EDIT\_UNDO отменяет последнюю операцию.  
  
     В настоящее время нет стандартная реализация для этой команды.  Необходимо реализовать это для каждого `CView`\- производного класса.  
  
     `CEditView` предоставляет реализацию этой команды, с помощью `CEdit::Undo`.  Если команда запрещена `CEdit::CanUndo` возвращает ЛОЖНОЕ.  
  
     Если решено реализовать эту команду, рекомендуется выполнять используется это идентификатор команды.  
  
-   ID\_EDIT\_REDO вернет последняя операция.  
  
     В настоящее время нет стандартная реализация для этой команды.  Необходимо реализовать это для каждого `CView`\- производного класса.  
  
     Если решено реализовать эту команду, рекомендуется выполнять используется это идентификатор команды.  
  
-   ID\_WINDOW\_NEW другое окно открывается в активном документе.  
  
     **CMDIFrameWnd::OnWindowNew** реализует мощную эту функцию с помощью шаблона документа текущего документа для создания другой кадр, содержащая другое представление текущего документа.  
  
     Как и большинство команд меню " Окна \(MDI\) интерфейс MDI, причиной команда при отсутствии активных дочернее окно MDI.  
  
     Настройка этого обработчика команды не рекомендуется.  При необходимости предоставить команды, которая создает дополнительные представления или фреймовые окна, может возникнуть всего за пределы разработка собственную команду.  Можно клон код из **CMDIFrameWnd::OnWindowNew** и измените его на конкретные кадра и классы представления в любить.  
  
-   ID\_WINDOW\_ARRANGE Значки располагается в нижней части окна MDI.  
  
     `CMDIFrameWnd` реализует эту стандартную команду MDI во вспомогательной функции **OnMDIWindowCmd** реализации.  Это вспомогательный метод сопоставляет идентификаторы команд на них Windows MDI и поэтому может использовать большой объем кода.  
  
     Как и большинство команд меню " окно MDI, причиной команда при отсутствии активных дочернее окно MDI.  
  
     Настройка этого обработчика команды не рекомендуется.  
  
-   ID\_WINDOW\_CASCADE каскадирует окна таким образом, чтобы они перекрывается.  
  
     `CMDIFrameWnd` реализует эту стандартную команду MDI во вспомогательной функции **OnMDIWindowCmd** реализации.  Это вспомогательный метод сопоставляет идентификаторы команд на них Windows MDI и поэтому может использовать большой объем кода.  
  
     Как и большинство команд меню " окно MDI, причиной команда при отсутствии активных дочернее окно MDI.  
  
     Настройка этого обработчика команды не рекомендуется.  
  
-   ID\_WINDOW\_TILE\_HORZ мозаик окна по горизонтали.  
  
     Эта команда реализована в `CMDIFrameWnd` как **ID\_WINDOW\_CASCADE**, за исключением того, что другое сообщение Windows MDI используется для операции.  
  
     Необходимо выбрать ориентации стандартной плитки для приложения.  Это можно сделать путем изменения идентификатор для пункта меню «мозаики» окна в **ID\_WINDOW\_TILE\_HORZ** или **ID\_WINDOW\_TILE\_VERT**.  
  
-   Окна мозаик ID\_WINDOW\_TILE\_VERT по вертикали.  
  
     Эта команда реализована в `CMDIFrameWnd` как **ID\_WINDOW\_CASCADE**, за исключением того, что другое сообщение Windows MDI используется для операции.  
  
     Необходимо выбрать ориентации стандартной плитки для приложения.  Это можно сделать путем изменения идентификатор для пункта меню «мозаики» окна в **ID\_WINDOW\_TILE\_HORZ** или **ID\_WINDOW\_TILE\_VERT**.  
  
-   Интерфейс клавиатуры в ID\_WINDOW\_SPLIT разделителю.  
  
     `CView` обрабатывает эту команду для реализации `CSplitterWnd`.  Если представление части окна\-разделителя, эта команда делегирует в функции `CSplitterWnd::DoKeyboardSplit` реализации.  При этом разделитель в режиме, который позволяет пользователям клавиатуры на разделению или unsplit разделитель.  
  
     Эта команда запрещена, если представление не в разделителе.  
  
     Настройка этого обработчика команды не рекомендуется.  
  
-   ID\_APP\_ABOUT вызывает диалогового окна.  
  
     Отсутствует стандартная реализация для приложения " о программе ".  Приложение AppWizard\- создается по умолчанию создает пользовательский класс диалогового окна для приложения и использует его, как будет около окна.  AppWizard также записывает тривиальный обработчик команды обработки этой команды и вызывает диалоговое окно.  
  
     Будут практически всегда будет реализации этой команды.  
  
-   Выход ID\_APP\_EXIT приложение.  
  
     **CWinApp::OnAppExit** обрабатывает эту команду, отправляя сообщение `WM_CLOSE` в главное окно приложения.  Стандартный работы приложения \(запросов для пакостных файлов и т д\) обрабатывается реализацией `CFrameWnd`.  
  
     Настройка этого обработчика команды не рекомендуется.  Переопределение `CWinApp::SaveAllModified` или логику `CFrameWnd` заключительная рекомендуется.  
  
     Если решено реализовать эту команду, рекомендуется выполнять используется это идентификатор команды.  
  
-   ID\_HELP\_INDEX список разделов справки из файла .HLP.  
  
    > [!NOTE]
    >  Необходимо подключить в `CWinApp`\- это схема сообщений производного класса, чтобы включить эту функцию.  
  
     `CWinApp::OnHelpIndex` обрабатывает эта команда тривиальным вызова `CWinApp::WinHelp`.  
  
     Настройка этого обработчика команды не рекомендуется.  
  
-   Отображение ID\_HELP\_USING справку по использованию справки.  
  
    > [!NOTE]
    >  Необходимо подключить в `CWinApp`\- это схема сообщений производного класса, чтобы включить эту функцию.  
  
     `CWinApp::OnHelpUsing` обрабатывает эта команда тривиальным вызова `CWinApp::WinHelp`.  
  
     Настройка этого обработчика команды не рекомендуется.  
  
-   ID\_CONTEXT\_HELP переходит в режим SHIFT\-F1 справки.  
  
    > [!NOTE]
    >  Необходимо подключить в `CWinApp`\- это схема сообщений производного класса, чтобы включить эту функцию.  
  
     `CWinApp::OnContextHelp` обрабатывает эту команду, поместить курсор режима справки, вставлять модальном цикл и ожидать пользователя, чтобы выбрать окно для получения справки по.  См. [Техническое примечание 28](../mfc/tn028-context-sensitive-help-support.md) более подробные сведения о реализации справки MFC.  
  
     Настройка этого обработчика команды не рекомендуется.  
  
-   ID\_HELP предоставляет справку в текущем контексте  
  
    > [!NOTE]
    >  Необходимо подключить в `CWinApp`\- это схема сообщений производного класса, чтобы включить эту функцию.  
  
     `CWinApp::OnHelp` обрабатывает эту команду, получая правой контекст справки для контекста текущего приложения.  Это помогает простой справка F1, справка в окнах и т д  См. [Техническое примечание 28](../mfc/tn028-context-sensitive-help-support.md) более подробные сведения о реализации справки MFC.  
  
     Настройка этого обработчика команды не рекомендуется.  
  
-   Отображение ID\_DEFAULT\_HELP не выполняют справка по умолчанию для контекста  
  
    > [!NOTE]
    >  Необходимо подключить в `CWinApp`\- это схема сообщений производного класса, чтобы включить эту функцию.  
  
     Эта команда обычно сопоставляется с `CWinApp::OnHelpIndex`.  
  
     Другой обработчик команды можно задать при необходимости различие между справкой по умолчанию и по индексу справки.  
  
-   ID\_NEXT\_PANE переходит к следующей области  
  
     `CView` обрабатывает эту команду для реализации `CSplitterWnd`.  Если представление части окна\-разделителя, эта команда делегирует в функцию **CSplitterWnd::OnNextPaneCmd** реализации.  Переместится активное представление к следующей области в разделителе.  
  
     Эта команда запрещена, если представление не в разделителе или отсутствует в области, необходимо перейти.  
  
     Настройка этого обработчика команды не рекомендуется.  
  
-   ID\_PREV\_PANE переходит к предыдущей области  
  
     `CView` обрабатывает эту команду для реализации `CSplitterWnd`.  Если представление части окна\-разделителя, эта команда делегирует в функцию **CSplitterWnd::OnNextPaneCmd** реализации.  Переместится активное представление к предыдущей области в разделителе.  
  
     Эта команда запрещена, если представление не в разделителе или нет предыдущая область, чтобы перейти.  
  
     Настройка этого обработчика команды не рекомендуется.  
  
-   ID\_OLE\_INSERT\_NEW вставляет новый объект OLE  
  
     В настоящее время нет стандартная реализация для этой команды.  Необходимо реализовать это для `CView`\- производный класс для вставки нового элемента OLE\/объект в текущее выделение.  
  
     Все OLE клиентские приложения должны реализовать этой команды.  AppWizard OLE, с параметром, создает каркасная реализация класса **OnInsertObject** по в представлении, для завершения.  
  
     В примере [OCLIENT](../top/visual-cpp-samples.md) примера MFC OLE полную реализацию этой команды.  
  
-   ID\_OLE\_EDIT\_LINKS изменяет OLE ссылки  
  
     `COleDocument` обрабатывает эту команду с помощью образце стала реализация стандартного OLE диалогового окна ссылок.  Реализация этого диалогового окна можно через класс `COleLinksDialog`.  Если текущий документ не содержит ссылки, команда запрещена.  
  
     Настройка этого обработчика команды не рекомендуется.  
  
-   ID\_OLE\_VERB\_FIRST… ПОСЛЕДНЕЕ диапазон идентификаторов для команд OLE  
  
     `COleDocument` использует этот диапазон идентификатор команды для команд, поддерживаемых в настоящее время выделенными элемент OLE и объектом.  Это должна быть диапазоном, поскольку заданный элемент OLE и тип объектов могут поддерживать ноль или более пользовательских команд.  В меню приложения необходимо наличие одного пункта меню с идентификатором **ID\_OLE\_VERB\_FIRST**.  Когда программа будет выполняться, меню будет обновлена с соответствующим описанием \(всплывающим команды меню или команд меню с несколькими\).  Элемент управления меню OLE обрабатывается `AfxOleSetEditMenu`, записей в обработчике пользовательского интерфейса команды обновления для этой команды.  
  
     В явном виде не обработчиков команд для обработки каждого из идентификатор команды в этом диапазоне.  **COleDocument::OnCmdMsg** переопределено для перехвата всех идентификаторов команд в этом диапазоне, преобразует их в отсчитываются от нуля число команд, и запускает сервер для этой команды \(с помощью `COleClientItem::DoVerb`\).  
  
     Не рекомендуется использовать настройки или другое использование этого диапазона идентификатор команды.  
  
-   ID\_VIEW\_TOOLBAR переключает инструмент время от времени  
  
     `CFrameWnd` обрабатывает этой команды и обработчика пользовательского интерфейса обновление\- команды переключение видимый состояние инструмента.  Панель инструментов должен быть дочерним фрейма окна с идентификатором дочернего окна `AFX_IDW_TOOLBAR`.  Обработчик команды, переключающую видимость окна инструментов.  `CFrameWnd::RecalcLayout` используется, чтобы redraw фреймовое окно с панелью инструментов в своем новом состоянии.  Обработчик пользовательского интерфейса обновление\- команды проверяет пункт меню, панели инструментов отображается.  
  
     Настройка этого обработчика команды не рекомендуется.  Если вы хотите добавить дополнительные инструменты, может возникнуть необходимость клонирования и изменять обработчик команды и обработчика пользовательского интерфейса обновление\- команды для этой команды.  
  
-   ID\_VIEW\_STATUS\_BAR для строки состояния время от времени  
  
     Эта команда реализована в `CFrameWnd` как **ID\_VIEW\_TOOLBAR**, за исключением того, что используется другой идентификатор дочернего окна \(**AFX\_IDW\_STATUS\_BAR**\).  
  
## Только для обновления обработчиков команд  
 Несколько стандартных идентификаторов команд используются как индикаторы в строке состояния.  Эти используется тот же пользовательский интерфейс обновление\- команды механизм обработки для визуального отображения своего текущего состояния во время бездействия приложения.  Так как они не могут быть выбраны пользователем \(то есть невозможно внедрения область строки состояния\), то он не выполняет никакой смысл иметь обработчик `ON_COMMAND` этих идентификаторов команд.  
  
-   **ID\_INDICATOR\_CAPS** : Индикатор клавиши фиксации заглавного регистр.  
  
-   **ID\_INDICATOR\_NUM** : Индикатор NUM блокировки.  
  
-   **ID\_INDICATOR\_SCRL** : Индикатор SCRL блокировки.  
  
-   **ID\_INDICATOR\_KANA** : Индикатор блокировки KANA \(применяется только к японским систем\).  
  
 Все 3 из этих реализованы в **CFrameWnd::OnUpdateKeyIndicator**, вспомогательном реализации, использующее идентификатор команды для сопоставления с соответствующим виртуальному ключу.  Общая реализация включить или отключить \(для запрещенных областей состояния \= без текста\) объекта `CCmdUI` в зависимости от блокирован ли соответствующий виртуальный ключ в данный момент.  
  
 Настройка этого обработчика команды не рекомендуется.  
  
-   **ID\_INDICATOR\_EXT: EXT** choice индикатор выполнения.  
  
-   индикатор забастовки **ID\_INDICATOR\_OVR: OV** e **R**.  
  
-   **ID\_INDICATOR\_REC: Рекомендуется** ording индикатор.  
  
 В настоящее время нет стандартная реализация этих индикаторов.  
  
 При выборе реализации этих индикаторы, рекомендуется выполнять используем эти идентификаторы индикатора и обслуживание упорядочение индикаторов в строку состояния \(то есть в следующем порядке: EXT, НАКОНЕЧНИК, NUM, SCRL, OVR, REC\).  
  
## См. также  
 [Технические примечания по номеру](../mfc/technical-notes-by-number.md)   
 [Технические примечания по категории](../mfc/technical-notes-by-category.md)