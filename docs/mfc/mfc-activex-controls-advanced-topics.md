---
title: 'Элементы управления ActiveX MFC: Дополнительные разделы | Документы Microsoft'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-mfc
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- MFC ActiveX controls [MFC], error codes
- MFC ActiveX controls [MFC], accessing invisible dialog controls
- MFC ActiveX controls [MFC], advanced topics
- FireError method [MFC]
- MFC ActiveX controls [MFC], database classes
- MFC ActiveX controls [MFC], special keys
- PreTranslateMessage method [MFC]
- MFC ActiveX controls [MFC], parameterized property
- ThrowError method [MFC]
ms.assetid: e9e34abb-8e2d-461e-bb9c-a1aec5dcecbd
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: eb451abc3aabe52d9aeffbc92f80df38f02e0b99
ms.sourcegitcommit: 76b7653ae443a2b8eb1186b789f8503609d6453e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
---
# <a name="mfc-activex-controls-advanced-topics"></a>Элементы управления ActiveX в MFC. Дополнительные разделы
В этой статье представлены дополнительные разделы, относящиеся к разработке элементов управления ActiveX. Сюда входит следующее.  
  
-   [Использование классов базы данных в элементах управления ActiveX](#_core_using_database_classes_in_activex_controls)  
  
-   [Реализация параметризованные свойства](#_core_implementing_a_parameterized_property)  
  
-   [Обработка ошибок в элементе управления ActiveX](#_core_handling_errors_in_your_activex_control)  
  
-   [Обработка специальных клавиш в элементе управления](#_core_handling_special_keys_in_your_control)  
  
-   [Доступ к элементам управления диалогового окна, которые невидимы во время выполнения](#_core_accessing_dialog_controls_that_are_invisible_at_run_time)  
  
##  <a name="_core_using_database_classes_in_activex_controls"></a> Использование классов базы данных в элементах управления ActiveX  
 Поскольку классы элементов управления ActiveX являются частью библиотеки классов, можно применить тех же процедур и правила для использование классов базы данных в приложении MFC standard для разработки элементов управления ActiveX, использующих классы базы данных MFC.  
  
 Общие классы MFC базы данных, в разделе [классы баз данных MFC (DAO и ODBC)](../data/mfc-database-classes-odbc-and-dao.md). Статьи представлены классы MFC ODBC и классы DAO Библиотеки MFC, а также указаны дополнительные сведения о либо.  
  
> [!NOTE]
>  Среда Visual C++ и мастера не поддерживают DAO (хотя классы DAO включены и их можно по-прежнему использовать). Корпорация Майкрософт рекомендует использовать [шаблонов OLE DB](../data/oledb/ole-db-programming.md) или [ODBC и MFC](../data/odbc/odbc-and-mfc.md) для новых проектов. DAO следует использовать только для поддержки существующих приложений.  
  
##  <a name="_core_implementing_a_parameterized_property"></a> Реализация параметризованные свойства  
 Свойства с параметрами (иногда называется массива свойств) — это метод для предоставления однородную коллекцию значений как одно свойство элемента управления. Например можно использовать параметризованные свойства для предоставления является массивом или словаря, как свойство. В Visual Basic это свойство осуществляется с помощью нотации массива:  
  
 [!code-vb[NVC_MFC_AxVb#1](../mfc/codesnippet/visualbasic/mfc-activex-controls-advanced-topics_1.vb)]  
  
 Используйте мастер добавления свойств для реализации свойства с параметрами. Мастер добавления свойств реализует свойство путем добавления пары функций Get и Set, позволяющие пользователю получить доступ к свойству, используя нотацию выше элемента управления или обычным способом.  
  
 Как и методы и свойства, параметризованные свойства также имеют максимальное число разрешенных параметров. В случае параметризованные свойства ограничение составляет 15 параметров (с одним параметром, зарезервированных для хранения значения свойства).  
  
 В следующей процедуре добавляется параметризованные свойство, которое называется массив, который может быть получен как двухмерный массив целочисленных значений.  
  
#### <a name="to-add-a-parameterized-property-using-the-add-property-wizard"></a>Добавление свойства с параметрами, используя мастер добавления свойства  
  
1.  Загрузите проект элемента управления.  
  
2.  В представлении класса разверните узел библиотеки элемента управления.  
  
3.  Щелкните правой кнопкой мыши узел интерфейса для элемента управления (второй узел узла библиотеки), чтобы открыть контекстное меню.  
  
4.  В контекстном меню щелкните **добавить** и нажмите кнопку **добавить свойство**.  
  
5.  В **имя свойства** введите `Array`.  
  
6.  В **тип свойства** выберите **короткие**.  
  
7.  Для **реализацию** тип, щелкните **методы Get и Set**.  
  
8.  В **функция Get** и **задать функция** диалоговые окна, введите уникальные имена для вашего функций Get и Set или примите имена по умолчанию.  
  
9. Добавьте параметр с именем `row` (тип `short`), с использованием **имя параметра** и **тип параметра** элементов управления.  
  
10. Добавьте второй параметр с именем `column` (типа `short`).  
  
11. Нажмите кнопку **Готово**.  
  
### <a name="changes-made-by-the-add-property-wizard"></a>Изменения, внесенные программой мастер добавления свойства  
 При добавлении пользовательских свойств, мастер добавления свойств вносит изменения в заголовке класса элемента управления (. (H) и реализацию (. Файлы CPP).  
  
 Следующие строки добавляются в класс элемента управления. H-файл:  
  
 [!code-cpp[NVC_MFC_AxUI#35](../mfc/codesnippet/cpp/mfc-activex-controls-advanced-topics_2.h)]  
  
 Этот код объявляет две функции `GetArray` и `SetArray` , которые позволяют пользователю запрашивать указанной строке и столбце при обращении к свойству.  
  
 Кроме того, мастер добавления свойств добавляет следующие строки диспетчеризации карты элементов управления, расположенных в реализацию класса элемента управления (. Файл .cpp):  
  
 [!code-cpp[NVC_MFC_AxUI#36](../mfc/codesnippet/cpp/mfc-activex-controls-advanced-topics_3.cpp)]  
  
 Наконец, реализации `GetArray` и `SetArray` функции добавляются в конец. CPP-файл. В большинстве случаев предстоит изменить функцию Get для возврата значения свойства. Функция Set обычно содержит код, который должен выполняться до или после изменения свойств.  
  
 Для этого свойства для использования, можно объявить переменную-член двумерный массив в класс элемента управления типа **короткие**, для хранения значений для свойства с параметрами. Можно затем изменить функцию Get возвращает значение, хранящееся в правильную строку и столбец, как указано параметрами и измените набор функцию, чтобы обновить значения, упоминаемого по параметрам, строк и столбцов.  
  
##  <a name="_core_handling_errors_in_your_activex_control"></a> Обработка ошибок в элементе управления ActiveX  
 Если произойдет ошибка в элементе управления, может потребоваться сообщить об ошибке в контейнер элемента управления. Существует два способа для сообщения об ошибках, в зависимости от ситуации, в которой произошла ошибка. Если произошла ошибка в свойстве Get или Set-функция, или в реализации метода OLE-автоматизации, управления должны вызывать [COleControl::ThrowError](../mfc/reference/colecontrol-class.md#throwerror), какие сигналы управления пользователя, произошла ошибка. Если данная ошибка возникает в любое время, элемент управления должен вызывать [COleControl::FireError](../mfc/reference/colecontrol-class.md#fireerror), который срабатывает стандартное событие ошибки.  
  
 Чтобы указать тип возникшей ошибки, элемента управления необходимо передать код ошибки для `ThrowError` или `FireError`. Код ошибки: код состояния OLE имеет 32-разрядное значение. По возможности выбирайте код ошибки из стандартного набора кодов, определенных в OLECTL. Файл заголовка. В следующей таблице перечислены эти коды.  
  
### <a name="activex-control-error-codes"></a>Коды ошибок элементов управления ActiveX  
  
|Error|Описание|  
|-----------|-----------------|  
|**CTL_E_ILLEGALFUNCTIONCALL**|Ошибочный вызов функции|  
|**CTL_E_OVERFLOW**|Переполнение|  
|**CTL_E_OUTOFMEMORY**|Нет памяти|  
|**CTL_E_DIVISIONBYZERO**|Деление на ноль|  
|**CTL_E_OUTOFSTRINGSPACE**|Место в строке|  
|**CTL_E_OUTOFSTACKSPACE**|Место в стеке|  
|**CTL_E_BADFILENAMEORNUMBER**|Недопустимое имя файла или номер|  
|**CTL_E_FILENOTFOUND**|Файл не найден|  
|**CTL_E_BADFILEMODE**|Недопустимый режим файла|  
|**CTL_E_FILEALREADYOPEN**|Файл уже открыт|  
|**CTL_E_DEVICEIOERROR**|Ошибка ввода-вывода устройства|  
|**CTL_E_FILEALREADYEXISTS**|Файл уже существует|  
|**CTL_E_BADRECORDLENGTH**|Недопустимая длина записи|  
|**CTL_E_DISKFULL**|Нет места на диске|  
|**CTL_E_BADRECORDNUMBER**|Неверный номер записи|  
|**CTL_E_BADFILENAME**|Недопустимое имя файла|  
|**CTL_E_TOOMANYFILES**|Слишком много файлов|  
|**CTL_E_DEVICEUNAVAILABLE**|Устройство недоступно|  
|**CTL_E_PERMISSIONDENIED**|В разрешении отказано|  
|**CTL_E_DISKNOTREADY**|Диск не готов|  
|**CTL_E_PATHFILEACCESSERROR**|Ошибка доступа к пути/файлу|  
|**CTL_E_PATHNOTFOUND**|Путь не найден|  
|**CTL_E_INVALIDPATTERNSTRING**|Недопустимая строка шаблона|  
|**CTL_E_INVALIDUSEOFNULL**|Недопустимое использование значения NULL|  
|**CTL_E_INVALIDFILEFORMAT**|Недопустимый формат файла|  
|**CTL_E_INVALIDPROPERTYVALUE**|Недопустимое значение свойства|  
|**CTL_E_INVALIDPROPERTYARRAYINDEX**|Недопустимый индекс массива свойств|  
|**CTL_E_SETNOTSUPPORTEDATRUNTIME**|Установка не поддерживается во время выполнения|  
|**CTL_E_SETNOTSUPPORTED**|Set не поддерживается (свойство доступно только для чтения)|  
|**CTL_E_NEEDPROPERTYARRAYINDEX**|Требуется индекс массива свойства|  
|**CTL_E_SETNOTPERMITTED**|Функция set запрещена|  
|**CTL_E_GETNOTSUPPORTEDATRUNTIME**|Get не поддерживается во время выполнения|  
|**CTL_E_GETNOTSUPPORTED**|Get не поддерживается (свойство доступно только для записи).|  
|**CTL_E_PROPERTYNOTFOUND**|Свойство не найдено|  
|**CTL_E_INVALIDCLIPBOARDFORMAT**|Недопустимый формат буфера обмена|  
|**CTL_E_INVALIDPICTURE**|Недопустимое изображение|  
|**CTL_E_PRINTERERROR**|Ошибка принтера|  
|**CTL_E_CANTSAVEFILETOTEMP**|Не удается сохранить файл в TEMP|  
|**CTL_E_SEARCHTEXTNOTFOUND**|Искомый текст не найден|  
|**CTL_E_REPLACEMENTSTOOLONG**|Недопустимая длина замены|  
  
 При необходимости используйте **CUSTOM_CTL_SCODE** макрос для определения пользовательских ошибок кода условие, которое не соответствует одним из стандартных кодов. Параметр этого макроса должен быть целым числом от 1000 до 32 767 включительно. Пример:  
  
 [!code-cpp[NVC_MFC_AxUI#37](../mfc/codesnippet/cpp/mfc-activex-controls-advanced-topics_4.cpp)]  
  
 При создании элемента управления ActiveX, чтобы заменить существующий элемент управления VBX определите вашей коды ошибок элементов управления ActiveX с же числовые значения, которые VBX управления использует, чтобы обеспечить совместимость коды ошибок.  
  
##  <a name="_core_handling_special_keys_in_your_control"></a> Обработка специальных клавиш в элементе управления  
 В некоторых случаях может потребоваться обрабатывать определенные сочетания клавиш особым образом; Например, вставить новую строку при нажатии клавиши ВВОД в многострочное текстовое поле элемента управления или перемещения между группу редактирования управляет при письмом нажата ИД ключа.  
  
 Если базовый класс элемента управления ActiveX — `COleControl`, можно переопределить [CWnd::PreTranslateMessage](../mfc/reference/cwnd-class.md#pretranslatemessage) для обработки сообщений перед их обрабатывает контейнера. При использовании этого метода всегда возвращает **TRUE** при обработке сообщения в переопределении `PreTranslateMessage`.  
  
 В следующем примере кода демонстрируется возможным способом обработки всех сообщений, относящихся к ключам, направления.  
  
 [!code-cpp[NVC_MFC_AxUI#38](../mfc/codesnippet/cpp/mfc-activex-controls-advanced-topics_5.cpp)]  
  
 Дополнительные сведения об обработке интерфейсы клавиатуры для элементов управления ActiveX см. в документации ActiveX SDK.  
  
##  <a name="_core_accessing_dialog_controls_that_are_invisible_at_run_time"></a> Доступ к элементам управления диалогового окна, которые невидимы во время выполнения  
 Можно создать элементы управления диалогового окна, которые не имеют пользовательского интерфейса и являются невидимыми во время выполнения. При добавлении невидимым во время выполнения элемент управления ActiveX в диалоговое окно и используйте [CWnd::GetDlgItem](../mfc/reference/cwnd-class.md#getdlgitem) для доступа к элементу управления, элемент управления не будет работать правильно. Вместо этого следует использовать один из следующих способов для получения объекта, который представляет элемент управления:  
  
-   Используя мастер добавления члена переменной, выберите **управления переменной** , а затем выберите идентификатор элемента управления. Введите имя переменной элемента и выберите класс-оболочку элемента управления как **типа элемента управления**.  
  
     - или -  
  
-   Объявите локальную переменную и подкласс как элемент диалоговое окно. Вставьте код, который имеет следующий вид (`CMyCtrl` является класс-оболочка, `IDC_MYCTRL1` — идентификатор элемента управления):  
  
     [!code-cpp[NVC_MFC_AxCont#19](../mfc/codesnippet/cpp/mfc-activex-controls-advanced-topics_6.cpp)]  
  
## <a name="see-also"></a>См. также  
 [Элементы ActiveX библиотеки MFC](../mfc/mfc-activex-controls.md)

