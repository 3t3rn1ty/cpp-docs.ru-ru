---
title: "Элементы управления ActiveX в MFC. Дополнительные разделы | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "FireError - метод"
  - "MFC ActiveX - элементы управления, доступ к элементам управления диалогового окна"
  - "MFC ActiveX - элементы управления, дополнительные разделы"
  - "MFC ActiveX - элементы управления, классы баз данных"
  - "MFC ActiveX - элементы управления, коды ошибок"
  - "MFC ActiveX - элементы управления, параметризованное свойство"
  - "MFC ActiveX - элементы управления, специальные ключи"
  - "PreTranslateMessage - метод"
  - "ThrowError - метод"
ms.assetid: e9e34abb-8e2d-461e-bb9c-a1aec5dcecbd
caps.latest.revision: 13
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 9
---
# Элементы управления ActiveX в MFC. Дополнительные разделы
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

В этой статье рассматриваются дополнительные разделы, относящиеся к разработке элементов управления ActiveX.  К ним относятся:  
  
-   [Использование классов базы данных в элементах управления ActiveX](#_core_using_database_classes_in_activex_controls)  
  
-   [Реализация параметризованное свойство](#_core_implementing_a_parameterized_property)  
  
-   [Обработка ошибок в коде элемента управления ActiveX](#_core_handling_errors_in_your_activex_control)  
  
-   [Обработка специальные ключи в элементе управления](#_core_handling_special_keys_in_your_control)  
  
-   [Доступ к элементам управления диалогового окна, невидимы во время выполнения](#_core_accessing_dialog_controls_that_are_invisible_at_run_time)  
  
##  <a name="_core_using_database_classes_in_activex_controls"></a> Использование классов базы данных в элементах управления ActiveX  
 Так как классы элементов управления ActiveX в библиотеку классов, можно применить те же процедуры и правила использования классов базы данных в стандартном приложении MFC в разработке элементов управления ActiveX, которые используют классы MFC базы данных.  
  
 Общие сведения о классов баз данных MFC см. в разделе [Классы MFC DAO и ODBC \(\)](../Topic/MFC%20Database%20Classes%20\(ODBC%20and%20DAO\).md).  Раздел содержит описание и классы MFC ODBC и MFC DAO и направляет. для получения дополнительных сведений об этом.  
  
> [!NOTE]
>  Что касается Visual C\+\+ .NET, то среда и мастера Visual C\+\+ больше не поддерживают DAO \(хотя классы DAO включены и вы по\-прежнему можете их использовать\).  Майкрософт рекомендует использовать [Шаблоны OLE DB](../data/oledb/ole-db-programming.md) или [ODBC и MFC](../data/odbc/odbc-and-mfc.md) для новых проектов.  DAO необходимо использовать только для поддержки существующих приложений.  
  
##  <a name="_core_implementing_a_parameterized_property"></a> Реализация параметризованное свойство  
 Параметризованное свойство \(иногда называемое массив свойств\) метод для предоставления однотиповая коллекция значений как отдельное свойство элемента управления.  Например, можно использовать свойство параметризованное предоставить массив или словарь в виде свойства.  В Visual Basic то свойство доступно использование нотацию массива:  
  
 [!code-vb[NVC_MFC_AxVb#1](../mfc/codesnippet/VisualBasic/mfc-activex-controls-advanced-topics_1.vb)]  
  
 Использование мастера добавления свойства для реализации параметризованное свойство.  Мастера добавления свойства реализует свойство, добавляя пары GET и задать функций, которая позволяет пользователю элемента управления для доступа к свойству с помощью вышеуказанную нотацию или в стандартной таким.  
  
 Аналогично методам и свойствам, параметризированным свойства также может настроить ограничение на число разрешенных параметров.  При использовании параметризованных свойств, ограничение параметры 15 \(с одним параметром зарезервировано для хранения значения свойства\).  
  
 Следующая процедура добавляет параметризованное свойство, именуемое Массив, который можно получить как двумерный массив целых чисел.  
  
#### Добавление параметризованное значение свойства с помощью мастера добавления свойства.  
  
1.  Загрузите проект элемента управления.  
  
2.  В представлении классов разверните узел библиотеки элемента управления.  
  
3.  Щелкните правой кнопкой мыши узел интерфейса для элемента управления \(второго узла узла библиотеки\), чтобы открыть контекстное меню.  
  
4.  В контекстном меню щелкните **Добавить**, а затем щелкните **Добавить свойство**.  
  
5.  В поле **Имя свойства** введите `Array`.  
  
6.  В поле **свойство Type**, выберите **short**.  
  
7.  Для типа **Реализация**, щелкните **Get\/set методы**.  
  
8.  В полях **Функция Get**  и **Функция Set**, уникальные имена типа для получения и установки или функции принимают имена по умолчанию.  
  
9. Добавьте параметр с именем `row` \(тип `short`\), с помощью элементов управления **Имя параметра** и **Тип параметра** .  
  
10. Добавьте второй `column` с именем параметра \(тип `short`\).  
  
11. Нажмите кнопку **Готово**.  
  
### Изменения, выполненные с помощью мастера добавления свойства.  
 При добавлении пользовательского свойства, мастера добавления свойства вносит изменения в качестве заголовка класса элемента управления \(. H\) и файлы реализации \(CPP\).  
  
 Следующие линии добавляются в класс элемента управления. Файл H:  
  
 [!code-cpp[NVC_MFC_AxUI#35](../mfc/codesnippet/CPP/mfc-activex-controls-advanced-topics_2.h)]  
  
 Этот код объявляет 2 вызываемой функции `GetArray` и `SetArray`, позволяющие пользователю оставлять определенные строку и столбец к свойству.  
  
 Кроме того, мастер добавления свойства добавляются следующие три линии на схеме подготовки к отправке элемента управления, находящуюся в файле реализации класса элемента управления \(CPP\).  
  
 [!code-cpp[NVC_MFC_AxUI#36](../mfc/codesnippet/CPP/mfc-activex-controls-advanced-topics_3.cpp)]  
  
 Наконец, реализации `GetArray` и функции `SetArray` добавляются в конец файла CPP.  В большинстве случаев следует изменить функции получения для возврата значения свойства.  Указывает функция обычно содержит код, который должен выполняться, до или после изменения свойств.  
  
 Для этого свойства точности, можно объявить переменной\-члена двумерного массива в классе элемента управления, типа **short**, для хранения значения свойства с параметрами  Затем можно изменить функции получения для возврата значения, хранящиеся в правильную строку и столбец, как показано параметрами и измените настройки параметров функции для обновления значения указанные параметрами строки и столбца.  
  
##  <a name="_core_handling_errors_in_your_activex_control"></a> Обработка ошибок в коде элемента управления ActiveX  
 Если условия ошибки возникают в элементе управления, можно создать отчет об ошибке на контейнер элементов управления.  2 Метода для сообщений об ошибках, в зависимости от ситуации, в которой произошла ошибка.  При возникновении ошибки в свойство get или set, функции или внутри реализации метода ole\-автоматизации, элемент управления должен вызвать метод [COleControl::ThrowError](../Topic/COleControl::ThrowError.md), которое сигнализирует пользователю элемента управления, что произошла ошибка.  При возникновении ошибки в любое другое время, элемент управления должен вызвать метод [COleControl::FireError](../Topic/COleControl::FireError.md), который вызывает событие ошибки хранения.  
  
 Для указания типа возникшей ошибки элемент управления должен передать код ошибки в `ThrowError` или `FireError`.  Код ошибки OLE код состояния, который имеет значение 32 бит.  Если возможно, выберите код ошибки из стандартного набора кодов, определенных в файле заголовка OLECTL.H.  В следующей таблице перечислены эти коды.  
  
### Коды ошибок элемент управления ActiveX  
  
|Ошибка|Описание|  
|------------|--------------|  
|**CTL\_E\_ILLEGALFUNCTIONCALL**|Недопустимый вызов функции|  
|**CTL\_E\_OVERFLOW**|Переполнение|  
|**CTL\_E\_OUTOFMEMORY**|Недостаточно памяти|  
|**CTL\_E\_DIVISIONBYZERO**|Деление на ноль|  
|**CTL\_E\_OUTOFSTRINGSPACE**|Не хватает строки|  
|**CTL\_E\_OUTOFSTACKSPACE**|Из пространство стека|  
|**CTL\_E\_BADFILENAMEORNUMBER**|Имя файла или число таких|  
|**CTL\_E\_FILENOTFOUND**|Файл не найден|  
|**CTL\_E\_BADFILEMODE**|Недопустимый файловый режим|  
|**CTL\_E\_FILEALREADYOPEN**|Файл уже открытого|  
|**CTL\_E\_DEVICEIOERROR**|Ошибка ВВОДА\-ВЫВОДА устройства|  
|**CTL\_E\_FILEALREADYEXISTS**|Файл уже существует|  
|**CTL\_E\_BADRECORDLENGTH**|Неверная рекордная длина|  
|**CTL\_E\_DISKFULL**|Нет места на диске.|  
|**CTL\_E\_BADRECORDNUMBER**|Неправильное количество record|  
|**CTL\_E\_BADFILENAME**|Неправильное имя файла|  
|**CTL\_E\_TOOMANYFILES**|Слишком много файлов|  
|**CTL\_E\_DEVICEUNAVAILABLE**|Отсутствует устройство|  
|**CTL\_E\_PERMISSIONDENIED**|Отказанное разрешение|  
|**CTL\_E\_DISKNOTREADY**|Диск не готово|  
|**CTL\_E\_PATHFILEACCESSERROR**|Путь или ошибка доступа к файлу|  
|**CTL\_E\_PATHNOTFOUND**|Путь не найден|  
|**CTL\_E\_INVALIDPATTERNSTRING**|Недопустимая строка шаблона|  
|**CTL\_E\_INVALIDUSEOFNULL**|Недопустимое использование NULL|  
|**CTL\_E\_INVALIDFILEFORMAT**|Недопустимый формат файла|  
|**CTL\_E\_INVALIDPROPERTYVALUE**|Недопустимое значение свойства|  
|**CTL\_E\_INVALIDPROPERTYARRAYINDEX**|Недопустимый индекс массива свойства|  
|**CTL\_E\_SETNOTSUPPORTEDATRUNTIME**|Набор не поддерживается во время выполнения|  
|**CTL\_E\_SETNOTSUPPORTED**|Не поддерживается набор \(свойство только для чтения\)|  
|**CTL\_E\_NEEDPROPERTYARRAYINDEX**|Индекс массива свойства необходимости|  
|**CTL\_E\_SETNOTPERMITTED**|Не разрешается набор|  
|**CTL\_E\_GETNOTSUPPORTEDATRUNTIME**|Получение не поддерживаемых во время выполнения|  
|**CTL\_E\_GETNOTSUPPORTED**|Получение не поддерживаемых \(доступное только на запись свойство\)|  
|**CTL\_E\_PROPERTYNOTFOUND**|Не найдены свойство|  
|**CTL\_E\_INVALIDCLIPBOARDFORMAT**|Недопустимый формат буфера обмена|  
|**CTL\_E\_INVALIDPICTURE**|Недопустимый рисунок|  
|**CTL\_E\_PRINTERERROR**|Ошибка принтера|  
|**CTL\_E\_CANTSAVEFILETOTEMP**|Не удается сохранить файл в TEMP|  
|**CTL\_E\_SEARCHTEXTNOTFOUND**|Не найдены текста поиска|  
|**CTL\_E\_REPLACEMENTSTOOLONG**|Слишком длинное.|  
  
 При необходимости используйте макрос **CUSTOM\_CTL\_SCODE**, чтобы определить пользовательский код ошибки для условия, не описаны одним из стандартных кодов.  Параметр для этого макроса должен быть целым числом от 1000 до 32767, включительно.  Примеры.  
  
 [!code-cpp[NVC_MFC_AxUI#37](../mfc/codesnippet/CPP/mfc-activex-controls-advanced-topics_4.cpp)]  
  
 Если создается элемент управления ActiveX, чтобы заменить существующий элемент управления VBX, укажите собственные коды ошибок элемент управления ActiveX с теми же числовыми значениями управление VBX используется, чтобы гарантировать, что коды ошибок совместимы.  
  
##  <a name="_core_handling_special_keys_in_your_control"></a> Обработка специальные ключи в элементе управления  
 В некоторых случаях может потребоваться обрабатывать некоторые сочетания клавиш особым образом. например, вставьте новую линию, если была нажата клавиша ВВОД будет в многострочных элементе управления или движении текстового поля между группой в составе элементы управления "Поле ввода" при дирекционное идентификатор ключа отжало.  
  
 Если базовый класс элемента управления ActiveX `COleControl`, можно переопределить [CWnd::PreTranslateMessage](../Topic/CWnd::PreTranslateMessage.md) для обработки сообщений перед их процессами контейнера.  При использовании этого метода, всегда возвращается значение **TRUE** при обработке сообщения в переопределении `PreTranslateMessage`.  
  
 В следующем примере кода демонстрируется способ возможности обрабатывать все связанные сообщения в дирекционным ключи.  
  
 [!code-cpp[NVC_MFC_AxUI#38](../mfc/codesnippet/CPP/mfc-activex-controls-advanced-topics_5.cpp)]  
  
 Дополнительные сведения об обработке интерфейсы клавиатуры для элементов управления ActiveX см. в документации по пакету SDK ActiveX.  
  
##  <a name="_core_accessing_dialog_controls_that_are_invisible_at_run_time"></a> Доступ к элементам управления диалогового окна, невидимы во время выполнения  
 Можно создать элементы управления диалогового окна, не оказывают интерфейс пользователя и невидимы во время выполнения.  При добавлении незримое во время выполнения элемента управления ActiveX в диалоговое окно и используется [CWnd::GetDlgItem](../Topic/CWnd::GetDlgItem.md), чтобы получить доступ к элементу управления, элемент управления не будет работать правильно.  Вместо этого следует использовать один из следующих методов, чтобы получить объект, представляющий элемент управления.  
  
-   С помощью мастера добавления переменной\-члена, выберите **Переменная элемента управления**, а затем выбирает идентификатор элемента управления.  Введите имя переменной и выделите класс\-оболочка элемента управления как **Тип элемента управления**.  
  
     – или –  
  
-   Объявите локальную переменную и подклассы как элемент диалогового окна.  Вставьте код, который похож на \(`CMyCtrl` класс\-оболочка, `IDC_MYCTRL1` идентификатор элемента управления\).  
  
     [!code-cpp[NVC_MFC_AxCont#19](../mfc/codesnippet/CPP/mfc-activex-controls-advanced-topics_6.cpp)]  
  
## См. также  
 [Элементы управления ActiveX MFC](../mfc/mfc-activex-controls.md)