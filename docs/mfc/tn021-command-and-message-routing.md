---
title: 'Команда TN021: Маршрутизация и сообщений | Документы Microsoft'
ms.custom: ''
ms.date: 06/28/2018
ms.technology:
- cpp-mfc
ms.topic: conceptual
f1_keywords:
- vc.routing
dev_langs:
- C++
helpviewer_keywords:
- TN021
- command routing [MFC], technical note TN021
- Windows messages [MFC], routing
ms.assetid: b5952c8b-123e-406c-a36d-a6ac7c6df307
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: e31a35878564fc09fa6c045566811a3ff9e4b0ef
ms.sourcegitcommit: 208d445fd7ea202de1d372d3f468e784e77bd666
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/29/2018
ms.locfileid: "37122021"
---
# <a name="tn021-command-and-message-routing"></a>TN021. Маршрутизация команд и сообщений

> [!NOTE]
>  Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

Эта заметка описывает команда архитектура маршрутизации и диспетчеризации, а также дополнительные разделы в общие окно маршрутизации сообщений.

Обратитесь к Visual C++ для Общие сведения об архитектурах, описанные здесь, особенно различие между Windows сообщения уведомления элементов управления и команд. Эта заметка предполагается знакомым с проблем, описанных в документации по печати и только адреса очень сложные вопросы.

## <a name="command-routing-and-dispatch-mfc-10-functionality-evolves-to-mfc-20-architecture"></a>Маршрутизация команд и диспетчеризации MFC 1.0 функции развития с MFC 2.0 архитектуры

В Windows есть сообщения WM_COMMAND, перегружен, чтобы предоставлять уведомления команды меню, сочетания клавиш и уведомлений элементов управления диалогового окна.

1.0 с MFC лежит, немного, позволяя обработчик команд (например, «OnFileNew») `CWnd` производного класса, чтобы получить вызывается в ответ на определенные WM_COMMAND. Это клееных вместе со структурой данных, называется схему сообщений и приводит к очень эффективно пространства команда механизм.

1.0 с MFC предоставляет также дополнительные функциональные возможности для разделения уведомления элементов управления из сообщения команд. Команды представлены по Идентификатору 16-разрядное, которую иногда называют ИД команды. Запуск команды `CFrameWnd` (выберите меню или переведенные accelerator) и будут направляться на множество других окон.

MFC 1.0 используется маршрутизация команд в ограниченной степени для реализации объекта многодокументного интерфейса (MDI). (Окне фрейма MDI делегировать команды, чтобы его активной дочерней MDI-формы окна).

Эта функциональность были обобщены, расширенных 2.0 MFC, чтобы разрешить выполнение команд может быть обработано более широкого круга объектов (не только окно). Он обеспечивает более формальных и расширяемую архитектуру для маршрутизации сообщений и использует ее целевой маршрутизации не только обработки команд, но и для обновления объектов пользовательского интерфейса (например, пункты меню и кнопки панели инструментов) в соответствии с текущей доступности команды .

## <a name="command-ids"></a>Идентификаторы команд

Visual C++ см. описание команды маршрутизации и процесс привязки. [Техническое Примечание 20](../mfc/tn020-id-naming-and-numbering-conventions.md) содержит сведения об именовании Идентификаторов.

Универсальный префикс «ID_» используется для идентификаторов команд. Идентификаторы команд, > = 0x8000. Сообщения строки или строки состояния отобразит строку описания команды существует ли ресурс STRINGTABLE с те же идентификаторы, как идентификатор команды.

В ресурсы приложения команды, которую можно идентификатор отображается в нескольких местах:

-   В один STRINGTABLE ресурс, который имеет тот же идентификатор, как запрашивать строки сообщения.

-   В возможно много ресурсов меню, подключенные к пунктам меню, которые вызывают одной команде.

-   (ДОПОЛНИТЕЛЬНО) в диалоговом окне кнопку команды GOSUB.

В исходном коде приложения команды, которую можно идентификатор отображается в нескольких местах:

-   В РЕСУРСЕ. H (или другие главного файла символов заголовков) для определения идентификаторов команд конкретного приложения.

-   ВОЗМОЖНО, в массив идентификатор, используемый для создания панели инструментов.

-   В ON_COMMAND-макрос.

-   ВОЗМОЖНО в ON_UPDATE_COMMAND_UI-макрос.

В настоящее время это единственная реализация в MFC, который требует идентификаторы команд быть > = 0x8000 является реализацией GOSUB диалоговые окна и команды.

## <a name="gosub-commands-using-command-architecture-in-dialogs"></a>GOSUB команд, с помощью команды архитектуры в диалоговых окнах

Команда архитектура маршрутизации и включение команд хорошо работает с фреймов, пункты меню, кнопки панели инструментов, кнопки диалоговой панели, других панелей элементов управления и других элементов пользовательского интерфейса, предназначенных для обновления по запросу и маршрутизации команд или идентификаторы элемента управления в главное целевой объект команды (обычно фрейма главного окна). Нацеленные основную команду может маршрутизации уведомлений команда или элемент управления в другие целевые объекты команды, соответствующим образом.

Диалоговое окно (модальные и немодальные) могут использовать преимущества некоторых функций архитектуры команда идентификатор элемента управления диалогового окна управления назначается идентификатор соответствующие команды. Поддержка для диалоговых окон не выполняется автоматически, поэтому нужно написать дополнительный код.

Обратите внимание, для всех этих функций для правильной работы вашего идентификаторы команд должен быть > = 0x8000. Так как множество диалоговых окон могут перенаправляться одного кадра, общие команды должно быть > = 0x8000, хотя должен быть не совместно IDCs в конкретном диалоговом окне < = 0x7FFF.

Можно поместить обычная кнопка в обычном модального диалогового окна с IDC кнопки, задайте соответствующую команду. Когда пользователь выбирает кнопку, владелец диалоговое окно (обычно фрейма главного окна) получает команду, так же, как любые другие команды. Это называется GOSUB команду, так как он обычно используется для вызова другого диалогового (GOSUB первое диалоговое окно).

Можно также вызвать функцию `CWnd::UpdateDialogControls` на ваше диалоговое окно и передать ему адрес фрейма главного окна. Эта функция будет включить или отключить элементы управления диалогового окна зависимости от наличия у них обработчики команд в кадре. Эта функция вызывается автоматически для вас для панелей элементов управления в цикл простоя приложения, но вы должны вызывать непосредственно для обычных диалоговых окон, которые вы хотите иметь этот компонент.

## <a name="when-onupdatecommandui-is-called"></a>При вызове ON_UPDATE_COMMAND_UI

Поддержания состояния включена проверка пунктов меню программы постоянно может быть проблемой требовательных к вычислительным ресурсам. Методика — и Проверка включения элементов меню только в том случае, когда пользователь выбирает всплывающее ОКНО. Реализация MFC 2.0 `CFrameWnd` обрабатывает сообщение WM_INITMENUPOPUP и использует архитектура маршрутизации команд для определения состояния меню посредством ON_UPDATE_COMMAND_UI обработчиков.

`CFrameWnd` обрабатывает сообщение WM_ENTERIDLE для описания текущего выбранного элемента в строке (строке сообщения) состояния меню.

Структуре меню приложения, изменить с помощью Visual C++ используется для представления потенциальных команды, доступные во время WM_INITMENUPOPUP. Обработчики ON_UPDATE_COMMAND_UI можно изменить состояние или текст элемента меню или для расширенного использования (например, список последних Использованных файлов или всплывающего меню команд OLE), фактически следует изменить структуру меню перед рисованием меню.

Такого же типа ON_UPDATE_COMMAND_UI обработки выполняется для панели инструментов (и других панелей элементов управления) при приложение входит в его пустых циклов. В разделе *Справочник по библиотеке классов* и [Технические заметки 31](../mfc/tn031-control-bars.md) Дополнительные сведения о панели элементов управления.

## <a name="nested-pop-up-menus"></a>Вложенные всплывающие меню

При использовании структуры вложенные меню можно заметить, что обработчик ON_UPDATE_COMMAND_UI для первого элемента меню во всплывающем меню вызывается в двух разных случаях.

Во-первых он вызывается для самого всплывающего меню. Это необходимо, поскольку всплывающих меню не имеют идентификаторов, и мы используем идентификатор первого элемента меню из контекстного меню для ссылки на весь во всплывающем меню. В этом случае *m_pSubMenu* переменной-члена `CCmdUI` объект будет иметь значение NULL и будет пункты контекстного меню.

Во-вторых он вызывается непосредственно перед, во всплывающем меню пункты меню для отображения. В этом случае идентификатор ссылается только на первый элемент меню и *m_pSubMenu* переменной-члена `CCmdUI` объект будет иметь значение NULL.

Это дает возможность включить всплывающего меню, отличающийся от элементами меню, но необходимо написать определенный код виду меню. Например в вложенные меню со следующей структурой:

```Output
File>
    New>
    Sheet (ID_NEW_SHEET)
    Chart (ID_NEW_CHART)
```

Команды ID_NEW_SHEET и ID_NEW_CHART можно независимо включить или отключить. **New** всплывающего меню должен быть включен, если один из двух включен.

Обработчик команд для ID_NEW_SHEET (первая команда во всплывающем) будет выглядеть примерно так:

```cpp
void CMyApp::OnUpdateNewSheet(CCmdUI* pCmdUI)
{
    if (pCmdUI->m_pSubMenu != NULL)
    {
        // enable entire pop-up for "New" sheet and chart
        BOOL bEnable = m_bCanCreateSheet || m_bCanCreateChart;
        // CCmdUI::Enable is a no-op for this case, so we
        // must do what it would have done.
        pCmdUI->m_pMenu->EnableMenuItem(pCmdUI->m_nIndex,
            MF_BYPOSITION | 
            (bEnable  MF_ENABLED : (MF_DISABLED | MF_GRAYED)));

        return;
    }
    // otherwise just the New Sheet command
    pCmdUI->Enable(m_bCanCreateSheet);
}
```

Обработчик команд для ID_NEW_CHART будет обработчик команд обычного обновления и что-то наподобие вид:

```cpp
void CMyApp::OnUpdateNewChart(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_bCanCreateChart);
}
```

## <a name="oncommand-and-onbnclicked"></a>ON_COMMAND и ON_BN_CLICKED

Макросы схемы сообщений для **ON_COMMAND** и **ON_BN_CLICKED** совпадают. MFC управления маршрутизации механизм уведомлений использует только идентификатор команды для выбора для маршрутизации. Управлять уведомления с кодом уведомления управления равно нулю (**BN_CLICKED**), интерпретируется как команды.

> [!NOTE]
> На самом деле все уведомляющих сообщений элемента управления перейдите по цепочке обработчика команд. Например, можно писать обработчика уведомлений элемента управления для **EN_CHANGE** в классе документа. Это не обычно рекомендуется, так как несколько вариантов практического применения этой функции, функция не поддерживается в ClassWizard и использование функции может привести к уязвимости кода.

## <a name="disabling-the-automatic-disabling-of-button-controls"></a>Отключение автоматического отключение элемента управления Button

Если поместить элемент управления "Кнопка" на панели диалогового окна или в диалоговом окне, где с помощью вызова **CWnd::UpdateDialogControls** самостоятельно, вы заметите, кнопки, которые не имеют **ON_COMMAND** или **ON_UPDATE_COMMAND_UI** обработчики автоматически отключаются автоматически платформой. В некоторых случаях не потребуется имеется обработчик, но требуется, чтобы оставить включенным. Для этого проще всего добавить обработчик фиктивный команды (легко сделать с помощью классов) и не выполняют никаких действий, в нем.

## <a name="window-message-routing"></a>Маршрутизация сообщений окна

Ниже описаны некоторые более сложные вопросы на классы MFC и маршрутизация сообщений Windows и другим темам влияние их. Только кратко описывается здесь информации. Ссылаться на *Справочник по библиотеке классов* для получения сведений об открытых API. См. исходный код библиотеки MFC, Дополнительные сведения о реализации.

См. в [Технические заметки 17](../mfc/tn017-destroying-window-objects.md) сведения об окне очистки, раздел очень важен для всех **CWnd**-производные классы.

## <a name="cwnd-issues"></a>Проблемы CWnd

Функция-член реализацию **CWnd::OnChildNotify** предоставляет мощный и расширяемая архитектура, для дочерних окон (также известные как элементы управления) и подключить или в противном случае будет получать уведомления об сообщений, команд и элементов управления уведомления, перейдите к их родительским (или «владелец»). Если дочернее окно (/ управления) является C++ **CWnd** объекта, виртуальная функция **OnChildNotify** сначала вызывается с параметрами из исходного сообщения (то есть **MSG**структуры). Дочернее окно сообщения не изменяйте, eat его или измените текст сообщения для родительского элемента (редко).

Значение по умолчанию **CWnd** реализация обрабатывает следующие сообщения и использует **OnChildNotify** ловушка разрешить дочернего окна (элементы управления) в первом доступе сообщения:

- **WM_MEASUREITEM** и **WM_DRAWITEM** (для самостоятельной рисования)

- **WM_COMPAREITEM** и **WM_DELETEITEM** (для самостоятельной рисования)

- **WM_HSCROLL** и **WM_VSCROLL**

- **WM_CTLCOLOR**

- **WM_PARENTNOTIFY**

Обратите внимание, **OnChildNotify** обработчик используется для изменения сообщения рисования владельцем в самостоятельно нарисовать сообщения.

В дополнение к **OnChildNotify** обработчика, имеют сообщения прокрутки дальнейшей пересылки поведение. См. ниже дополнительные сведения о источники и полос прокрутки **WM_HSCROLL** и **WM_VSCROLL** сообщений.

## <a name="cframewnd-issues"></a>Проблемы CFrameWnd

**CFrameWnd** класс предоставляет большинство маршрутизация команд и пользовательский интерфейс обновления реализации. Это в первую очередь для фрейма главного окна приложения (**CWinApp::m_pMainWnd**), но применяется для всех фреймов.

Главное окно — окно с меню и является родителем строки состояния или сообщений строки. См. в описании выше по маршрутизация команд и **WM_INITMENUPOPUP.**

**CFrameWnd** класс обеспечивает управление активное представление. Следующие сообщения маршрутизируются через активное представление:

- Все сообщения команды (активное представление возвращает первый доступ к ним).

- **WM_HSCROLL** и **WM_VSCROLL** отображаются сообщения из того же уровня полосы (см. ниже).

- **WM_ACTIVATE** (и **WM_MDIACTIVATE** для MDI) получить преобразуются в вызовы виртуальной функции **CView::OnActivateView**.

## <a name="cmdiframewndcmdichildwnd-issues"></a>CMDIFrameWnd-CMDIChildWnd проблемы

Классы окна фрейма обеих MDI являются производными от **CFrameWnd** и поэтому разрешены для такого же типа маршрутизация команд и обновление пользовательского интерфейса, предоставляемые в **CFrameWnd**. В типичном приложении MDI фрейма главного окна (то есть **CMDIFrameWnd** объекта) содержит строки меню и строки состояния и, следовательно, является основным источником реализацию маршрутизации команд.

Общие маршрутизации схема — что активную дочернюю MDI получает первый доступ к командам. Значение по умолчанию **PreTranslateMessage** функции обрабатывают таблицы сочетаний клавиш для обоих дочерних окон интерфейса MDI (first) и фрейма MDI (второго), а также стандартные команды системы акселераторы MDI, обычно обрабатываются с  **TranslateMDISysAccel** (последней).

## <a name="scroll-bar-issues"></a>Проблемы полосы прокрутки

При обработке сообщения прокрутки (**WM_HSCROLL**/**OnHScroll** и/или **WM_VSCROLL**/**OnVScroll**), следует написать код обработчика, он не зависит от происхождения строки сообщений прокрутки. Это не только общие Windows проблема, поскольку сообщения прокрутки могут поступать из true прокрутки панели элементов управления или из **WS_HSCROLL**/**WS_VSCROLL** не являющиеся элементов управления полосы прокрутки полосы прокрутки.

Расширяет возможности MFC, чтобы разрешить для элементов управления полосы прокрутки как дочерний или одноуровневых элементов с возможностью прокрутки окна (на самом деле иерархическое отношение между полосы прокрутки и возможностью прокрутки окна может быть никаких действий). Это особенно важно для полос прокрутки общего с окна разделителей. Обратитесь к [Технические заметки 29](../mfc/tn029-splitter-windows.md) сведения о реализации **CSplitterWnd** Включение Дополнительные сведения на общих проблем панель прокрутки.

На заметку, имеется два **CWnd** производные классы, где стили полосы прокрутки, указанный во время создания перехват и не передаются в Windows. При передаче в процедуре создания **WS_HSCROLL** и **WS_VSCROLL** может устанавливаться независимо друг от друга, но после создания невозможно изменить. Конечно непосредственно не следует тестирования или задать количество бит WS_SCROLL стиль окна, которое они созданы.

Для **CMDIFrameWnd** стили полосы прокрутки, переданного **создать** или **LoadFrame** используются для создания MDICLIENT. Если вы хотите иметь прокручиваемой MDICLIENT области (такие как программы диспетчера) необходимо задать оба полосы прокрутки стили (**WS_HSCROLL** &#124; **WS_VSCROLL**) для стиль, используемый для создания **CMDIFrameWnd**.

Для **CSplitterWnd** применить стили полосы прокрутки для полосы прокрутки специальные общие для областей разделителей. Для окна со статическим разделителем обычно не сможет задать стиль панели либо прокрутки. Для окна с динамическим разделителем, обычно имеют прокрутка набор стилей для направления будет разделить, то есть **WS_HSCROLL** возможность распределения строк, **WS_VSCROLL** возможность распределения столбцов.

## <a name="see-also"></a>См. также

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)  
[Технические примечания по категории](../mfc/technical-notes-by-category.md)  
