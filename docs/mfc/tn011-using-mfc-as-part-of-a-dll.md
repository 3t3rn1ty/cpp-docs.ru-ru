---
title: 'TN011: Использование MFC как часть библиотеки DLL | Документы Microsoft'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-mfc
ms.topic: conceptual
f1_keywords:
- vc.mfc.dll
dev_langs:
- C++
helpviewer_keywords:
- _USRDLL symbol
- USRDLLs, compiler switches
- TN011
- DLLs [MFC], linking
- MFC DLLs [MFC], linking regular MFC DLLs to MFC
ms.assetid: 76753e9c-59dc-40f6-b6a7-f6bb9a7c4190
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 0b558bb373416338f4136a6142ca6d491b28b510
ms.sourcegitcommit: c6b095c5f3de7533fd535d679bfee0503e5a1d91
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/26/2018
ms.locfileid: "36951462"
---
# <a name="tn011-using-mfc-as-part-of-a-dll"></a>TN011. Использование MFC как часть библиотеки DLL
Эта заметка описывает обычные библиотеки DLL MFC, которая позволяет использовать библиотеку MFC как часть библиотеки динамической компоновки (DLL) Windows. Предполагается, что вы знакомы с библиотеки DLL Windows, а также способы их построения. Сведения о библиотеках расширения MFC, с помощью которого можно создавать расширения для библиотеки MFC, см. [версии библиотеки DLL MFC](../mfc/tn033-dll-version-of-mfc.md).  
  
## <a name="dll-interfaces"></a>Интерфейсы библиотеки DLL  
 обычные библиотеки DLL MFC Предположим, указанные в функции в стиле C или явно экспортируемые классы интерфейсы между приложением и библиотеки DLL. Не удается экспортировать интерфейсы классов MFC.  
  
 Если требуется использовать MFC библиотеки DLL и приложения, как был на использование либо общедоступной версии библиотек MFC или статическое связывание копии библиотек. Приложения и библиотеки DLL могут оба используйте одну из стандартных версии библиотеки MFC.  
  
 обычные библиотеки DLL MFC имеют несколько преимуществ:  
  
-   Приложение, которое использует библиотеку DLL, не нужно использовать MFC и не должен быть приложения Visual C++.  
  
-   С обычные библиотеки DLL MFC, статическая компоновка с MFC размер DLL зависит только от MFC и C процедур среды выполнения, используемых и связанные.  
  
-   С обычные библиотеки DLL MFC, динамически связываются с MFC экономия места в памяти с помощью общедоступной версии MFC может оказаться значительным. Тем не менее, необходимо распространить общих библиотек DLL Mfc*\<версии >* DLL- и Msvvcrt*\<версии >*.dll, библиотеки DLL.  
  
-   Проект библиотеки DLL не зависит от реализации классов. Проект библиотеки DLL экспортирует только к API требуется. Поэтому при изменении реализации обычные библиотеки DLL MFC действительны.  
  
-   С помощью обычных библиотек DLL MFC, статическая компоновка с MFC Если библиотека DLL и приложения MFC, нет никаких проблем с приложением, которое требуется другая версия MFC DLL или наоборот. Так как библиотеки MFC статически связанная с каждой библиотеки DLL или EXE, нет без сомнения относительно версии у вас есть.  
  
## <a name="api-limitations"></a>Ограничения API  
 Некоторые функции MFC не применяется к DLL-версии, либо из-за технических ограничений или потому, что эти службы обычно предоставляются приложением. С помощью текущей версии MFC является единственной функцией, не применяется `CWinApp::SetDialogBkColor`.  
  
## <a name="building-your-dll"></a>Построение библиотеки DLL  
 При компиляции обычные библиотеки DLL MFC, статическая компоновка с MFC, символы `_USRDLL` и `_WINDLL` должен быть определен. Код библиотеки DLL, также должны быть скомпилированы с следующие параметры компилятора:  
  
- **/ D_WINDLL** означает компиляции библиотеки DLL  
  
- **/ D_USRDLL** указывает построении обычной DLL MFC  
  
 Необходимо также определить эти символы и использовать эти параметры компилятора при компиляции обычные библиотеки DLL MFC, динамически связываются с MFC. Кроме того, символ `_AFXDLL` должны быть определены и код библиотеки DLL должна быть скомпилирована с:  
  
- **/ D_AFXDLL** указывает, что построении обычной MFC DLL, динамически связанной с MFC  
  
 Необходимо явным образом экспортировать интерфейсов (API) между приложением и библиотеки DLL. Рекомендуется определить интерфейсы, чтобы быть низкой пропускной способностью и использовать только интерфейсы C, если это возможно. Прямой C интерфейсы являются проще, чем более сложные классы C++.  
  
 Поместите собственные интерфейсы API в отдельном заголовок, который может быть включено с файлами C и C++. Заголовок ScreenCap.h в образце Дополнительные понятия MFC в статье [DLLScreenCap](../visual-cpp-samples.md) в качестве примера. Чтобы экспортировать свои функции, введите их в `EXPORTS` разделе файла определения модуля (. DEF) или включать `__declspec(dllexport)` на определениях функций. Используйте `__declspec(dllimport)` для импорта этих функций в исполняемый файл клиента.  
  
 Необходимо добавить макрос AFX_MANAGE_STATE в начале экспортируемых функций в обычных библиотеках DLL MFC, который динамически связываются с MFC. Этот макрос задает текущее состояние модуля одну библиотеку DLL. Чтобы использовать этот макрос, добавьте следующую строку кода в начало функции, экспортированные из библиотеки DLL:  
  
 `AFX_MANAGE_STATE(AfxGetStaticModuleState( ))`  
  
## <a name="winmain---dllmain"></a>WinMain -> DllMain  
 Библиотека MFC определяет стандартные Win32 `DllMain` точки входа, который инициализирует вашей [CWinApp](../mfc/reference/cwinapp-class.md) производный объект как стандартное приложение MFC. Поместите все инициализации библиотеки DLL в [InitInstance](../mfc/reference/cwinapp-class.md#initinstance) метода, как показано типичное приложение MFC.  
  
 Обратите внимание, что [CWinApp::Run](../mfc/reference/cwinapp-class.md#run) механизм не применяется к библиотеке DLL, поскольку приложение, которому принадлежит основной конвейер сообщений. Если библиотека DLL отображает немодальные диалоговые окна или имеет собственный фрейм окна, приложения цикла обработки сообщений необходимо вызвать процедуру экспорта библиотеки DLL, которая вызывает [CWinApp::PreTranslateMessage](../mfc/reference/cwinapp-class.md#pretranslatemessage).  
  
 См. в образце DLLScreenCap для использования этой функции.  
  
 `DllMain` Функция, которая предоставляет MFC вызывает [CWinApp::ExitInstance](../mfc/reference/cwinapp-class.md#exitinstance) метод класса, который является производным от `CWinApp` перед выгрузкой библиотеки DLL.  
  
## <a name="linking-your-dll"></a>Компоновка библиотеки DLL  
 Обычные библиотеки DLL MFC, статическая компоновка с MFC необходимо связывать библиотеки DLL с Nafxcwd.lib или Nafxcw.lib и версии среды выполнения C, с именем библиотеки Libcmt.lib. Эти библиотеки представляют собой готовые и могут быть установлены, указав их при запуске программы установки Visual C++.  
  
## <a name="sample-code"></a>Пример кода  
 См. в образце MFC Дополнительные понятия программирования DLLScreenCap полный пример. Ниже приведены несколько интересных фактов в этом примере следует обратить внимание.  
  
-   Флаги компилятора библиотеки DLL и приложение отличаются.  
  
-   Линии связи и. DEF-файлы для библиотеки DLL, так и для приложения отличаются.  
  
-   Приложение, которое использует библиотеку DLL не обязательно в C++.  
  
-   Интерфейс между приложением и библиотеки DLL — это API, можно использовать в C или C++ и экспортируется с DLLScreenCap.def.  
  
 В следующем примере демонстрируется API, который определен в обычной MFC DLL, статически связанной с MFC. В этом примере объявление заключено в `extern "C" { }` блок для пользователей C++. Это имеет несколько преимуществ. Во-первых он делает собственные интерфейсы API библиотеки DLL можно использовать не C++ клиентскими приложениями. Во-вторых она сокращает количество служебных DLL, так как C++ искажение имени не будут применяться к экспортируемое имя. Наконец, он упрощает явным образом добавить. (Для экспорта по порядковому номеру) файла DEF, не беспокоясь о искажение имени.  
  
```  
#ifdef __cplusplus  
extern "C" {  
#endif  /* __cplusplus */  
 
struct TracerData  
{  
    BOOL bEnabled;  
    UINT flags;  
};  
 
BOOL PromptTraceFlags(TracerData FAR* lpData);

 
#ifdef __cplusplus  
}  
#endif  
```  
  
 Структуры, используемые API не являются производными от классов MFC и определяются в заголовке API. Это снижает сложность интерфейс между приложения и библиотеки DLL и делает DLL может использоваться программами C.  
  
## <a name="see-also"></a>См. также  
 [Технические примечания по номеру](../mfc/technical-notes-by-number.md)   
 [Технические примечания по категории](../mfc/technical-notes-by-category.md)

