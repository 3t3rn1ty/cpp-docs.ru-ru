---
title: 'TN006: Схемы сообщений | Документы Microsoft'
ms.custom: ''
ms.date: 06/25/2018
ms.technology:
- cpp-mfc
ms.topic: conceptual
f1_keywords:
- vc.messages.maps
dev_langs:
- C++
helpviewer_keywords:
- ON_UPDATE_COMMAND_UI macro [MFC]
- ON_NOTIFY_RANGE macro [MFC]
- ON_COMMAND macro [MFC]
- ON_CONTROL_RANGE macro [MFC]
- ON_REGISTERED_MESSAGE macro [MFC]
- ON_NOTIFY message [MFC]
- ON_COMMAND_RANGE_EX macro [MFC]
- ON_MESSAGE macro [MFC]
- Windows messages [MFC], message maps
- ON_COMMAND_RANGE macro [MFC]
- TN006
- ON_CONTROL macro [MFC]
- ON_COMMAND_EX macro [MFC]
- message maps [MFC], Windows messaging
ms.assetid: af4b6794-4b40-4f1e-ad41-603c3b7409bb
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 2c4bc820c6b54e055235c1bd29bd55ccfc032c92
ms.sourcegitcommit: 208d445fd7ea202de1d372d3f468e784e77bd666
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/29/2018
ms.locfileid: "37121680"
---
# <a name="tn006-message-maps"></a>TN006. Схемы сообщений

Эта заметка описывает функцию карты сообщений MFC.

## <a name="the-problem"></a>Проблема

Microsoft Windows реализует виртуальные функции в классы окон, использующие его средства обмена сообщениями. Из-за большого числа сообщений, участвующих предоставление отдельные виртуальные функции для каждого сообщения Windows создаст чрезмерно большим vtable.

Так как количество системных сообщений Windows меняются с течением времени, и потому, что приложения могут определять свои собственные сообщения Windows, схемы сообщений обеспечивают уровень косвенности, который предотвращает изменения интерфейса нарушения существующего кода.

## <a name="overview"></a>Обзор

MFC предоставляет альтернативный способ для оператора switch, который использовался в традиционных программ Windows для обработки сообщений, отправляемых в окно. Сопоставление сообщений методов можно задать, чтобы автоматически при получении сообщения окна, вызывается соответствующий метод. Эта функция позволяет схемы сообщений разработан напоминают виртуальные функции, но обеспечивает дополнительные преимущества, невозможно использовать с виртуальными функциями C++.

## <a name="defining-a-message-map"></a>Определение схемы сообщений

[DECLARE_MESSAGE_MAP](reference/message-map-macros-mfc.md#declare_message_map) макрос объявляет три члена класса.

- Вызывается частного массива записей AFX_MSGMAP_ENTRY *_messageEntries*.

- Защищенная структура AFX_MSGMAP вызывается *messageMap* , указывающий *_messageEntries* массива.

- Защищенная виртуальная функция, вызываемая `GetMessageMap` , возвращает адрес *messageMap*.

Этот макрос должен быть помещен в объявлении класса, с помощью схемы сообщений. По соглашению это в конце объявления класса. Пример:

```cpp
class CMyWnd : public CMyParentWndClass
{
    // my stuff...

protected:
    //{{AFX_MSG(CMyWnd)
    afx_msg void OnPaint();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};
```

Это формат, созданные AppWizard и ClassWizard при создании новых классов. / / {{И / или}} квадратные скобки необходимы для классов.

Таблицы в схеме сообщений определяется с помощью набор макросов, которые можно развернуть для записи схемы сообщений. Таблица начинается со [BEGIN_MESSAGE_MAP](reference/message-map-macros-mfc.md#begin_message_map) вызов макроса, который определяет класс, которое обрабатывается этой схеме сообщений и родительского класса, на который передаются необработанных сообщений. Таблица заканчивается [END_MESSAGE_MAP](reference/message-map-macros-mfc.md#end_message_map) вызов макроса.

Между вызовами этих двух макрос — это запись для каждого сообщения должны обрабатываться этой схеме сообщений. Каждый стандартных сообщений Windows имеют макрос формы ON_WM_*MESSAGE_NAME* , создает запись для этого сообщения.

Подпись стандартной функции был определен для распаковки параметров каждого сообщения Windows и обеспечивая безопасность типов. Эти подписи можно найти в файле Afxwin.h в объявлении объекта [CWnd](../mfc/reference/cwnd-class.md). Каждый из них помечен с помощью ключевого слова **afx_msg** для упрощения идентификации.

> [!NOTE]
> Мастер классов необходимо использовать **afx_msg** ключевое слово в объявлениях обработчика сообщений карты.

 Эти функции подписи был получен с помощью простого соглашения. Имя функции всегда начинается с `"On`». Это следуют имя Windows для этого сообщения WM_» «удалить и первой буквы каждого слова прописными буквами. Порядок параметров имеет *wParam* следуют `LOWORD`(*lParam*) затем `HIWORD`(*lParam*). Неиспользуемые параметры не передаются. Все дескрипторы, которые являются оболочкой для классов MFC, преобразуются в указатели на соответствующие объекты MFC. Приведенный ниже показано, как обрабатывать сообщения WM_PAINT и привести к `CMyWnd::OnPaint` вызывать функцию:

```cpp
BEGIN_MESSAGE_MAP(CMyWnd, CMyParentWndClass)
    //{{AFX_MSG_MAP(CMyWnd)
    ON_WM_PAINT()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
```

 Таблица карты сообщений должны быть определены за пределами области любого определения класса или функции. Его не следует размещать в блоке extern «C».

> [!NOTE]
> ClassWizard изменит записи схемы сообщений, которые происходят между / / {{и / или}} комментарий квадратную скобку.

## <a name="user-defined-windows-messages"></a>Определяемые пользователем сообщения Windows

Пользовательские сообщения могут быть включены в схему сообщений с помощью [ON_MESSAGE](reference/message-map-macros-mfc.md#on_message) макрос. Этот макрос принимает номер сообщения и метод формы:

```cpp
    // inside the class declaration
    afx_msg LRESULT OnMyMessage(WPARAM wParam, LPARAM lParam);

    #define WM_MYMESSAGE (WM_USER + 100)

BEGIN_MESSAGE_MAP(CMyWnd, CMyParentWndClass)
    ON_MESSAGE(WM_MYMESSAGE, OnMyMessage)
END_MESSAGE_MAP()
```

В этом примере мы устанавливаем обработчик пользовательского сообщения, которое не является Идентификатором сообщения Windows, производный от стандартной базового WM_USER для определяемых пользователем сообщений. В следующем примере показано, как вызывать этот обработчик:

```cpp
CWnd* pWnd = ...;
pWnd->SendMessage(WM_MYMESSAGE);
```

Диапазон определяемых пользователем сообщений, использующих этот подход должен быть в диапазоне от WM_USER до 0x7fff.

> [!NOTE]
> Мастер классов не поддерживает ввод процедуры обработчика ON_MESSAGE из классов пользовательского интерфейса. Необходимо вручную ввести их в редакторе Visual C++. Мастер классов проанализирует эти записи и позволяют просматривать их так же, как другие записи схемы сообщений.

## <a name="registered-windows-messages"></a>Сообщения Windows зарегистрированного

[RegisterWindowMessage](http://msdn.microsoft.com/library/windows/desktop/ms644947) функция используется для определения нового сообщение окна, которое гарантированно будет уникальным во всей системе. Макрос ON_REGISTERED_MESSAGE используется для обработки этих сообщений. Этот макрос принимает имя *UINT РЯДОМ* переменную, которая содержит идентификатор сообщения зарегистрированных windows. Пример

```cpp
class CMyWnd : public CMyParentWndClass
{
public:
    CMyWnd();

    //{{AFX_MSG(CMyWnd)
    afx_msg LRESULT OnFind(WPARAM wParam, LPARAM lParam);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

static UINT NEAR WM_FIND = RegisterWindowMessage("COMMDLG_FIND");

BEGIN_MESSAGE_MAP(CMyWnd, CMyParentWndClass)
    //{{AFX_MSG_MAP(CMyWnd)
    ON_REGISTERED_MESSAGE(WM_FIND, OnFind)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
```

Зарегистрированный идентификатор переменная Windows сообщения (WM_FIND в этом примере), должна иметь *NEAR* переменной из-за способа реализации ON_REGISTERED_MESSAGE.

Диапазон пользовательские сообщения, использующие этот подход будет находиться в диапазоне 0xC000 до 0xFFFF.

> [!NOTE]
> Мастер классов не поддерживает ввод процедуры обработчика ON_REGISTERED_MESSAGE из классов пользовательского интерфейса. Необходимо вручную ввести их из текстового редактора. Мастер классов проанализирует эти записи и позволяют просматривать их так же, как другие записи схемы сообщений.

## <a name="command-messages"></a>Сообщения команд

Схемы сообщений с ON_COMMAND-макрос обрабатываются сообщения команд из меню и сочетания клавиш. Этот макрос принимает идентификатор команды и метод. Только определенные сообщения WM_COMMAND с *wParam* равно указанную команду идентификатор обрабатывается методом, указанным в записи схемы сообщений. Функции-члены обработчика команды не принимают никаких параметров и возвращает **void**. Макрос имеет следующий вид:

```cpp
ON_COMMAND(id, memberFxn)
```

Команда обновления сообщения маршрутизируются через тот же механизм, но вместо этого использовать макрос ON_UPDATE_COMMAND_UI. Функции-члены обработчика команд обновления принимать единственный параметр, указатель на [CCmdUI](../mfc/reference/ccmdui-class.md) и возвращать **void**. Макрос имеет форму

```cpp
ON_UPDATE_COMMAND_UI(id, memberFxn)
```

Опытные пользователи могут использовать ON_COMMAND_EX-макрос, являющегося расширенной формы сообщения обработчиков команд. Макрос содержит надмножество ON_COMMAND функциональные возможности. Функции-члены расширенного обработчика команд принимать единственный параметр, **UINT** , содержащее идентификатор команды и возвращать **BOOL**. Возвращаемое значение должно быть **TRUE** для указания обработки команды. В противном случае маршрутизации продолжит другие целевые объекты команды.

Примеры этих форм.

- Внутри Resource.h (как правило, создаются средой Visual C++)

    ```cpp
    #define    ID_MYCMD      100
    #define    ID_COMPLEX    101
    ```

- Внутри объявления класса

    ```cpp
    afx_msg void OnMyCommand();
    afx_msg void OnUpdateMyCommand(CCmdUI* pCmdUI);
    afx_msg BOOL OnComplexCommand(UINT nID);
    ```

- Внутри определения схемы сообщений

    ```cpp
    ON_COMMAND(ID_MYCMD, OnMyCommand)
    ON_UPDATE_COMMAND_UI(ID_MYCMD, OnUpdateMyCommand)
    ON_COMMAND_EX(ID_MYCMD, OnComplexCommand)
    ```

- В файле реализации

    ```cpp
    void CMyClass::OnMyCommand()
    {
        // handle the command
    }

    void CMyClass::OnUpdateMyCommand(CCmdUI* pCmdUI)
    {
        // set the UI state with pCmdUI
    }

    BOOL CMyClass::OnComplexCommand(UINT nID)
    {
        // handle the command
        return TRUE;
    }
    ```

 Опытные пользователи может обрабатывать широкий набор команд с помощью одной команды обработчика: [ON_COMMAND_RANGE](reference/message-map-macros-mfc.md#on_command_range) или ON_COMMAND_RANGE_EX. Дополнительные сведения об этих макросах см.

> [!NOTE]
> Мастер классов поддерживает создание ON_COMMAND и ON_UPDATE_COMMAND_UI обработчики, но не поддерживает создание ON_COMMAND_EX или ON_COMMAND_RANGE обработчиков. Тем не менее мастер классов синтаксического анализа и позволяют Обзор всех четырех команд обработчик вариантов.

## <a name="control-notification-messages"></a>Уведомляющие сообщения элементов управления

Сообщения, отправленные из дочерних элементов управления в окно установлен дополнительный бит информации в своих сообщений сопоставить запись: идентификатор элемента управления. Обработчик сообщений, указанной в элемент карты сообщений вызывается только в том случае, если выполняются следующие условия:

- Код уведомления элемента управления (старшее слово *lParam*), например BN_CLICKED, соответствует код уведомления, указанным в записи схемы сообщений.

- Идентификатор элемента управления (*wParam*) совпадает с Идентификатором элемента управления, указанным в схеме сообщений операции.

Уведомляющие сообщения пользовательского элемента управления может использовать [ON_CONTROL](reference/message-map-macros-mfc.md#on_control) макрос для определения записи карты сообщение с кодом настраиваемое уведомление. Этот макрос имеет форму

```cpp
ON_CONTROL(wNotificationCode, id, memberFxn)
```

Для использования дополнительных [ON_CONTROL_RANGE](reference/message-map-macros-mfc.md#on_control_range) может использоваться для обработки уведомления из диапазона элементов управления с такой же обработчик конкретного элемента управления.

> [!NOTE]
> Мастер классов не поддерживает создание обработчика ON_CONTROL или ON_CONTROL_RANGE в пользовательском интерфейсе. Необходимо вручную ввести их с помощью текстового редактора. Мастер классов проанализирует эти записи и позволяют просматривать их так же, как другие записи схемы сообщений.

Общие элементы управления Windows использовать более мощного [WM_NOTIFY](http://msdn.microsoft.com/library/windows/desktop/bb775583) уведомлений сложном элементе управления. Эта версия MFC имеет прямую поддержку этого нового сообщения с помощью макросов ON_NOTIFY и ON_NOTIFY_RANGE. Дополнительные сведения об этих макросах см.

## <a name="see-also"></a>См. также

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)  
[Технические примечания по категории](../mfc/technical-notes-by-category.md)  
