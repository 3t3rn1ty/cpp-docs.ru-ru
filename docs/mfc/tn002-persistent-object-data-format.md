---
title: "TN002. Формат данных постоянного объекта | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "vc.data"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "CArchive - класс, поддержка постоянных данных"
  - "постоянные объекты C++"
  - "данные постоянных объектов"
  - "TN002"
  - "VERSIONABLE_SCHEMA - макрос"
ms.assetid: 553fe01d-c587-4c8d-a181-3244a15c2be9
caps.latest.revision: 22
caps.handback.revision: 18
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# TN002. Формат данных постоянного объекта
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Эта заметка описаны процедуры MFC, поддерживающие постоянные объекты C\+\+ формат данных объекта, если они хранятся в файле.  Это применяется только к классам с макросами [DECLARE\_SERIAL](../Topic/DECLARE_SERIAL.md) и [IMPLEMENT\_SERIAL](../Topic/IMPLEMENT_SERIAL.md).  
  
## Проблема  
 Реализация MFC для упорных данных хранилищ данных для различных объектов в одной непрерывной части файла.  Метод `Serialize` объекта преобразует данные объекта в компактный бинарный формат.  
  
 Реализация гарантирует, что все данные сохраняются в том же формате с помощью [CArchive Class](../mfc/reference/carchive-class.md).  Она использует объект `CArchive` как переводчику.  Этот объект сохраняется от времени создается до тех пор, пока не будет вызван [CArchive::Close](../Topic/CArchive::Close.md).  Этот метод может быть назван явно или неявно программистом или деструктором при выходы программы область, которая содержит `CArchive`.  
  
 Эта заметка описывается реализация членов [CArchive::ReadObject](../Topic/CArchive::ReadObject.md) и [CArchive::WriteObject](../Topic/CArchive::WriteObject.md)`CArchive`.  Как только код этих функций в Arcobj.cpp и основной реализацией для `CArchive` в Arccore.cpp.  Код пользователя не вызывает `ReadObject` и `WriteObject` напрямую.  Вместо этого эти объекты используются вставкой и операторов извлечения для класса типобезопасной, которые были автоматически созданы макросами `DECLARE_SERIAL` и `IMPLEMENT_SERIAL`.  В следующем коде показано, как `WriteObject` и `ReadObject` неявно называются:  
  
```  
class CMyObject : public CObject  
{  
    DECLARE_SERIAL(CMyObject)  
};  
  
IMPLEMENT_SERIAL(CMyObj, CObject, 1)  
  
// example usage (ar is a CArchive&)  
CMyObject* pObj;  
CArchive& ar;  
ar << pObj;        // calls ar.WriteObject(pObj)  
ar >> pObj;        // calls ar.ReadObject(RUNTIME_CLASS(CObj))  
```  
  
## Сохранение объекты в хранилище CArchive::WriteObject \(\)  
 Метод `CArchive::WriteObject` записывает сведения заголовка, которые используются для этой объект.  Эти данные состоит из 2 частей: тип объекта и состояние объекта.  Этот метод также отвечает за обслуживание идентификатора объекта записываются out, чтобы только один экземпляр будет сохранен, независимо от количества указателей на объект \(включая допускается указатели\).  
  
 Сохранить \(вставка\) и восстановлении объектов \(\) для извлечения основаны на нескольких «очевидных констант.» Эти значения, хранящиеся в бинарный и содержат важные сведения архив \(обратите внимание, что префикс «w» отображается 16 разрядные числа\).  
  
|Tag|Описание|  
|---------|--------------|  
|wNullTag|Используется для указателей пустой объект \(0\).|  
|wNewClassTag|Указывает, что описание класса, заново применяются к этому контексту архива \(\- 1\).|  
|wOldClassTag|Указывает, что класс, читанным объекта было показано в данном контексте \(0x8000\).|  
  
 Храните объекты, архив поддерживает [CMapPtrToPtr](../mfc/reference/cmapptrtoptr-class.md) \( `m_pStoreMap`\), сопоставление из сохраненного объекта в 32 разрядному постоянное идентификатор \(PID\).  PID присваивается каждому уникальный объект и каждому уникального имени класса, сохраненные в контексте архива.  Вручают этим PIDs out последовательно запустить из 1.  Эти PIDs не имеет никакой значение вне области архива и, в частности, не следует путать с рекордными числом или другими элементами идентификатора.  
  
 В классе `CArchive`, PIDs 32 бита, но они написаны, как 16, если только они не являются более 0x7FFE.  Большие PIDs записываются как 0x7FFF за 32 разрядным PID.  Это обеспечивает совместимость с проектами, созданных в предыдущих версиях.  
  
 При создании запроса сохранить объект в архив \(обычно с помощью глобального оператора вставки\), проверка выполняется для указателя NULL [CObject](../Topic/CObject%20Class.md).  Если указатель NULL, `wNullTag` вставляется в поток архива.  
  
 Если указатель NOT NULL и может быть сериализуется \(класс `DECLARE_SERIAL` \), проверки кода `m_pStoreMap` для просмотра сохранен ли объект уже.  Если он имеет, код вставляет 32 — PID, связанный с этим объектом в поток архива.  
  
 Если объект не был сохранен, до 2 возможности, которые нужно учитывать: или и объект и точный тип \(класс\) объекта новыми к этому контексту архива или объекта явного уже увиденного типа.  Определить, является ли тип увиден, запросы кода `m_pStoreMap` для объекта [CRuntimeClass](../Topic/CRuntimeClass%20Structure.md), соответствующее объект `CRuntimeClass`, связанного с сохраняемого объекта.  Если совпадение, `WriteObject` вставляет тег, 32\-разрядные мудрое `OR``wOldClassTag` и этого индекса.  Если `CRuntimeClass` также к этому контексту архива, `WriteObject` присвоить новый PID к этому классу и вставляет его в архив, предшествуемый `wNewClassTag` значение.  
  
 Дескриптор этого класса затем вставляется в архив с помощью метода `CRuntimeClass::Store`.  `CRuntimeClass::Store` вставляет число схемы \(см. ниже\) класса и имени класса текста ASCII.  Обратите внимание, что использование имени текста ASCII не гарантирует уникальность архива в различных приложениях.  Поэтому следует тег файлы данных во избежание повреждения.  После вставки данных класса, архив помещает объект в `m_pStoreMap` и затем вызывает метод `Serialize`, чтобы вставить данные для класса.  Параметр объекта в `m_pStoreMap` перед вызовом `Serialize` предотвращает несколько копий объекта из сохранены в хранилище.  
  
 Возврат в первоначальный вызывающий объект \(обычно корня сети объектов\), необходимо вызвать метод [CArchive::Close](../Topic/CArchive::Close.md).  Если планируется выполнить другие операции [CFile](../mfc/reference/cfile-class.md) необходимо вызвать метод [Приток](../Topic/CArchive::Flush.md)`CArchive`, чтобы предотвратить повреждение архива.  
  
> [!NOTE]
>  Эта реализация вызывает трудное ограничение индексов 0x3FFFFFFE на контекст архива.  Это значение представляет максимальное число уникальных объектов и классов, которые можно сохранить в одном журнала, но один дисковый файл может иметь неограниченное число контекстов архива.  
  
## Объекты загрузки из магазином \(CArchive::ReadObject\)  
 Загрузки \(извлекая\) объекты с помощью метода `CArchive::ReadObject` и converse `WriteObject`.  Как и `WriteObject`, `ReadObject` не вызывается напрямую кодом пользователя; код пользователя должен вызвать типобезопасный оператор извлечения, вызывающий `ReadObject` с ожиданным `CRuntimeClass`.  Это обеспечивает целостность типа операции риск.  
  
 Поскольку реализация `WriteObject` ей повышение PIDs, начиная с 1 \(0 предопределено как пустой объект\), реализация `ReadObject` может использовать массив для поддержания состояния контекста архива.  Когда PID прочитан из магазина, если PID больше текущей верхняя граница `m_pLoadArray`, `ReadObject` знает, что новый объект \(или описание класса\) используется.  
  
## Номера схемы  
 Номер, присвоенный схемы, класс при достижении метод `IMPLEMENT_SERIAL` класса, «версия» реализации класса.  Схема ссылается на реализации класса, а не на количество раз данный объект был сделан упорным \(обычно с именем версии объекта\).  
  
 Если планируется поддерживать несколько различных реализаций того же класса с течением времени, увеличить схему как была пересмотрена реализация метода `Serialize` объекта класса позволит возможность писать код, который может загрузить объекты, который хранит с помощью прежних версий реализации.  
  
 Метод [CArchiveException](../mfc/reference/carchiveexception-class.md)`CArchive::ReadObject` возникает при обнаружении номер схемы в постоянном магазине, отличающегося от числа описания схемы классов в памяти.  Не легко восстановить из этого исключения.  
  
 Можно использовать `VERSIONABLE_SCHEMA`, объединенным с \(побитовое `OR`\) версией схемы для упрощения этого исключения с делегатом.  С помощью `VERSIONABLE_SCHEMA`, код может принимать соответствующие действия в своей функции `Serialize` путем проверки возвращаемое значение в [CArchive::GetObjectSchema](../Topic/CArchive::GetObjectSchema.md).  
  
## Сериализует непосредственно вызывать  
 Во многих случаях нагрузка общей схемы архива объекта `WriteObject` и `ReadObject` не требуется.  Это общий случай сериализации данных в [CDocument](../Topic/CDocument%20Class.md).  В этом случае метод `Serialize``CDocument` вызывается сразу, а не с операторами извлекать или вставки.  Содержимое документа в свою очередь, могут использовать более общую схему архива объекта.  
  
 Вызов `Serialize` непосредственно имеет следующие преимущества и недостатки:  
  
-   Использование дополнительных байтов не добавляются в архив до или после объект сериализуется.  Это не только в сохраненных данных более маленьким, но позволяет реализовать процедуры `Serialize`, могут обрабатывать все форматы файлов.  
  
-   MFC настроен таким образом реализации `WriteObject` и `ReadObject` и связанные коллекции не передается в приложение, если это не требуется более общую схему архива объекта для определенной других целях.  
  
-   Код не должен выйти из старых чисел схемы.  Это делает код сериализации документа ответственным для кодирования числа схем, номер версии формата файла или все идентификационные номера используется в начале файлов данных.  
  
-   Любой объект, который сериализует с прямым вызовом `Serialize` использовать `CArchive::GetObjectSchema` или обработки возвращаемое значение \(UINT\) — 1, что версия была неизестна.  
  
 Поскольку `Serialize` вызывается непосредственно в документе, обычно это невозможно для вложенных объектов документа к ссылкам архива к их родительскому документ.  Эти объекты должны быть указатель на их документ контейнера явным образом или необходимо использовать функцию [CArchive::MapObject](../Topic/CArchive::MapObject.md) для сопоставления указатель `CDocument` в PID до задние эти указатели архивированы.  
  
 Как было сказано выше, должны самостоятельно писать сведения о версии и класса при вызове `Serialize` непосредственно, позволяя необходимо изменить формат позже в то же время хранить обратную совместимость с более старыми файлами.  Функция `CArchive::SerializeClass` можно явно вызывать непосредственно перед сериализации объекта или до вызова базового класса.  
  
## См. также  
 [Технические примечания по номеру](../mfc/technical-notes-by-number.md)   
 [Технические примечания по категории](../mfc/technical-notes-by-category.md)