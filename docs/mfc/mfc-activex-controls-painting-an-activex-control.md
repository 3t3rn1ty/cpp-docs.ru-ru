---
title: "Элементы управления ActiveX в MFC. Закраска элементов управления ActiveX | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "MFC ActiveX - элементы управления, оптимизация"
  - "MFC ActiveX - элементы управления, рисование"
ms.assetid: 25fff9c0-4dab-4704-aaae-8dfb1065dee3
caps.latest.revision: 10
caps.handback.revision: 6
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Элементы управления ActiveX в MFC. Закраска элементов управления ActiveX
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Этот раздел описывает процесс рисования элементов управления ActiveX и как можно изменить код рисования, чтобы оптимизировать процесс. \(См. [Оптимизировать рисование элементов управления](../mfc/optimizing-control-drawing.md) для методов, как оптимизировать рисование не содержать элементы управления по отдельности восстановление ранее выбранные объекты GDI.  После того как все элементы управления, вычерченны контейнер может автоматически восстановить исходные объекты\).  
  
 Примеры в этой статье от элемента управления, созданного мастером элемента управления ActiveX MFC с параметрами по умолчанию.  Дополнительные сведения о создании схемы приложение элемента управления с помощью мастера элементов управления ActiveX MFC см. в статье [Мастер элементов ActiveX MFC](../mfc/reference/mfc-activex-control-wizard.md).  
  
 В следующих разделах рассмотрены:  
  
-   [Общий процесс для заливки фона элемента управления и код, созданными с помощью мастера элементов управления ActiveX для поддержки рисование](#_core_the_painting_process_of_an_activex_control)  
  
-   [Как оптимизировать процесс рисования](#_core_optimizing_your_paint_code)  
  
-   [Как элемент управления с помощью рисование метафайлов](#_core_painting_your_control_using_metafiles)  
  
##  <a name="_core_the_painting_process_of_an_activex_control"></a> Процесс рисования элементов управления ActiveX  
 Если элементы управления ActiveX отображаются исходная или перерисовать, они подчиняются процесс рисования аналогично другим приложениям начатым использование MFC, одним важным отличием: Элементы управления ActiveX могут находиться в активном или неактивном состоянии.  
  
 Активный элемент управления представлен в контейнере элементов управления ActiveX дочерние окна.  Как и другие окна, он отвечает за рисование при `WM_PAINT` получено сообщение.  Базовый класс элемента управления, [COleControl](../mfc/reference/colecontrol-class.md) обрабатывает это сообщение в своей функции `OnPaint`.  Эта реализация по умолчанию вызывает функцию `OnDraw` элемента управления.  
  
 Неактивный элемент управления создается по\-разному.  Если элемент управления бездействия, его окно или незаметного или ее, поэтому он не может получить сообщение изображения.  Вместо этого контейнер элементов управления непосредственно вызывает функцию `OnDraw` элемента управления.  Это отличается от процесса рисования активным элементом управления тем, что функция\-член `OnPaint` никогда не вызывается.  
  
 Как описано в предыдущих абзацах, как элемент управления ActiveX обновляется зависит от состояния элемента управления.  Однако поскольку платформа вызывает функцию\-член `OnDraw` в обоих случаях необходимо добавить большая часть кода рисования в этом функции\-члене.  
  
 Функция\-член `OnDraw` обрабатывает изображение элемента управления.  Если элемент управления бездействия, контейнер элементов управления вызывает `OnDraw`, передавая контекст устройства контейнера элементов управления и координаты занятой прямоугольной области элемента управления.  
  
 Прямоугольник, передаваемый платформой в функцию\-член `OnDraw` содержит область занятую элементом управления.  Если элемент управления активен, верхний левый угол \(0, 0\), и контекст устройства для дочернего окна, содержащего элемент управления.  Если элемент управления бездействия, то верхняя левая координата не обязательно \(0, 0\), и контекст устройства для контейнера элементов управления, содержащую элемент управления.  
  
> [!NOTE]
>  Важно, чтобы изменения `OnDraw`  не зависят от точки прямоугольника верхней левой, равно 0 \(0\), а также создаваемые только внутри прямоугольника, переданного в `OnDraw`.  Непредвиденные результаты могут возникать при рисовании прямоугольника, области.  
  
 По умолчанию предоставленная мастером реализация элемента управления ActiveX MFC в файле реализации элемента управления \(CPP\), показанном ниже, рисует прямоугольник с белой кистью и заливка эллипса с текущим цветом фона.  
  
 [!code-cpp[NVC_MFC_AxUI#1](../mfc/codesnippet/CPP/mfc-activex-controls-painting-an-activex-control_1.cpp)]  
  
> [!NOTE]
>  Рисования элемента управления, не следует делать предположения о состоянии контекста устройства, передается в качестве параметра *pdc* функции `OnDraw`.  Иногда контекст устройства предоставляется из приложения контейнера и не обязательно будет инициализирован в состояние по умолчанию.  В частности, явно выделите перья, кисти цвета, шрифты и другие ресурсы, код рисования зависит от.  
  
##  <a name="_core_optimizing_your_paint_code"></a> Оптимизировать код рисования  
 После того как элемент управления рисует успешно, следующим шагом является оптимизированной функции `OnDraw`.  
  
 Реализация по умолчанию элемент управления ActiveX рисования рисования весь участок регулирования.  Для этого достаточно простых элементов управления но во многих случаях обновление элемент управления будет быстрее, если только часть, необходимое обновление обновления, вместо всех элементов управления.  
  
 Функция `OnDraw` предоставляет удобный метод оптимизации путем передачи `rcInvalid`, прямоугольную область элемента управления, которому необходимо перерисовки.  Эта область, обычно более чем все небольшой участок регулирования, чтобы ускорить процесс рисования.  
  
##  <a name="_core_painting_your_control_using_metafiles"></a> Элемент управления с помощью рисование метафайлов  
 В большинстве случаев параметр `pdc` функции `OnDraw` указывает на контекст устройства \(DC\) экрана.  Однако при печати изображения элемента управления или во время сеанса предварительного просмотра, DC полученное для отрисовки вызывается особый тип «DC метафайла».  В отличие от DC экрана, непосредственно обрабатывает запросы, отправленные в него DC метафайла хранят запросы, воспроизведенным обратно позднее.  Некоторые приложение\-контейнеры могут выбрать изображение отрисовки элемента управления с помощью DC метафайлов в режиме конструктора.  
  
 Запросы рисование метафайлов может быть сделан контейнером до 2 функции интерфейса: **IViewObject::Draw** \(этой функции можно вызвать для рисования не метафайла\) и **IDataObject::GetData**.  При DC метафайла передается в качестве одного из параметров платформа MFC выполняется вызов [COleControl::OnDrawMetafile](../Topic/COleControl::OnDrawMetafile.md).  Поскольку это виртуальная функция\-член, переопределите этой функции в обработке задачи класса элемента управления все специальные.  Реакция на событие по умолчанию вызывает `COleControl::OnDraw`.  
  
 Убедиться в элемент управления можно создавать и на экране и контексты устройств метафайла, необходимо использовать только функции\-члены, поддерживаются в экране, так и в DC метафайлов.  Следует помнить, что система координат, не может быть измерена в пикселях.  
  
 Поскольку реализация по умолчанию `OnDrawMetafile` вызывает функцию `OnDraw` элемента управления используется только в функциях\-членах, можно использовать как для метафайла, так и для контекста устройства экрана, если не переопределено `OnDrawMetafile`.  Ниже перечислены некоторые функции\-члены `CDC`, которые можно использовать в метафайле, так и в контексте устройства экрана.  Дополнительные сведения об этих функциях см. в описании класса [CDC](../Topic/CDC%20Class.md) в *справочнике по MFC*.  
  
|Дуги|BibBlt|Хорда|  
|----------|------------|-----------|  
|**Эллипс**|**Escape\-символ**|`ExcludeClipRect`|  
|`ExtTextOut`|`FloodFill`|`IntersectClipRect`|  
|`LineTo`|`MoveTo`|`OffsetClipRgn`|  
|`OffsetViewportOrg`|`OffsetWindowOrg`|`PatBlt`|  
|`Pie`|**Polygon**|`Polyline`|  
|`PolyPolygon`|`RealizePalette`|`RestoreDC`|  
|`RoundRect`|`SaveDC`|`ScaleViewportExt`|  
|`ScaleWindowExt`|`SelectClipRgn`|`SelectObject`|  
|`SelectPalette`|`SetBkColor`|`SetBkMode`|  
|`SetMapMode`|`SetMapperFlags`|`SetPixel`|  
|`SetPolyFillMode`|`SetROP2`|`SetStretchBltMode`|  
|`SetTextColor`|`SetTextJustification`|`SetViewportExt`|  
|`SetViewportOrg`|`SetWindowExt`|`SetWindowORg`|  
|`StretchBlt`|`TextOut`||  
  
 В дополнение к функциям элемента `CDC` существует несколько других функций, которые совместимы в DC метафайлов.  Они включают [CPalette::AnimatePalette](../Topic/CPalette::AnimatePalette.md), [CFont::CreateFontIndirect](../Topic/CFont::CreateFontIndirect.md) и 3 функции\-члена `CBrush`: [CreateBrushIndirect](../Topic/CBrush::CreateBrushIndirect.md), [CreateDIBPatternBrush](../Topic/CBrush::CreateDIBPatternBrush.md) и [CreatePatternBrush](../Topic/CBrush::CreatePatternBrush.md).  
  
 Функции, не записываются в метафайле: [DrawFocusRect](../Topic/CDC::DrawFocusRect.md), [DrawIcon](../Topic/CDC::DrawIcon.md), [DrawText](../Topic/CDC::DrawText.md), [ExcludeUpdateRgn](../Topic/CDC::ExcludeUpdateRgn.md), [FillRect](../Topic/CDC::FillRect.md), [FrameRect](../Topic/CDC::FrameRect.md), [GrayString](../Topic/CDC::GrayString.md), [InvertRect](../Topic/CDC::InvertRect.md), [ScrollDC](../Topic/CDC::ScrollDC.md) и [TabbedTextOut](../Topic/CDC::TabbedTextOut.md).  Поскольку DC метафайла фактически не связано с устройством, нельзя использовать SetDIBits, GetDIBits и CreateDIBitmap с DC метафайлов.  Можно использовать SetDIBitsToDevice и StretchDIBits с DC метафайлов в качестве назначения.  [CreateCompatibleDC](../Topic/CDC::CreateCompatibleDC.md)[CreateDiscardableBitmap](../Topic/CBitmap::CreateDiscardableBitmap.md), [CreateCompatibleBitmap](../Topic/CBitmap::CreateCompatibleBitmap.md) и не имеют смысла с DC метафайлов.  
  
 Другая точка, когда использовать DC метафайла, что система координат, не может быть измерена в пикселях.  По этой причине весь код рисования должен быть изменен в соответствии с в прямоугольник, переданный `OnDraw`  в параметре `rcBounds`.  Это предотвращает случайное рисование вне элемента управления, так как `rcBounds` представляет размер окна элемента управления.  
  
 После реализации отрисовку метафайла служат для элемента управления используется тестовый контейнер для выполнения метафайл.  Сведения о доступе к тестовому контейнеру см. в разделе [Тестирование свойств и событий при помощи тестового контейнера](../mfc/testing-properties-and-events-with-test-container.md).  
  
#### Выполнить метафайл элемента управления с помощью тестового контейнера  
  
1.  В меню  **Изменить** тестового контейнера, щелкните **Вставьте новый элемент управления.**  
  
2.  В окне **Вставьте новый элемент управления.**  выберите элемент управления и нажмите **ОК**.  
  
     Элемент управления отобразится в тестовый контейнер.  
  
3.  В меню **Управление**  выберите пункт **Метафайл рисования**.  
  
     Отдельное окно. при этом метафайл.  Можно изменить размер этого окна, чтобы увидеть, как влияет на метафайл масштабирование элемента управления.  Можно закрыть это окно в любое время.  
  
## См. также  
 [Элементы управления ActiveX MFC](../mfc/mfc-activex-controls.md)