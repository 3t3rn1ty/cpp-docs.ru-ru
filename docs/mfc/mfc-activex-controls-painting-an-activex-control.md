---
title: 'Элементы управления ActiveX MFC: Закраска элементов управления ActiveX | Документы Microsoft'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-mfc
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- MFC ActiveX controls [MFC], painting
- MFC ActiveX controls [MFC], optimizing
ms.assetid: 25fff9c0-4dab-4704-aaae-8dfb1065dee3
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: de12a21c4b411f3cd1fe25d7d6badd8d26318351
ms.sourcegitcommit: 060f381fe0807107ec26c18b46d3fcb859d8d2e7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/25/2018
ms.locfileid: "36929816"
---
# <a name="mfc-activex-controls-painting-an-activex-control"></a>Элементы управления ActiveX в MFC. Закраска элементов управления ActiveX
Эта статья описывает процесс рисования элемента управления ActiveX и как можно изменить код прорисовки для оптимизации процесса. (См. [оптимизация рисования элементов управления](../mfc/optimizing-control-drawing.md) для методик по оптимизации рисования, не выполняя элементов управления по отдельности восстановить ранее выбранные объекты GDI. После рисования всех элементов управления контейнера можно автоматически восстановить исходные объекты.)  
  
 В этой статье приведены из элемента управления, созданные с помощью мастера элементов управления ActiveX MFC с параметрами по умолчанию. Дополнительные сведения о создании приложений каркас управления с помощью мастера элементов управления ActiveX MFC см. в статье [мастер элементов управления ActiveX MFC](../mfc/reference/mfc-activex-control-wizard.md).  
  
 Рассматриваются следующие вопросы:  
  
-   [Общий процесс для прорисовки элемента управления и код, созданный с помощью мастера элементов управления ActiveX для поддержки рисования](#_core_the_painting_process_of_an_activex_control)  
  
-   [Как оптимизировать процесс рисования](#_core_optimizing_your_paint_code)  
  
-   [Как для закрашивания элемента управления с помощью векторными изображениями](#_core_painting_your_control_using_metafiles)  
  
##  <a name="_core_the_painting_process_of_an_activex_control"></a> Процесс рисования элемента управления ActiveX  
 Элементы управления ActiveX, изначально отображаются или перерисовываются, они следуют рисования так же как и для других приложений, использующих MFC, с одно важное различие: элементы управления ActiveX могут находиться в активное или неактивное состояние.  
  
 Активный элемент управления представляется в контейнере элементов управления ActiveX, дочернее окно. Как и других окнах он отвечает за рисование сам при получении сообщения WM_PAINT. Базовый класс элемента управления, [COleControl](../mfc/reference/colecontrol-class.md), обрабатывает это сообщение в его `OnPaint` функции. По умолчанию реализация вызывает `OnDraw` функции элемента управления.  
  
 Неактивный элемент управления отрисовывается по-разному. Если элемент управления неактивен, его окна или имеет значение невидимой несуществующей, не может получать сообщения рисования. Вместо этого контейнера управления напрямую вызывает `OnDraw` функции элемента управления. Это отличается от процесса рисования активный элемент управления в том, что `OnPaint` никогда не вызвать функцию-член.  
  
 Как отмечалось выше, обновление элемента управления ActiveX зависит от состояния элемента управления. Тем не менее так как платформа вызывает `OnDraw` функции-члена в обоих случаях можно добавить большая часть кода рисования в эту функцию-член.  
  
 `OnDraw` Функции-члена обрабатывает отрисовку элемента управления. Когда элемент управления неактивен, контейнер элемента управления вызывает `OnDraw`, передавая контекст устройства контейнера элемента управления и координаты прямоугольную область, занимаемая элементом управления.  
  
 Прямоугольник, переданный платформой для `OnDraw` функции-члена содержит область, занимаемая элементом управления. Если элемент управления является активным, верхнего левого угла — (0, 0) и переданного контекста устройства для дочернего окна, содержащего элемент управления. Если элемент управления становится неактивным, координаты левого верхнего не обязательно является (0, 0) и переданного контекста устройства для контейнера элемента управления, содержащего элемент управления.  
  
> [!NOTE]
>  Очень важно, изменения `OnDraw` не зависят от прямоугольника верхней левой точки которых равен (0, 0) и нарисовать только внутри прямоугольника передается `OnDraw`. Рисование за пределы прямоугольника может привести к непредвиденным результатам.  
  
 Реализация по умолчанию, мастер элементов управления ActiveX MFC в файле реализации элемента управления, предоставляемые (. CPP), показано ниже, рисует прямоугольник с белым кисти и выполняет заливку эллипса цветом фона.  
  
 [!code-cpp[NVC_MFC_AxUI#1](../mfc/codesnippet/cpp/mfc-activex-controls-painting-an-activex-control_1.cpp)]  
  
> [!NOTE]
>  При рисовании элемента управления, не следует делать предположений о состояние контекста устройства, которое передается как *pdc* параметр `OnDraw` функции. Иногда контекст устройства предоставляется приложением-контейнером и не обязательно появится в состояние по умолчанию. В частности явно выберите перья, кисти, цвета, шрифты и другие ресурсы, от которых зависит ваш код прорисовки.  
  
##  <a name="_core_optimizing_your_paint_code"></a> Оптимизация кода рисования  
 После элемента управления успешно Рисование сам, следующим шагом является оптимизация `OnDraw` функции.  
  
 Реализация по умолчанию закраска элементов управления ActiveX закрашивает область всего элемента управления. Этого достаточно для простых элементов управления, но во многих случаях перерисовки элемента управления будет быстрее, если только окрашивание часть, которая требуется обновление, а не всего элемента управления.  
  
 `OnDraw` Функция обеспечивает легкий метод оптимизации, передав *rcInvalid*, прямоугольную область элемента управления, который требуется перерисовка. Используйте эту область, обычно меньше всего элемента управления зоны, чтобы ускорить процесс рисования.  
  
##  <a name="_core_painting_your_control_using_metafiles"></a> Рисование элемента управления с помощью векторными изображениями  
 В большинстве случаев *pdc* параметр `OnDraw` функция указывает на контекст устройства экрана (DC). Тем не менее при печати изображения элемента управления или во время сеанса в режиме предварительного просмотра, контроллер домена получил для подготовки отчетов — это специальный тип, называется «метафайл контроллера домена». В отличие от экрана контроллера домена, который немедленно обрабатывает запросы, отправленные на него, запросы для последующего воспроизведения в дальнейшем хранятся метафайла контроллера домена. Некоторые приложения контейнера также может отображать изображения элемента управления с помощью метафайла контроллера домена в режиме конструктора.  
  
 Метафайл Рисование запросы могут выполнять контейнера через две функции интерфейса: `IViewObject::Draw` (эта функция может также вызываться для рисования не метафайл) и `IDataObject::GetData`. При метафайла, DC передается в качестве одного из параметров, платформа MFC вызывает [COleControl::OnDrawMetafile](../mfc/reference/colecontrol-class.md#ondrawmetafile). Поскольку это виртуальная функция-член, переопределите эту функцию в класс элемента управления для выполнения специальной обработки. Поведение по умолчанию вызывает `COleControl::OnDraw`.  
  
 Чтобы убедиться в том, что элемент управления можно рисовать экрана и метафайлов контексты устройств, необходимо использовать только функции-члены, поддерживаемые в экране и метафайла контроллера домена. Имейте в виду, что система координат, не может быть измеряется в пикселях.  
  
 Так как реализация по умолчанию `OnDrawMetafile` вызывает элемент управления `OnDraw` функции, используйте только функции-члены, которые можно метафайл и экран контекста устройства, если не переопределено `OnDrawMetafile`. В таблице ниже приведены подмножество `CDC` функций-членов, используемых в метафайл и на экране контекст устройства. Дополнительные сведения об этих функциях см. класс [CDC](../mfc/reference/cdc-class.md) в *Справочник по библиотеке MFC*.  
  
|Дуги|BibBlt|Сочетания|  
|---------|------------|-----------|  
|`Ellipse`|`Escape`|`ExcludeClipRect`|  
|`ExtTextOut`|`FloodFill`|`IntersectClipRect`|  
|`LineTo`|`MoveTo`|`OffsetClipRgn`|  
|`OffsetViewportOrg`|`OffsetWindowOrg`|`PatBlt`|  
|`Pie`|`Polygon`|`Polyline`|  
|`PolyPolygon`|`RealizePalette`|`RestoreDC`|  
|`RoundRect`|`SaveDC`|`ScaleViewportExt`|  
|`ScaleWindowExt`|`SelectClipRgn`|`SelectObject`|  
|`SelectPalette`|`SetBkColor`|`SetBkMode`|  
|`SetMapMode`|`SetMapperFlags`|`SetPixel`|  
|`SetPolyFillMode`|`SetROP2`|`SetStretchBltMode`|  
|`SetTextColor`|`SetTextJustification`|`SetViewportExt`|  
|`SetViewportOrg`|`SetWindowExt`|`SetWindowORg`|  
|`StretchBlt`|`TextOut`||  
  
 В дополнение к `CDC` функции-члены, существует несколько других функций, совместимых в метафайл контроллера домена. К ним относятся [CPalette::AnimatePalette](../mfc/reference/cpalette-class.md#animatepalette), [CFont::CreateFontIndirect](../mfc/reference/cfont-class.md#createfontindirect)и три функции-члены `CBrush`: [CreateBrushIndirect](../mfc/reference/cbrush-class.md#createbrushindirect), [CreateDIBPatternBrush](../mfc/reference/cbrush-class.md#createdibpatternbrush), и [CreatePatternBrush](../mfc/reference/cbrush-class.md#createpatternbrush).  
  
 Функции, которые не зарегистрированы в метафайл являются: [DrawFocusRect](../mfc/reference/cdc-class.md#drawfocusrect), [DrawIcon](../mfc/reference/cdc-class.md#drawicon), [DrawText](../mfc/reference/cdc-class.md#drawtext), [ExcludeUpdateRgn](../mfc/reference/cdc-class.md#excludeupdatergn), [FillRect](../mfc/reference/cdc-class.md#fillrect), [FrameRect](../mfc/reference/cdc-class.md#framerect), [GrayString](../mfc/reference/cdc-class.md#graystring), [InvertRect](../mfc/reference/cdc-class.md#invertrect), [ScrollDC](../mfc/reference/cdc-class.md#scrolldc)и [TabbedTextOut](../mfc/reference/cdc-class.md#tabbedtextout). Поскольку метафайла контроллера домена не связаны с устройством, нельзя использовать SetDIBits, GetDIBits и CreateDIBitmap с метафайла контроллера домена. Можно использовать SetDIBitsToDevice и StretchDIBits с метафайла контроллера домена в качестве цели. [CreateCompatibleDC](../mfc/reference/cdc-class.md#createcompatibledc), [CreateCompatibleBitmap](../mfc/reference/cbitmap-class.md#createcompatiblebitmap), и [CreateDiscardableBitmap](../mfc/reference/cbitmap-class.md#creatediscardablebitmap) не имеют смысла с метафайла контроллера домена.  
  
 Другой точки, которые необходимо учитывать при использовании метафайла контроллера домена — что системы координат, не может быть измеряется в пикселях. По этой причине все рисования кода следует скорректировать, чтобы поместиться в прямоугольник, передаваемый `OnDraw` в *rcBounds* параметра. Это предотвращает случайное рисования вне элемента управления, поскольку *rcBounds* представляет размер окна элемента управления.  
  
 После реализации метафайла отрисовки для элемента управления, используйте контейнер для тестирования метафайл. Сведения о том, как получить доступ к Контейнеру для тестирования, см. в разделе [Тестирование свойств и событий в Контейнере для тестирования](../mfc/testing-properties-and-events-with-test-container.md) .  
  
#### <a name="to-test-the-controls-metafile-using-test-container"></a>Чтобы проверить метафайла элемента управления с использованием тестового контейнера  
  
1.  На тестовый контейнер **изменить** меню, нажмите кнопку **вставить новый элемент управления**.  
  
2.  В **вставить новый элемент управления** , выберите элемент управления и нажмите кнопку **ОК**.  
  
     Элемент управления будет отображаться в тестовом контейнере.  
  
3.  На **управления** меню, нажмите кнопку **нарисовать метафайла**.  
  
     Отдельное окно отображается, в котором отображается метафайл. Можно изменить размер это окно, чтобы увидеть, как Масштабирование влияет метафайла элемента управления. Это окно можно закрыть в любое время.  
  
## <a name="see-also"></a>См. также  
 [Элементы ActiveX библиотеки MFC](../mfc/mfc-activex-controls.md)

