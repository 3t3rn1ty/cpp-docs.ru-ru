---
title: 'Сокеты Windows: Порядок байтов | Документы Microsoft'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-mfc
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- byte order issues in sockets programming
- sockets [MFC], byte order issues
- Windows Sockets [MFC], byte order issues
ms.assetid: 8a787a65-f9f4-4002-a02f-ac25a5dace5d
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 18fc3f586c7fc8861bfc29dade7b62e741bb0ffc
ms.sourcegitcommit: 76b7653ae443a2b8eb1186b789f8503609d6453e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
---
# <a name="windows-sockets-byte-ordering"></a>Сокеты Windows. Порядок байтов
В этой статье и в двух статей дополнительное приведены некоторые проблемы в программировании Windows Sockets. В этой статье описан порядок байтов. Другие проблемы рассматриваются в статьях: [Windows Sockets: блокирование](../mfc/windows-sockets-blocking.md) и [Windows Sockets: преобразование строки](../mfc/windows-sockets-converting-strings.md).  
  
 Если вы используете или являются производными от класса [CAsyncSocket](../mfc/reference/casyncsocket-class.md), потребуется самостоятельно управлять эти проблемы. Если вы используете или являются производными от класса [CSocket](../mfc/reference/csocket-class.md), MFC автоматически управляет ими.  
  
## <a name="byte-ordering"></a>Порядок байтов  
 Иногда разной архитектурой хранят данные, используя разный порядок байтов. Например компьютерах с процессорами Intel хранить данные в порядке, обратном машин Macintosh (Motorola). Порядок байтов Intel, называется «прямой порядок байтов,» также является обратной по отношению сети стандартный порядок «обратный». В следующей таблице описаны эти условия.  
  
### <a name="big--and-little-endian-byte-ordering"></a>И мало обратный порядок байтов  
  
|Порядок байтов|Смысл|  
|-------------------|-------------|  
|Обратный порядок байтов|На левой стороне слова — самый старший байт.|  
|Обратный порядок байтов|Самый старший байт — в правом конце слова.|  
  
 Как правило не нужно беспокоиться о преобразовании порядка следования байтов данных, отправку и прием по сети, но существуют ситуации, в которых необходимо преобразовать порядок байтов.  
  
## <a name="when-you-must-convert-byte-orders"></a>При выполнении преобразования порядок байтов  
 Необходимо преобразовать порядок байтов в следующих ситуациях:  
  
-   Вы передаете данные, необходимые для интерпретации в сети, а не данные, которые вы отправляете на другой компьютер. Например, можно передать порты и адреса, которые необходимо понять сети.  
  
-   Серверное приложение, с которым устанавливается соединение не является приложение MFC (и для него нет исходного кода). Это вызывает для преобразования порядка байтов, если две машины не используют совместно одинаковые порядок байтов.  
  
## <a name="when-you-do-not-have-to-convert-byte-orders"></a>Если вам не нужно выполнять преобразование порядок байтов  
 Не требуется выполнять действия по преобразованию порядок байтов в следующих ситуациях:  
  
-   Машины с обеих сторон можно условия не замены байт, и оба компьютера использовать одинаковый порядок следования байтов.  
  
-   На сервере, который используют для обмена данными является приложение MFC.  
  
-   У вас есть исходный код для сервера, который вы взаимодействует, поэтому можно определить явным образом ли порядок байтов необходимо преобразовать или нет.  
  
-   Можно перенести сервер с MFC. Это довольно просто, и результат обычно меньшие, более быстрый код.  
  
 Работа с [CAsyncSocket](../mfc/reference/casyncsocket-class.md), необходимо управлять любые необходимые порядка байтов преобразования самостоятельно. Сокеты Windows стандартизирует порядка следования байтов «big Endian» модели и предоставляет функции для преобразования между данного заказа и другими. [CArchive](../mfc/reference/carchive-class.md), тем не менее, используемый вместе с [CSocket](../mfc/reference/csocket-class.md), использует в обратном порядке («прямой порядок байтов»), но `CArchive` берет на себя процесс преобразования порядка следования байтов. Используя этот стандартный порядок сортировки в приложениях, или с помощью функции преобразования Windows Sockets порядка байтов, может сделать код более переносимым.  
  
 Является идеальным случаем использования сокеты MFC при написании обоих концах связи: Использование MFC на обоих концах. При написании приложения, которое будет взаимодействовать с приложений, не являющихся MFC, таких как FTP-сервера, возможно, потребуется управлять Смена байтов самостоятельно прежде чем передать данные в архиве объект, с помощью процедуры преобразования Windows Sockets **ntohs**, **ntohl**, **htons**, и **htonl**. Пример этих функций, используемых при взаимодействии с приложением не MFC приведен далее в этой статье.  
  
> [!NOTE]
>  Если другом конце связи не приложения MFC, следует избегать потоковой передачи объектов C++, производных от `CObject` в своем архиве так как получатель не сможет их обработки. См. Примечание в [Windows Sockets: с помощью сокетов с архивами](../mfc/windows-sockets-using-sockets-with-archives.md).  
  
 Дополнительные сведения о заказах байтов см. спецификацию сокетов Windows в Windows SDK.  
  
## <a name="a-byte-order-conversion-example"></a>Пример преобразования порядок байтов  
 В следующем примере показано функция сериализации для `CSocket` объект, который использует архив. Здесь также показано использование функции преобразования порядка следования байтов в Windows Sockets API.  
  
 В этом примере приведен сценарий, в котором записи клиента, взаимодействующего с серверным приложением не MFC, для которого у вас нет доступа, к исходному коду. В этом случае следует предполагать, что сервер не MFC использует стандартный сетевой порядок байтов. В противоположность этому, клиентское приложение MFC использует `CArchive` объекта с `CSocket` объекта, и `CArchive` использует порядок байтов «обратный порядок байтов», противоположное стандартной сети.  
  
 Предположим, что сервер не MFC, с которой планируется взаимодействия имеет установленный протокол пакета сообщения следующим образом:  
  
 [!code-cpp[NVC_MFCSimpleSocket#5](../mfc/codesnippet/cpp/windows-sockets-byte-ordering_1.cpp)]  
  
 В терминах MFC это будет записано следующим образом:  
  
 [!code-cpp[NVC_MFCSimpleSocket#6](../mfc/codesnippet/cpp/windows-sockets-byte-ordering_2.cpp)]  
  
 В C++ `struct` имеет то же самое класса. `Message` Структуру может содержать функции-члены, например `Serialize` функция-член объявлены выше. `Serialize` Функция-член может выглядеть следующим образом:  
  
 [!code-cpp[NVC_MFCSimpleSocket#7](../mfc/codesnippet/cpp/windows-sockets-byte-ordering_3.cpp)]  
  
 В этом примере вызывается для преобразования порядка следования байтов данных, поскольку очистить несоответствие между порядок байтов, не являющихся MFC серверного приложения с одной стороны и `CArchive` используется в клиентском приложении MFC на другом конце канала. В примере показано несколько функций преобразования порядка следования байтов, которые предоставляет сокеты Windows. В следующей таблице описаны эти функции.  
  
### <a name="windows-sockets-byte-order-conversion-functions"></a>Функции преобразования порядка следования байтов сокетов Windows  
  
|Функция|Цель|  
|--------------|-------------|  
|**ntohs**|Преобразуйте 16-разрядное число байтов из сетевого узла порядка байтов (big-Endian для прямой порядок байтов).|  
|**ntohl**|Преобразуйте 32-разрядное число байтов из сетевого узла порядка байтов (big-Endian для прямой порядок байтов).|  
|**Htons**|Преобразуйте 16-разрядное число из узла байтового сетевой порядок байтов (прямой порядок байтов на обратный порядок байтов).|  
|**Htonl**|Преобразуйте 32-разрядное число из байтового формата узла в сетевой порядок байтов (прямой порядок байтов на обратный порядок байтов).|  
  
 Другой точки в этом примере — когда приложение сокета на другом конце связи приложения не MFC, необходимо избегать приблизительно следующим образом:  
  
 `ar << pMsg;`  
  
 где `pMsg` — это указатель на объект с ++, производный от класса `CObject`. Это будет отправлено дополнительных сведений MFC, связанных с объектами и сервер не может понять, как если бы они были в приложении MFC.  
  
 Дополнительные сведения:  
  
-   [Сокеты Windows. Использование класса CAsyncSocket](../mfc/windows-sockets-using-class-casyncsocket.md)  
  
-   [Сокеты Windows. Фон](../mfc/windows-sockets-background.md)  
  
-   [Сокеты Windows. Сокеты потоков](../mfc/windows-sockets-stream-sockets.md)  
  
-   [Сокеты Windows. Сокеты датаграмм](../mfc/windows-sockets-datagram-sockets.md)  
  
## <a name="see-also"></a>См. также  
 [Сокеты Windows в MFC](../mfc/windows-sockets-in-mfc.md)

