---
title: "Tn061: сообщения ON_NOTIFY и WM_NOTIFY сообщения | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords:
- ON_NOTIFY
- WM_NOTIFY
dev_langs: C++
helpviewer_keywords:
- ON_NOTIFY_EX message [MFC]
- TN061
- ON_NOTIFY message [MFC]
- ON_NOTIFY_EX_RANGE message [MFC]
- ON_NOTIFY_RANGE message [MFC]
- notification messages
- WM_NOTIFY message
ms.assetid: 04a96dde-7049-41df-9954-ad7bb5587caf
caps.latest.revision: "9"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.openlocfilehash: e8e8b8c806d03a1378998031453bffff85892086
ms.sourcegitcommit: ebec1d449f2bd98aa851667c2bfeb7e27ce657b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/24/2017
---
# <a name="tn061-onnotify-and-wmnotify-messages"></a>TN061. Сообщения ON_NOTIFY и WM_NOTIFY
> [!NOTE]
>  Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.  
  
 Это техническое Примечание сведения общего характера на новом **WM_NOTIFY** сообщение и описывает рекомендуемые (и самый распространенный) способ обработки **WM_NOTIFY** сообщений в приложении MFC.  
  
 **Уведомляющих сообщений в Windows 3.x**  
  
 В Windows 3.x, элементы управления уведомлять своих родителей события, такие как щелчки мыши изменяется в содержимого и выбора и рисования фона элемента управления путем отправки сообщения в родительский объект. Простой уведомления отправляются специальными **WM_COMMAND** сообщений с кодом уведомления (такие как **BN_CLICKED**) и упаковываются в идентификатор элемента управления `wParam` и дескриптор элемента управления в `lParam`. Обратите внимание, что поскольку `wParam` и `lParam` являются full, нет возможности для передачи любых дополнительных данных, эти сообщения могут быть только простой уведомления. Например, в **BN_CLICKED** уведомления, нет возможности на отправку сведений о расположении мыши, если была нажата кнопка.  
  
 Если элементы управления в Windows 3.x должен отправить сообщение уведомления, который содержит дополнительные данные, они используют различные специальные сообщения, включая `WM_CTLCOLOR`, `WM_VSCROLL`, `WM_HSCROLL`, `WM_DRAWITEM`, `WM_MEASUREITEM`, `WM_COMPAREITEM`, `WM_DELETEITEM`, `WM_CHARTOITEM`, `WM_VKEYTOITEM`, и т. д. Эти сообщения могут быть отражены обратно в элемент управления, отправившего их. Дополнительные сведения см. в разделе [TN062: сообщение отражения для элементов управления Windows](../mfc/tn062-message-reflection-for-windows-controls.md).  
  
 **Уведомляющих сообщений в Win32**  
  
 Для элементов управления, которые существовали в Windows 3.1, Win32 API использует большую часть сообщения уведомлений, которые использовались в Windows 3.x. Однако Win32 также увеличивает число сложных, сложных элементов управления имена, поддерживаемые в Windows 3.x. Как правило эти элементы управления необходимо отправить дополнительные данные для их уведомляющих сообщений. Вместо добавления нового **WM_\***  сообщений для каждого нового уведомления, требуются дополнительные данные, конструкторы Win32 API было добавлено только одно сообщение **WM_NOTIFY**, который можно передать любой объем дополнительных данных в стандартизованном виде.  
  
 **WM_NOTIFY** сообщение, которое содержит идентификатор элемента управления, отправляющего сообщения `wParam` и указатель на структуру в `lParam`. Эта структура является либо **NMHDR** структуру или некоторые крупной структуры, который имеет **NMHDR** структуру, что ее первого элемента. Обратите внимание, что поскольку **NMHDR** первый член, указатель на эту структуру может использоваться как указатель на **NMHDR** или как указатель на крупной структуры, в зависимости от того, как он приведен.  
  
 В большинстве случаев указатель указывает на более крупной структуры, и необходимо привести его при его использовании. В несколько уведомлений, таких как общих уведомлений (имена которых начинаются с **NM_**) и управления всплывающей подсказки **TTN_SHOW** и **TTN_POP** уведомления, — **NMHDR** фактически используемый структуры.  
  
 **NMHDR** структуры или начального члена содержит дескриптор и идентификатор элемента управления, отправляющего сообщения и код уведомления (например, **TTN_SHOW**). Формат **NMHDR** структуры, показано ниже:  
  
```  
typedef struct tagNMHDR {  
    HWND hwndFrom;  
    UINT idFrom;  
    UINT code;  
} NMHDR;  
```  
  
 Для **TTN_SHOW** сообщение, **кода** член будет иметь значение **TTN_SHOW**.  
  
 Большинство уведомления передать указатель на более крупной структуры, содержащий **NMHDR** структуру, что ее первого элемента. Например, рассмотрим структуру, используемые элементом управления представление списка **LVN_KEYDOWN** сообщение уведомления, которое передается при нажатии клавиши в элементе управления списком. Указатель указывает на **LV_KEYDOWN** структуру, которая определяется, как показано ниже:  
  
```  
typedef struct tagLV_KEYDOWN {  
    NMHDR hdr;     
    WORD wVKey;    
    UINT flags;    
} LV_KEYDOWN;  
```  
  
 Обратите внимание, что поскольку **NMHDR** член является первой в этой структуре, указатель, выполняется переданный сообщения уведомления может быть приведен к указателю на **NMHDR** или указатель на **LV_KEYDOWN** .  
  
 **Уведомления, общие для всех новых элементов управления Windows**  
  
 Некоторые уведомления являются общими для всех новых элементов управления Windows. Эти уведомления передать указатель на **NMHDR** структуры.  
  
|Код уведомления|Отправить, так как|  
|-----------------------|------------------|  
|**NM_CLICK**|Пользователь щелкнул левую кнопку мыши в элементе управления|  
|**NM_DBLCLK**|Пользователь двойном щелчке левой кнопкой мыши в элементе управления|  
|**NM_RCLICK**|Пользователь щелкнул правой кнопкой мыши в элементе управления|  
|**NM_RDBLCLK**|Пользователь двойном щелчке правой кнопкой мыши в элементе управления|  
|**NM_RETURN**|Нажатии клавиши ВВОД, когда элемент управления имеет фокус ввода пользователя|  
|**NM_SETFOCUS**|Элемент управления получил фокус ввода|  
|**NM_KILLFOCUS**|Элемент управления потерял фокус ввода|  
|**NM_OUTOFMEMORY**|Элемент управления не удалось выполнить операцию, поскольку не было достаточный объем памяти доступен|  
  
##  <a name="_mfcnotes_on_notify.3a_.handling_wm_notify_messages_in_mfc_applications"></a>ON_NOTIFY: Обработки сообщения WM_NOTIFY в приложениях MFC  
 Функция `CWnd::OnNotify` обрабатывает сообщения уведомления. Его реализация по умолчанию проверяет схему сообщений для обработчиков уведомлений для вызова. В общем случае не следует переопределять `OnNotify`. Вместо этого укажите функцию обработчика событий и добавить запись схемы сообщений для этого обработчика в схему сообщений для окна-владельца класса.  
  
 Мастер классов, через окно свойств классов, можно создать `ON_NOTIFY` запись сопоставления сообщения и предоставить функцию каркас обработчика событий. Дополнительные сведения об использовании классов для упрощения этой процедуры см. в разделе [сопоставление сообщений с функциями](../mfc/reference/mapping-messages-to-functions.md).  
  
 `ON_NOTIFY` Макрос схемы сообщений имеет следующий синтаксис:  
  
```  
 
ON_NOTIFY(
wNotifyCode  ,  
id  ,
    memberFxn)  
 
```  
  
 где заменяются выделены курсивом параметров:  
  
 `wNotifyCode`  
 Код для сообщения уведомления для обработки, такие как **LVN_KEYDOWN**.  
  
 `id`  
 Идентификатор дочернего элемента управления, для которого отправляется уведомление.  
  
 `memberFxn`  
 Функция-член вызывается в том случае, когда это уведомление отправляется.  
  
 Функция-член должен объявляться с следующий прототип:  
  
```  
 
afx_msg void  
memberFxn  
(NMHDR* 
pNotifyStruct  , LRESULT* result);

 
```  
  
## <a name="remarks"></a>Примечания  
 выделены курсивом используются следующие параметры:  
  
 `pNotifyStruct`  
 Указатель на структуру уведомления, как описано в предыдущем разделе.  
  
 *результат*  
 Указатель на код результата можно задать до возврата.  
  
## <a name="example"></a>Пример  
 Можно указать, что функция-член `OnKeydownList1` для обработки **LVN_KEYDOWN** сообщений из `CListCtrl` которого является идентификатор `IDC_LIST1`, позволяют ClassWizard добавьте следующие элементы в сопоставление сообщений:  
  
```  
ON_NOTIFY(LVN_KEYDOWN,
    IDC_LIST1,
    OnKeydownList1)  
```  
  
 В приведенном выше примере — функции, предоставляемой ClassWizard:  
  
```  
void CMessageReflectionDlg::OnKeydownList1(NMHDR* pNMHDR, LRESULT* pResult)  
{  
    LV_KEYDOWN* pLVKeyDow = (LV_KEYDOWN*)pNMHDR; *// TODO: Add your control notification handler *//       code here  
 
 *pResult = 0;  
}  
```  
  
 Обратите внимание ClassWizard автоматически предоставляет указатель соответствующего типа. Для доступа к структуре уведомления либо `pNMHDR` или `pLVKeyDow`.  
  
##  <a name="_mfcnotes_on_notify_range"></a>ON_NOTIFY_RANGE  
 Если требуется обработать же **WM_NOTIFY** сообщений для набора элементов управления, можно использовать **ON_NOTIFY_RANGE** вместо `ON_NOTIFY`. Например имеется набор кнопок, для которого требуется выполнить те же действия для определенного сообщения уведомления.  
  
 При использовании **ON_NOTIFY_RANGE**, укажите непрерывный диапазон идентификаторов дочерних, для которого требуется обрабатывать сообщения уведомления путем указания начала и конца диапазона идентификаторы дочерних.  
  
 Мастер классов не обрабатывает **ON_NOTIFY_RANGE**; Чтобы использовать его, необходимо изменить схему сообщения самостоятельно.  
  
 Схемы сообщений входа и функция прототип для **ON_NOTIFY_RANGE** , как показано ниже:  
  
```  
 
ON_NOTIFY_RANGE(
wNotifyCode  ,   
id  ,   
idLast  ,
    memberFxn)  
 
```  
  
 где заменяются выделены курсивом параметров:  
  
 `wNotifyCode`  
 Код для сообщения уведомления для обработки, такие как **LVN_KEYDOWN**.  
  
 `id`  
 Первый идентификатор в непрерывный диапазон идентификаторов.  
  
 `idLast`  
 Идентификатор последнего в непрерывный диапазон идентификаторов.  
  
 `memberFxn`  
 Функция-член вызывается в том случае, когда это уведомление отправляется.  
  
 Функция-член должен объявляться с следующий прототип:  
  
```  
 
afx_msg void  
memberFxn  
(UINT   
id  ,
    NMHDR* 
pNotifyStruct  ,
    LRESULT* result);

 
```  
  
## <a name="remarks"></a>Примечания  
 выделены курсивом используются следующие параметры:  
  
 `id`  
 Идентификатор дочернего элемента управления, которому было отправлено уведомление.  
  
 `pNotifyStruct`  
 Указатель на структуру уведомления, как описано выше.  
  
 *результат*  
 Указатель на код результата можно задать до возврата.  
  
##  <a name="_mfcnotes_tn061_on_notify_ex.2c_.on_notify_ex_range"></a>ON_NOTIFY_EX ON_NOTIFY_EX_RANGE  
 Если требуется более одного объекта в уведомлении маршрутизации для обработки сообщения, можно использовать **ON_NOTIFY_EX** (или **ON_NOTIFY_EX_RANGE**) вместо `ON_NOTIFY` (или **ON_NOTIFY_RANGE** ). Единственное различие между **EX** и регулярного версии — что функция-член вызывается для **EX** версия возвращает **BOOL** , указывает ли Обработка сообщений должна быть продолжена. Возвращение **FALSE** этой функции позволяет обработать это сообщение в более одного объекта.  
  
 Мастер классов не обрабатывает **ON_NOTIFY_EX** или **ON_NOTIFY_EX_RANGE**; Если вы хотите использовать один из них, необходимо изменить схему сообщения самостоятельно.  
  
 Схемы сообщений входа и функция прототип для **ON_NOTIFY_EX** и **ON_NOTIFY_EX_RANGE** , как показано ниже. Значения параметров, идентичны представлениям отличного**EX** версии.  
  
```  
 
ON_NOTIFY_EX(
nCode  ,  
id  ,
    memberFxn) ON_NOTIFY_EX_RANGE(
wNotifyCode  ,   
id  ,   
idLast  ,
    memberFxn)  
 
```  
  
 Прототип для обоих указанных выше аналогичен:  
  
```  
 
afx_msg BOOL  
memberFxn  
(UINT   
id  ,
    NMHDR* 
pNotifyStruct  ,
    LRESULT* result);

 
```  
  
## <a name="remarks"></a>Примечания  
 В обоих случаях `id` содержит идентификатор дочернего элемента управления, которому было отправлено уведомление.  
  
 Функция должна возвращать **TRUE** Если уведомление было обработано полностью или **FALSE** других объектов в маршрутизации команд, должна быть возможность для обработки сообщения.  
  
## <a name="see-also"></a>См. также  
 [Технические примечания по номеру](../mfc/technical-notes-by-number.md)   
 [Технические примечания по категории](../mfc/technical-notes-by-category.md)

