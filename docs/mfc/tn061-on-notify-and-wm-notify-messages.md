---
title: 'Tn061: сообщения ON_NOTIFY и WM_NOTIFY сообщения | Документы Microsoft'
ms.custom: ''
ms.date: 06/28/2018
ms.technology:
- cpp-mfc
ms.topic: conceptual
f1_keywords:
- ON_NOTIFY
- WM_NOTIFY
dev_langs:
- C++
helpviewer_keywords:
- ON_NOTIFY_EX message [MFC]
- TN061
- ON_NOTIFY message [MFC]
- ON_NOTIFY_EX_RANGE message [MFC]
- ON_NOTIFY_RANGE message [MFC]
- notification messages
- WM_NOTIFY message
ms.assetid: 04a96dde-7049-41df-9954-ad7bb5587caf
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 74b5a6a8d072a0cea9c92b9766fbe3ffa7c84c4f
ms.sourcegitcommit: 208d445fd7ea202de1d372d3f468e784e77bd666
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/29/2018
ms.locfileid: "37122514"
---
# <a name="tn061-onnotify-and-wmnotify-messages"></a>TN061. Сообщения ON_NOTIFY и WM_NOTIFY

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

Данный технический комментарий содержит общие сведения в сообщении WM_NOTIFY новый и описывает рекомендуемые (и самый распространенный) способ обработки сообщения WM_NOTIFY в приложении MFC.

**Уведомляющих сообщений в Windows 3.x**

В Windows 3.x, элементы управления уведомлять своих родителей события, такие как щелчки мыши изменяется в содержимого и выбора и рисования фона элемента управления путем отправки сообщения в родительский объект. Простой уведомления отправляются в виде специальных WM_COMMAND-сообщения, с кодом уведомления (например, BN_CLICKED) и упаковываются в идентификатор элемента управления *wParam* и дескриптор элемента управления в *lParam*. Обратите внимание, что поскольку *wParam* и *lParam* являются full, нет возможности для передачи любых дополнительных данных, эти сообщения могут быть только простой уведомления. Например в уведомлении BN_CLICKED нет возможности на отправку сведений о расположении мыши, если была нажата кнопка.

Если элементы управления в Windows, требуется 3.x отправить сообщение уведомления, который содержит дополнительные данные, они используют различные специальные сообщений, включая WM_CTLCOLOR, WM_VSCROLL, WM_HSCROLL, WM_DRAWITEM, WM_MEASUREITEM, WM_COMPAREITEM, WM_DELETEITEM, WM_ CHARTOITEM, WM_VKEYTOITEM и т. д. Эти сообщения могут быть отражены обратно в элемент управления, отправившего их. Дополнительные сведения см. в разделе [TN062: сообщение отражения для элементов управления Windows](../mfc/tn062-message-reflection-for-windows-controls.md).

**Уведомляющих сообщений в Win32**

Для элементов управления, которые существовали в Windows 3.1, Win32 API использует большую часть сообщения уведомлений, которые использовались в Windows 3.x. Однако Win32 также увеличивает число сложных, сложных элементов управления имена, поддерживаемые в Windows 3.x. Как правило эти элементы управления необходимо отправить дополнительные данные для их уведомляющих сообщений. Вместо добавления нового **WM_\***  сообщений для каждого нового уведомления, требуются дополнительные данные, конструкторы Win32 API было добавлено только одно сообщение, WM_NOTIFY, который можно передать любое количество дополнительных данных в стандартизованном виде.

WM_NOTIFY-сообщение, которое содержит идентификатор элемента управления, отправляющего сообщения *wParam* и указатель на структуру в *lParam*. Эта структура является либо **NMHDR** структуру или некоторые крупной структуры, который имеет **NMHDR** структуру, что ее первого элемента. Обратите внимание, что поскольку **NMHDR** первый член, указатель на эту структуру может использоваться как указатель на **NMHDR** или как указатель на крупной структуры, в зависимости от того, как он приведен.

В большинстве случаев указатель указывает на более крупной структуры, и необходимо привести его при его использовании. В несколько уведомлений, таких как общих уведомлений (имена которых начинаются с **NM_**) и средство совет TTN_SHOW и TTN_POP уведомления элемента управления, **NMHDR** фактически используемый структуры.

**NMHDR** структуры или начального члена содержит дескриптор и идентификатор элемента управления, отправляющего сообщения и код уведомления (например, TTN_SHOW). Формат **NMHDR** структуры, показано ниже:

```cpp
typedef struct tagNMHDR {
    HWND hwndFrom;
    UINT idFrom;
    UINT code;
} NMHDR;
```

Сообщения об TTN_SHOW **кода** TTN_SHOW будет иметь значение члена.

Большинство уведомления передать указатель на более крупной структуры, содержащий **NMHDR** структуру, что ее первого элемента. Например рассмотрим структура, используемая сообщение уведомления LVN_KEYDOWN управления представления списка, которая отправляется при нажатии клавиши в элементе управления списком. Указатель указывает на **LV_KEYDOWN** структуру, которая определяется, как показано ниже:

```cpp
typedef struct tagLV_KEYDOWN {
    NMHDR hdr;
    WORD wVKey;
    UINT flags;
} LV_KEYDOWN;
```

Обратите внимание, что поскольку **NMHDR** член является первой в этой структуре, указатель, выполняется переданный сообщения уведомления может быть приведен к указателю на **NMHDR** или указатель на **LV_KEYDOWN** .

**Уведомления, общие для всех новых элементов управления Windows**

Некоторые уведомления являются общими для всех новых элементов управления Windows. Эти уведомления передать указатель на **NMHDR** структуры.

|Код уведомления|Отправить, так как|
|-----------------------|------------------|
|NM_CLICK|Пользователь щелкнул левую кнопку мыши в элементе управления|
|NM_DBLCLK|Пользователь двойном щелчке левой кнопкой мыши в элементе управления|
|NM_RCLICK|Пользователь щелкнул правой кнопкой мыши в элементе управления|
|NM_RDBLCLK|Пользователь двойном щелчке правой кнопкой мыши в элементе управления|
|NM_RETURN|Нажатии клавиши ВВОД, когда элемент управления имеет фокус ввода пользователя|
|NM_SETFOCUS|Элемент управления получил фокус ввода|
|NM_KILLFOCUS|Элемент управления потерял фокус ввода|
|NM_OUTOFMEMORY|Элемент управления не удалось выполнить операцию, поскольку не было достаточный объем памяти доступен|

##  <a name="_mfcnotes_on_notify.3a_.handling_wm_notify_messages_in_mfc_applications"></a> ON_NOTIFY: Обработки сообщения WM_NOTIFY в приложениях MFC

Функция `CWnd::OnNotify` обрабатывает сообщения уведомления. Его реализация по умолчанию проверяет схему сообщений для обработчиков уведомлений для вызова. В общем случае не следует переопределять `OnNotify`. Вместо этого укажите функцию обработчика событий и добавить запись схемы сообщений для этого обработчика в схему сообщений для окна-владельца класса.

ClassWizard через окно свойств классов, можно создать записи карты сообщения ON_NOTIFY и предоставить функцию каркас обработчика событий. Дополнительные сведения об использовании классов для упрощения этой процедуры см. в разделе [сопоставление сообщений с функциями](../mfc/reference/mapping-messages-to-functions.md).

ON_NOTIFY-макрос схемы сообщений имеет следующий синтаксис:

```cpp
ON_NOTIFY(wNotifyCode, id, memberFxn)
```

Используются следующие параметры.

*wNotifyCode*  
 Код для сообщения уведомления, подлежащих обработке, например LVN_KEYDOWN.

*id*  
 Идентификатор дочернего элемента управления, для которого отправляется уведомление.

*memberFxn*  
 Функция-член вызывается в том случае, когда это уведомление отправляется.

Функция-член должен объявляться с следующий прототип:

```cpp
afx_msg void memberFxn(NMHDR* pNotifyStruct, LRESULT* result);
```

Используются следующие параметры.

*pNotifyStruct*  
 Указатель на структуру уведомления, как описано в предыдущем разделе.

*результат*  
 Указатель на код результата можно задать до возврата.

## <a name="example"></a>Пример

Можно указать, что функция-член `OnKeydownList1` для обработки сообщений LVN_KEYDOWN из `CListCtrl` которого является идентификатор `IDC_LIST1`, позволяют ClassWizard добавьте следующие элементы в сопоставление сообщений:

```cpp
ON_NOTIFY(LVN_KEYDOWN, IDC_LIST1, OnKeydownList1)
```

В приведенном выше примере — функции, предоставляемой ClassWizard:

```cpp
void CMessageReflectionDlg::OnKeydownList1(NMHDR* pNMHDR, LRESULT* pResult)
{
    LV_KEYDOWN* pLVKeyDow = (LV_KEYDOWN*)pNMHDR;
    
    // TODO: Add your control notification handler
    //       code here

    *pResult = 0;
}
```

Обратите внимание ClassWizard автоматически предоставляет указатель соответствующего типа. Для доступа к структуре уведомления либо *pNMHDR* или *pLVKeyDow*.

##  <a name="_mfcnotes_on_notify_range"></a> ON_NOTIFY_RANGE

Если необходимо обработать это сообщение WM_NOTIFY для набора элементов управления, можно использовать ON_NOTIFY_RANGE, а не ON_NOTIFY. Например имеется набор кнопок, для которого требуется выполнить те же действия для определенного сообщения уведомления.

При использовании ON_NOTIFY_RANGE указываются непрерывный диапазон идентификаторов дочерних, для которого требуется обрабатывать сообщения уведомления путем указания начала и конца диапазона идентификаторы дочерних.

Мастер классов не обрабатывает ON_NOTIFY_RANGE; Чтобы использовать его, необходимо изменить схему сообщения самостоятельно.

Запись сопоставления сообщения и прототип функции для ON_NOTIFY_RANGE таковы:

```cpp
ON_NOTIFY_RANGE(wNotifyCode, id, idLast, memberFxn)
```

Используются следующие параметры.

*wNotifyCode*  
 Код для сообщения уведомления, подлежащих обработке, например LVN_KEYDOWN.

*id*  
 Первый идентификатор в непрерывный диапазон идентификаторов.

*idLast*  
 Идентификатор последнего в непрерывный диапазон идентификаторов.

*memberFxn*  
 Функция-член вызывается в том случае, когда это уведомление отправляется.

Функция-член должен объявляться с следующий прототип:

```cpp
afx_msg void memberFxn(UINT id, NMHDR* pNotifyStruct, LRESULT* result);
```

Используются следующие параметры.

*id*  
 Идентификатор дочернего элемента управления, которому было отправлено уведомление.

*pNotifyStruct*  
 Указатель на структуру уведомления, как описано выше.

*результат*  
 Указатель на код результата можно задать до возврата.

##  <a name="_mfcnotes_tn061_on_notify_ex.2c_.on_notify_ex_range"></a> ON_NOTIFY_EX ON_NOTIFY_EX_RANGE

Если требуется более одного объекта в маршрутизации обрабатывать сообщения уведомления, можно использовать ON_NOTIFY_EX (или ON_NOTIFY_EX_RANGE), а не ON_NOTIFY (или ON_NOTIFY_RANGE). Единственное различие между **EX** и регулярного версии — что функция-член вызывается для **EX** версия возвращает **BOOL** , указывает ли Обработка сообщений должна быть продолжена. Возвращение **FALSE** этой функции позволяет обработать это сообщение в более одного объекта.

Мастер классов не может обрабатывать ON_NOTIFY_EX или ON_NOTIFY_EX_RANGE; Если вы хотите использовать один из них, необходимо изменить схему сообщения самостоятельно.

Запись сопоставления сообщения и прототип функции для ON_NOTIFY_EX и ON_NOTIFY_EX_RANGE являются следующим образом. Значения параметров, идентичны представлениям отличного**EX** версии.

```cpp
ON_NOTIFY_EX(nCode, id, memberFxn)
ON_NOTIFY_EX_RANGE(wNotifyCode, id, idLast, memberFxn)
```

Прототип для обоих указанных выше аналогичен:

```cpp
afx_msg BOOL memberFxn(UINT id, NMHDR* pNotifyStruct, LRESULT* result);
```

В обоих случаях *идентификатор* содержит идентификатор дочернего элемента управления, которому было отправлено уведомление.

Функция должна возвращать **TRUE** Если уведомление было обработано полностью или **FALSE** других объектов в маршрутизации команд, должна быть возможность для обработки сообщения.

## <a name="see-also"></a>См. также

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)  
[Технические примечания по категории](../mfc/technical-notes-by-category.md)  
