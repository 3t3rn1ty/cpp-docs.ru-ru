---
title: "TN040: MFC OLE по месту изменение размеров и масштабирование | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords: vc.mfc.ole
dev_langs: C++
helpviewer_keywords:
- resizing in-place
- TN040
- zooming and in-place activation
- in-place activation, zooming and resizing
ms.assetid: 4d7859bd-0b2e-4254-be62-2735cecf02c6
caps.latest.revision: "10"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: b1113da01e58ec00cd4420aab4424b1c20e127e0
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="tn040-mfcole-in-place-resizing-and-zooming"></a>TN040. Изменение размеров и масштабирование MFC/OLE по месту
> [!NOTE]
>  Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.  
  
 Эта заметка будут рассматриваться вопросы, относящиеся к редактирования по месту, а также как сервер должен выполнять правильного масштабирования и изменения размера на месте. Активации на месте WYSIWYG понятие берется один шаг вперед в контейнерах, и серверы взаимодействовать друг с другом и в частности интерпретировать спецификации OLE во многом так же, как.  
  
 Из-за закрытия взаимодействие между контейнер и сервер, поддерживающий активации на месте существует число ожиданий от конечных пользователей, которое должно сохраняться.  
  
-   Отображение представления (метафайла, рисуется `COleServerItem::OnDraw` переопределить) должен выглядеть точно так же, как при его рисования для редактирования (за исключением того, что средства редактирования не отображаются).  
  
-   Когда контейнер устанавливает масштаб, окно сервера следует слишком!  
  
-   Сервер и контейнер отображать объекты для редактирования с помощью одинаковых метрик. То есть если используется режим сопоставления, в зависимости от числа *логических* точек на дюйм — не физических точек на дюйм, при подготовке к просмотру на устройстве отображения.  
  
> [!NOTE]
>  Так как встроенной активации применяется только к элементам, которые внедряются (не связанные), масштабирование применяется только к внедренные объекты. Вы увидите API-интерфейсы в обоих `COleServerDoc` и `COleServerItem` , которые используются для масштабирования. Описанная в этом дихотомия обусловлено тем, только те функции, которые являются допустимыми для связанные и внедренные элементы находятся в `COleServerItem` (Это позволяет иметь общую реализацию) и функций, которые допустимы только для внедренных объектов находятся в `COleServerDoc` класс (с точки зрения сервера, он является `document` который внедряется).  
  
 Большую часть нагрузки помещается в реализации сервера, в том, что сервер должен знать коэффициента масштабирования контейнера и его редактирования интерфейса соответствующим образом изменить. Но как сервер определяет, что контейнер использует коэффициента масштабирования  
  
## <a name="mfc-support-for-zooming"></a>Поддержка MFC для масштабирования  
 Текущий масштаб можно определить путем вызова `COleServerDoc::GetZoomFactor`. Этот вызов, если документ не является активным на месте всегда приводит в коэффициент масштаба 100% (или отношение 1:1). Вызов его, пока активным на месте может возвращать отличные от 100%.  
  
 Пример правильно масштабирования см. Пример MFC OLE [HIERSVR](../visual-cpp-samples.md). Увеличение HIERSVR осложняется тем, что он отображает текст и текст, как правило, не масштабируется в линейном порядке (подсказки, обозначения, разработки ширины и высоты усложнить заключается в). Тем не менее, HIERSVR разумного ссылку для реализации масштабирования правильно, как и учебник MFC [SCRIBBLE](../visual-cpp-samples.md) (шаг 7).  
  
 `COleServerDoc::GetZoomFactor`Определяет масштаб на основе количества различных показателей, из контейнера или от реализации вашей `COleServerItem` и `COleServerDoc` классы. Иными словами текущий масштаб определяется по следующей формуле:  
  
```  
Position Rectangle (PR) / Container Extent (CE)  
```  
  
 ПРЯМОУГОЛЬНИК ПОЗИЦИИ определяется контейнера. Он возвращается к серверу во время активации на месте при `COleClientItem::OnGetItemPosition` вызывается и обновляется, когда контейнер вызывает сервера `COleServerDoc::OnSetItemRects` (с помощью вызова `COleClientItem::SetItemRects`).  
  
 ОБЛАСТЬ КОНТЕЙНЕРА немного более сложными для вычисления. Если контейнер называется `COleServerItem::OnSetExtent` (с помощью вызова `COleClientItem::SetExtent`), то ЭКСТЕНТ КОНТЕЙНЕРА — это значение, преобразуются в пиксельные на основе числа пикселей на логический дюйм по оси. Если контейнер не вызван SetExtent (которая обычно является регистр), то ЭКСТЕНТ КОНТЕЙНЕР — это размер, возвращенный `COleServerItem::OnGetExtent`. Таким образом, если контейнер не вызван SetExtent, платформа предполагается, если как контейнер будет вызвали его со 100% естественным экстента (значение, возвращаемое из **COleServerItem::GetExtent**). Другим способом, указанным платформа предполагает отображении 100% (не более того, не меньше) элемента контейнера.  
  
 Важно отметить, что хотя `COleServerItem::OnSetExtent` и `COleServerItem::OnGetExtent` имеют одинаковые имена, они не работают один и тот же атрибут элемента. `OnSetExtent`вызывается, чтобы разрешить серверу знать, сколько объекта отображается в контейнере (вне зависимости от коэффициента масштабирования) и `OnGetExtent` вызывается контейнером, чтобы определить наилучший размер объекта.  
  
 Анализируя каждый из используемых API, можно получить более точную картину:  
  
## <a name="coleserveritemongetextent"></a>COleServerItem::OnGetExtent  
 Эта функция должна возвращать «естественным size» в единицах HIMETRIC элемента. Можно рассматривать «размеру» рекомендуется определить в качестве размера, она может появиться при печати. Размер, возвращаемый здесь является константой для конкретного элемента содержимого (наподобие метафайл, который является постоянным для конкретного элемента). Этот размер не изменяется, когда масштабирование применяется к элементу. Обычно не изменяется при ему элемент более или менее пространства путем вызова `OnSetExtent`. Пример изменения, возможно, простого текстового редактора с отсутствует возможность «поля», текст, основанный на последнюю область отправленных контейнера в оболочку. Если изменить сервер, сервер, возможно, следует задать OLEMISC_RECOMPOSEONRESIZE бит в системном реестре (см. в документации OLE SDK, Дополнительные сведения об этом параметре).  
  
## <a name="coleserveritemonsetextent"></a>COleServerItem::OnSetExtent  
 Эта функция вызывается, когда контейнер показывает «больше» объекта. Большинству контейнеров не вызывается вообще. Реализация по умолчанию сохраняет последнее значение получено из контейнера в «m_sizeExtent», которая используется в `COleServerDoc::GetZoomFactor` при вычислении значение КОНТЕЙНЕРА ЭКСТЕНТА, описанных выше.  
  
## <a name="coleserverdoconsetitemrects"></a>COleServerDoc::OnSetItemRects  
 Эта функция вызывается только в том случае, если документ является активным на месте. Вызывается, когда контейнер обновляет позиции элемента или обрезки, применяемый к элементам. ПРЯМОУГОЛЬНИК ПОЗИЦИИ, как описано выше, предоставляет числитель для расчета коэффициента масштабирования. Сервер можно запрашивать изменить положение элемента вызовом `COleServerDoc::RequestPositionChange`. Контейнер может или не может ответить на него, вызвав `OnSetItemRects` (с помощью вызова **COleServerItem::SetItemRects**).  
  
## <a name="coleserverdocondraw"></a>COleServerDoc::OnDraw  
 Важно понимать, что метафайла, созданных переопределение `COleServerItem::OnDraw` выводятся точно того же метафайла, независимо от того, текущий масштаб. Контейнер будет масштабироваться метафайла соответствующим образом. Это важное различие между представлением `OnDraw` и элементом сервера `OnDraw`. Просто создает представление маркеров масштабирования, элемент *масштабируемым* метафайла и оставляет контейнера и выполните соответствующее изменение масштаба.  
  
 Чтобы обеспечить правильное поведение сервера рекомендуется использовать реализацию `COleServerDoc::GetZoomFactor` Если документ является активным на месте.  
  
## <a name="mfc-support-for-in-place-resizing"></a>Поддержка MFC для изменения размера на месте  
 MFC полностью реализует интерфейс изменения размера на месте, как описано в спецификации OLE 2. Пользовательский интерфейс поддерживается `COleResizeBar` класса пользовательское сообщение **WM_SIZECHILD**и специальная обработка сообщения в `COleIPFrameWnd`.  
  
 Может потребоваться реализовать различной обработки этого сообщения, чем предоставляет платформа. Как описано выше, платформа оставляет результаты изменения размера на месте до контейнера — сервер отвечает на изменение коэффициента масштабирования. Если контейнер реагирует оба ЭКСТЕНТ КОНТЕЙНЕРА и ПРЯМОУГОЛЬНИК ПОЗИЦИИ во время обработки его `COleClientItem::OnChangeItemPosition` (вызывается в результате вызова `COleServerDoc::RequestPositionChange`), а затем изменения размера на месте приведет к «больше» элемента отображаются в редактирование окно. Если контейнер будет реагировать, просто задав ПРЯМОУГОЛЬНИК ПОЗИЦИИ во время обработки `COleClientItem::OnChangeItemPosition`, приведет к изменению масштаба, и элемент будет отображаться «увеличения или уменьшения».  
  
 Сервер можно управлять (до некоторой степени), что происходит в процессе согласования. Электронные таблицы, например может выбрать для отображения количества ячеек при изменении размера окна во время редактирования элемента на месте. Текстовых процессоров могут сами изменить «поля страницы», поэтому их таким же, как окно и выполняет повторную изоляцию текст для нового поля. Серверы реализуется путем изменения естественным экстент (размер, возвращаемый из `COleServerItem::OnGetExtent`) после завершения изменения размеров. Это вызовет ПРЯМОУГОЛЬНИК ПОЗИЦИИ и области КОНТЕЙНЕРА для изменения на величину, возникающие в одном коэффициента масштабирования, но больше или меньше области просмотра. Кроме того, больше или меньше документа будут отображаться в метафайл, создаваемые `OnDraw`. В этом случае сам документ изменяется при изменении размера элемента, а не в области просмотра.  
  
 Можно реализовать пользовательские изменения размера и по-прежнему использовать пользовательский интерфейс, предоставляемый `COleResizeBar` путем переопределения **WM_SIZECHILD** сообщение в ваш `COleIPFrameWnd` класса. Дополнительные сведения об устанавливаемых **WM_SIZECHILD**, в разделе [техническом примечании 24](../mfc/tn024-mfc-defined-messages-and-resources.md).  
  
## <a name="see-also"></a>См. также  
 [Технические примечания по номеру](../mfc/technical-notes-by-number.md)   
 [Технические примечания по категории](../mfc/technical-notes-by-category.md)

