---
title: "TN040. Изменение размеров и масштабирование MFC/OLE по месту | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "vc.mfc.ole"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "активация "на месте", изменение масштаба и размера"
  - "изменения размера на месте"
  - "TN040"
  - "изменение масштаба и активация на месте"
ms.assetid: 4d7859bd-0b2e-4254-be62-2735cecf02c6
caps.latest.revision: 10
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 6
---
# TN040. Изменение размеров и масштабирование MFC/OLE по месту
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

> [!NOTE]
>  Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию.  В результате некоторые процедуры и разделы могут быть устаревшими или неверными.  Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.  
  
 Эта заметка обсудит проблемы, относящиеся к редактирования локально и как сервер должен выполнить правильное увеличение и на месте изменения.  Встроенной функции с активацией, режим представления WYSIWYG концепции принимают один шаг вперед, так как контейнеры и серверы сотрудничают друг с другом, особенно интерпретирует спецификация OLE во многом аналогично.  
  
 Из\-за " взаимодействия между контейнером и встроенной активацией сервера поддерживает несколько ожиданий от пользователя, который должен быть доступен.  
  
-   Отображение представления \(метафайл рисование в переопределении `COleServerItem::OnDraw` \) должно выглядеть точно так же, как при его будет выполнено для редактирования \(за исключением того, что редактирования средства не отображается\).  
  
-   Когда контейнер увеличится, окно сервера слишком\!  
  
-   Является и контейнером, и сервер должны показывать объекты для редактирования с использованием той же метрики.  Это означает, что с использованием режима сопоставления на основе количества *логических пикселей* на дюйм — физических пикселей на дюйм, отрисовки на дисплее.  
  
> [!NOTE]
>  Поскольку функция активация применяется только к элементам, которые внедрены \(\), не связанный горизонтали применяется только к внедренным объекты.  При этом API в обоих `COleServerDoc` и `COleServerItem`, используемые для расширения.  Причина этой дихотомии, что только функции, которые являются допустимыми и связанных и встроенных элементов в `COleServerItem` \(это позволяет иметь общую реализацию\) и функциях, допустимо только для внедренных объектов находятся в классе `COleServerDoc` \(с точки зрения сервера, это `document`, встраиваемого\).  
  
 Большинство тяготы будет помещена в разработчике сервера, в котором содержится имя сервера необходимо получить контейнера и изменяет его интерфейс редактирования соответственно.  Но когда сервер задает коэффициент масштабирования, контейнер использует?  
  
## Поддержка MFC для увеличения  
 Текущий коэффициент масштабирования может быть определен с помощью вызова `COleServerDoc::GetZoomFactor`.  При вызове этого документа, если нет активного встроенного результата воли всегда факторе в отношении масштаба 100% \(или 1:1\).  Вызывать ее, пока на месте активный май возвращает отлична от 100%.  
  
 Пример увелича правильно см. в примере MFC [HIERSVR](../top/visual-cpp-samples.md) OLE.  Увеличить HIERSVR осложняется тем, что он отображает текст, и текст, как правило, не обеспечивает напрямую \(подсказки, являются типографскими соглашениями разработки и ширины и высоты всех затрудняет выполнение независимо от\).  Тем не менее, HIERSVR разумная ссылку для реализации увеличить правильно, поэтому это MFC [Образец SCRIBBLE](../top/visual-cpp-samples.md) \(раздел 7\).  
  
 `COleServerDoc::GetZoomFactor` задает коэффициент масштабирования на основе нескольких отличающейся метрик, или из контейнера или из реализации класса `COleServerItem` и `COleServerDoc`.  Вкратце, текущий коэффициент масштабирования определяется следующей формулой:  
  
```  
Position Rectangle (PR) / Container Extent (CE)  
```  
  
 RECT ПОЗИЦИИ определяется контейнером.  Он возвращается на сервер во время встроенной активации при `COleClientItem::OnGetItemPosition` называется и обновляется, когда контейнер вызывает `COleServerDoc::OnSetItemRects` сервера \(с вызовом `COleClientItem::SetItemRects`\).  
  
 ЭКСТЕНТ CONTAINER немного более сложным для вычисления.  Если контейнер, `COleServerItem::OnSetExtent` \(с вызовом `COleClientItem::SetExtent`\), ЭКСТЕНТ CONTAINER это значение, преобразованное в пиксели, на основании количества пикселей на логические дюйм.  Если контейнер не вызывается SetExtent \(который обычно регистра\), ЭКСТЕНТ CONTAINER размер, возвращенный из `COleServerItem::OnGetExtent`.  Таким образом, если контейнер не вызывается SetExtent, платформа высказывать, если она имела бы контейнер вызыватьTfа ее с 100% из естественных экстента, возвращаемого из \(значение **COleServerItem::GetExtent**\).  Заявил другим способом, платформа высказывать контейнер отображается 100% \(нет, больше не менее\) из элемента.  
  
 Обратите внимание, что `COleServerItem::OnSetExtent` и `COleServerItem::OnGetExtent` имеют похожие имена, они не работающим с одним атрибутом элемента.  `OnSetExtent` вызывается, чтобы разрешить серверу знать, насколько из объекта отображается в контейнере \(независимо от фактора увеличения\) и `OnGetExtent` называется контейнером для определения идеальный размер объекта.  
  
 Анализируя каждый из используемых API, можно получить более очистить рисунке:  
  
## COleServerItem::OnGetExtent  
 Эта функция должна возвращать естественный «размер» в модульных HIMETRIC элемента.  Лучшим способом представить естественных «размер» определить его как его размер должен быть напечатан.  Возвращает размер здесь неизменным для содержимого элемента частности \(подобно метафайл, констант для указанного элемента\).  Этот размер не изменяет увелича применяется к элементу.  Обычно не изменяется, когда контейнер предоставляет элемент больше или меньше места путем вызова `OnSetExtent`.  Пример изменения может быть одним из простого текстового редактора без возможности «поля», которая создает текст на последнем отправленном экстенте контейнером.  Если сервер изменяется, то, возможно, сервер должен установить бит OLEMISC\_RECOMPOSEONRESIZE в системном реестре \(см. OLE документации пакета SDK дополнительные сведения об этом параметре\).  
  
## COleServerItem::OnSetExtent  
 Эта функция вызывается, когда контейнер означает «больше» или из объекта.  Большинство контейнеры не вызывают это вообще.  Реализация по умолчанию сохраняет последнее значение, предоставленное в контейнере «m\_sizeExtent», которое используется в `COleServerDoc::GetZoomFactor` вычислительных ЭКСТЕНТ значение CONTAINER, описанной выше.  
  
## COleServerDoc::OnSetItemRects  
 Эта функция вызывается, только если документ на месте активен.  Она вызывается при обновлении любого контейнера или отсечения положение элемента, примененные к элементу.  RECT ПОЗИЦИИ, как описано выше, предоставляет делимое для вычисления фактора увеличения.  Сервер может отправить, чтобы положение элемента была изменена путем вызова `COleServerDoc::RequestPositionChange`.  Контейнер может и не может ответ на этот запрос путем вызова `OnSetItemRects` \(при вызове функции **COleServerItem::SetItemRects**\).  
  
## COleServerDoc::OnDraw  
 Важно понять, что метафайл, созданный путем переопределения `COleServerItem::OnDraw` приводит одинаковым метафайл, независимо от текущего фактора увеличения.  Обеспечивает контейнер метафайл соответственно.  Это важное различие между `OnDraw` представления и `OnDraw` элемента сервера.  Представление обрабатывает увеличить, элемент, просто создает *zoomable* метафайл и оставить его до задачи контейнера соответствующий увеличить.  
  
 Лучший способ убедиться, что сервер работает правильно использовать реализацию `COleServerDoc::GetZoomFactor`, если документ на месте активен.  
  
## Поддержка MFC для изменения на месте  
 Библиотека MFC полностью реализует на месте пользовательским интерфейсом, описанной в разделе 2 спецификации OLE.  Интерфейс пользователя поддерживается классом `COleResizeBar`, пользовательским сообщением **WM\_SIZECHILD** и специальным обработки этого сообщения в `COleIPFrameWnd`.  
  
 Может потребоваться реализовать другой обработки этого сообщения, что не средой выполнения.  Как указано выше, платформа. результаты на месте изменения до контейнера — сервер реагирует на изменение в факторе увеличения.  Если контейнер с правилом, устанавливать и ЭКСТЕНТ CONTAINER и RECT ПОЗИЦИИ во время обработки его `COleClientItem::OnChangeItemPosition` \(с именем в результате вызова `COleServerDoc::RequestPositionChange`\), а затем на месте, то изменение приведет к отображению нескольких «или» из элемента в окне редактирования.  Если контейнер реагирует только параметр RECT ПОЗИЦИИ во время обработки `COleClientItem::OnChangeItemPosition`, коэффициент масштабирования изменится и будет показан элемент увеличенный или «out».  
  
 Сервер может элемента управления \(в некоторой степени\), происходит во время данного согласования.  Электронная таблица, например может избрать, чтобы показать больше или меньше ячеек, когда пользователь изменяет размер окна во время редактирования элемент на месте.  Текстовый редактор избрать может изменять поля «страницы», поэтому тот же окно и rewrap текст в новое поле.  Серверы реализуют это можно изменить естественный экстент \(размер, возвращенный из `COleServerItem::OnGetExtent`\), если изменение будет выполнен.  Это приведет к тому, что и RECT ПОЗИЦИИ и ЭКСТЕНТ CONTAINER изменить так же, количества, и в одном факторе увеличения, но более крупной или более небольшую область обзора.  Кроме того, больше или из документа будут видны в метафайле произведенном `OnDraw`.  В этом случае сам документ изменяется, когда пользователь изменяет размер элемента, а не просто области просмотра.  
  
 Реализация пользовательских можно изменить и по\-прежнему использовать пользовательский интерфейс, предоставляемый `COleResizeBar` путем переопределения сообщение **WM\_SIZECHILD** в классе `COleIPFrameWnd`.  Дополнительные сведения об особенностях **WM\_SIZECHILD** см. в разделе [Техническое примечание 24](../mfc/tn024-mfc-defined-messages-and-resources.md).  
  
## См. также  
 [Технические примечания по номеру](../mfc/technical-notes-by-number.md)   
 [Технические примечания по категории](../mfc/technical-notes-by-category.md)