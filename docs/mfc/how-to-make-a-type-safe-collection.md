---
title: "Практическое руководство. Создание типобезопасных коллекций | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "классы коллекций, производное из нешаблонного"
  - "классы коллекций, на основе шаблона"
  - "классы коллекций, безопасность типа"
  - "сериализация [C++], классы коллекций"
  - "SerializeElements - функция"
  - "сериализуемые элементы класса коллекции"
  - "типобезопасные коллекции"
ms.assetid: 7230b2db-4283-4083-b098-eb231bf5b89e
caps.latest.revision: 10
caps.handback.revision: 7
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Практическое руководство. Создание типобезопасных коллекций
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

В этой статье описывается, как сделать типобезопасные коллекции для собственных типов данных.  Ниже приведен список разделов.  
  
-   [С помощью класса, созданный на основе шаблона для безопасности типов](#_core_using_template.2d.based_classes_for_type_safety)  
  
-   [Реализация вспомогательные функции](#_core_implementing_helper_functions)  
  
-   [Использование классов коллекций nontemplate](#_core_using_nontemplate_collection_classes)  
  
 Библиотеки Microsoft Foundation Class предоставляет предварительно определенные типобезопасные коллекции, основанные на шаблонах C C\+\+.  Поскольку эти шаблоны, эти классы помогают обеспечить безопасность типов и простые в использовании без приведения, а другую дополнительную работу, задействованных при использовании класса nontemplate для этой цели.  В примере MFC [СОБЕРИТЕ](../top/visual-cpp-samples.md) показано использование классов коллекций команды, в приложении MFC.  Как правило, эти классы каждый раз при написании нового кода коллекции.  
  
##  <a name="_core_using_template.2d.based_classes_for_type_safety"></a> С помощью класса, созданный на основе шаблона для безопасности типов  
  
#### Использование класса, созданный на основе шаблона  
  
1.  Объявите переменную типа класса коллекции.  Примеры.  
  
     [!code-cpp[NVC_MFCCollections#7](../mfc/codesnippet/CPP/how-to-make-a-type-safe-collection_1.cpp)]  
  
2.  Вызовите функции\-члены объекта коллекции.  Примеры.  
  
     [!code-cpp[NVC_MFCCollections#8](../mfc/codesnippet/CPP/how-to-make-a-type-safe-collection_2.cpp)]  
  
3.  При необходимости, реализуйте [вспомогательные функции](../mfc/reference/collection-class-helpers.md) и [SerializeElements](../Topic/SerializeElements.md).  Сведения о реализации этих функций см. в разделе [Реализация вспомогательные функции](#_core_implementing_helper_functions).  
  
 В этом примере показано объявление списка целых чисел.  Первый параметр в шаге 1 тип данных, хранящихся в виде элементов списка.  Второй параметр задает, как данные и передавать, возвращенным функции\-члены класса коллекций, например **Добавить** и `GetAt`.  
  
##  <a name="_core_implementing_helper_functions"></a> Реализация вспомогательные функции  
 Классы коллекций `CArray`, `CList` и вспомогательные функции команды на основе использования 5 `CMap` глобальные, можно настраивать по мере необходимости для производного класса коллекции.  Дополнительные сведения об этих вспомогательных функций см. в разделе [Вспомогательных классов коллекций](../mfc/reference/collection-class-helpers.md) в *справочнике по MFC*.  Реализация функции сериализации требуется для большинства использует классы коллекций, команды.  
  
###  <a name="_core_serializing_elements"></a> Сериализация элементы  
 `CArray`, `CList` и классы `CMap` вызывают `SerializeElements` для хранения элементы коллекции к или зачитывать их из архива.  
  
 Реализация по умолчанию вспомогательной функции `SerializeElements` выполняет побитовые записи из объектов в архив, или побитовое прочитанному из архива к объектам в зависимости от того, хранятся ли объекты в или извлечь из архива.  Переопределите `SerializeElements`, если это действие не подходит.  
  
 Если коллекция содержит объекты, унаследованные от `CObject` и используется макрос `IMPLEMENT_SERIAL` в реализации класса элемента коллекции, можно воспользоваться преимуществами функции сериализации, созданных в `CArchive` и `CObject`:  
  
 [!code-cpp[NVC_MFCCollections#9](../mfc/codesnippet/CPP/how-to-make-a-type-safe-collection_3.cpp)]  
  
 Перегруженные операторы вставки для `CArchive` вызывают `CObject::Serialize` \(или переопределения этой функции\) для каждого объекта **CPerson**.  
  
##  <a name="_core_using_nontemplate_collection_classes"></a> Использование классов коллекций Nontemplate  
 MFC также поддерживает классы коллекций, которые используются с версии MFC 1.0.  Эти классы не основаны на шаблонах.  Их можно использовать для хранения данных, поддерживаемых типов `CObject*`, **uint**`DWORD` и `CString`.  Можно использовать эти предопределенные коллекции \(например, `CObList`\) хранения коллекции всех объектов, производном от `CObject`.  MFC предоставляет также другие предопределенные коллекции для хранения простые типы, такие как **uint** и указатели \(`void`\*\).  Как правило, однако оптимальнее определения собственных типобезопасные коллекции для хранения объектов более определенного класса и его производных.  Обратите внимание, что управляемая куча с классами коллекций не на основе шаблонов больше операций, чем с помощью класса, созданный на основе шаблона.  
  
 Существует два способа создания 2 типобезопасные коллекции с коллекциями nontemplate:  
  
1.  Используйте nontemplate коллекции, где тип позволяет при необходимости.  Это наиболее простой подход.  
  
2.  Наследование от и расширить типобезопасную коллекцию nontemplate.  
  
#### Использование коллекции nontemplate с приведением типов  
  
1.  Используйте один из классов nontemplate, например `CWordArray`, напрямую.  
  
     Например, можно создать `CWordArray` и добавьте все 32 разрядные значения в него, а затем извлечь их.  Ничего несколько задач.  Вы только используется предварительно определенной функции.  
  
     Можно также использовать предварительно определенная коллекция, например `CObList`, хранение всех объектов, производных от `CObject`.  Коллекция `CObList` определяется для хранения указателей на `CObject`.  При извлечении объекта из списка, можно привести результат к нужному типу, поскольку функции `CObList` возвращают указатели на `CObject`.  Например, если хранить объекты `CPerson` в коллекции `CObList`, необходимо привести извлекается элемент, который должен быть указателем на объект `CPerson`.  В следующем примере используется коллекцию `CObList` для хранения объектов `CPerson`:  
  
     [!code-cpp[NVC_MFCCollections#10](../mfc/codesnippet/CPP/how-to-make-a-type-safe-collection_4.cpp)]  
  
     Этот метод использования типа предварительно определенной коллекции и приведение при необходимости может быть целесообразным для многих из коллекции.  Если требуется более дальнеишая функция или более безопасность типов, используйте класс, созданный на основе шаблона или выполните следующую процедуру.  
  
#### Создать и расширить типобезопасную коллекцию nontemplate  
  
1.  Создать собственный класс коллекции из одного из предварительно определенных классов nontemplate.  
  
     При получении класса можно добавить типобезопасные функции оболочки для реализации типобезопасный интерфейс существующих функций.  
  
     Например, если вывели список из `CObList` для хранения объектов `CPerson`, можно добавить функции `AddHeadPerson` и `GetHeadPerson` оболочки, как показано ниже.  
  
     [!code-cpp[NVC_MFCCollections#11](../mfc/codesnippet/CPP/how-to-make-a-type-safe-collection_5.h)]  
  
     Эти функции оболочки предоставляет типобезопасный способ добавлять и извлекать объекты `CPerson` производного списка.  Можно видеть, что для функции `GetHeadPerson`, просто ресурсами приведение типов.  
  
     Можно также добавить новую функцию, определяя новые функции, которые расширяют возможности коллекции, а не только определение программу\-оболочку существующие функциональные возможности в типобезопасных программах\-оболочках.  Например, статья [Удалить все объекты в коллекции CObject](../Topic/Deleting%20All%20Objects%20in%20a%20CObject%20Collection.md) описываются функции для удаления всех объектов, содержащихся в списке.  Эта функция может быть добавлена в производный класс как функции\-члена.  
  
## См. также  
 [Коллекции](../mfc/collections.md)