---
title: "Как: создание коллекций типобезопасный | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
helpviewer_keywords:
- type-safe collections [MFC]
- serializing collection-class elements [MFC]
- collection classes [MFC], type safety
- SerializeElements function [MFC]
- collection classes [MFC], template-based
- serialization [MFC], collection classes
- collection classes [MFC], deriving from nontemplate
ms.assetid: 7230b2db-4283-4083-b098-eb231bf5b89e
caps.latest.revision: 
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: 74cb81ecc6b935c87384a8a0a315e35b4adbc465
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="how-to-make-a-type-safe-collection"></a>Практическое руководство. Создание типобезопасных коллекций
В этой статье объясняется, как делать строго типизированные коллекции, для собственных типов данных. Ниже приведен список разделов.  
  
-   [С помощью классов на основе шаблона на строгую типизацию](#_core_using_template.2d.based_classes_for_type_safety)  
  
-   [Реализация вспомогательные функции](#_core_implementing_helper_functions)  
  
-   [Использование классов коллекций нешаблонных](#_core_using_nontemplate_collection_classes)  
  
 Библиотеки классов Microsoft Foundation предоставляет предопределенные строго типизированные коллекции, основанные на шаблонах C++. Так как они являются шаблонами, эти классы помогают обеспечить безопасность типов и удобстве использования без приведение типа и другие дополнительные действия, связанные с использованием нешаблонный класс для этой цели. Пример MFC [СБОРА](../visual-cpp-samples.md) демонстрируется использование классов коллекций, основанных на шаблонах в приложении MFC. Как правило, эти классы используются каждый раз, когда вы написание нового кода коллекции.  
  
##  <a name="_core_using_template.2d.based_classes_for_type_safety"></a>С помощью классов на основе шаблона на строгую типизацию  
  
#### <a name="to-use-template-based-classes"></a>Использование классов на основе шаблона  
  
1.  Объявите переменную типа класса коллекции. Пример:  
  
     [!code-cpp[NVC_MFCCollections#7](../mfc/codesnippet/cpp/how-to-make-a-type-safe-collection_1.cpp)]  
  
2.  Вызовите член функции объекта коллекции. Пример:  
  
     [!code-cpp[NVC_MFCCollections#8](../mfc/codesnippet/cpp/how-to-make-a-type-safe-collection_2.cpp)]  
  
3.  При необходимости реализовать [вспомогательные функции](../mfc/reference/collection-class-helpers.md) и [SerializeElements](../mfc/reference/collection-class-helpers.md#serializeelements). Сведения о реализации этих функций см. в разделе [реализации вспомогательные функции](#_core_implementing_helper_functions).  
  
 В этом примере показано объявление списка целых чисел. Первый параметр в шаге 1 является типом данных, хранящихся в виде элементов списка. Второй параметр указывает способ данные быть передаваемые и возвращаемые из функций-членов класса коллекции, такие как **добавить** и `GetAt`.  
  
##  <a name="_core_implementing_helper_functions"></a>Реализация вспомогательные функции  
 Классы коллекций на основе шаблона `CArray`, `CList`, и `CMap` использовать пять глобального вспомогательные функции, которые можно настраивать при необходимости для класса производной коллекции. Сведения об этих функциях вспомогательный. в разделе [вспомогательные функции классов коллекции](../mfc/reference/collection-class-helpers.md) в *Справочник по библиотеке MFC*. Реализация функции сериализации необходима для большинства случаев классы коллекций на основе шаблона.  
  
###  <a name="_core_serializing_elements"></a>Сериализуемые элементы  
 `CArray`, `CList`, И `CMap` классы вызов `SerializeElements` для хранения элементов коллекции или считывает их из архива.  
  
 Реализация по умолчанию `SerializeElements` вспомогательная функция выполняет побитовое записи из объектов для архива или побитовой операции чтения из архива на объекты, в зависимости от того, является ли объекты будут сохраняться в или извлечения из архива. Переопределить `SerializeElements` Если это действие не подходит.  
  
 Если ваша коллекция хранит объектов, производных от `CObject` и использовании `IMPLEMENT_SERIAL` макрос в реализации классом элемента коллекции можно воспользоваться преимуществами функций сериализации, встроенных в `CArchive` и `CObject`:  
  
 [!code-cpp[NVC_MFCCollections#9](../mfc/codesnippet/cpp/how-to-make-a-type-safe-collection_3.cpp)]  
  
 Операторы перегруженных вставки для `CArchive` вызвать `CObject::Serialize` (или переопределение этой функции) для каждого **CPerson** объекта.  
  
##  <a name="_core_using_nontemplate_collection_classes"></a>Использование классов коллекций нешаблонных  
 MFC также поддерживает классы коллекций с MFC версии 1.0. Эти классы не на основе шаблонов. Они могут использоваться для хранения данных, поддерживаемым `CObject*`, **UINT**, `DWORD`, и `CString`. Можно использовать этих коллекций (такие как `CObList`) для хранения коллекций объектов, производных от `CObject`. MFC также предоставляет другие предопределенные коллекции для хранения типы-примитивы, такие как **UINT** и указатели void (`void`*). Как правило Однако часто полезно для определения собственных строго типизированные коллекции, для хранения объектов более определенный класс и производные от него. Обратите внимание, что это с помощью классов коллекции не на основе шаблонов сложнее, чем с помощью классов на основе шаблона.  
  
 Создание строго типизированные коллекции, с помощью коллекций нешаблонных двумя способами.  
  
1.  Использование коллекций нешаблонных с приведение типа при необходимости. Это простой подход.  
  
2.  Создавать производные и расширять нешаблонных строго типизированную коллекцию.  
  
#### <a name="to-use-the-nontemplate-collections-with-type-casting"></a>Использование коллекций нешаблонных с приведением типов  
  
1.  Использование одного из нешаблонных классов, таких как `CWordArray`, напрямую.  
  
     Например, можно создать `CWordArray` и добавлять в нее любой 32-разрядные значения, а затем извлечение их. Нет ничего делать. Просто используйте стандартные функциональные возможности.  
  
     Можно также использовать стандартные коллекции, такие как `CObList`, для хранения объектов, производных от `CObject`. Объект `CObList` определена коллекция для хранения указателей на `CObject`. При извлечении объекта из списка, может потребоваться приведения результата к нужному типу с момента `CObList` функции возвращают указатели на `CObject`. Например, при сохранении `CPerson` объекты в `CObList` коллекции, необходимо выполнить приведение полученного элемента указатель на `CPerson` объект. В следующем примере используется `CObList` коллекция, содержащая `CPerson` объектов:  
  
     [!code-cpp[NVC_MFCCollections#10](../mfc/codesnippet/cpp/how-to-make-a-type-safe-collection_4.cpp)]  
  
     Этот способ, с помощью типа предопределенная коллекция и приведение при необходимости может быть достаточно для многих из ваших потребностей в коллекциях. Если дополнительные функциональные возможности или требуется более строгая типизация, использовать классов на основе шаблона или выполните следующую процедуру.  
  
#### <a name="to-derive-and-extend-a-nontemplate-type-safe-collection"></a>Наследования и строго типизированные коллекции нешаблонных расширить  
  
1.  Создайте производный класс коллекции из одного из нешаблонных предопределенных классов.  
  
     При создании производного класса, можно добавить функции строго типизированные оболочки для предоставления интерфейса типобезопасный существующих функций.  
  
     Например, если получен список из `CObList` для хранения `CPerson` объектов, можно добавить функции-оболочки `AddHeadPerson` и `GetHeadPerson`, как показано ниже.  
  
     [!code-cpp[NVC_MFCCollections#11](../mfc/codesnippet/cpp/how-to-make-a-type-safe-collection_5.h)]  
  
     Эти функции-оболочки предоставляют типобезопасный способ добавлять и извлекать `CPerson` объекты из списка производный. Можно видеть, что для `GetHeadPerson` функции, просто инкапсулированы приведение типа.  
  
     Определение новых функций, расширяющих возможности коллекции, а не просто перенос существующих функциональных возможностей в строго типизированные оболочки также можно добавить новые функциональные возможности. Например, статьи [удаление всех объектов из коллекции CObject](../mfc/deleting-all-objects-in-a-cobject-collection.md) описывает функцию для удаления всех объектов, содержащихся в списке. Эта функция удалось добавить производного класса, как функция-член.  
  
## <a name="see-also"></a>См. также  
 [Коллекции](../mfc/collections.md)

