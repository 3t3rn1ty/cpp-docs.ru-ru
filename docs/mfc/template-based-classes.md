---
title: "Классы на основе шаблона | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
helpviewer_keywords:
- type-safe collections
- CTypedPtrList class [MFC], template-based classes
- arrays [MFC], classes
- arrays [MFC], pointers
- typed pointers, collections of
- arrays [MFC], template-based
- CArray class [MFC], template-based classes
- simple template-based collections
- simple array collection classes [MFC]
- typed pointers
- collections, typed-pointer
- CList class [MFC], template-based classes
- collection classes [MFC], template-based
- CTypedPtrMap class [MFC], template-based classes
- pointers, collections of typed
- CTypedPtrArray class [MFC], template-based classes
- MFC collection classes [MFC], template-based
- template-based collection classes [MFC]
- simple list collection classes [MFC]
ms.assetid: c69fc95b-c8f6-4a99-abed-517c9898ef0c
caps.latest.revision: 
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: 2beb417bdedab6196ff6d27a387c4b61f083c4ed
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="template-based-classes"></a>Классы на основе шаблонов
В этой статье описываются классы строго типизированную коллекцию на основе шаблона с MFC версии 3.0 и более поздней версии. Использовать эти шаблоны для создания строго типизированные коллекции является более удобным и позволяет более эффективно, чем использование классов коллекций, которые не основаны на шаблоны являются типобезопасными.  
  
 MFC есть стандартных коллекций на основе шаблона две категории:  
  
-   [Простые классы массивов, список и карты](#_core_using_simple_array.2c_.list.2c_.and_map_templates)  
  
     `CArray`, `CList`, `CMap`  
  
-   [Массивы, списки и сопоставления типизированных указателей](#_core_using_typed.2d.pointer_collection_templates)  
  
     `CTypedPtrArray`, `CTypedPtrList`, `CTypedPtrMap`  
  
 Простой коллекции классы являются производными от класса `CObject`, поэтому они наследуют сериализации, динамическое создание и другие свойства `CObject`. Требовать указания класса являются производными от классов коллекций типизированных указателей, который должен быть одним из коллекций нешаблонных указатель, предопределенное MFC, такие как `CPtrList` или `CPtrArray`. Новый класс коллекции наследует от заданного базового класса и функции-члены нового класса используйте инкапсулированный вызовы к членам базового класса для обеспечения безопасности типов.  
  
 Дополнительные сведения о шаблонах C++ см. в разделе [шаблоны](../cpp/templates-cpp.md) в *Справочник по языку C++*.  
  
##  <a name="_core_using_simple_array.2c_.list.2c_.and_map_templates"></a>С помощью простого массива, список и сопоставление шаблонов  
 Использование простой коллекции шаблонов, необходимо знать, какие данные можно хранить в эти коллекции и какие параметры для использования в объявлениях коллекции.  
  
###  <a name="_core_simple_array_and_list_usage"></a>Простого массива и использование списка  
 Простого массива и классы списков [CArray](../mfc/reference/carray-class.md) и [CList](../mfc/reference/clist-class.md), принимают два параметра: *тип* и `ARG_TYPE`. Эти классы можно хранить данные любого типа, которое задается в *тип* параметр:  
  
-   Типы данных основных C++, такие как `int`, `char`, и **число с плавающей запятой**  
  
-   Классы и структуры C++  
  
-   Другие типы, определяемые  
  
 Для удобства и эффективности, можно использовать `ARG_TYPE` параметр для указания типа аргументов функции. Как правило, можно указать `ARG_TYPE` как ссылка на тип, указанный в *ТИПА* параметра. Пример:  
  
 [!code-cpp[NVC_MFCCollections#1](../mfc/codesnippet/cpp/template-based-classes_1.cpp)]  
  
 Первый пример объявляет массив-коллекцию `myArray`, который содержит `int`s. Во втором примере объявляется коллекцию списков `myList`, в которых хранятся `CPerson` объектов. Некоторые функции-члены классов коллекций принимают аргументы, тип которого определяется `ARG_TYPE` параметр шаблона. Например **добавить** функции-члена класса `CArray` принимает `ARG_TYPE` аргумент:  
  
 [!code-cpp[NVC_MFCCollections#2](../mfc/codesnippet/cpp/template-based-classes_2.cpp)]  
  
###  <a name="_core_simple_map_usage"></a>Использование простой схемы  
 Класс простой схемы [CMap](../mfc/reference/cmap-class.md), принимает четыре параметра: *ключ*, `ARG_KEY`, *значение*, и `ARG_VALUE`. Как классы array и list классы сопоставления можно хранить объекты любого типа данных. В отличие от массивов и списков, которые индекса и порядок выполнения они сохраняют данные, связать карты ключей и значений: доступ значения, хранящегося в карту путем указания значения соответствующего ключа. *Ключ* параметр задает тип данных, ключей, используемых для доступа к данным, хранящимся в схеме. Если тип *ключ* — это структура или класс, `ARG_KEY` параметра обычно является ссылкой на тип, указанный в *ключ*. *Значение* параметр указывает тип элементов, которые хранятся в схеме. Если тип `ARG_VALUE` — это структура или класс, `ARG_VALUE` параметра обычно является ссылкой на тип, указанный в *значение*. Пример:  
  
 [!code-cpp[NVC_MFCCollections#3](../mfc/codesnippet/cpp/template-based-classes_3.cpp)]  
  
 Первый пример хранилищ `MY_STRUCT` значений, обращается к ним, `int` ключей и возвращает доступ к `MY_STRUCT` элементы по ссылке. Второй пример хранилищ `CPerson` значений, обращается к ним, `CString` ключей и возвращает ссылки на элементы, к которому осуществляется доступ. В этом примере может представлять простой адресную книгу, в которой можно поиск менеджеров по фамилиям в.  
  
 Поскольку *ключ* параметр имеет тип `CString` и *KEY_TYPE* параметр имеет тип `LPCSTR`, ключи хранятся в схеме как элементы типа `CString` , но на которые имеются ссылки в функции, такие как `SetAt` через указатели типа `LPCSTR`. Пример:  
  
 [!code-cpp[NVC_MFCCollections#4](../mfc/codesnippet/cpp/template-based-classes_4.cpp)]  
  
##  <a name="_core_using_typed.2d.pointer_collection_templates"></a>С помощью шаблонов коллекции типизированный указатель  
 Для работы с шаблонами коллекцию типизированных указателей, необходимо знать, какие виды данных можно хранить в эти коллекции и какие параметры для использования в объявлениях коллекции.  
  
###  <a name="_core_typed.2d.pointer_array_and_list_usage"></a>Массив типизированных указателей и использование списка  
 Массив типизированных указателей и классы списков [CTypedPtrArray](../mfc/reference/ctypedptrarray-class.md) и [CTypedPtrList](../mfc/reference/ctypedptrlist-class.md), принимают два параметра: `BASE_CLASS` и *ТИПА*. Эти классы можно хранить данные любого типа, которое задается в *ТИПА* параметра. Они являются производными от одного из классов коллекций нешаблонных, которые хранит указатели; Укажите этот базовый класс в `BASE_CLASS`. Для массивов, используйте `CObArray` или `CPtrArray`. Для списков, используйте `CObList` или `CPtrList`.  
  
 По сути, при объявлении коллекции на основании сказать `CObList`, новый класс наследует не только члены базового класса, но также объявляет ряд дополнительных строго типизированный элемент функций и операторов, которые помогают обеспечить безопасность типов, инкапсулируя вызовы к членам базового класса. Эти encapsulations управление преобразование всех необходимых типов. Пример:  
  
 [!code-cpp[NVC_MFCCollections#5](../mfc/codesnippet/cpp/template-based-classes_5.cpp)]  
  
 В первом примере объявляется массив типизированных указателей, `myArray`, который является производным от `CObArray`. Массив сохраняет и возвращает указатели на `CPerson` объектов (где `CPerson` класс, производный от `CObject`). Можно вызывать любые `CObArray` функции-члена, либо вызвать новый типобезопасный `GetAt` и `ElementAt` функции или использовать строго типизированный **[]** оператор.  
  
 Во втором примере объявляется список типизированных указателей, `myList`, который является производным от `CPtrList`. В списке сохраняет и возвращает указатели на `MY_STRUCT` объектов. На основе класса `CPtrList` используется для хранения указателей на объекты, не является производным от `CObject`. `CTypedPtrList`имеется ряд функций-членов типобезопасный: `GetHead`, `GetTail`, `RemoveHead`, `RemoveTail`, `GetNext`, `GetPrev`, и `GetAt`.  
  
###  <a name="_core_typed.2d.pointer_map_usage"></a>Использование карты типизированный указатель  
 Класс map типизированный указатель, [CTypedPtrMap](../mfc/reference/ctypedptrmap-class.md), принимает три параметра: `BASE_CLASS`, *ключ*, и *значение*. `BASE_CLASS` Указывает класс, от которого новый класс: `CMapPtrToWord`, `CMapPtrToPtr`, `CMapStringToPtr`, `CMapWordToPtr`, `CMapStringToOb`, и т. д. *КЛЮЧ* является аналогом *ключ* в `CMap`: это задает тип ключа, используемого для уточняющих запросов. *ЗНАЧЕНИЕ* является аналогом *значение* в `CMap`: это задает тип объекта, хранящегося в схеме. Пример:  
  
 [!code-cpp[NVC_MFCCollections#6](../mfc/codesnippet/cpp/template-based-classes_6.cpp)]  
  
 Первый пример выполняется на основе карты **CMapPtrToPt**r — он использует `CString` клавиш, назначенных указатели на `MY_STRUCT`. Можно выполнять поиск сохраненного указателя, вызвав типобезопасную `Lookup` функции-члена. Можно использовать **[]** оператор для поиска сохраненного указателя и добавить его, если не найден. Можно пройти карты с помощью типобезопасного `GetNextAssoc` функции. Можно также вызвать другой член функции класса `CMapPtrToPtr`.  
  
 Во втором примере является карты на основе **CMapStringToO**b — он использует ключи строка сопоставляется хранимых указатели на `CMyObject` объектов. Можно использовать те же элементы строго типизированным, описанный в предыдущем абзаце или члены класса можно вызвать `CMapStringToOb`.  
  
> [!NOTE]
>  При указании **класса** или `struct` тип для *значение* параметра, а не указатель или ссылку на тип класса или структуры, должен иметь конструктор копирования.  
  
 Дополнительные сведения см. в разделе [внесение типобезопасную коллекцию](../mfc/how-to-make-a-type-safe-collection.md).  
  
## <a name="see-also"></a>См. также  
 [Коллекции](../mfc/collections.md)

