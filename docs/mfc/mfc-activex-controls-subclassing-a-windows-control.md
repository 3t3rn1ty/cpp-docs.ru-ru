---
title: "Элементы управления ActiveX MFC: Создание подкласса элемента управления Windows | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords:
- precreatewindow
- IsSubclassed
dev_langs:
- C++
helpviewer_keywords:
- OnDraw method, MFC ActiveX controls
- subclassing
- DoSuperclassPaint method [MFC]
- subclassing Windows controls
- subclassing, Windows controls
- reflected messages, in ActiveX controls
- PreCreateWindow method, overriding
- MFC ActiveX controls [MFC], subclassed controls
- MFC ActiveX controls [MFC], creating
- IsSubclassed method [MFC]
ms.assetid: 3236d4de-401f-49b7-918d-c84559ecc426
caps.latest.revision: 
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: 3e41eefdf1c1be2d0e91061e0efce5f5408c1848
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="mfc-activex-controls-subclassing-a-windows-control"></a>Элементы управления ActiveX в MFC. Создание подкласса элемента управления Windows
В этой статье описывается процесс создания подклассов стандартного элемента управления Windows для создания элемента управления ActiveX. Создание подклассов существующих окон элемент управления является быстрым способом разработки элемента управления ActiveX. Новый элемент управления будет иметь возможности подклассов элемента управления Windows, таких как рисование и реагирование на щелчки мышью. MFC ActiveX-элементы управления образец [кнопку](../visual-cpp-samples.md) является примером Создание подкласса элемента управления Windows Forms.  
  
 Подкласс элемента управления Windows Forms выполните следующие задачи.  
  
-   [Переопределение функции-члены IsSubclassedControl и PreCreateWindow из COleControl](#_core_overriding_issubclassedcontrol_and_precreatewindow)  
  
-   [Изменить функцию-член OnDraw](#_core_modifying_the_ondraw_member_function)  
  
-   [Обрабатывать сообщения элемента управления ActiveX (OCM), отражаются в элемент управления](#_core_handling_reflected_window_messages)  
  
    > [!NOTE]
    >  Большая часть этой работы выполняется автоматически с помощью мастера элементов управления ActiveX при выборе элемента управления, для которого создаются подклассы с помощью **выберите родительский класс окна** раскрывающегося списка на **параметры управления** страницы.  
  
 В статье базы знаний Q243454 подробнее на создание подкласса элемента управления.  
  
##  <a name="_core_overriding_issubclassedcontrol_and_precreatewindow"></a>Переопределение IsSubclassedControl и PreCreateWindow  
 Чтобы переопределить `PreCreateWindow` и `IsSubclassedControl`, добавьте следующие строки кода, чтобы `protected` раздел объявления класса элемента управления:  
  
 [!code-cpp[NVC_MFC_AxSub#1](../mfc/codesnippet/cpp/mfc-activex-controls-subclassing-a-windows-control_1.h)]  
  
 В файле реализации элемента управления (. CPP) добавьте следующие строки кода для реализации переопределенный две функции:  
  
 [!code-cpp[NVC_MFC_AxSub#2](../mfc/codesnippet/cpp/mfc-activex-controls-subclassing-a-windows-control_2.cpp)]  
  
 Обратите внимание, что в этом примере элемент управления кнопку Windows указывается в `PreCreateWindow`. Тем не менее может быть подклассом все стандартные элементы управления Windows. Дополнительные сведения о стандартных элементов управления Windows см. в разделе [элементов управления](../mfc/controls-mfc.md).  
  
 Если создание подкласса элемента управления Windows Forms, может возникнуть необходимость указать нужное окно стиль (**WS_**) или расширенный стиль окна (**WS_EX_**) флаги, которые должны использоваться при создании окна элемента управления. Можно задать значения для этих параметров в `PreCreateWindow` функция-член, изменив **cs.style** и **cs.dwExStyle** поля структуры. Необходимо внести изменения в этих полей с помощью `OR` операцию, чтобы сохранить флаги по умолчанию, заданные классом `COleControl`. Например, если элемент управления является создание подкласса элемента управления BUTTON и элемент управления для отображения в качестве типа "флажок", вставьте следующую строку кода в реализации `CSampleCtrl::PreCreateWindow`, прежде чем оператор return:  
  
 [!code-cpp[NVC_MFC_AxSub#3](../mfc/codesnippet/cpp/mfc-activex-controls-subclassing-a-windows-control_3.cpp)]  
  
 Эта операция добавляет **BS_CHECKBOX** стиля флаг, оставив флаг стиль по умолчанию (**WS_CHILD**) класса `COleControl` без изменений.  
  
##  <a name="_core_modifying_the_ondraw_member_function"></a>Изменение функции-члена OnDraw  
 Если требуется подклассов элемент управления для сохранения одинаково как соответствующий элемент управления Windows `OnDraw` функции-члена для элемента управления должен содержать только вызов `DoSuperclassPaint` функции-члена, как показано в следующем примере:  
  
 [!code-cpp[NVC_MFC_AxSub#4](../mfc/codesnippet/cpp/mfc-activex-controls-subclassing-a-windows-control_4.cpp)]  
  
 `DoSuperclassPaint` Функция-член, реализуемый `COleControl`, использует процедуру окна элемента управления Windows для изображения элемента управления в заданном контексте устройства, внутри ограничивающего прямоугольника. Это делает элемент управления видимым даже в том случае, если она не активна.  
  
> [!NOTE]
>  `DoSuperclassPaint` Функция-член будет работать только с типов элементов управления, позволяющие на контекст устройства для передачи как **wParam** из `WM_PAINT` сообщения. Это включает некоторые из стандартных элементов управления Windows, такие как **полосы ПРОКРУТКИ** и **кнопку**и всех общих элементов управления. Для элементов управления, которые не поддерживают это поведение необходимо предоставить собственный код для правильного отображения элемента управления неактивным.  
  
##  <a name="_core_handling_reflected_window_messages"></a>Обработка отраженных сообщений окна  
 Элементы управления Windows обычно отправки определенных сообщений окна к их родительскому окну. Некоторые из этих сообщений, таких как **WM_COMMAND**, предоставлять уведомления действия со стороны пользователя. Другие, такие как `WM_CTLCOLOR`, используются для получения сведений от родительского окна. Обычно элемент управления ActiveX взаимодействует с родительским окном другими средствами. Уведомления, взаимодействуют с вызова событий (отправка уведомлений о событиях), и сведения о контейнере элемента управления обеспечивается доступ к свойствам окружения контейнера. Так как существует эти способы связи, контейнеры элементов управления ActiveX не должны обрабатывать все окна сообщения, отправляемые с помощью элемента управления.  
  
 Чтобы предотвратить получение сообщений окна, отправленных в элемент управления Windows, контейнер `COleControl` создает другое открытое окно, в качестве родительского элемента управления. Это дополнительное окно, называется «reflector» создается только для элемента управления ActiveX, подклассы Windows, управления и имеет тот же размер и положение, что окна элемента управления. Окно reflector перехватывает некоторые окна сообщения и отправляет их обратно в элемент управления. Элемент управления в его процедуру окна, затем могут обработать эти отраженные сообщения, выполнив действия, которые соответствуют для элемента управления ActiveX (например, вызов события). В разделе [отражены идентификаторы сообщений окон](../mfc/reflected-window-message-ids.md) список перехваченного windows сообщения и соответствующие им отраженных сообщений.  
  
 Контейнер элементов управления ActiveX могут быть разработаны для выполнения отражения сообщения, устраняя необходимость в `COleControl` для создания окна reflector и сокращение времени выполнения затраты для элемент управления Windows. `COleControl`Определяет, поддерживает ли эта возможность контейнера, проверив свойство окружения MessageReflect со значением **TRUE**.  
  
 Для обработки сообщения отраженный окна, добавьте запись сообщений карты элементов управления и реализовать функцию обработчика событий. Поскольку отраженные сообщения не являются частью стандартного набора сообщений, определенных в Windows, представление классов не поддерживает добавление таких обработчиков сообщений. Однако это не сложно вручную добавьте обработчик.  
  
 Чтобы добавить обработчик сообщений для отраженного окна сообщения вручную выполните следующее:  
  
-   В классе элемента управления. H-файл, объявить функцию-обработчик. Функция должна иметь тип возвращаемого значения **LRESULT** и два параметра с типами **WPARAM** и **LPARAM**соответственно. Пример:  
  
     [!code-cpp[NVC_MFC_AxSub#5](../mfc/codesnippet/cpp/mfc-activex-controls-subclassing-a-windows-control_5.h)]  
    [!code-cpp[NVC_MFC_AxSub#6](../mfc/codesnippet/cpp/mfc-activex-controls-subclassing-a-windows-control_6.h)]  
  
-   В классе элемента управления. CPP файлов, добавьте `ON_MESSAGE` записи в схеме сообщений. Параметры данной записи должен быть идентификатор сообщения и имя функции обработчика. Пример:  
  
     [!code-cpp[NVC_MFC_AxSub#7](../mfc/codesnippet/cpp/mfc-activex-controls-subclassing-a-windows-control_7.cpp)]  
  
-   Кроме того, в. Файл .cpp реализовать **OnOcmCommand** функции-члена для обработки отраженного сообщения. **WParam** и **lParam** параметров используются те же исходного окна сообщения.  
  
 Для примера отражены обработки сообщений, см. Пример элементов управления MFC ActiveX [кнопку](../visual-cpp-samples.md). Он демонстрирует **OnOcmCommand** обработчик, который обнаруживает **BN_CLICKED** код уведомления и отвечает, срабатывание (отправка) события щелчка кнопкой мыши.  
  
## <a name="see-also"></a>См. также  
 [Элементы ActiveX библиотеки MFC](../mfc/mfc-activex-controls.md)

