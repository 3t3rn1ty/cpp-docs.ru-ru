---
title: 'Сокеты Windows: Пример сокетов с использованием архивов | Документы Microsoft'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-mfc
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- sockets [MFC], with archives
- examples [MFC], Windows Sockets
- Windows Sockets [MFC], with archives
ms.assetid: 2e3c9bb2-7e7b-4f28-8dc5-6cb7a484edac
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 02cd74a20f0ccc54a366c1a62d913ee30e72471a
ms.sourcegitcommit: 76b7653ae443a2b8eb1186b789f8503609d6453e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
---
# <a name="windows-sockets-example-of-sockets-using-archives"></a>Сокеты Windows. Пример сокетов с использованием архивов
Это статье приведен пример использования класса [CSocket](../mfc/reference/csocket-class.md). Пример использует `CArchive` объектов для сериализации данных через сокет. Обратите внимание, что это не сериализации документа или файла.  
  
 В следующем примере показано, как использовать архив для отправки и получения данных с помощью `CSocket` объектов. В этом образце, чтобы два экземпляра приложения (на том же компьютере или на разных компьютерах в сети) обмена данными. Один экземпляр отправляет данные, что другой экземпляр получает и подтверждает. Любое приложение может начать обмен и либо может выступать в качестве сервера или клиента в другое приложение. Следующая функция определяется в классе представления приложения:  
  
 [!code-cpp[NVC_MFCSimpleSocket#1](../mfc/codesnippet/cpp/windows-sockets-example-of-sockets-using-archives_1.cpp)]  
  
 Наиболее важно об этом примере, что ее структуру параллельно, MFC `Serialize` функции. **PacketSerialize** функция-член состоит из **Если** инструкции с **else** предложения. Функция получает два [CArchive](../mfc/reference/carchive-class.md) ссылки в качестве параметров: `arData` и `arAck`. Если `arData` архив объект настроен для хранения (отправка), **Если** выполняет ветвь; в противном случае, если `arData` устанавливается загрузка (получение) Эта функция принимает **else** ветви. Дополнительные сведения о сериализации в MFC см. в разделе [сериализации](../mfc/how-to-make-a-type-safe-collection.md).  
  
> [!NOTE]
>  `arAck` Архивный объект считается противоположность `arData`. Если `arData` — для отправки, `arAck` получает, и верно обратное.  
  
 Для отправки, пример функции циклов для указанное число раз, каждый раз, создавая некоторые случайные данные для демонстрационных целей. Приложение может получить реальные данные из источника, например файл. `arData` Оператора вставки архива (**<<**) используется для отправки потока из трех последовательных фрагментов данных:  
  
-   «Заголовок», определяющее природу данных (в данном случае значение `bValue` переменной и количество копий будут отправлены).  
  
     В этом примере оба элемента формируется случайным образом.  
  
-   Указанное число копий данных.  
  
     Внутренний **для** цикл отправляет `bValue` указанное число раз.  
  
-   Строка с именем `strText` , получатель отображает его пользователю.  
  
 Для получения, функция работает точно так же, за исключением того, что он использует оператор извлечения архива (**>>**) для получения данных из архива. Принимающее приложение проверяет данные получает, отображается сообщение «Получено» последним и затем отправляет сообщение с текстом «Отправленные» для отправляющего приложения для отображения.  
  
 В этой модели взаимодействия word «Получено» отправить сообщение `strText` переменная является отображает их в другой конец связи, поэтому он указывает получателя определенное число пакетов данных были получены. Получатель отвечает с аналогичной строкой с надписью «Отправленные», для отображения на экране исходного отправителя. Обе строки указывает произошедшем успешной связи.  
  
> [!CAUTION]
>  При написании программы MFC клиента для взаимодействия с серверами установленное (не являющихся MFC), не отправляйте объектами C++ с помощью архива. Если сервер все еще приложения MFC, поддерживающее типы объектов, которые требуется отправить, не будет возможность получения и десериализации объектов. Пример в статье [Windows Sockets: порядок байтов](../mfc/windows-sockets-byte-ordering.md) показывает связи данного типа.  
  
 Дополнительные сведения см. в разделе спецификации Windows Sockets: **htonl**, **htons**, **ntohl**, **ntohs**. Кроме того Дополнительные сведения см. в разделе:  
  
-   [Сокеты Windows. Наследование от классов сокета](../mfc/windows-sockets-deriving-from-socket-classes.md)  
  
-   [Сокеты Windows. Работа сокетов с архивами](../mfc/windows-sockets-how-sockets-with-archives-work.md)  
  
-   [Сокеты Windows. Фон](../mfc/windows-sockets-background.md)  
  
## <a name="see-also"></a>См. также  
 [Сокеты Windows в MFC](../mfc/windows-sockets-in-mfc.md)   
 [CArchive::IsStoring](../mfc/reference/carchive-class.md#isstoring)   
 [CArchive::operator <<](../mfc/reference/carchive-class.md#operator_lt_lt)   
 [CArchive::operator >>](../mfc/reference/carchive-class.md#operator_lt_lt)   
 [CArchive::Flush](../mfc/reference/carchive-class.md#flush)   
 [CObject::Serialize](../mfc/reference/cobject-class.md#serialize)

