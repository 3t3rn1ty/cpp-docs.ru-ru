---
title: "Сокеты Windows. Пример сокетов с использованием архивов | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "примеры [MFC], Сокеты Windows"
  - "сокеты [C++], с архивами"
  - "Сокеты Windows [C++], с архивами"
ms.assetid: 2e3c9bb2-7e7b-4f28-8dc5-6cb7a484edac
caps.latest.revision: 12
caps.handback.revision: 8
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Сокеты Windows. Пример сокетов с использованием архивов
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

В этой статье описывается пример класса [CSocket](../mfc/reference/csocket-class.md).  В этом примере используется объекты `CArchive` для сериализации данных через сокет.  Обратите внимание, что это не сериализации документа на или из файла.  
  
 В следующем примере показано использование архив отправлять и получать данные с помощью объектов `CSocket`.  Будет создан образец, чтобы 2 экземпляр обменов данными приложения \(на том же компьютере или на разных компьютерах в сети\).  Один экземпляр отправляет данные, другой экземпляр получает и подтверждает.  Любое приложение может начать обмен, и это может выступать в роли сервера или в качестве клиента к другому приложению.  Следующая функция определена в классе представления приложения.  
  
 [!code-cpp[NVC_MFCSimpleSocket#1](../mfc/codesnippet/CPP/windows-sockets-example-of-sockets-using-archives_1.cpp)]  
  
 Наиболее важной прежде всего об этом примере, его параллельные структуры, функции MFC `Serialize`.  Функцию\-член **PacketSerialize** состоит из выписки **if** с предложением **else**.  Функция получает 2 ссылки [CArchive](../mfc/reference/carchive-class.md) в качестве параметров. `arData` и `arAck`.  Если объект архива `arData` задается для хранения \(отправить\), ветвь **if** выполняется; в противном случае, если `arData` установлено для загрузки \(получение\) функция принимает ветвь **else**.  Дополнительные сведения о сериализации в MFC см. в разделе [Сериализация](../mfc/how-to-make-a-type-safe-collection.md).  
  
> [!NOTE]
>  Предполагается, что будет объект архива `arAck` противоположностью `arData`.  Если `arData` для отправки, `arAck` получает и converse значение true.  
  
 Для отправки функция примера выполняются для указанного числа раз, каждый раз при создании некоторые случайные данные для демонстрации.  Приложение будет получена реальные данные из определенного источника, например файл.  Оператор вставки архива `arData` \(**\<\<**\) используется, чтобы отправить поток 3 последовательных блоков данных:  
  
-   «Заголовок», указывают на природу данных \(в данном случае значение переменной `bValue` и отправляются количество копий\).  
  
     Оба элемента создаются случайно для данного образца.  
  
-   Заданное число копий данных.  
  
     Внутренний цикл **for** отправляет `bValue` заданное число раз.  
  
-   Строка с `strText` этим отображаются приемника его пользователю.  
  
 Для получения функция работает аналогично, за исключением того, что она использует оператор извлечения архива \(**\>\>**\) для получения данных из архива.  Принимающее приложение проверяет данные, он получает сообщение указывает конечный «последнего», а затем отправляет обратно сообщение, которое гласит «отправить» для отправя приложениям отображать.  
  
 В этой модели взаимодействий,» ключевое слово «полученное сообщение, отправленное в переменной `strText`, для отображения на другом окончании сообщения, и определяет, является принимающим пользователю, что были получены определенное количество пакетов данных.  Получатель отвечает со сходной строкой, гласит «отправить» для отображения на экране исходного отправителя.  Является сообщением обеих строк успешного сообщение указывает, что произошло.  
  
> [!CAUTION]
>  При создании клиентской программы MFC для связи с установленными серверами библиотек \(\), не отправлять объекты C\+\+ по архивным.  Если сервер не будет приложение MFC, понимает типы объектов требуется отправить, он не сможет получить и поиск объекты.  В примере этого раздела [Windows SSL. Порядок байтов](../mfc/windows-sockets-byte-ordering.md) показано сообщение данного типа.  
  
 Спецификация Windows SSL см. Дополнительные сведения в: **htonl**, **htons**, **ntohl**, **ntohs**.  Кроме того, дополнительные сведения см. в разделах:  
  
-   [Windows SSL. Наследование от классов socket](../mfc/windows-sockets-deriving-from-socket-classes.md)  
  
-   [Windows SSL. Как работают с архивами сокеты](../mfc/windows-sockets-how-sockets-with-archives-work.md)  
  
-   [Windows SSL. Фон](../mfc/windows-sockets-background.md)  
  
## См. также  
 [Сокеты Windows в MFC](../mfc/windows-sockets-in-mfc.md)   
 [CArchive::IsStoring](../Topic/CArchive::IsStoring.md)   
 [CArchive::operator \<\<](../Topic/CArchive::operator%20%3C%3C.md)   
 [CArchive::operator \>\>](../Topic/CArchive::operator%20%3E%3E.md)   
 [CArchive::Flush](../Topic/CArchive::Flush.md)   
 [CObject::Serialize](../Topic/CObject::Serialize.md)