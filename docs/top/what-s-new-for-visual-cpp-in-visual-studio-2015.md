---
title: "Новые возможности Visual C++ в Visual Studio 2015 | Microsoft Docs"
ms.custom: ""
ms.date: "12/16/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
ms.assetid: 1cc09fad-85a2-43c2-b022-bb99f5fe0ad7
caps.latest.revision: 101
caps.handback.revision: 101
author: "ghogen"
ms.author: "ghogen"
manager: "ghogen"
---
# Новые возможности Visual C++ в Visual Studio 2015
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

В Visual Studio 2015 компилятор C\+\+ и стандартная библиотека были обновлены, и теперь в этом выпуске реализована расширенная поддержка C\+\+11 и базовая поддержка определенных функций C\+\+14.  Кроме того, в предварительном виде реализована поддержка определенных функций, которые, как предполагается, войдут в стандарт C\+\+17.  
  
 Кроме того, добавлены шаблоны проектов для разработки кроссплатформенных приложений для разных устройств на базе [Android и iOS](../Topic/Visual%20C++%20for%20Cross-Platform%20Mobile%20Development.md), реализованы различные усовершенствования в области [диагностики](#BK_Diagnostics) и [производительности](#BK_IDE), существенно сокращена [продолжительность разработки](#BK_FasterBuildTimes).  
  
> [!WARNING]
>  По умолчанию Visual C\+\+ не установлен в Visual Studio 2015.  При установке следует выбрать **выборочный** вариант установки, а затем выбрать нужные компоненты C\+\+.  Или если среда Visual Studio уже установлена, выберите **Файл &#124; Создать &#124; Проект &#124; C\+\+**, после чего будет выведено предложение установить необходимые компоненты.  
  
 Сведения о других нововведениях в составе Visual Studio 2015 см. в разделе [Новые возможности Visual Studio 2015](../Topic/What's%20New%20in%20Visual%20Studio%202015.md).  
  
 Содержание раздела  
  
1.  [Компилятор](#BK_Compiler)  
  
2.  [Стандартная библиотека C++](#BK_CppStdLib)  
  
3.  [Библиотека времени выполнения C](#BK_CRT)  
  
4.  [Ускорение сборки](#BK_FasterBuildTimes)  
  
5.  [Производительность и качество кода](#BK_PerfCodeQuality)  
  
6.  [Продуктивность, отладка и диагностика](#BK_IDE)  
  
    1.  [IntelliSense для одного файла](#BK_SingleFileIntelliSense)  
  
    2.  [Рефакторинг](#BK_Refactoring)  
  
    3.  [Усовершенствования в базе данных программы](#BK_PDB)  
  
    4.  [Диагностика](#BK_Diagnostics)  
  
7.  [Выбор целевой платформы Windows 10](#BK_Win10)  
  
8.  [Диагностика графики](#BK_GraphicsDiagnostics)  
  
9. [Средство учета использования графического процессора (ГП)](#BK_GPUUsage)  
  
10. [Новые функции MFC](#BK_MFC)  
  
## Поддержка стандартов ISO C\/C\+\+  
  
###  <a name="BK_Compiler"></a> Компилятор  
  
-   **Возобновляемые функции \(resume\/await\)** Ключевые слова resume и await обеспечивают поддержку асинхронного программирования на уровне языка и делают возможным использование возобновляемых функций.  В настоящее время эта функция по\-прежнему является экспериментальной и доступна только для устройств x64.  **\(Предлагается для C\+\+17 \[N3858\]\)**  
  
-   **Универсальные \(полиморфные\) лямбда\-выражения** Типы параметров лямбда\-функций теперь можно задавать с помощью ключевого слова auto; компилятор интерпретирует ключевое слово auto в данном контексте следующим образом: оператор вызова функции закрытия является шаблоном функции\-члена, и каждый случай использования ключевого слова auto в лямбда\-выражении соответствует определенному параметр\-типу шаблона.  **\(C\+\+14 \)**  
  
-   **Обобщенные выражения захвата лямбды** Также известно как первоначальный захват.  Результат произвольного выражения теперь можно назначить переменной в предложении захвата лямбды.  Это позволяет фиксировать доступные только для перемещения типы по значению, а лямбда\-выражение получает возможность определять произвольные члены данных в объекте закрытия.  **\(C\+\+14\)**  
  
-   **Двоичные литералы** Реализована поддержка двоичных литералов.  Такие литералы имеют префикс 0B или 0b и содержат только цифры 0 и 1.  **\(C\+\+14\)**  
  
-   **Выведение типа возвращаемых данных** Теперь можно вывести тип возвращаемых данных для обычных функций, включая функции с множественными операторами Return и рекурсивные функции.  Подобным определениям функций предшествует ключевое слово auto, как в определениях функций, которые завершаются типом возвращаемых данных, однако завершающий тип возвращающих данных опущен.  **\(C\+\+14\)**  
  
-   **decltype\(auto\)** Выведение типа с использованием ключевого слова auto для инициализирующих выражений подразумевает извлечение из выражения квалификаторов ref и квалификаторов верхнего уровня cv.  decltype\(auto\) сохраняет квалификаторы ref и cv и теперь может использоваться везде, где может использоваться ключевое слово auto, кроме ввода функции с выведенным или завершающим типом возвращаемых данных.  **\(C\+\+14\)**  
  
-   **Неявное создание специальных функций\-членов перемещения** Конструкторы перемещения и операторы назначения перемещения теперь неявно создаются при наличии подходящих условий, тем самым приводя компилятор в полное соответствие со ссылками rvalue C\+\+.  **\(C\+\+11\)**  
  
-   **Наследование конструкторов** Производный класс теперь может указать, что будет наследовать конструкторы своего базового класса \(Base\), включая оператор с конструкцией Base::Base в свое определение.  Производный класс может наследовать только все конструкторы своего базового класса, невозможно наследовать лишь некоторые базовые конструкторы.  Производный класс не может наследовать от нескольких базовых классов, если они имеют конструкторы с идентичной подписью. Кроме того, производный класс не может определять конструктор, подпись которого идентична подписи любого из унаследованных им конструкторов.  **\(C\+\+11\)**  
  
-   **Запрос и контроль выравнивания** Оформить запрос выравнивания переменной можно с помощью оператора alignof\(\), а контроль над выравниванием осуществляется с помощью описателя alignas\(\).  alignof\(\) возвращает байтовую границу, на которой необходимо разместить экземпляры типа; для ссылок этот оператор возвращает выравнивание ссылочного типа, а для массивов — выравнивание типа элемента.  alignas\(\) управляет выравниванием переменной; оператор берет константу или тип, где тип является сокращением alignas\(alignof\(type\)\).  **\(C\+\+11\)**  
  
-   **Изъятие с ограниченным размером** Глобальные переменные  `void operator delete(void *, std::size_t) noexcept` и `void operator delete[](void *, std::size_t) noexcept` теперь поддерживают перегрузку.  
  
-   **Расширенный оператор sizeof** Размер переменной члена\-класса или структуры теперь можно определить без экземпляра класса или структуры, используя только оператор sizeof\(\).**\(C\+\+11\)**  
  
-   **Атрибуты** позволяют расширить синтаксис для функций, переменных, типов и других элементов программ, не определяя новые ключевые слова.**\(C\+\+11\)**  
  
-   **constexpr** Создание переменных, функций и определяемых пользователем типов константы времени компиляции.  **\(C\+\+11\)**  
  
-   **Определяемые пользователем литералы \(UDL\)** Теперь значимые суффиксы можно добавлять к численным и строковым литералам, придавая им определенное семантическое значение.  Компилятор интерпретирует литералы с суффиксом как вызовы, адресованные соответствующему оператору UDL.  **\(C\+\+11\)**  
  
-   **Потокобезопасная статика Magic** Статические локальные переменные теперь инициализируются потокобезопасным способом, устраняя необходимость в синхронизации вручную.  Только инициализация является потокобезопасной, при использовании статических локальных переменных в нескольких потоках необходимо по\-прежнему выполнять синхронизацию вручную.  Функцию потокобезопасной статики можно отключить с помощью флага \/Zc:threadSafeInit\-. Это позволит избежать создания зависимости от CRT.  **\(C\+\+11\)**  
  
-   **Локальное хранилище потока** Используйте ключевое слово thread\_local, чтобы объявить, что для каждого потока необходимо создать независимый объект.  **\(C\+\+11\)**  
  
-   **noexcept** Оператор noexcept теперь можно использовать для проверки возможности создания исключения выражением.  Описатель noexcept теперь можно использовать, чтобы указать, что функция не создает исключений.  **\(C\+\+11\)**  
  
-   **Встроенные пространства имен** Пространство имен теперь можно указать в строке и тем самым поместить его содержимое во внешнее пространство имен.  Встроенные пространства имен можно использовать для создания библиотек с контролем версий, которые по умолчанию предоставляют свою самую актуальную версию. Предыдущие версии API остаются при этом доступными явным образом.  **\(C\+\+11\)**  
  
-   **Неограниченные объединения** Тип Union теперь может содержать типы с нестандартными конструкторами.  Необходимо определить конструкторы для таких объединений.  **\(C\+\+11\)**  
  
-   **Новые типы символов и литералы Юникода** Реализована поддержка символов и строковых литералов в формате UTF\-8, UTF\-16 и UTF\-32. Кроме того, впервые представлены новые типы символов: char16\_t и char32\_t.  Символьным литералам может предшествовать u8 \(UTF\-8\), u \(UTF\-16\) или U \(UTF\-32\), как в U'a', а строковым литералам, помимо этого, могут предшествовать неформатированные строковые эквиваленты u8R \(неформатированная строка UTF\-8\), uR \(неформатированная строка UTF\-16\) или UR \(неформатированная строка UTF\-32\).  Универсальные имена символов можно свободно использовать в литералах Юникода, как в u'\\u00EF', u8«\\u00EF равно i», а u«\\U000000ef — I».  **\(C\+\+11\)**  
  
-   **Разделители между цифрами** Одинарные кавычки можно вставить через регулярные интервалы для упрощения чтения длинных числовых литералов:  `int x = 1'000'000;` **C \+\+ 14**.  
  
-   **\_\_func\_\_** Предопределенный идентификатор \_\_func\_\_ неявно определяется как строка, которая содержит неполное имя включающей функции без каких\-либо дополнительных элементов.  
  
-   **\_\_restrict \_\_**ключевое слово restrict теперь можно применять к ссылкам.  
  
###  <a name="BK_CppStdLib"></a> Стандартная библиотека C\+\+  
  
-   **Определяемые пользователями литералы \(UDL\) для стандартных типов библиотек** Заголовки \<chrono\>, \<string\> и \<complex\> теперь предоставляют операторы UDL для вашего удобства.  Например, 123ms означает std::chrono::milliseconds\(123\), "hello"s означает std::string\("hello"\), а 3.14i означает std::complex\(0.0, 3.14\).  
  
-   **Прямые итераторы Null** Стандартная библиотека теперь позволяет создавать прямые итераторы, которые не ссылаются на экземпляр контейнера.  Такие итераторы инициализируются значением и считаются равными для конкретного типа контейнера.  Сравнение инициализируемого значением итератора с итератором другого типа не определено.  **\(C\+\+14\)**  
  
-   **quoted\(\)** Стандартная библиотека теперь поддерживает функцию quoted\(\), что упрощает работу с заключенными в кавычки строковыми значениями и вводом\/выводом.  При использовании функции quoted\(\) вся заключенная в кавычки строка обрабатывается как единая сущность \(как строки отличных от пробела символов в потоках ввода\/вывода\); кроме того, в операциях ввода\/вывода сохраняются escape\-последовательности.  **\(C\+\+14\)**  
  
-   **Разнородная ассоциативная подстановка** Реализована поддержка стандартной библиотекой функций разнородной подстановки для ассоциативных контейнеров.  Такие функции позволяют выполнять подстановку по типам, отличным от типа key\_type, пи условии, что этот тип сравним с типом key\_type.  **\(C\+\+14\)**  
  
-   **Последовательности целых чисел времени компиляции** Реализована поддержка стандартной библиотекой типа integer\_sequence, который представляет последовательность целочисленных значений, которые можно оценить во время компиляции, чтобы сделать более удобной работу с пакетами параметров и упростить определенные схемы программирования шаблонов.  **\(C\+\+14\)**  
  
-   **exchange\(\)** Реализована поддержка стандартной библиотекой служебной функции std::exchange\(\) с целью назначения нового значения для объекта и возвращения его старого значения.  В случае со сложными типами функция exchange\(\) не копирует старое значение, если доступен конструктор перемещения, не копирует новое значение, если оно является временным или переносится, и принимает любой тип в качестве нового значения, используя любой оператор назначения с конвертацией.   **\(C\+\+14\)**  
  
-   **Функции equal\(\), is\_permutation\(\), mismatch\(\) с двумя диапазонами** Стандартная библиотека теперь поддерживает перегрузки для функций std::equal\(\), std::is\_permutation\(\) и std::mismatch\(\), принимающих два диапазона.  Эти перегрузки проверяют, что две последовательности имеют одинаковую длину, поэтому вызывающему коду это делать не нужно; в последовательностях, которые не поддерживают требование о произвольном итераторе, эти перегрузки проверяют длину и сравнивают элементы. Такой подход является более эффективным.  **\(C\+\+14\)**  
  
-   **get\<T\>\(\)** Стандартная библиотека теперь поддерживает функцию шаблона get\<T\>\(\), что делает возможной адресацию элементов кортежа по типу.  Если кортеж содержит два или более элементов одинакового типа get\<T\>\(\), адресация кортежа по этому типу будет невозможна, однако возможность адресации других однозначно типизированных элементов сохранится.  **\(C\+\+14\)**  
  
-   **tuple\_element\_t** Стандартная библиотека теперь поддерживает псевдоним типа tuple\_element\_t\<I, T\>, который является псевдонимом для имени типа tuple\_element\<I, T\>::type.  Это обеспечивает некоторые удобства для программистов, создателей шаблона, равно как и другие псевдонимы типа метафункции в \< type\_traits \>.  **\(C\+\+14\)**  
  
-   **Техническая спецификация файловой системы V3** Включенная реализация технической спецификации файловой системы была обновлена до третьей версии.  \[N3940\]  
  
-   **Минимальные распределители** Стандартная библиотека теперь поддерживает интерфейс минимального распределителя повсеместно; к числу значимых усовершенствований можно отнести std::function, shared\_ptr, allocate\_shared\(\) и basic\_string.  **\(C\+\+11\)**  
  
-   **\<chrono\>** Исправлены ошибки во временных типах high\_resolution\_clock и steady\_clock.  **\(C\+\+11\)**  
  
-   **N2761 Атомарные элементы в обработчиках сигналов \(C\+\+11\)**  
  
-   **N3922 Новые правила для автоматического использования с braced\-init\-lists \(C\+\+17\)**  
  
-   **N4051 имя типа в параметрах шаблона \(C\+\+17\)**  
  
-   **N4259 std::uncaught\_exceptions\(\)**  
  
-   **N4266: атрибуты пространств имен и перечислителей**  
  
-   **N4267: знаковые литералы u8**  
  
###  <a name="BK_CRT"></a> Библиотека времени выполнения C  
 **Рефакторинг библиотеки CRT**. Библиотека CRT была подвергнута рефакторингу и разделена на две части.  **Универсальная CRT** содержит код, который реализует стандартную библиотеку времени выполнения C.  Vcruntime140.dll \(или LIB\-файл\) содержит определяемый версией код для запуска процесса и обработки исключений.  Универсальная CRT имеет стабильный API, позволяющий использовать ее без изменения номера версии в любом выпуске Visual Studio.  Теперь это компонент операционной системы Windows, обслуживаемый Центром обновления Windows.  Он уже установлен в Windows 10.  Используя распространяемый пакет Visual C\+\+ \(vcredist\), можно распространять его вместе с приложениями для более ранних версий Windows.  
  
 Функция **соответствия C99** [!INCLUDE[vs_dev14](../mfc/includes/vs_dev14_md.md)] полностью реализует стандартную библиотеку C99, за исключением любых компонентов библиотеки, зависящих от функций компилятора, еще не поддерживаемых компилятором Visual C\+\+ \(например, \<tgmath.h\> не реализован\).  
  
 **Производительность**. Был выполнен рефакторинг большей части библиотеки для оптимизации и упрощения использования макросов файла заголовка.  Это ускоряет компиляцию и работу IntelliSense и улучшает читаемость.  Кроме того, многие функции stdio были переписаны для соответствия стандартам и повышения производительности.  
  
### Критические изменения  
 Подобная расширенная поддержка стандартов ISO C\/C\+\+ может потребовать внесения изменений в существующий код, чтобы он соответствовал стандарту C\+\+11 и C99 и правильно компилировался в Visual Studio 2015.  Дополнительные сведения см. в разделе [Критические изменения в Visual C\+\+ 2015](../Topic/Visual%20C++%20change%20history%202003%20-%2020151.md).  
  
 Класс concurrency::task и связанные типы в ppltasks.h более не зависят от среды выполнения ConcRT.  Теперь они используют пул потоков Windows Threadpool в качестве планировщика.  Это единственный код imacts, использующий примитивы синхронизации ConcRT внутри операций concurrency::task.  В таком коде следует использовать вместо этого примитивы синхронизации Windows.  
  
 Примитивы синхронизации STL также более не зависят от ConcRT.  В целях предотвращения взаимоблокировок не используйте примитивы синхронизации STL внутри таких функций, как **concurrency::parallel\_for**, или с асинхронными типами агентов PPL.  
  
##  <a name="BK_FasterBuildTimes"></a> Ускорение сборки  
  
-   **Добавочное создание кода во время компоновки \(LTCG\)** В целях сокращения продолжительности компоновки приложений с использованием LTCG можно выполнять добавочную компоновку, работая с LTCG.  Активируйте эту функцию с помощью параметров компоновщика \/LTCG:incremental и \/LTCG:incremental\_rebuild.  \\  
  
-   **Добавочная компоновка для статичных библиотек** Изменения статичных библиотек, на которые ссылаются другие модули кода, теперь компонуются добавочным способом.  
  
-   **\/Debug:FastLink** существенно сокращает продолжительность компоновки благодаря использованию новых техник создания PDB.  
  
-   В целях сокращения продолжительности компоновки в алгоритм компоновщика также были внесены определенные усовершенствования.  
  
-   Реализованные усовершенствования позволят быстрее создавать массивный код шаблона.  
  
-   **Инструментарий для быстрой профильной оптимизации** В сегменте профильной оптимизации появился новый облегченный инструментальный режим для игр и систем в режиме реального времени.  Используя эти и другие новые функции, которые стали доступны через параметры компоновщика \/GENPROFILE и \/FASTGETPROFILE, можно найти баланс между качеством кода и скоростью построения при использовании профильной оптимизации.  
  
-   **Уменьшение размера объектных файлов** Усовершенствования компилятора и стандартной библиотеки C\+\+ привели к существенному уменьшению размера объектных файлов и статических библиотек.  Эти усовершенствования не повлияли на размер динамически подключаемых библиотек \(DLL\) и исполняемых файлов \(EXE\), потому что избыточный код изначально удалялся компоновщиком.  
  
##  <a name="BK_PerfCodeQuality"></a> Производительность и качество кода  
  
-   **Усовершенствования в области автоматической векторизации** Реализована векторизация потока управления \(if\-then\-else\), векторизация при компиляции в \/O1 \(уменьшение размера\), повысилось общее качество векторного кода, включая поддержку параллельного STL, векторизацию циклов на основе диапазонов и поддержку цикла \#pragma loop\(ivdep\).  
  
-   **Усовершенствования в области скалярной оптимизации** Усовершенствованное создание кода для операций битового тестирования, слияние и оптимизация потокового управления \(переключение loop\-if\) и другие скалярные оптимизации \(усовершенствовано создание кода для параметров std::min и std::max\).  
  
-   **Профильная оптимизация \(PGO\)** Реализован ряд усовершенствований в области профильной оптимизации, включая усовершенствованные наборы ссылок, расширенные возможности работы с макетами данных и возможность повторного использования сделанных ранее встраиваний, баланс между скоростью и  размером, оптимизация принятия решений по макетам.  
  
##  <a name="BK_IDE"></a> Продуктивность, отладка и диагностика  
  
###  <a name="BK_SingleFileIntelliSense"></a> IntelliSense для одного файла  
 Теперь вы можете получить доступ к IntelliSense при открытии одного файла исходного кода в редакторе, без необходимости открывать файл проекта.  
  
###  <a name="BK_Refactoring"></a> Рефакторинг  
 Добавлена поддержка рефакторинга для C\+\+, которая обеспечивается следующими функциями.  
  
-   **Переименовывание символа** Имя символа заменяется на новое во всех вхождениях символа.  
  
-   **Извлечение в функцию** Переместите выделенный код в собственную функцию.  Данная оптимизация кода доступна в качестве расширения Visual Studio в коллекции Visual Studio.  
  
-   **Реализация чистых виртуальных функций** Создает определения функций для чистых виртуальных функций, унаследованных классом или структурой.  Поддерживается множественное и рекурсивное наследование.  Активируйте эту оптимизацию кода из определения наследующего класса, чтобы реализовать все унаследованные чистые виртуальные функции, или из описателя базового класса, чтобы реализовать чистые виртуальные функции только из того базового класса.  
  
-   **Создание объявления или определения** Создает объявление из существующего определения или определение по умолчанию из существующего объявления.  Данная оптимизация кода доступна из существующего объявления или определения, а также из индикатора LightBulb.  
  
-   **Перемещение определения функции** Перемещает основную часть функции между исходным кодом и файлами заголовка.  Активируйте эту оптимизацию кода из подписи функции.  
  
-   **Преобразование в необработанный строковый литерал** Преобразует строку, содержащую escape\-последовательности, в необработанный строковый литерал.  Поддерживаются следующие escape\-последовательности: \\\\ \(обратная косая черта\), \\n \(новая строка\), \\t \(табуляция\), \\' \(одинарная кавычка\), \\" \(двойная кавычка\) и \\?  \(вопросительный знак\).  Активируйте эту функцию, щелкнув правой кнопкой мыши в любом месте внутри строки.  
  
 Поиск в файлах был улучшен путем реализации возможности добавления новых результатов к полученным ранее; накопленные результаты можно удалять.  
  
 **Повышение удобочитаемости IntelliSense** Сложные шаблоны для создания экземпляров и определения типов в справке по параметрам и разделе кратких сведений упрощены, что сделало их более удобочитаемыми.  
  
###  <a name="BK_PDB"></a> Усовершенствования в базе данных программы  
  
-   Скорость сканирования решения повысилась, особенно для крупных решений.  
  
-   Такие операции, как «Перейти к определению», больше не блокируются во время сканирования решения. Исключение составляет первоначальное сканирование решения, когда новое решение открывается впервые.  
  
##  <a name="BK_Diagnostics"></a> Диагностика  
  
1.  **Визуализации отладчика** Добавьте визуализации отладчика Natvis в свой проект Visual Studio для удобства управления и интеграции механизмов контроля версий.  NATVIS\-файлы можно редактировать и сохранять во время сеанса отладки, и отладчик будет автоматически загружать изменения.  Дополнительные сведения см. в этой [записи блога](http://blogs.msdn.com/b/vcblog/archive/2014/06/12/project-support-for-natvis.aspx).  
  
2.  **Диагностика собственной памяти**  
  
    1.  **Сеансы диагностики памяти** \(Ctrl \+ Alt \+ F2\) позволяют осуществлять мониторинг использования динамической памяти в собственном приложении во время сеанса отладки.  
  
    2.  **Снимки памяти** фиксируют моментальный снимок содержимого кучи вашего приложения.  Различия в состоянии кучи можно выявить, сравнив два снимка памяти.  После остановки приложения можно просмотреть типы объектов, значения экземпляров и стеки запросов на выделение ресурсов по каждому экземпляру.  Просмотр дерева вызовов по кадру стека для каждого моментального снимка.  
  
3.  **Усовершенствования в области обнаружения взаимоблокировок и восстановления** при вызове функций C\+\+ из окон контрольных значений и интерпретации.  
  
4.  **Усовершенствования в области диагностики компилятора** Компилятор более эффективно выдает предупреждения о подозрительном коде.  Добавлены новые предупреждения \(например, затененные переменные и строки с несоответствующим форматом printf\).  Существующие предупреждения стали более понятными.  
  
5.  **Флаг \/Wv** Предупреждения, появившиеся после выхода конкретной версии компилятора \(XX.YY.ZZZZ\), можно отключить с помощью флага \/Wv:XX.YY.ZZZZ.  Другие предупреждения можно специально отключить в дополнение к отключенным с помощью флага \/Wv.  
  
6.  **Усовершенствованная поддержка отладки оптимизированного кода** Реализована возможность отладки кода с использованием флагов \/Zi, \/Zo или \/Z7.  
  
##  <a name="BK_Win10"></a> Выбор целевой платформы Windows 10  
 Visual Studio теперь поддерживает выбор целевой платформы Windows 10 в C\+\+.  Новые шаблоны проектов для разработки универсального приложения Windows поддерживают выбор целевых устройств Windows 10, таких как настольные компьютеры, мобильные телефоны, планшетные ПК, HoloLens и другие устройства.  Дополнительные сведения см. в разделе [Создание приложения «hello world» в Windows 10](https://msdn.microsoft.com/ru-ru/library/windows/apps/dn996906.aspx).  
  
##  <a name="BK_GraphicsDiagnostics"></a> Диагностика графики  
 В области диагностики графики усовершенствованы следующие функции.  
  
-   **Поддержка диагностики графики для DirectX12.** Средство диагностики графики Visual Studio теперь поддерживает отладку проблем отрисовки в приложениях DirectX12.  
  
-   **Последовательный захват** Возможность захвата до 30 последовательных кадров одной операцией.  
  
-   **Программный захват** Инициирование захвата кадров программными способами.  Программный захват особенно полезен для отладки вычислительных шейдеров в программах, которые никогда не вызывают метод Present, или в случаях, когда проблему с отрисовкой сложно зафиксировать вручную, однако можно спрогнозировать программными методами по состоянию приложения во время выполнения.  
  
-   **Расширенный список событий графики** Добавлено новое представление «Вызовы Draw», в котором отображаются зафиксированные события и их состояние в иерархии, организованной по вызовам Draw.  Можно развернуть вызов Draw, чтобы увидеть состояние устройства на момент вызова. Далее можно развернуть каждый тип состояния, чтобы увидеть события, которые задали эти значения.  
  
-   **Поддержка для Windows Phone 8.1** Диагностика графики теперь полностью поддерживает отладку приложений Windows Phone 8.1 в эмуляторе Phone или в связанном устройстве Phone.  
  
-   **Анализ кадров графики** Это средство собирает измерения производительности по записанным кадрам; кроме того, оно выполняет набор предварительно определенных экспериментов, позволяющих понять, как применение тех или иных техник текстурирования повлияет на производительность.  Анализ кадров также собирает показания счетчиков производительности с оборудования.  
  
-   **Выделенный пользовательский интерфейс для графического анализа** Новое окно Visual Studio Graphics Analyzer представляет собой особую рабочую область для анализа кадров графики.  
  
-   **Изменение и применение шейдера** Оцените влияние изменений в коде шейдера в журнале зафиксированных данных, не перезапуская приложение.  
  
-   Настройте параметры захвата в меню Сервис \-\> Параметры \-\> Диагностика графики.  
  
-   Средство командной строки для записи и воспроизведения кадров.  
  
 Дополнительные сведения см. в разделе [Диагностика графики \(отладка графики DirectX\)](../Topic/Visual%20Studio%20Graphics%20Diagnostics.md).  
  
##  <a name="BK_GPUUsage"></a> Средство учета использования графического процессора \(ГП\)  
 Средство учета использования ГП в Visual Studio 2015 можно использовать, чтобы проанализировать использование ГП в приложениях DirectX.  Во время выполнения приложений в режиме реального времени доступны схемы времени кадров, частоты кадров и использования ЦП.  Кроме того, собирая и анализируя подробные данные об использовании ГП, это средство может предоставить сведения о времени выполнения отдельных событий DirectX на ЦП и ГП и, следовательно, поможет определить, что вызывает проблемы с производительностью — ЦП или ГП.  См. раздел [Использование GPU](../Topic/GPU%20Usage.md).  
  
##  <a name="BK_MFC"></a> Новые функции MFC  
 Теперь можно задать изменение размеров и перемещение элементов управления при изменении размера диалогового окна.  Дополнительные сведения см. в разделе [Динамический макет](../mfc/dynamic-layout.md).  
  
## См. также  
 [Новые возможности Visual Studio 2015](../Topic/What's%20New%20in%20Visual%20Studio%202015.md)   
 [Блог команды разработчиков Visual C\+\+](http://blogs.msdn.com/b/vcblog/)