---
title: "Транзакция. Влияние транзакций на обновления (ODBC) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "CommitTrans - метод"
  - "наборы записей ODBC, транзакции"
  - "Rollback - метод, транзакции ODBC"
  - "транзакции, откат"
  - "транзакции, обновление записей"
ms.assetid: 9e00bbf4-e9fb-4332-87fc-ec8ac61b3f68
caps.latest.revision: 9
caps.handback.revision: 9
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Транзакция. Влияние транзакций на обновления (ODBC)
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

Управление обновлениями [источника данных](../../data/odbc/data-source-odbc.md) осуществляется в процессе транзакций посредством использования буфера изменения \(тот же метод применяется вне транзакций\).  Члены данных поля в наборе записей служат в качестве буфера изменений, содержащего текущую запись, резервную копию которой набор записей временно создает в ходе операции `AddNew` или **Edit**.  В ходе операции **Delete** резервная копия текущей записи не создается.  Подробные сведения о буфере изменений и о том, как обновления сохраняют текущую запись, см. в разделе [Набор записей. Обновление записей наборами записей \(ODBC\)](../../data/odbc/recordset-how-recordsets-update-records-odbc.md).  
  
> [!NOTE]
>  Если реализована массовая выборка строк, вызвать операторы `AddNew`, **Edit** или **Delete** невозможно.  Вместо этого можно написать собственные функции для выполнения обновлений источника данных.  Дополнительные сведения о групповой выборке строк см. в разделе [Набор записей. Групповая выборка строк \(ODBC\)](../Topic/Recordset:%20Fetching%20Records%20in%20Bulk%20\(ODBC\).md).  
  
 В ходе транзакций может быть выполнена фиксация или откат операций `AddNew`, **Edit** и **Delete**.  Выполнение функций **CommitTrans** и **Rollback** может привести к тому, что текущая запись не будет сохранена в буфере изменений.  Чтобы текущая запись была сохранена должным образом, важно понимать, как функции\-члены **CommitTrans** и **Rollback** класса `CDatabase` работают с функциями обновления класса `CRecordset`.  
  
##  <a name="_core_how_committrans_affects_updates"></a> Влияние функции CommitTrans на обновления  
 В представленной ниже таблице поясняется влияние **CommitTrans** на транзакции.  
  
### Влияние функции CommitTrans на обновления  
  
|Операция|Состояние источника данных|  
|--------------|--------------------------------|  
|`AddNew` и **Update**, а затем **CommitTrans**|Добавление новой записи в источник данных|  
|`AddNew` \(без **Update**\), а затем **CommitTrans**|Потеря новой записи.  Запись не добавлена в источник данных.|  
|**Edit** и **Update**, а затем **CommitTrans**|Изменения источника данных зафиксированы.|  
|**Edit** \(без **Update**\), а затем **CommitTrans**|Изменения записи потеряны.  Запись в источнике данных остается без изменений.|  
|**Delete**, а затем **CommitTrans**|Запись удалена из источника данных.|  
  
##  <a name="_core_how_rollback_affects_updates"></a> Влияние функции Rollback на транзакции  
 В представленной ниже таблице поясняется влияние функции **Rollback** на транзакции.  
  
### Влияние функции Rollback на транзакции  
  
|Операция|Состояние текущей записи|Дополнительные действия, которые требуется выполнить|Состояние источника данных|  
|--------------|------------------------------|----------------------------------------------------------|--------------------------------|  
|`AddNew` и **Update**, а затем **Rollback**|Содержимое текущей записи временно сохраняется для освобождения места для новой записи.  Новая запись вводится в буфер изменений.  После вызова **Update** текущая запись восстанавливается в буфере изменений.||Добавление данных к источнику данных, выполненное с помощью функции **Update**, отменяется.|  
|`AddNew` \(без **Update**\), а затем **Rollback**|Содержимое текущей записи временно сохраняется для освобождения места для новой записи.  Буфер изменений содержит новую запись.|Вызовите операцию `AddNew` снова для восстановления в буфере изменений в состоянии пустой новой записи.  Или же вызовите операцию **Move**\(0\) для восстановления прежних значений буфера изменений.|Поскольку операция **Update** не была вызвана, в источник данных изменения не вносились.|  
|**Edit** и **Update**, а затем **Rollback**|Временно сохраняется неизмененная версия текущей записи.  Изменения вносятся в содержимое буфера изменений.  После вызова операции **Update** неизмененная версия записи остается в расположении временного хранения.|*Dynaset*: прокрутка текущей записи и восстановление неизмененной версии записи в буфере изменений.<br /><br /> *Snapshot*: вызов операции **Requery** для обновления набора записей из источника данных.|Изменение данных в источнике данных, выполненное с помощью **Update**, отменяется.|  
|**Edit** \(без **Update**\), а затем **Rollback**|Временно сохраняется неизмененная версия текущей записи.  Изменения вносятся в содержимое буфера изменений.|Вызовите **Edit** снова для восстановления неизмененной версии записи в буфере изменений.|Поскольку операция **Update** не была вызвана, в источник данных изменения не вносились.|  
|**Delete**, а затем **Rollback**|Удаление содержимого текущей записи.|Вызовите **Requery** для восстановления текущей записи из источника данных.|Отмена удаления данных из источника данных.|  
  
## См. также  
 [Транзакция \(ODBC\)](../../data/odbc/transaction-odbc.md)   
 [Транзакция \(ODBC\)](../../data/odbc/transaction-odbc.md)   
 [Транзакции: выполнение транзакции в наборе записей \(ODBC\)](../../data/odbc/transaction-performing-a-transaction-in-a-recordset-odbc.md)   
 [CDatabase Class](../../mfc/reference/cdatabase-class.md)   
 [CRecordset Class](../Topic/CRecordset%20Class.md)