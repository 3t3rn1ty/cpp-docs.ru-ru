---
title: 'Транзакция: Влияние транзакций на обновления (ODBC) | Документы Microsoft'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-data
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- transactions, updating recordsets
- ODBC recordsets, transactions
- transactions, rolling back
- CommitTrans method
- Rollback method, ODBC transactions
ms.assetid: 9e00bbf4-e9fb-4332-87fc-ec8ac61b3f68
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- data-storage
ms.openlocfilehash: 549f8495ca3a088ec4314cd26318d19f9a5a3176
ms.sourcegitcommit: 76b7653ae443a2b8eb1186b789f8503609d6453e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
ms.locfileid: "33098008"
---
# <a name="transaction-how-transactions-affect-updates-odbc"></a>Транзакция. Влияние транзакций на обновления (ODBC)
Обновления для [источника данных](../../data/odbc/data-source-odbc.md) осуществляется в процессе транзакций посредством использования буфера изменения (тот же метод применяется вне транзакций). Члены данных полей в наборе записей служат в качестве буфера изменений, содержащего текущую запись набора записей резервную копию которой временно во время `AddNew` или **изменить**. Во время **удалить** операции, текущая запись не архивируются в рамках транзакции. Дополнительные сведения о буфере изменений и как обновления сохраняют текущую запись см. в разделе [набор записей: как наборы записей обновления записей (ODBC)](../../data/odbc/recordset-how-recordsets-update-records-odbc.md).  
  
> [!NOTE]
>  Если реализована массовая выборка строк, не удается вызвать `AddNew`, **изменить**, или **удалить**. Вместо этого необходимо написать собственные функции для выполнения обновлений в источнике данных. Дополнительные сведения о массовой выборке строк см. в разделе [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
 Во время выполнения транзакций `AddNew`, **изменить**, и **удалить** может быть зафиксирована или выполнен откат операции. Эффекты **CommitTrans** и **отката** может привести к текущей записи не будет сохранена в буфере. Чтобы убедиться в том, что восстановления текущей записи, необходимо понимать, как **CommitTrans** и **отката** функциями-членами `CDatabase` работают с функциями обновления класса `CRecordset`.  
  
##  <a name="_core_how_committrans_affects_updates"></a> Влияние CommitTrans обновление  
 В следующей таблице описываются последствия **CommitTrans** на транзакции.  
  
### <a name="how-committrans-affects-updates"></a>Влияние CommitTrans обновление  
  
|Операция|Состояние источника данных|  
|---------------|---------------------------|  
|`AddNew` и **обновление**, а затем **CommitTrans**|Новые записи добавляются к источнику данных.|  
|`AddNew` (без **обновление**), а затем **CommitTrans**|Новая запись будут утеряны. Запись не добавлена в источник данных.|  
|**Изменить** и **обновление**, а затем **CommitTrans**|Изменения источника данных зафиксированы.|  
|**Изменить** (без **обновление**), а затем **CommitTrans**|Изменения, внесенные в запись, будут потеряны. Запись остается без изменений в источнике данных.|  
|**Удалить** затем **CommitTrans**|Записи удалены из источника данных.|  
  
##  <a name="_core_how_rollback_affects_updates"></a> Влияние операций отката  
 В следующей таблице описываются последствия **отката** на транзакции.  
  
### <a name="how-rollback-affects-transactions"></a>Влияние операций отката  
  
|Операция|Состояние текущей записи|Кроме того, необходимо|Состояние источника данных|  
|---------------|------------------------------|-------------------|---------------------------|  
|`AddNew` и **обновление**, затем **отката**|Содержимое текущей записи временно сохраняется для освобождения места для новой записи. Новая запись вводится в буфере. После **обновление** вызывается текущего запись восстанавливается в буфере.||Добавление к источнику данных, внесенных **обновление** поворачивается в обратном направлении.|  
|`AddNew` (без **обновление**), затем **отката**|Содержимое текущей записи временно сохраняется для освобождения места для новой записи. Изменить буфер содержит новую запись.|Вызовите `AddNew` снова для восстановления в буфере пустой новой записи. Или позвоните **переместить**(0), чтобы восстановить старые значения в буфере.|Поскольку **обновление** не был вызван, не вносит изменения, сделанные в источнике данных.|  
|**Изменить** и **обновление**, затем **отката**|Временно сохраняется неизмененная версия текущей записи. Изменений, чтобы содержимое в буфере. После **обновления** вызове неизмененная версия записи по-прежнему временно хранится.|*Динамический набор*: прокрутка текущей записи и восстановление неизмененной версии записи в буфере изменений.<br /><br /> *Моментальный снимок*: вызов **Requery** для обновления записей в источнике данных.|Изменения источника данных, внесенных **обновление** отменяются.|  
|**Изменить** (без **обновление**), затем **отката**|Временно сохраняется неизмененная версия текущей записи. Изменений, чтобы содержимое в буфере.|Вызовите **изменить** снова для восстановления неизмененной версии записи в буфере.|Поскольку **обновление** не был вызван, не вносит изменения, сделанные в источнике данных.|  
|**Удалить** затем **отката**|Содержимое текущей записи удаляются.|Вызовите **Requery** для восстановления текущей записи из источника данных.|Удаление данных из источника данных меняется на противоположный.|  
  
## <a name="see-also"></a>См. также  
 [Транзакция (ODBC)](../../data/odbc/transaction-odbc.md)   
 [Транзакция (ODBC)](../../data/odbc/transaction-odbc.md)   
 [Транзакции: Выполнение транзакции в наборе записей (ODBC)](../../data/odbc/transaction-performing-a-transaction-in-a-recordset-odbc.md)   
 [CDatabase-класс](../../mfc/reference/cdatabase-class.md)   
 [Класс CRecordset](../../mfc/reference/crecordset-class.md)