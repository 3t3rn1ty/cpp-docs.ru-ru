---
title: "Наборы записей. Принципы работы функций AddNew, Edit и Delete (ODBC) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "AddNew - метод"
  - "данные в наборах записей [C++]"
  - "наборы записей ODBC [C++], добавление записей"
  - "наборы записей ODBC [C++], удаление записей"
  - "наборы записей ODBC [C++], изменение записей"
  - "редактирование записей [C++], наборы записей"
  - "записи [C++], добавление"
  - "записи [C++], удаление в наборах записей"
  - "записи [C++], редактирование"
  - "записи [C++], обновление"
  - "наборы записей [C++], добавление записей"
  - "наборы записей [C++], удаление записей"
  - "наборы записей [C++], изменение записей"
  - "наборы записей [C++], обновление"
ms.assetid: cab43d43-235a-4bed-ac05-67d10e94f34e
caps.latest.revision: 9
caps.handback.revision: 9
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Наборы записей. Принципы работы функций AddNew, Edit и Delete (ODBC)
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

Данный раздел относится к классам ODBC библиотеки MFC.  
  
 В данном разделе описываются принципы работы функций\-членов `AddNew`, **Edit** и **Delete** класса `CRecordset`.  В разделе рассматриваются следующие вопросы:  
  
-   [Принципы добавления записей](#_core_adding_a_record)  
  
-   [Видимость добавленных записей](#_core_visibility_of_added_records)  
  
-   [Принципы редактирования записей](#_core_editing_an_existing_record)  
  
-   [Принципы удаления записей](#_core_deleting_a_record)  
  
> [!NOTE]
>  В этом разделе приведены сведения, относящиеся к объектам, производным от класса `CRecordset`, в котором групповая выборка строк не реализована.  При использовании групповой выборки строк следует ознакомиться с разделом [Набор записей: групповая выборка записей \(ODBC\)](../Topic/Recordset:%20Fetching%20Records%20in%20Bulk%20\(ODBC\).md).  
  
 В дополнение можно ознакомиться с разделом [Обмен полями записей. Принципы работы RFX](../../data/odbc/record-field-exchange-how-rfx-works.md), в котором описывается роль RFX при выполнении операций обновления.  
  
##  <a name="_core_adding_a_record"></a> Добавление записи  
 Добавление новой записи в набор записей предполагает вызов функции\-члена [AddNew](../Topic/CRecordset::AddNew.md) набора записей, задание значений элементов данных полей нового набора записей и вызов функции\-члена [Update](../Topic/CRecordset::Update.md) для передачи записи в источник данных.  
  
 При вызове функции\-члена `AddNew` набор записей не должен быть открыт только для чтения.  Функции\-члены `CanUpdate` и `CanAppend` позволяют определять эти условия.  
  
 При обращении к методу `AddNew` происходит следующее:  
  
-   Запись сохраняется в буфере редактирования, так что при отмене операции ее содержимое может быть восстановлено.  
  
-   Элементы данных полей помечаются флагами, что делает возможным определение наличия в них изменений в дальнейшем.  Кроме того, элементы данных полей помечаются как чистые \(без изменений\), и им присваивается значение Null.  
  
 После вызова `AddNew` в буфере обмена содержится новая пустая запись, которую можно заполнять значениями.  Для этого необходимо присвоить значения вручную.  Вместо указания конкретного значения для поля можно вызвать метод `SetFieldNull`, чтобы задать значение Null.  
  
 Чтобы зафиксировать изменения, необходимо вызвать метод **Update**.  При вызове метода **Update** для новой записи происходит следующее:  
  
-   Если драйвер ODBC поддерживает функцию ODBC API **::SQLSetPos**, MFC использует эту функцию для добавления записи в источник данных.  Функция **::SQLSetPos** позволяет библиотеке MFC более эффективно производить добавление записей, поскольку устраняется необходимость в построении и обработке инструкции SQL.  
  
-   Если функция **::SQLSetPos** не может быть использована, MFC выполняет следующие действия:  
  
    1.  Если изменения не обнаружены, метод **Update** не производит никаких действий и возвращает значение "0".  
  
    2.  При наличии изменений метод **Update** создает инструкцию SQL **INSERT**.  Столбцы, представленные всеми измененными элементами данных полей, перечисляются в инструкции **INSERT**.  Чтобы принудительно включить столбец в список, вызовите функцию\-член [SetFieldDirty](../Topic/CRecordset::SetFieldDirty.md):  
  
        ```  
        SetFieldDirty( &m_dataMember, TRUE );  
        ```  
  
    3.  Метод **Update** фиксирует новую запись: выполняется инструкция **INSERT**, и запись фиксируется в таблице источника данных \(и в наборе записей, если он не является снимком\), если только транзакция не находится в состоянии выполнения.  
  
    4.  Сохраненная запись восстанавливается в буфер редактирования.  Запись, являвшаяся текущей перед вызовом функции `AddNew`, снова становится текущей вне зависимости от успешности выполнения инструкции **INSERT**.  
  
    > [!TIP]
    >  Для обеспечения полного контроля над новой записью можно использовать следующий подход: задайте значения всех полей, которые будут иметь значения, после чего явным образом задайте все поля, которые сохранят значение Null, вызвав `SetFieldNull` с указателем на поле и параметром **TRUE** \(по умолчанию\).  Если поле не должно записываться в источник данных, вызовите метод `SetFieldDirty` с указателем на поле и параметром **FALSE**, не изменяя значение поля.  Чтобы определить, допустимо ли для данного поля значение Null, вызовите `IsFieldNullable`.  
  
    > [!TIP]
    >  Для обнаружения изменений значений элементов данных набора записей MFC использует значение **PSEUDO\_NULL**, соответствующее каждому типу данных, которые могут храниться в наборе записей.  Если полю необходимо явным образом присвоить значение **PSEUDO\_NULL**, но оно уже помечено как Null, необходимо также вызвать метод `SetFieldNull`, передав адрес поля в качестве первого параметра и значение **FALSE** в качестве второго параметра.  
  
##  <a name="_core_visibility_of_added_records"></a> Видимость добавленных записей  
 Когда добавленная запись является видимой для набора записей?  Добавленные записи могут являться видимыми в зависимости от двух факторов:  
  
-   возможностей драйвера;  
  
-   возможностей, которые может использовать среда.  
  
 Если драйвер ODBC поддерживает API\-функцию ODBC **::SQLSetPos**, MFC использует эту функцию для добавления записей.  При использовании **::SQLSetPos** добавленные записи являются видимыми для любого обновляемого набора записей MFC.  Если эта функция не поддерживается, добавленные записи являются невидимыми, и чтобы сделать их видимыми, необходимо вызвать **Requery**.  Кроме того, использование функции **::SQLSetPos** является более эффективным.  
  
##  <a name="_core_editing_an_existing_record"></a> Изменение существующей записи  
 Изменение существующей записи в наборе записей предполагает переход к записи, вызов функции\-члена [Edit](../Topic/CRecordset::Edit.md) набора записей, задание значений элементов данных полей для новой записи и вызов функции\-члена [Update](../Topic/CRecordset::Update.md) для записи измененной записи в источник данных.  
  
 Для выполнения вызова функции\-члена **Edit** набор записей должен являться обновляемым и находиться в записи.  Функции\-члены `CanUpdate` и `IsDeleted` позволяют определять эти условия.  Кроме того, текущая запись не должна быть удаленной ранее, а набор записей должен содержать записи \(`IsBOF` и `IsEOF` возвращают значение "0"\).  
  
 При вызове функции\-члена **Edit** запись, находящаяся в буфере редактирования \(текущая запись\), сохраняется.  Значения сохраненной записи используются в дальнейшем для обнаружения изменений в полях.  
  
 После вызова функции\-члена **Edit** в буфере редактирования по\-прежнему содержится текущая запись, однако теперь буфер готов к внесению изменений в элементы данных полей.  Для изменения записи необходимо вручную задать значения для элементов данных полей, которые требуется изменить.  Вместо указания конкретного значения для поля можно вызвать метод `SetFieldNull`, чтобы задать значение Null.  Для фиксации изменений необходимо вызвать функцию\-член **Update**.  
  
> [!TIP]
>  Чтобы выйти из режима `AddNew` или **Edit**, следует вызвать **Move** с параметром **AFX\_MOVE\_REFRESH**.  
  
 Для выполнения вызова функции\-члена **Update** набор записей не должен быть пустым, а текущая запись не должна быть ранее удалена.  `IsBOF`, `IsEOF` и `IsDeleted` должны возвращать значение "0".  
  
 При вызове **Update** для измененной записи выполняются следующие действия:  
  
-   Если драйвер ODBC поддерживает API\-функцию ODBC **::SQLSetPos**, MFC использует эту функцию для обновления записи в источнике данных.  При использовании **::SQLSetPos** драйвер сравнивает содержимое буфера редактирования с соответствующей записью на сервере, обновляя запись на сервере, если они отличаются.  Использование **::SQLSetPos** позволяет MFC более эффективно производить обновление записей, поскольку отсутствует необходимость в построении и обработке инструкции SQL.  
  
     – или –  
  
-   Если функция **::SQLSetPos** не может быть использована, MFC выполняет следующие действия:  
  
    1.  Если изменения не обнаружены, метод **Update** не производит никаких действий и возвращает значение "0".  
  
    2.  При наличии изменений функция **Update** создает инструкцию SQL **UPDATE**.  Столбцы, перечисленные в инструкции **UPDATE**, соответствуют измененным элементам данных полей.  
  
    3.  **Update** фиксирует изменения: выполняется инструкция **UPDATE**, и запись в источнике данных изменяется, если только транзакция не находится в состоянии выполнения \(сведения о влиянии транзакции на выполнение обновления см. в разделе [Транзакции. Выполнение транзакции в наборе записей \(ODBC\)](../../data/odbc/transaction-performing-a-transaction-in-a-recordset-odbc.md)\).  ODBC сохраняет копию записи, которая также изменяется.  
  
    4.  В отличие от выполнения функции `AddNew`, при выполнении функции **Edit** сохраненная запись не восстанавливается.  Измененная запись остается в качестве текущей записи.  
  
    > [!CAUTION]
    >  При подготовке к обновлению набора записей с помощью вызова **Update** следует следить за тем, чтобы в набор записей были включены все столбцы, составляющие первичный ключ таблицы \(или все столбцы уникального индекса таблицы, или столбцы, достаточные для уникальной идентификации строк\).  В некоторых случаях для определения записи в наборе, нуждающейся в обновлении, платформа может использовать только столбцы, выбранные в наборе данных.  При отсутствии необходимых столбцов обновлению может быть подвергнуто несколько записей в таблице.  В таком случае при вызове функции **Update** платформа создает исключения.  
  
    > [!TIP]
    >  Если функции `AddNew` или **Edit** вызываются после того, как одна из них была вызвана ранее, но перед вызовом **Update**, в буфер редактирования помещается хранимая запись вместо текущей новой или измененной записи.  Эта особенность позволяет отменить выполнение функций `AddNew` или **Edit** и вызвать их заново. Если текущая обрабатываемая запись была определена как ошибочная, следует просто повторно вызвать **Edit** или `AddNew`.  
  
##  <a name="_core_deleting_a_record"></a> Удаление записи  
 Удаление записи из набора записей предполагает переход к записи и вызов функции\-члена [Delete](../Topic/CRecordset::Delete.md) набора записей.  В отличие от функций `AddNew` и **Edit**, вызов **Delete** не требует соответствующего вызова **Update**.  
  
 Для выполнения вызова функции\-члена **Delete** набор записей должен являться обновляемым и находиться в записи.  Функции\-члены `CanUpdate`, `IsBOF`, `IsEOF` и `IsDeleted` позволяют определять эти условия.  
  
 При вызове функции\-члена **Delete** выполняются следующие действия:  
  
-   Если драйвер ODBC поддерживает API\-функцию ODBC **::SQLSetPos**, MFC использует эту функцию для удаления записи в источнике данных.  Как правило, использование функции **::SQLSetPos** является более эффективным по сравнению с использованием SQL.  
  
     – или –  
  
-   Если функция **::SQLSetPos** не может быть использована, MFC выполняет следующие действия:  
  
    1.  Резервная копия текущей записи в буфере редактирования не сохраняется, как при вызове `AddNew` и **Edit**.  
  
    2.  Функция **Delete** создает инструкцию SQL **DELETE**, с помощью которой удаляется запись.  
  
         Текущая запись в буфере редактирования не сохраняется, как при вызове `AddNew` и **Edit**.  
  
    3.  Функция **Delete** фиксирует удаление, выполняя инструкцию **DELETE**.  Запись помечается как удаленная в источнике данных и, если запись является снимком, в ODBC.  
  
    4.  Значения удаленной записи все еще находятся в элементах данных полей набора записей, но элементы данных помечаются как Null, а функция\-член `IsDeleted` набора записей возвращает ненулевое значение.  
  
    > [!NOTE]
    >  После удаления записи следует перейти к другой записи, чтобы заполнить буфер редактирования данными новой записи.  Повторный вызов функции **Delete** или вызов **Edit** будет ошибкой.  
  
 Дополнительные сведения об инструкциях SQL, используемых в операциях обновления, см. в разделе [SQL](../../data/odbc/sql.md).  
  
## См. также  
 [Набор записей \(ODBC\)](../../data/odbc/recordset-odbc.md)   
 [Набор записей. Дополнительные сведения об обновлениях \(ODBC\)](../../data/odbc/recordset-more-about-updates-odbc.md)   
 [Обмен данными полями записей \(RFX\)](../../data/odbc/record-field-exchange-rfx.md)