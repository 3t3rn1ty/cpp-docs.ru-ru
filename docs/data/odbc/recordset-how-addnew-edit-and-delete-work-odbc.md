---
title: 'Набор записей: Принципы AddNew, Edit и Delete работы (ODBC) | Документы Microsoft'
ms.custom: ''
ms.date: 11/04/2016
ms.reviewer: ''
ms.suite: ''
ms.technology:
- cpp-windows
ms.tgt_pltfrm: ''
ms.topic: article
dev_langs:
- C++
helpviewer_keywords:
- records [C++], updating
- record editing [C++], in recordsets
- recordsets [C++], adding records
- records [C++], adding
- ODBC recordsets [C++], adding records
- recordsets [C++], editing records
- recordsets [C++], updating
- AddNew method
- ODBC recordsets [C++], deleting records
- records [C++], deleting in recordsets
- data in recordsets [C++]
- recordsets [C++], deleting records
- ODBC recordsets [C++], editing records
- records [C++], editing
ms.assetid: cab43d43-235a-4bed-ac05-67d10e94f34e
caps.latest.revision: 9
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
- data-storage
ms.openlocfilehash: dbbf224797bd7d2eed2b085a6a7dd8eb1865de1c
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="recordset-how-addnew-edit-and-delete-work-odbc"></a>Наборы записей. Принципы работы функций AddNew, Edit и Delete (ODBC)
Этот раздел относится к классам MFC ODBC.  
  
 В этом разделе объясняется, как `AddNew`, **изменить**, и **удаление** функции-члены класса `CRecordset` работы. Рассмотрены следующие темы.  
  
-   [Принципы добавления записей](#_core_adding_a_record)  
  
-   [Видимость добавленных записей](#_core_visibility_of_added_records)  
  
-   [Изменение записей](#_core_editing_an_existing_record)  
  
-   [Принципы удаления записей](#_core_deleting_a_record)  
  
> [!NOTE]
>  Этот раздел относится к объектам, производным от `CRecordset` в какой строке массовая выборка не был реализован. Если используется выборка строк, см. раздел [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
 В дополнение вы можете прочитать [обмен полями записей: принцип работы RFX](../../data/odbc/record-field-exchange-how-rfx-works.md), описывающей роль RFX при выполнении операций обновления.  
  
##  <a name="_core_adding_a_record"></a>Добавление записи  

 Добавление новой записи в набор записей заключается в вызове набора записей [AddNew](../../mfc/reference/crecordset-class.md#addnew) функция-член, задание значений элементов данных полей для новой записи и вызов [обновление](../../mfc/reference/crecordset-class.md#update) функции-члена для записи запись в источник данных.  
  
 В вызове функции-члена `AddNew`, набор записей не должен быть открыт только для чтения. `CanUpdate` И `CanAppend` функции-члены позволяют определять эти условия.  
  
 При вызове `AddNew`:  
  
-   Запись в буфере редактирования, сохраняется, чтобы можно было восстановить его содержимое, если операция отменена.  
  
-   Члены данных полей помечаются флагами, имеется возможность обнаружения изменений в их позже. Данные поля, элементы также помечаются как чистые (без изменений) и присваивается значение Null.  
  
 После вызова метода `AddNew`, представляет новый буфер редактирования, пустая запись, заполняется с использованием значений. Чтобы сделать это, можно вручную установить значения путем назначения им. Вместо указания конкретного значения для поля, можно вызвать `SetFieldNull` для указания значения Null.  
  
 Для фиксации изменений необходимо вызвать **обновление**. При вызове **обновление** для новой записи:  
  
-   Если драйвер ODBC поддерживает **:: SQLSetPos** API-интерфейса ODBC, MFC использует эту функцию для добавления записи в источнике данных. С **:: SQLSetPos**, MFC можно добавить запись более эффективно, так как отсутствует необходимость в построении и обработке инструкции SQL.  
  
-   Если **:: SQLSetPos** не может быть использована, MFC выполняет следующее:  
  
    1.  Если изменения не обнаружены, **обновление** не выполняет никаких действий и возвращает 0.  
  
    2.  Если были внесены изменения, **обновление** создает SQL **вставить** инструкции. Столбцы, представленные все «грязные» поля элементов данных, перечислены в **вставить** инструкции. Чтобы принудительно включить столбец, вызовите [SetFieldDirty](../../mfc/reference/crecordset-class.md#setfielddirty) функции-члена:  
  
        ```  
        SetFieldDirty( &m_dataMember, TRUE );  
        ```  
  
    3.  **Обновление** фиксирует новую запись — **вставить** выполняется инструкция, и запись фиксируется в таблицу источника данных (и в наборе записей, если он не моментальный снимок), если транзакция выполняется.  
  
    4.  Сохраненная запись восстанавливается в буфере. Записи, которая была текущей до `AddNew` вызова текущего снова независимо от того, следует ли **вставить** инструкция была выполнена успешно.  
  
    > [!TIP]
    >  Для обеспечения полного контроля над новой записью можно использовать следующий подход: задайте значения всех полей, которые будут иметь значения явно задать все поля, которые сохранят значение Null, вызвав `SetFieldNull` с указателем на поле и параметром **TRUE**  (по умолчанию). Если вы хотите убедиться, что поле не записывается в источнике данных, вызова `SetFieldDirty` с указателем на поле и параметром **FALSE**и не изменяйте значение поля. Чтобы определить, разрешено ли поле иметь значение Null, вызовите `IsFieldNullable`.  
  
    > [!TIP]
    >  Для обнаружения изменений значений элементов данных набора записей, MFC использует **PSEUDO_NULL** значение, подходящее для каждого типа данных, которые могут храниться в наборе записей. Если необходимо явно задать поле **PSEUDO_NULL** значения, а поле происходит уже помечено как Null, необходимо вызвать `SetFieldNull`, передав адрес поля в качестве первого параметра и **FALSE**в качестве второго параметра.  
  
##  <a name="_core_visibility_of_added_records"></a>Видимость добавленных записей  
 Если добавленная запись является видимой для набора записей? Иногда отображаются добавленных записей и иногда не отображаются, в зависимости от две вещи:  
  
-   Какой драйвер способен.  
  
-   Какие платформы можно воспользоваться преимуществами.  
  
 Если драйвер ODBC поддерживает **:: SQLSetPos** API-интерфейса ODBC, MFC использует эту функцию для добавления записей. С **:: SQLSetPos**, добавленные записи являются видимыми для любого обновляемого набора записей MFC. Не поддерживается для функции, добавленные записи не отображаются, и необходимо вызвать **Requery** для их просмотра. С помощью **:: SQLSetPos** также является более эффективным.  
  
##  <a name="_core_editing_an_existing_record"></a>Изменение существующей записи  
 Изменение существующей записи в наборе записей предполагает переход к записи, вызов набора записей [изменить](../../mfc/reference/crecordset-class.md#edit) функция-член, задание значений элементов данных полей для новой записи и вызов [обновить](../../mfc/reference/crecordset-class.md#update)функции-члена для записи измененной записи в источник данных.  
  
 В вызове функции-члена **изменить**, набора записей должно быть обновляемым и на запись. `CanUpdate` И `IsDeleted` функции-члены позволяют определять эти условия. Текущая запись также должна не уже были удалены, а в наборе записей должен содержать записи (оба `IsBOF` и `IsEOF` возвращают 0).  
  
 При вызове **изменить**, запись в буфере редактирования (текущая запись), сохраняется. Позже сохраненной записи используются для определения того, были ли изменены все поля.  
  
 После вызова метода **изменить**, в буфере по-прежнему представляет текущую запись, но теперь готов к внесению изменений элементами данных полей. Чтобы изменить запись, вручную установить значения членов данных поля, которую требуется изменить. Вместо указания конкретного значения для поля, можно вызвать `SetFieldNull` для указания значения Null. Для фиксации изменений необходимо вызвать **обновление**.  
  
> [!TIP]
>  Чтобы получить из `AddNew` или **изменить** режиме, вызовите **переместить** с параметром **AFX_MOVE_REFRESH**.  
  
 В вызове функции-члена **обновление**, набор записей не может быть пустым, и текущая запись не должны были быть удалены. `IsBOF`, `IsEOF`, и `IsDeleted` должен возвращать 0.  
  
 При вызове **обновление** для измененной записи:  
  
-   Если драйвер ODBC поддерживает **:: SQLSetPos** API-интерфейса ODBC, MFC использует эту функцию для обновления записей в источнике данных. С **:: SQLSetPos**, драйвер сравнивает содержимое буфера редактирования с соответствующей записью на сервере, обновляя запись на сервере, если они отличаются. С **:: SQLSetPos**, MFC более эффективно производить обновление записей, так как отсутствует необходимость в построении и обработке инструкции SQL.  
  
     - или -  
  
-   Если **:: SQLSetPos** не может быть использована, MFC выполняет следующее:  
  
    1.  Если изменения не были **обновление** не выполняет никаких действий и возвращает 0.  
  
    2.  Если были внесены изменения, **обновление** создает SQL **обновление** инструкции. Столбцы, перечисленные в **обновление** инструкции основаны на поля элементов данных, которые были изменены.  
  
    3.  **Обновление** фиксирует изменения — выполняет **обновление** инструкции — и запись в источнике данных изменяется, но если только транзакция не выполняется (см. [транзакции: выполнение транзакции в набор записей (ODBC)](../../data/odbc/transaction-performing-a-transaction-in-a-recordset-odbc.md) сведения о влиянии транзакции на выполнение обновления). ODBC сохраняет копию записи, которая также изменяется.  
  
    4.  В отличие от выполнения `AddNew`, **изменить** сохраненная запись не восстанавливается. Измененной записи остается в качестве текущей записи.  
  
    > [!CAUTION]
    >  При подготовке к обновлению набора записей путем вызова **обновление**, будьте внимательны, что набор записей включает все столбцы, составляющие первичный ключ таблицы (или все столбцы из любой уникальный индекс для столбца таблицы или столбцы, достаточные для уникальной идентифицировать строку). В некоторых случаях платформу можно использовать для определения записи в таблице для обновления только столбцы, выбранные в наборе записей. Без необходимых столбцов может обновить несколько записей в таблице. В этом случае платформа создает исключения, при вызове **обновление**.  
  
    > [!TIP]
    >  При вызове метода `AddNew` или **изменить** после вызова либо функции ранее, но до вызова **обновление**, обновляются с использованием хранимая запись вместо текущей новой или измененной записи в буфере Ход выполнения. Такое поведение позволяет прервать `AddNew` или **изменить** и начать новый: Если выяснилось, что запись выполняется неисправен, просто вызвать **изменить** или `AddNew` еще раз.  
  
##  <a name="_core_deleting_a_record"></a>Удаление записи  
 Удаление записи из набора записей предполагает переход к записи и вызов набора записей [удалить](../../mfc/reference/crecordset-class.md#delete) функции-члена. В отличие от `AddNew` и **изменить**, **удаление** не требует соответствующего вызова **обновление**.  
  
 В вызове функции-члена **удалить**, набор записей должна быть обновлена, и он должен быть на запись. `CanUpdate`, `IsBOF`, `IsEOF`, И `IsDeleted` функции-члены позволяют определять эти условия.  
  
 При вызове **удалить**:  
  
-   Если драйвер ODBC поддерживает **:: SQLSetPos** API-интерфейса ODBC, MFC использует эту функцию для удаления записи в источнике данных. С помощью **:: SQLSetPos** обычно более эффективен, чем при использовании SQL.  
  
     - или -  
  
-   Если **:: SQLSetPos** не может быть использована, MFC выполняет следующее:  
  
    1.  В качестве текущей записи в буфере редактирования не резервного копирования `AddNew` и **изменить**.  
  
    2.  **Удалить** создает SQL **удалить** инструкцию, которая удаляет запись.  
  
         Текущая запись в буфере редактирования не сохраняется как в `AddNew` и **изменить**.  
  
    3.  **Удалить** фиксирует удаление — выполняет **удалить** инструкции. Запись помечается как удаленная в источнике данных и, если запись является моментальным снимком, в ODBC.  
  
    4.  Удаленная запись все еще находятся в элементами данных полей в наборе записей, но элементами данных полей помечаются Null и набора записей `IsDeleted` функция-член возвращает ненулевое значение.  
  
    > [!NOTE]
    >  После удаления записи, следует перейти к другой записи, чтобы заполнить буфер редактирования данными новой записи. Это ошибка для вызова **удаление** еще раз или вызвать **изменить**.  
  
 Сведения об инструкциях SQL, используемых в операциях обновления см. в разделе [SQL](../../data/odbc/sql.md).  
  
## <a name="see-also"></a>См. также  
 [Набор записей (ODBC)](../../data/odbc/recordset-odbc.md)   
 [Набор записей: Дополнительные сведения об обновлениях (ODBC)](../../data/odbc/recordset-more-about-updates-odbc.md)   
 [Обмен данными полей записей (RFX)](../../data/odbc/record-field-exchange-rfx.md)