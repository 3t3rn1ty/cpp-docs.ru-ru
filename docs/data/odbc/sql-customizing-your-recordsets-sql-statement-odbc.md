---
title: 'SQL: Настройка инструкции SQL набора записей (ODBC) | Документы Microsoft'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-data
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- recordsets, SQL statements
- ODBC recordsets, SQL statements
- SQL statements, customizing
- SQL statements, recordset
- customizing SQL statements
- overriding, SQL statements
- SQL, opening recordsets
ms.assetid: 72293a08-cef2-4be2-aa1c-30565fcfbaf9
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- data-storage
ms.openlocfilehash: f385127d1b61e1453eb7a079963da727f82f1874
ms.sourcegitcommit: 76b7653ae443a2b8eb1186b789f8503609d6453e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
ms.locfileid: "33098593"
---
# <a name="sql-customizing-your-recordsets-sql-statement-odbc"></a>SQL. Настройка инструкции SQL набора записей (ODBC)
Содержание раздела:  
  
-   Как платформа создает инструкцию SQL  
  
-   Переопределение инструкции SQL  
  
> [!NOTE]
>  Эти сведения относятся к классам MFC ODBC. При работе с классами MFC DAO см. в разделе «Сравнение Microsoft Jet базы данных ядра SQL и ANSI SQL» справки DAO.  
  
## <a name="sql-statement-construction"></a>Создание инструкции SQL  
 Набор записей оснований выбора записей главным образом от SQL **ВЫБЕРИТЕ** инструкции. При объявлении класса с помощью мастера, она записывает переопределение `GetDefaultSQL` функция-член, выглядит следующим образом (класс набора записей с именем `CAuthors`).  
  
```  
CString CAuthors::GetDefaultSQL()  
{  
    return "AUTHORS";  
}  
```  
  
 По умолчанию это переопределение возвращает имя таблицы, указанное с помощью мастера. В этом примере имя таблицы — «АВТОРЫ». При последующем вызове набора записей **откройте** функции-члена **откройте** создает окончательную **ВЫБЕРИТЕ** инструкции формы:  
  
```  
SELECT rfx-field-list FROM table-name [WHERE m_strFilter]   
       [ORDER BY m_strSort]  
```  
  
 где `table-name` получается путем вызова метода `GetDefaultSQL` и `rfx-field-list` получается из функции RFX в `DoFieldExchange`. Это именно **ВЫБЕРИТЕ** инструкции, если не будет заменена переопределением во время выполнения, несмотря на то, что также можно изменить инструкцию по умолчанию с параметрами или фильтра.  
  
> [!NOTE]
>  Если указать имя столбца, который содержит (или может содержать) пробелы, необходимо заключить имя в квадратные скобки. К примеру имя «Имя» должен быть «[имя]».  
  
 Чтобы переопределить значение по умолчанию **ВЫБЕРИТЕ** инструкции, передайте строку, содержащую полный **ВЫБЕРИТЕ** инструкции при вызове **откройте**. Вместо создания собственной строки по умолчанию, набор записей использует строку. Если замещающая инструкция содержит **ГДЕ** предложения, не указать фильтр в **m_strFilter** так, как вам потребуется указать два фильтра инструкций. Аналогично Если замещающая инструкция содержит **ORDER BY** предложения, не указать порядок сортировки в `m_strSort` , чтобы не будет иметь двух инструкций сортировки.  
  
> [!NOTE]
>  При использовании строк-литералов в фильтрах (или другие части инструкции SQL), может потребоваться «Квота» (заключить в указанные разделители) такие строки литерал префиксом СУБД и литералов суффикс символ (или символы).  
  
 В зависимости от используемой СУБД также могут возникнуть особые требования к синтаксису для операции, такие как внешние соединения. Использование функции ODBC для получения этих сведений из драйвера для СУБД. Например, вызов **:: SQLGetTypeInfo** для определенного типа данных, таких как **SQL_VARCHAR**, запрашивая **LITERAL_PREFIX** и **LITERAL_SUFFIX** символов. При написании кода базы данных, см в *ODBC SDK ** Справочник программиста* на компакт-диске библиотеки MSDN подробные сведения о синтаксисе.  
  
 Объект набора записей создает инструкцию SQL, который используется для выбора записей, если не передать пользовательские инструкции SQL. Как это можно сделать зависит главным образом от значения, передаваемого в `lpszSQL` параметр **откройте** функции-члена.  
  
 Общая форма SQL **ВЫБЕРИТЕ** инструкции:  
  
```  
SELECT [ALL | DISTINCT] column-list FROM table-list  
    [WHERE search-condition][ORDER BY column-list [ASC | DESC]]  
```  
  
 Один из способов добавления **DISTINCT** ключевое слово для инструкции SQL набора записей является внедрение этого ключевого слова в первый вызов функции RFX в `DoFieldExchange`. Например:  
  
```  
...  
    RFX_Text(pFX, "DISTINCT CourseID", m_strCourseID);  
...  
```  
  
> [!NOTE]
>  Этот прием можно используйте только с набором записей, открыт только для чтения.  
  
## <a name="overriding-the-sql-statement"></a>Переопределение инструкции SQL  
 В следующей таблице показаны возможности `lpszSQL` параметр **откройте**. В таблице случаи описаны в следующей таблице.  
  
 **LpszSQL параметра и результирующая строка SQL**  
  
|Case|Передать lpszSQL|Результирующая инструкция SELECT|  
|----------|------------------------------|------------------------------------|  
|1|**NULL**|**ВЫБЕРИТЕ** *списка для полей rfx* **FROM** *имя таблицы*<br /><br /> `CRecordset::Open` вызовы `GetDefaultSQL` для получения имени таблицы. Результирующая строка является одним из случаев 2 – 5, в зависимости от того, что `GetDefaultSQL` возвращает.|  
|2|Имя таблицы|**ВЫБЕРИТЕ** *списка для полей rfx* **FROM** *имя таблицы*<br /><br /> Список полей извлекается из инструкций RFX в `DoFieldExchange`. Если **m_strFilter** и `m_strSort` не являются пустыми, добавляет **ГДЕ** и/или **ORDER BY** предложения.|  
|3 *|Полный **ВЫБЕРИТЕ** инструкции но без **ГДЕ** или **ORDER BY** предложения|Как пройденный. Если **m_strFilter** и `m_strSort` не являются пустыми, добавляет **ГДЕ** и/или **ORDER BY** предложения.|  
|4 *|Полный **ВЫБЕРИТЕ** инструкции с **ГДЕ** и/или **ORDER BY** предложения|Как пройденный. **m_strFilter** или `m_strSort` должно оставаться пустым или два фильтра или сортировки инструкции.|  
|5 *|Вызов хранимой процедуры|Как пройденный.|  
  
 \* `m_nFields` должно быть меньше или равно числу столбцов, указанных в **ВЫБЕРИТЕ** инструкции. Тип данных каждого столбца, указанного в **ВЫБЕРИТЕ** инструкции должны совпадать как тип данных соответствующего выходного столбца RFX.  
  
### <a name="case-1---lpszsql--null"></a>Вариант 1 lpszSQL = NULL  
 Выбранные зависит то, что `GetDefaultSQL` возвращает результат, когда `CRecordset::Open` вызывает ее. Случаев 2 – 5 описываются возможные строки.  
  
### <a name="case-2---lpszsql--a-table-name"></a>Вариант 2 lpszSQL = имя таблицы  
 Набор записей использует обмен полями записей (RFX) для создания списка столбцов по именам, предоставляемых в RFX функция вызывает переопределение класса набора записей `DoFieldExchange`. Если мастер используется для объявления класса набора записей, данный случай имеет тот же результат, в случае 1 (при условии, что необходимо передать же имя таблицы, указанной в мастере). Если не используется мастер для создания класса, вариант 2 является самым простым способом создания инструкции SQL.  
  
 Следующий пример создает инструкцию SQL, который выбирает записи из базы данных приложения MFC. Когда платформа вызывает `GetDefaultSQL` функция-член, функция возвращает имя таблицы, `SECTION`.  
  
```  
CString CEnrollSet::GetDefaultSQL()  
{  
    return "SECTION";  
}  
```  
  
 Чтобы получить имена столбцов для SQL **ВЫБЕРИТЕ** инструкции, платформа вызывает `DoFieldExchange` функции-члена.  
  
```  
void CEnrollSet::DoFieldExchange(CFieldExchange* pFX)  
{  
    pFX->SetFieldType(CFieldExchange::outputColumn);  
    RFX_Text(pFX, "CourseID", m_strCourseID);  
    RFX_Text(pFX, "InstructorID", m_strInstructorID);  
    RFX_Text(pFX, "RoomNo", m_strRoomNo);  
    RFX_Text(pFX, "Schedule", m_strSchedule);  
    RFX_Text(pFX, "SectionNo", m_strSectionNo);  
}  
```  
  
 После завершения инструкции SQL выглядит следующим образом:  
  
```  
SELECT CourseID, InstructorID, RoomNo, Schedule, SectionNo   
    FROM SECTION  
```  
  
### <a name="case-3---lpszsql--a-selectfrom-statement"></a>Вариант 3 lpszSQL = SELECT / FROM, инструкция  
 Укажите список столбцов вручную вместо того чтобы полагаться на RFX автоматического создания. Возможно, вы хотите это сделать, если:  
  
-   Чтобы задать **DISTINCT** ключевое слово после **ВЫБЕРИТЕ**.  
  
     Список столбцов должно соответствовать имена столбцов и типов в том же порядке, как они указаны в `DoFieldExchange`.  
  
-   У вас есть необходимо вручную извлечь значения столбцов с помощью функции ODBC **:: SQLGetData** вместо того чтобы полагаться на RFX для привязки и извлечения столбцов.  
  
     Например, можно включить новые столбцы, для добавления клиента приложения в таблицы базы данных после распространения приложения. Необходимо добавить эти члены-поля данных, которые не были известны во время объявления класса с помощью мастера.  
  
     Список столбцов должно соответствовать имена столбцов и типов в том же порядке, как они перечислены в `DoFieldExchange`, а затем имена столбцов, связываемых вручную. Дополнительные сведения см. в разделе [набор записей: динамическая привязка столбцов данных (ODBC)](../../data/odbc/recordset-dynamically-binding-data-columns-odbc.md).  
  
-   Требуется соединение таблиц несколько таблиц в **FROM** предложения.  
  
     Сведения и пример см. в разделе [набор записей: выполнение Join (ODBC)](../../data/odbc/recordset-performing-a-join-odbc.md).  
  
### <a name="case-4---lpszsql--selectfrom-plus-where-andor-order-by"></a>Вариант 4 lpszSQL = Выбор / с, а также ГДЕ и/или ORDER BY  
 Указывается все: список столбцов (на основе вызовов RFX в `DoFieldExchange`), список таблиц и содержимое **ГДЕ** и/или **ORDER BY** предложения. При указании вашей **ГДЕ** и/или **ORDER BY** предложений таким образом, не используйте **m_strFilter** и/или `m_strSort`.  
  
### <a name="case-5---lpszsql--a-stored-procedure-call"></a>Случай 5 lpszSQL = вызов хранимой процедуры  
 Если необходимо вызвать предопределенный запрос (например, хранимая процедура в базе данных Microsoft SQL Server), необходимо написать **вызвать** инструкцией в строке, передаваемой в `lpszSQL`. Мастер не поддерживает объявление класса набора записей для вызова предопределенного запроса. Не все предопределенные запросы возвращают записи.  
  
 Если предопределенный запрос не возвращает записи, можно использовать `CDatabase` функции-члена `ExecuteSQL` напрямую. Для предопределенных запросов, возвращающих записи, необходимо вручную записать вызовы RFX в `DoFieldExchange` для всех столбцов, процедура возвращает результат. Вызовы функций RFX должен быть в том же порядке и возвращает те же типы, что предопределенного запроса. Дополнительные сведения см. в разделе [набор записей: объявление класса для предопределенных запросов (ODBC)](../../data/odbc/recordset-declaring-a-class-for-a-predefined-query-odbc.md).  
  
## <a name="see-also"></a>См. также  
 [SQL: SQL и типы данных C++ (ODBC)](../../data/odbc/sql-sql-and-cpp-data-types-odbc.md)   
 [SQL. Выполнение прямых вызовов SQL (ODBC)](../../data/odbc/sql-making-direct-sql-calls-odbc.md)
