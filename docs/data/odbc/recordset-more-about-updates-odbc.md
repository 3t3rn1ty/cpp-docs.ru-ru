---
title: "Набор записей: Дополнительные сведения о обновления (ODBC) | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
helpviewer_keywords:
- records, updating
- transactions, updating recordsets
- ODBC recordsets, updating
- multiuser environments, updates to recordsets
- scrolling, updates to recordsets
- updating recordsets
- recordsets, updating
ms.assetid: 0353a742-d226-4fe2-8881-a7daeffe86cd
caps.latest.revision: 
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
- data-storage
ms.openlocfilehash: 1ad9042c4001fc1a0e0c8c8d19e5ac53b6312875
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="recordset-more-about-updates-odbc"></a>Набор записей. Дополнительные сведения об обновлениях (ODBC)
Этот раздел относится к классам MFC ODBC.  
  
 Содержание раздела:  
  
-   [Влияние других операций, таких как транзакции, на обновления](#_core_how_transactions_affect_updates).  
  
-   [Обновления и других пользователей](#_core_your_updates_and_the_updates_of_other_users).  
  
-   [Дополнительные сведения о функции-члены Update и Delete](#_core_more_about_update_and_delete).  
  
> [!NOTE]
>  Этот раздел относится к объектам, производным от `CRecordset` в какой строке массовая выборка не был реализован. Если реализована массовая выборка строк, некоторые данные не применяется. Например, невозможно вызвать `AddNew`, **изменить**, **удаление**, и **обновление** функций-членов; тем не менее, можно выполнять транзакции. Дополнительные сведения о массовой выборке строк см. в разделе [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
##  <a name="_core_how_other_operations_affect_updates"></a>Влияние других операций на обновления  
 Обновления зависят от транзакции в силе во время обновления, закрыв набора записей до завершения транзакции и прокручивается до завершения транзакции.  
  
###  <a name="_core_how_transactions_affect_updates"></a>Влияние транзакций на обновления  
 Помимо понимания как `AddNew`, **изменить**, и **удалить** работы, важно понять, как **BeginTrans**, **CommitTrans**, и **отката** функциями-членами [CDatabase](../../mfc/reference/cdatabase-class.md) работают с функциями обновления класса [CRecordset](../../mfc/reference/crecordset-class.md).  
  
 По умолчанию, вызывает `AddNew` и **изменить** влияют на источник данных, немедленно при вызове **обновление**. **Удалить** вызовы вступают в силу немедленно. Однако можно создать транзакцию и выполнить группу таких вызовов. Обновления не являются постоянными, до их фиксации. Если вы передумаете, можно выполнить откат транзакции, а его фиксации.  
  
 Дополнительные сведения о транзакциях см. в разделе [транзакции (ODBC)](../../data/odbc/transaction-odbc.md).  
  
###  <a name="_core_how_closing_the_recordset_affects_updates"></a>Влияние закрытия набора записей на обновление  
 Если вы закроете набор записей или связанный с ним `CDatabase` объекта с транзакцией в данный момент (не вызывался [CDatabase::CommitTrans](../../mfc/reference/cdatabase-class.md#committrans) или [CDatabase::Rollback](../../mfc/reference/cdatabase-class.md#rollback)), откат транзакции Создайте резервную автоматически (если не базы данных серверной части базы данных Microsoft Jet).  
  
> [!CAUTION]
>  При использовании базы данных Microsoft Jet, закрытии набора записей в явной транзакции не приводит к появлению освобождение блокировки, которые были размещены пока явная транзакция фиксируется или откатывается назад или строки, которые были изменены. Что вы всегда и открытия и закрытия наборы записей внутри или за пределами явной транзакции Jet рекомендуется.  
  
###  <a name="_core_how_scrolling_affects_updates"></a>Влияние прокрутки на обновление  
 Когда вы [набор записей: прокрутка (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) в наборе записей, каждая новая текущая запись (предыдущая запись при этом не сохраняется) содержатся в буфере. При прокрутке пропускаются ранее удаленные записи. При прокрутке после `AddNew` или **изменить** вызова без вызова **обновление**, **CommitTrans**, или **отката** во-первых, любые изменения При новой записи в буфер, будут потеряны (с предупреждение при этом не отображается). В буфере заполняется новая запись, сохраненная запись освобождается и не происходит никаких изменений в источнике данных. Это относится как к `AddNew` и **изменить**.  
  
##  <a name="_core_your_updates_and_the_updates_of_other_users"></a>Обновления и обновления других пользователей  
 При использовании набора записей для обновления данных, обновлений, влияющих на других пользователей. Аналогичным образом обновления других пользователей в течение времени существования набора записей затрагивают именно вас.  
  
 В многопользовательской среде другие пользователи могут открывать наборы записей, содержащих некоторые из записей, выбранных в наборе записей. Изменения к записи до ее извлечения, отражаются в наборе записей. В динамических наборах извлечение записи каждый раз при прокрутке к нему, отображение выполненных изменений каждый раз при прокрутке к записи. Моментальные снимки извлечение записи при первом запуске прокрутки, поэтому моментальные снимки отражены только те изменения, которые прежде чем перейти к записи, изначально.  
  
 Записи, добавленные другими пользователями после открытия набора записей не отображаются в наборе данных только по отдельному запросу. Если набор записей является динамическим подмножеством данных, изменения, внесенные в существующие записи другими пользователями, отображаются в динамического набора при прокрутке к измененной записи. Если набор записей является моментальным снимком, изменения отображаются только requery моментального снимка. Если вы хотите просмотреть записи, добавленные или удаленные другими пользователями в моментального снимка или записи, добавленные другими пользователями динамического набора, вызовите метод [метод CRecordset::Requery](../../mfc/reference/crecordset-class.md#requery) для перестроения набора записей. (Обратите внимание, что динамического набора показываться удаляемые другими пользователями). Также можно вызвать метод **Requery** для просмотра записей добавляется, но отсутствует для удаления.  
  
> [!TIP]
>  Чтобы выполнить принудительное кэширование всего моментального снимка за один раз, вызовите `MoveLast` сразу после открытия моментального снимка. Затем вызовите **MoveFirst** чтобы начать работу с записями. `MoveLast`— аналогичен прокрутке всех записей, но извлекает их все одновременно. Обратите внимание, что это может привести к снижению производительности и не является обязательным для некоторых драйверов.  
  
 Влияние обновления на других пользователей похожи на их влиянии на вас.  
  
##  <a name="_core_more_about_update_and_delete"></a>Дополнительные сведения о Update и Delete  
 Этот раздел содержит дополнительные сведения, которые помогают работать с **обновление** и **удалить**.  
  
### <a name="update-success-and-failure"></a>Обновление Успех и отказ  
 Если **обновление** завершается успешно, `AddNew` или **изменить** режим заканчивается. Чтобы начать `AddNew` или **изменить** режим, вызовите `AddNew` или **изменить**.  
  
 Если **обновление** сбоя (возвращает **FALSE** или создает исключение), остаются в `AddNew` или **изменить** режим, в зависимости от того, какие функции называемый последнего. Можно затем выполните одно из следующих действий.  
  
-   Изменение элемента данных поля и повторите **обновление** еще раз.  
  
-   Вызовите `AddNew` для сброса поля элементов данных в значение Null, установите значения поля элементов данных, а затем вызвать **обновление** еще раз.  
  
-   Вызовите **изменить** перезагрузить значения, которые были в наборе записей до первого вызова `AddNew` или **изменить**, задайте значения поля элементов данных, а затем вызвать **обновить**еще раз. После успешной **обновление** вызова (за исключением после `AddNew` вызова), элементами данных полей сохраняются новые значения.  
  
-   Вызовите **переместить** (включая **переместить** с параметром **AFX_MOVE_REFRESH**, или 0), который очищает все изменения и завершает `AddNew` или **изменить** действующий режим.  
  
### <a name="update-and-delete"></a>Обновление и удаление  
 Этот раздел относится к обеим версиям **обновление** и **удалить**.  
  
 На **обновление** или **удалить** операции, должны быть обновлены только одна запись. Эта запись является текущей записи, которой соответствует значениям данных в полях набора записей. Если для какой-то причине записи не изменяются или изменяется несколько записей, вызывается исключение с одним из следующих **RETCODE** значения:  
  
-   **AFX_SQL_ERROR_NO_ROWS_AFFECTED**  
  
-   **AFX_SQL_ERROR_MULTIPLE_ROWS_AFFECTED**  
  
 При вызове этих исключений, `AddNew` или **изменить** состояния был выбран при вызове **обновление** или **удалить**. Ниже приведены наиболее распространенные сценарии, в которых отображаются эти исключения. В большинстве случаев для просмотра:  
  
-   **AFX_SQL_ERROR_NO_ROWS_AFFECTED** при использовании режима оптимистической блокировки и другой пользователь изменил запись в результате которого препятствует платформа идентификации нужной записи для обновления или удаления.  
  
-   **AFX_SQL_ERROR_MULTIPLE_ROWS_AFFECTED** при обновлении таблицы не имеет первичного ключа или уникального индекса, а не содержит достаточного количества столбцов в наборе записей для уникальной идентификации строки таблицы.  
  
## <a name="see-also"></a>См. также  
 [Набор записей (ODBC)](../../data/odbc/recordset-odbc.md)   
 [Набор записей: Порядок выборки записей в наборе (ODBC)](../../data/odbc/recordset-how-recordsets-select-records-odbc.md)   
 [Обмен полями записей (RFX)](../../data/odbc/record-field-exchange-rfx.md)   
 [SQL](../../data/odbc/sql.md)   
 [Исключения. Исключения баз данных](../../mfc/exceptions-database-exceptions.md)