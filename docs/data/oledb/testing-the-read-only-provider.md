---
title: "Проверка поставщика в режиме &quot;только для чтения&quot; | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "поставщики OLE DB, вызов"
  - "поставщики OLE DB, проверка"
  - "тестирование поставщиков"
  - "проверка, поставщики OLE DB"
ms.assetid: e4aa30c1-391b-41f8-ac73-5270e46fd712
caps.latest.revision: 8
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
caps.handback.revision: 8
---
# Проверка поставщика в режиме &quot;только для чтения&quot;
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

Для проверки поставщика требуется наличие объекта\-получателя.  Она помогает в том случае, если объект\-получатель может совпадать с поставщиком.  Шаблоны объектов\-получателей OLE DB являются оболочками для OLE DB и соответствуют поставщику COM\-объектов.  Поскольку источник поставляется с шаблонами объектов\-получателей, с их помощью легко провести отладку поставщика.  Шаблоны объектов\-получателей также представляют собой простой и быстрый способ проведения разработки приложений объектов\-получателей.  
  
 В этом разделе показан пример, в котором по умолчанию для проверки объекта\-получателя создается приложение "Мастер приложений MFC".  Этот пример приложения представляет собой простое диалоговое окно, в которое добавлен код шаблона объекта\-получателя OLE DB.  
  
### Создание примера приложения  
  
1.  В меню **Файл** последовательно выберите пункты **Создать** и **Проект**.  
  
2.  В области "Типы проектов" выберите папку **Проекты Visual C\+\+**.  В области "Шаблоны" выберите папку **Приложение MFC**.  
  
3.  Назовите проект **TestProv** и затем нажмите кнопку **ОК**.  
  
     Появится мастер приложений MFC.  
  
4.  На странице **Тип приложения** выберите пункт **На базе диалогового окна**.  
  
5.  На странице **Дополнительные возможности** выберите пункт **Автоматизация** и затем нажмите кнопку **Готово**.  
  
> [!NOTE]
>  Приложение не требует наличия поддержки автоматизации при добавлении метода **CoInitialize** в функцию **CTestProvApp::InitInstance**.  
  
 Можно просматривать и изменять диалоговое окно TestProv \(IDD\_TESTPROV\_DIALOG\) выделив его в окне "Представление ресурса".  Разместите два списка в диалоговом окне, по одному для каждой строки набора строк.  Отключите свойство sort для обоих списков, нажав комбинацию клавиш ALT\+Enter, предварительно выделив список, выберите вкладку **Стили** и снимите флажок **Сортировка**.  Также разместите кнопку **Выполнение** в диалоговом окне для выбора файла.  В завершенном диалоговом окне TestProv должно находиться два списка — "String 1" и "String 2". В нем также присутствуют кнопки **ОК**, **Отмена**, и **Выполнить**.  
  
 Откройте файл заголовка для диалогового класса \(в данном случае, файл TestProvDlg.h\).  Добавьте следующий код в файл заголовка \(вне объявлений классов\):  
  
```  
////////////////////////////////////////////////////////////////////////  
// TestProvDlg.h  
  
class CProvider   
{  
// Attributes  
public:  
   char   szField1[16];  
   char   szField2[16];  
  
   // Binding Maps  
BEGIN_COLUMN_MAP(CProvider)  
   COLUMN_ENTRY(1, szField1)  
   COLUMN_ENTRY(2, szField2)  
END_COLUMN_MAP()  
};  
```  
  
 В коде представлена запись пользователя, определяющая номера столбцов, входящих в набор строк.  При вызове клиентом метода **IAccessor::CreateAccessor** эти записи используются для определения столбцов, которые требуется связать.  С помощью шаблонов объектов\-получателей OLE DB также можно производить динамическое связывание столбцов.  Макрос COLUMN\_ENTRY является клиентской версией макроса PROVIDER\_COLUMN\_ENTRY.  Два макроса COLUMN\_ENTRY указывают порядковый номер, тип, длину и элемент данных для двух строк.  
  
 Добавьте функцию обработчика событий для кнопки **Выполнить** нажав клавишу CTRL и дважды щелкните кнопку **Выполнить**.  Поместите в функцию следующий код:  
  
```  
///////////////////////////////////////////////////////////////////////  
// TestProvDlg.cpp  
  
void CtestProvDlg::OnRun()  
{  
   CCommand<CAccessor<CProvider> > table;  
   CDataSource source;  
   CSession   session;  
  
   if (source.Open("MyProvider.MyProvider.1", NULL) != S_OK)  
      return;  
  
   if (session.Open(source) != S_OK)  
      return;  
  
   if (table.Open(session, _T("c:\\samples\\myprov\\myData.txt")) != S_OK)  
      return;  
  
   while (table.MoveNext() == S_OK)  
   {  
      m_ctlString1.AddString(table.szField1);  
      m_ctlString2.AddString(table.szField2);  
   }  
}  
```  
  
 Классы `CCommand`, `CDataSource` и `CSession` принадлежат к числу шаблонов объектов\-получателей OLE DB.  Каждый класс имитирует COM\-объект в поставщике.  Объект `CCommand` принимает класс `CProvider`, объявленный в файле заголовка, в качестве параметра шаблона.  Параметр `CProvider` представляет привязки, которые используются для получения доступа к данным поставщика.  Здесь код `Open` для источника данных, сеанса и команды.  
  
```  
if (source.Open("MyProvider.MyProvider.1", NULL) != S_OK)  
   return;  
  
if (session.Open(source) != S_OK)  
   return;  
  
if (table.Open(session, _T("c:\\samples\\myprov\\myData.txt")) != S_OK)  
   return;  
```  
  
 Строки для открытия каждого класса создают каждый COM\-объект в поставщике.  Чтобы найти поставщика, используйте ProgID поставщика.  Файл ProgID можно получить из системного реестра или из файла MyProvider.rgs \(откройте директорию поставщика и проведите поиск ключа ProgID\).  
  
 Файл MyData.txt включен в образец MyProv.  Для создания собственного файла используйте редактор и введите четное число строк, отделяя каждую строку нажатием клавиши ENTER.  Измените имя пути при перемещении файла.  
  
 Строка "c:\\\\samples\\\\myprov\\\\MyData.txt" передается в строку `table.Open`.  Если в пошаговом режиме перейти к вызову кода `Open`, то станет видно, что эта строка передается в метод `SetCommandText` поставщика.  Обратите внимание, что метод `ICommandText::Execute` использует эту строку.  
  
 Чтобы извлечь данные, вызовите `MoveNext` для таблицы.  `MoveNext` вызывает функции **IRowset::GetNextRows**, `GetRowCount` и `GetData` functions.  Если строк больше нет \(это происходит, если текущее положение в наборе строк больше значения счетчика строк `GetRowCount`\), цикл завершается:  
  
```  
while (table.MoveNext() == S_OK)  
{  
   m_ctlString1.AddString(table.szField1);  
   m_ctlString2.AddString(table.szField2);  
}  
```  
  
 Обратите внимание, что если строк больше нет, поставщик возвращает значение **DB\_S\_ENDOFROWSET**.  Значение **DB\_S\_ENDOFROWSET** не является ошибкой.  Всегда следует проверять значение `S_OK` для отмены цикла выборки и не использовать макрос SUCCEEDED.  
  
 Теперь можно построить и проверить программу.  
  
## См. также  
 [Усовершенствование простого поставщика только для чтения](../../data/oledb/enhancing-the-simple-read-only-provider.md)