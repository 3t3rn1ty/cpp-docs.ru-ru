---
title: Проверка поставщика только для чтения | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-data
ms.topic: reference
dev_langs:
- C++
helpviewer_keywords:
- testing, OLE DB providers
- testing providers
- OLE DB providers, calling
- OLE DB providers, testing
ms.assetid: e4aa30c1-391b-41f8-ac73-5270e46fd712
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- data-storage
ms.openlocfilehash: 4e8df26063a8d854f643b78fa127d1c17ef43589
ms.sourcegitcommit: 889a75be1232817150be1e0e8d4d7f48f5993af2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/30/2018
ms.locfileid: "39339468"
---
# <a name="testing-the-read-only-provider"></a>Проверка поставщика в режиме "только для чтения"
Для проверки поставщика требуется объект-получатель. Это полезно, если потребитель может совпадать с поставщиком. Шаблоны потребителей OLE DB являются оболочками для OLE DB и соответствуют поставщику COM-объектов. Так как источник поставляется с шаблонами объекта-получателя, это можно легко выполнять отладку поставщика с ними. Шаблоны потребителей также являются простой и быстрый способ разработки приложения-потребители.  
  
 В примере в этом разделе создается приложение по умолчанию мастер приложений MFC для проверки объекта-получателя. Тестовое приложение представляет собой простой диалог с добавленным кодом шаблона потребителя OLE DB.  
  
### <a name="to-create-the-test-application"></a>Создание тестового приложения  
  
1.  В меню **Файл** последовательно выберите пункты **Создать**и **Проект**.  
  
2.  В области "Типы проектов" выберите папку **Проекты Visual C++**. В области «Шаблоны» выберите **приложения MFC**.  
  
3.  Имя проекта, введите **TestProv**, а затем нажмите кнопку **ОК**.  
  
     Появится мастер приложений MFC.  
  
4.  На **тип приложения** выберите **на основе диалоговых окон**.  
  
5.  На **дополнительные функции** выберите **автоматизации**, а затем нажмите кнопку **Готово**.  
  
> [!NOTE]
>  При добавлении приложения не требуется поддержка модели автоматизации **CoInitialize** в **CTestProvApp::InitInstance**.  
  
 Вы можете просматривать и изменять диалоговом окне TestProv (IDD_TESTPROV_DIALOG), выбрав его в представлении ресурсов. Поместите два окна списка, по одному для каждой строки в наборе строк, в диалоговом окне. Отключить свойство sort для обоих списках, нажав клавиши ALT + ВВОД, поле со списком выбран, щелкнув **стили** вкладку и очистке **сортировки** "флажок". Кроме того, поместите **запуска** кнопку в диалоговом окне для выбора файла. Диалоговое окно завершения TestProv должен иметь два окна с меткой «Строка 1» и «строка 2", соответственно; есть также **ОК**, **отменить**, и **запуска** кнопки.  
  
 Откройте файл заголовка для класса диалогового окна (в случае этого, файл TestProvDlg.h). Добавьте следующий код в файл заголовка (вне объявлений классов):  
  
```cpp
////////////////////////////////////////////////////////////////////////  
// TestProvDlg.h  
  
class CProvider   
{  
// Attributes  
public:  
   char   szField1[16];  
   char   szField2[16];  
  
   // Binding Maps  
BEGIN_COLUMN_MAP(CProvider)  
   COLUMN_ENTRY(1, szField1)  
   COLUMN_ENTRY(2, szField2)  
END_COLUMN_MAP()  
};  
```  
  
 Код представляет запись пользователя, который определяет, какие столбцы будут в наборе строк. Когда клиент вызывает `IAccessor::CreateAccessor`, эти записи используются для определения столбцов для привязки. Шаблоны потребителей OLE DB также позволяют динамическая привязка столбцов. COLUMN_ENTRY они версию PROVIDER_COLUMN_ENTRY в клиентские. Два макроса COLUMN_ENTRY указать порядковый номер, тип, длина и элемент данных для двух строк.  
  
 Добавьте функцию обработчика событий для **запуска** кнопку, нажав клавишу CTRL и дважды щелкнув **запуска** кнопки. Поместите следующий код в функцию:  
  
```cpp
///////////////////////////////////////////////////////////////////////  
// TestProvDlg.cpp  
  
void CtestProvDlg::OnRun()  
{  
   CCommand<CAccessor<CProvider>> table;  
   CDataSource source;  
   CSession   session;  
  
   if (source.Open("MyProvider.MyProvider.1", NULL) != S_OK)  
      return;  
  
   if (session.Open(source) != S_OK)  
      return;  
  
   if (table.Open(session, _T("c:\\samples\\myprov\\myData.txt")) != S_OK)  
      return;  
  
   while (table.MoveNext() == S_OK)  
   {  
      m_ctlString1.AddString(table.szField1);  
      m_ctlString2.AddString(table.szField2);  
   }  
}  
```  
  
 `CCommand`, `CDataSource`, И `CSession` классы, которые принадлежат к числу Шаблоны потребителей OLE DB. Каждый класс имитирует COM-объект в поставщике. `CCommand` Объекта принимает `CProvider` класс, объявленный в файле заголовка, в качестве параметра шаблона. `CProvider` Представляет параметр привязки, которые используются для доступа к данным от поставщика. Вот `Open` код для источника данных, сеанса и команды:  
  
```cpp  
if (source.Open("MyProvider.MyProvider.1", NULL) != S_OK)  
   return;  
  
if (session.Open(source) != S_OK)  
   return;  
  
if (table.Open(session, _T("c:\\samples\\myprov\\myData.txt")) != S_OK)  
   return;  
```  
  
 Строки для открытия каждого класса создайте каждого COM-объект в поставщике. Чтобы найти поставщика, используйте идентификатор ProgID поставщика. Идентификатор ProgID можно получить из системного реестра, либо в файле MyProvider.rgs (откройте каталог и выполните поиск ключа ProgID поставщика).  
  
 Файл MyData.txt входит в состав образца поставщика MyProv. Для создания собственного файла, используйте редактор и введите четное число строк, нажав клавишу ВВОД после каждой строки. Измените имя пути, при перемещении файла.  
  
 Передайте строку «c:\\\samples\\\myprov\\\MyData.txt» в `table.Open` строки. При выполнении шага с заходом `Open` вызова, появится эта строка передается `SetCommandText` метод в поставщике. Обратите внимание, что `ICommandText::Execute` метод, используемый этой строки.  
  
 Чтобы извлечь данные, вызовите `MoveNext` для таблицы. `MoveNext` вызовы `IRowset::GetNextRows`, `GetRowCount`, и `GetData` функции. При наличии больше нет строк (то есть текущей позиции в наборе строк больше, чем `GetRowCount`), цикл завершается:  
  
```cpp  
while (table.MoveNext() == S_OK)  
{  
   m_ctlString1.AddString(table.szField1);  
   m_ctlString2.AddString(table.szField2);  
}  
```  
  
 Обратите внимание, что если больше нет строк, поставщики, возвращают DB_S_ENDOFROWSET. Значение DB_S_ENDOFROWSET не ошибка. Всегда следует проверять значение S_OK для отмены цикла выборки и не использовать макрос SUCCEEDED.  
  
 Теперь можно создавать и тестировать программу.  
  
## <a name="see-also"></a>См. также  
 [Усовершенствование простого поставщика только для чтения](../../data/oledb/enhancing-the-simple-read-only-provider.md)