---
title: "Тестирование поставщика только для чтения | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-windows
ms.tgt_pltfrm: 
ms.topic: reference
dev_langs:
- C++
helpviewer_keywords:
- testing, OLE DB providers
- testing providers
- OLE DB providers, calling
- OLE DB providers, testing
ms.assetid: e4aa30c1-391b-41f8-ac73-5270e46fd712
caps.latest.revision: 
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
- data-storage
ms.openlocfilehash: 49f86150afe9116909a137e97a0e04d5a7d54bac
ms.sourcegitcommit: d51ed21ab2b434535f5c1d553b22e432073e1478
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/23/2018
---
# <a name="testing-the-read-only-provider"></a>Проверка поставщика в режиме "только для чтения"
Для проверки поставщика требуется объект-получатель. Это полезно, если потребитель может совпадать с поставщиком. Шаблоны потребителя OLE DB являются оболочками для OLE DB и соответствуют поставщику COM-объектов. Поскольку источник поставляется с шаблонами объектов-получателей, можно легко провести отладку поставщика с ними. Шаблоны потребителя также являются простой и быстрый способ разработки приложения-потребители.  
  
 В этом разделе создается приложение по умолчанию мастер приложений MFC для проверки объекта-получателя. Тестовое приложение представляет собой простой диалог с добавленным кодом шаблона потребителя OLE DB.  
  
### <a name="to-create-the-test-application"></a>Создание тестового приложения  
  
1.  В меню **Файл** последовательно выберите пункты **Создать**и **Проект**.  
  
2.  На панели типов проекта выберите **проекты Visual C++** папки. В области шаблонов выберите **приложение MFC**.  
  
3.  Имя проекта, введите **TestProv**, а затем нажмите кнопку **ОК**.  
  
     Появится мастер приложений MFC.  
  
4.  На **тип приложения** выберите **на базе диалогового окна**.  
  
5.  На **дополнительные функции** выберите **автоматизации**, а затем нажмите кнопку **Готово**.  
  
> [!NOTE]
>  Приложение не требует поддержки автоматизации при добавлении **CoInitialize** в **CTestProvApp::InitInstance**.  
  
 Можно просмотреть и изменить диалоговое окно TestProv (IDD_TESTPROV_DIALOG), выбрав его в представлении ресурсов. Установите два окна списка, по одному для каждой строки в наборе строк, в диалоговом окне. Отключить свойство sort для обоих полей со списком, нажав клавиши ALT + ВВОД, выделив поле со списком, щелкнув **стили** вкладку и очистке **сортировки** флажок. Кроме того, поместите **запуска** кнопку в диалоговом окне для выбора файла. Диалоговое окно по завершении TestProv должен иметь два окна с меткой «Строка 1» и «String-2», соответственно; Он также имеет **ОК**, **отменить**, и **запуска** кнопки.  
  
 Откройте файл заголовка для класса диалогового окна (в случае это, файл TestProvDlg.h). Добавьте следующий код в файл заголовка (вне объявлений классов):  
  
```cpp
////////////////////////////////////////////////////////////////////////  
// TestProvDlg.h  
  
class CProvider   
{  
// Attributes  
public:  
   char   szField1[16];  
   char   szField2[16];  
  
   // Binding Maps  
BEGIN_COLUMN_MAP(CProvider)  
   COLUMN_ENTRY(1, szField1)  
   COLUMN_ENTRY(2, szField2)  
END_COLUMN_MAP()  
};  
```  
  
 Код представляет запись пользователя, который определяет, какие столбцы будут в наборе строк. Когда клиент вызывает **IAccessor::CreateAccessor**, эти записи используются для определения столбцов для привязки. Шаблоны потребителя OLE DB также позволяют динамическая привязка столбцов. COLUMN_ENTRY они клиентскую версию PROVIDER_COLUMN_ENTRY макросов. Два макроса COLUMN_ENTRY указать порядковый номер, тип, длину и элемент данных для двух строк.  
  
 Добавьте функцию обработчика событий для **запуска** кнопку, удерживая клавишу CTRL и дважды щелкнув **запуска** кнопки. Поместите следующий код в функцию:  
  
```cpp
///////////////////////////////////////////////////////////////////////  
// TestProvDlg.cpp  
  
void CtestProvDlg::OnRun()  
{  
   CCommand<CAccessor<CProvider>> table;  
   CDataSource source;  
   CSession   session;  
  
   if (source.Open("MyProvider.MyProvider.1", NULL) != S_OK)  
      return;  
  
   if (session.Open(source) != S_OK)  
      return;  
  
   if (table.Open(session, _T("c:\\samples\\myprov\\myData.txt")) != S_OK)  
      return;  
  
   while (table.MoveNext() == S_OK)  
   {  
      m_ctlString1.AddString(table.szField1);  
      m_ctlString2.AddString(table.szField2);  
   }  
}  
```  
  
 `CCommand`, `CDataSource`, И `CSession` классов, принадлежащих шаблоны потребителя OLE DB. Каждый класс имитирует COM-объект в поставщике. `CCommand` Принимает `CProvider` класс, объявленный в файле заголовка, в качестве параметра шаблона. `CProvider` Представляет параметр привязки, которые используются для доступа к данным от поставщика. Вот `Open` код для источника данных, сеанса и команды:  
  
```  
if (source.Open("MyProvider.MyProvider.1", NULL) != S_OK)  
   return;  
  
if (session.Open(source) != S_OK)  
   return;  
  
if (table.Open(session, _T("c:\\samples\\myprov\\myData.txt")) != S_OK)  
   return;  
```  
  
 Строки для открытия каждого класса создайте каждый COM-объект в поставщике. Чтобы найти поставщика, используйте ProgID поставщика. Идентификатор ProgID можно получить из системного реестра, или в файле MyProvider.rgs (откройте каталог и выполните поиск ключа ProgID поставщика).  
  
 Файл MyData.txt входит в состав образца поставщика MyProv. Для создания собственного файла, используйте редактор и введите четное число строк, нажимая клавишу ВВОД после каждой строки. Измените имя пути при перемещении файла.  
  
 Передайте строку «c:\\\samples\\\myprov\\\MyData.txt» в `table.Open` строки. Если зайти в `Open` вызов, вы видите, что эта строка передается `SetCommandText` метод в поставщике. Обратите внимание, что `ICommandText::Execute` метод, используемый этой строки.  
  
 Чтобы извлечь данные, вызовите `MoveNext` для таблицы. `MoveNext` вызовы **IRowset::GetNextRows**, `GetRowCount`, и `GetData` функции. Если отсутствуют дополнительные строки (то есть текущее положение в наборе строк больше, чем `GetRowCount`), цикл завершается:  
  
```  
while (table.MoveNext() == S_OK)  
{  
   m_ctlString1.AddString(table.szField1);  
   m_ctlString2.AddString(table.szField2);  
}  
```  
  
 Обратите внимание, что если больше нет строк, поставщики, возвращают **DB_S_ENDOFROWSET**. **DB_S_ENDOFROWSET** значение не является ошибкой. Всегда следует проверять `S_OK` для отмены цикла выборки и не использовать макрос SUCCEEDED.  
  
 Теперь можно собрать и протестировать программу.  
  
## <a name="see-also"></a>См. также  
 [Усовершенствование простого поставщика только для чтения](../../data/oledb/enhancing-the-simple-read-only-provider.md)