---
title: "signal | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
apiname: 
  - "signal"
apilocation: 
  - "msvcrt.dll"
  - "msvcr80.dll"
  - "msvcr90.dll"
  - "msvcr100.dll"
  - "msvcr100_clr0400.dll"
  - "msvcr110.dll"
  - "msvcr110_clr0400.dll"
  - "msvcr120.dll"
  - "msvcr120_clr0400.dll"
  - "ucrtbase.dll"
  - "api-ms-win-crt-runtime-l1-1-0.dll"
apitype: "DLLExport"
f1_keywords: 
  - "signal"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "signal - функция"
ms.assetid: 094118de-d789-4063-b4f4-cffcc80bf29d
caps.latest.revision: 26
author: "corob-msft"
ms.author: "corob"
manager: "ghogen"
caps.handback.revision: 26
---
# signal
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

Установка обработки сигналов прерываний.  
  
> [!IMPORTANT]
>  Не используйте этот метод для завершения приложения [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)], за исключением сценариев тестирования или отладки.  Закрытие приложения [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] программным способом или с помощью пользовательского интерфейса на допускается в соответствии с разделом 3.6 [сертификационных требований к приложениям для Windows 8](http://go.microsoft.com/fwlink/?LinkId=262889).  Дополнительные сведения см. в разделе [Жизненный цикл приложения \(приложения Магазина Windows\)](http://go.microsoft.com/fwlink/?LinkId=262853).  
  
## Синтаксис  
  
```  
void (__cdecl *signal(  
   int sig,   
   void (__cdecl *func ) (int [, int ] )))   
   (int);  
```  
  
#### Параметры  
 `sig`  
 Значение сигнала.  
  
 `func`  
 Выполняемая функция.  Первый параметр является значением сигнала, второй \- дополнительным кодом, который может быть использован, когда первый параметр \- SIGFPE.  
  
## Возвращаемое значение  
 `signal` возвращает предыдущее значение `func`, связанное с заданным сигналом.  Например, если предыдущее значение `func` было `SIG_IGN`, то возвращаемое значение также является `SIG_IGN`.  Возвращаемое значение `SIG_ERR` отображает ошибку; в этом случае `errno` устанавливается в `EINVAL`.  
  
 См. раздел [errno, \_doserrno, \_sys\_errlist, and \_sys\_nerr](../Topic/errno,%20_doserrno,%20_sys_errlist,%20and%20_sys_nerr.md) для дополнительных сведений о кодах возврата.  
  
## Заметки  
 Функция `signal` позволяет процессу выбрать один из нескольких способов обработки сигнала прерывания от операционной системы.  Аргумент `sig` это прерывание, к которому отвечает `signal`; он должен быть одной из следующих констант манифестов, указанных в SIGNAL.H.  
  
|Значение `sig`|Описание|  
|--------------------|--------------|  
|`SIGABRT`|Аварийное завершение|  
|`SIGFPE`|Ошибка в операции с плавающей запятой|  
|`SIGILL`|Недопустимая инструкция|  
|`SIGINT`|Сигнал CTRL\+C|  
|`SIGSEGV`|Недопустимый доступ к хранилищу|  
|`SIGTERM`|Запрос завершения|  
  
 Если `sig` не является одним из приведенных выше значений, то вызывается обработчик недопустимого параметра, как определено в [Проверка параметров](../../c-runtime-library/parameter-validation.md).  Если продолжение выполнения разрешено, функция устанавливает `errno` в `EINVAL` и возвращает `SIG_ERR`.  
  
 По умолчанию `signal` завершает вызывающую программу с кодом завершения 3, независимо от значения `sig`.  
  
> [!NOTE]
>  `SIGINT` не поддерживается для любого приложения Win32.  Если происходит прерывание CTRL\+C, операционные системы Win32 создают новый поток специально для обработки этого прерывания.  Это может привести к тому, что однопоточное приложение, как в UNIX, становится многопоточным, что вызывает непредвиденное поведение.  
  
 Аргумент `func` — это адрес написанного обработчика сигнала или одной из предопределенных констант `SIG_DFL` или `SIG_IGN`, указанных в SIGNAL.H.  Если `func` — функция, она установлена как обработчик сигнала для данного сигнала.  Прототип обработчика сигнала требует один формальный аргумент, `sig` типа `int`.  Операционная система предоставляет фактический аргумент через `sig`, когда происходит прерывание; аргумент это сигнал, вызвавший прерывание.  Поэтому можно использовать шесть констант манифеста \(перечисленных в приведенной выше таблице\) в обработчике сигнала, чтобы определить, какое прерывание произошло, и предпринять соответствующие действия.  Например, можно вызвать `signal` дважды, чтобы назначить один и тот же обработчик на два различных сигнала, и затем проверить аргумент `sig` в обработчике для выполнения различных действий на основании полученного сигнала.  
  
 При проверке на исключение с плавающей запятой \(`SIGFPE`\) `func` указывает на функцию, которая принимает необязательный второй аргумент, являющийся одной из нескольких констант манифеста, определенных в файле FLOAT.H формы `FPE_xxx`.  При возникновении сигнала `SIGFPE` можно проверить значение второго аргумента для того, чтобы определить вид исключения в операции с плавающей запятой, а затем предпринять соответствующее действие.  Этот аргумент и его возможные значения являются расширениями Microsoft.  
  
 Для исключений в операциях с плавающей запятой значение `func` не сбрасывается после получения сигнала.  Для восстановления после исключения в операции с плавающей запятой, используйте конструкции try\/except, связанные с операциями с плавающей запятой.  Кроме того, можно восстановиться, используя [setjmp](../../c-runtime-library/reference/setjmp.md) с [longjmp](../../c-runtime-library/reference/longjmp.md).  В любом случае, вызывающий процесс продолжает выполнение и заканчивается с неопределенным состоянием регистров с плавающей запятой.  
  
 Если обработчик сигнала завершается, вызывающий процесс продолжает выполнение сразу после точки, на которой он получил сигнал прерывания.  Это верно независимо от вида сигнала или режима работы.  
  
 Прежде чем функция будет выполняться, значение `func` установлено в `SIG_DFL`.  Следующий сигнал прерывания обрабатывается как описано для `SIG_DFL`, если промежуточный вызов `signal` не укажет другое.  С помощью этой функции для сброса сигналов в вызванной функции.  
  
 Поскольку функции обработчиков сигналов обычно вызываются асинхронно при возникновении прерывания, функция обработчика сигнала может получить управления, когда операция среды выполнения не полностью завершена и находится в неопределенном состоянии.  Следующий список приводит ограничения, которые определяют, какие функции могут использоваться в функции обработчика сигнала.  
  
-   Не указывайте процедуры ввода\/вывода низкого уровня или из STDIO.H \(например, `printf` или `fread`\).  
  
-   Не вызывайте процедуры кучи или другие процедуры, использующие процедуры кучи \(например, `malloc`, `_strdup` или `_putenv`\).  Дополнительные сведения см. в разделе [malloc](../../c-runtime-library/reference/malloc.md).  
  
-   Не используйте какие\-либо функции, которые создают системный вызов \(например, `_getcwd` или `time`\).  
  
-   Не используйте `longjmp`, если прерывание не вызвано исключением в операции с плавающей точкой \(то есть `sig,`  равно `SIGFPE`\).  В этом случае вначале следует инициализировать пакет операций с плавающей точкой с помощью вызова `_fpreset`.  
  
-   Не следует использовать функции, которые могли быть уже вызваны.  
  
 Программа должна содержать код с операциями с плавающей точкой, если она отлавливает исключение `SIGFPE` с помощью этой функции.  Если программа не содержит код, использующий операции с плавающей точкой, и требует выполнение кода обработчиков сигналов библиотеки времени выполнения, только объявите зависимый тип double и инициализируйте его нулем.  
  
```  
volatile double d = 0.0f;   
```  
  
 Сигналы `SIGILL` и `SIGTERM` не формируются в Windows.  Они включены для режима совместимости ANSI.  Таким образом, можно задать обработчики сигнала для этих сигналов с помощью `signal`, а также явно создавать эти сигналы с помощью вызова [raise](../../c-runtime-library/reference/raise.md).  
  
 Параметры сигнала не сохраняются в порожденных процессах, созданных вызовами функций `_exec` или `_spawn`.  Параметры сигнала сбрасываются в значения по умолчанию в новом процессе.  
  
## Требования  
  
|Подпрограмма|Обязательный заголовок|  
|------------------|----------------------------|  
|`signal`|\<signal.h\>|  
  
 Дополнительные сведения о совместимости см. в разделе [Совместимость](../../c-runtime-library/compatibility.md).  
  
## Пример  
 В следующем примере показано, как использовать `signal` для добавления пользовательской функциональности сигналу `SIGABRT`.  Дополнительные сведения о расширениях функциональности прерывания см. в разделе [\_set\_abort\_behavior](../../c-runtime-library/reference/set-abort-behavior.md).  
  
```cpp  
// crt_signal.c  
// compile with: /EHsc /W4  
// Use signal to attach a signal handler to the abort routine  
#include <stdlib.h>  
#include <signal.h>  
#include <tchar.h>  
  
void SignalHandler(int signal)  
{  
    if (signal == SIGABRT) {  
        // abort signal handler code  
    } else {  
        // ...  
    }  
}  
  
int main()  
{  
    typedef void (*SignalHandlerPointer)(int);  
  
    SignalHandlerPointer previousHandler;  
    previousHandler = signal(SIGABRT, SignalHandler);  
  
    abort();  
}  
  
```  
  
  **Приложение потребовало от среды выполнения завершить работу ненормальным образом.**  
**Для получения дополнительных сведений обратитесь в службу поддержки приложения.**   
## Эквивалент в .NET Framework  
 Неприменимо. Для вызова стандартной функции C используйте `PInvoke`. Для получения дополнительной информации см. [Platform Invoke Examples](../Topic/Platform%20Invoke%20Examples.md).  
  
## См. также  
 [Управление процессами и средой](../../c-runtime-library/process-and-environment-control.md)   
 [abort](../../c-runtime-library/reference/abort.md)   
 [Функции \_exec, \_wexec](../../c-runtime-library/exec-wexec-functions.md)   
 [exit, \_Exit, \_exit](../../c-runtime-library/reference/exit-exit-exit.md)   
 [\_fpreset](../../c-runtime-library/reference/fpreset.md)   
 [Функции \_spawn, \_wspawn](../Topic/_spawn,%20_wspawn%20Functions.md)