---
title: "signal | Документы Майкрософт"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-cpp
ms.tgt_pltfrm: 
ms.topic: article
apiname:
- signal
apilocation:
- msvcrt.dll
- msvcr80.dll
- msvcr90.dll
- msvcr100.dll
- msvcr100_clr0400.dll
- msvcr110.dll
- msvcr110_clr0400.dll
- msvcr120.dll
- msvcr120_clr0400.dll
- ucrtbase.dll
- api-ms-win-crt-runtime-l1-1-0.dll
apitype: DLLExport
f1_keywords:
- signal
dev_langs:
- C++
helpviewer_keywords:
- signal function
ms.assetid: 094118de-d789-4063-b4f4-cffcc80bf29d
caps.latest.revision: 26
author: corob-msft
ms.author: corob
manager: ghogen
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
translationtype: Machine Translation
ms.sourcegitcommit: a937c9d083a7e4331af63323a19fb207142604a0
ms.openlocfilehash: 1f05c16dff5bd490866a58fcd36ae28cba862fdd
ms.lasthandoff: 02/24/2017

---
# <a name="signal"></a>signal
Задает обработку сигнала прерывания.  
  
> [!IMPORTANT]
>  Не используйте этот метод для завершения приложения [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)], за исключением сценариев тестирования или отладки. Закрытие приложения [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] программным способом или с помощью пользовательского интерфейса не допускается в соответствии с разделом 3.6 [сертификационных требований к приложениям для Windows 8](http://go.microsoft.com/fwlink/?LinkId=262889). Дополнительные сведения см. в разделе [Жизненный цикл приложений (приложения для Магазина Windows)](http://go.microsoft.com/fwlink/?LinkId=262853).  
  
## <a name="syntax"></a>Синтаксис  
  
```  
void (__cdecl *signal(  
   int sig,   
   void (__cdecl *func ) (int [, int ] )))   
   (int);  
```  
  
#### <a name="parameters"></a>Параметры  
 `sig`  
 Значение сигнала.  
  
 `func`  
 Выполняемая функция. Первый параметр указывает значение сигнала, второй параметр — подкод, который можно использовать, если первый параметр — SIGFPE.  
  
## <a name="return-value"></a>Возвращаемое значение  
 `signal` возвращает предыдущее значение `func`, связанное с заданным сигналом. Например, если предыдущее значение функции `func` было `SIG_IGN`, то возвращаемое значение также равно `SIG_IGN`. Возвращаемое значение `SIG_ERR` отображает ошибку; в этом случае для `errno` устанавливается значение `EINVAL`.  
  
 Дополнительные сведения о кодах возврата см. в разделе [errno, _doserrno, _sys_errlist и _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md).  
  
## <a name="remarks"></a>Примечания  
 Функция `signal` позволяет процессу выбрать один из нескольких способов обработки сигнала прерывания от операционной системы. Аргумент `sig` — это прерывание, на которое реагирует функция `signal`; он должен быть одной из следующих констант манифеста, определенных в файле SIGNAL.H.  
  
|Значение `sig`|Описание|  
|-----------------|-----------------|  
|`SIGABRT`|Аварийное завершение|  
|`SIGFPE`|Ошибка с плавающей запятой|  
|`SIGILL`|Недопустимая инструкция|  
|`SIGINT`|Сигнал CTRL + C|  
|`SIGSEGV`|Недопустимый доступ к хранилищу|  
|`SIGTERM`|Запрос на завершение|  
  
 Если `sig` не имеет одно из значений, приведенных выше, вызывается обработчик недопустимого параметра, как описано в разделе [Проверка параметров](../../c-runtime-library/parameter-validation.md) . Если выполнение может быть продолжено, эта функция задает для `errno` значение `EINVAL` и возвращает `SIG_ERR`.  
  
 По умолчанию `signal` завершает вызывающую программу с кодом выхода 3, независимо от значения `sig`.  
  
> [!NOTE]
>  `SIGINT`не поддерживается ни одним приложением Win32. Когда происходит прерывание CTRL + C, операционные системы Win32 создают новый поток специально для обработки такого прерывания. Это может привести к тому, что однопоточное приложение, например в UNIX, становится многопоточным и вызывает непредвиденное поведение.  
  
 Аргумент `func` — это адрес написанного вами обработчика сигнала или одной из предопределенных констант `SIG_DFL` или `SIG_IGN`, которые также определены в файле SIGNAL.H. Если `func` является функцией, она устанавливается в качестве обработчика для данного сигнала. Прототип обработчика сигнала требуется один формальный аргумент `sig` типа `int`. В случае прерывания операционная система предоставляет фактический аргумент с помощью `sig`; аргумент является сигналом, который вызвал прерывание. Поэтому можно использовать шесть констант манифеста (перечисленных в приведенной выше таблице) в обработчике сигнала, чтобы определить, какое прерывание произошло, и предпринять соответствующие действия. Например, можно вызвать функцию `signal` дважды, чтобы назначить один и тот же обработчик двум различным сигналам, и затем проверять аргумент `sig` в обработчике для выполнения различных действий в зависимости от полученного сигнала.  
  
 При тестировании исключения с плавающей запятой (`SIGFPE`), `func` указывает на функцию, которая принимает необязательный второй аргумент, являющийся одним из нескольких констант манифеста, определенных в FLOAT.H, в формате `FPE_xxx`. При возникновении сигнала `SIGFPE` можно проверять значение второго аргумента для того, чтобы определить вид исключения в операции с плавающей запятой, а затем предпринять соответствующее действие. Этот аргумент и его возможные значения являются расширениями Майкрософт.  
  
 Для исключений в операциях с плавающей запятой значение параметра `func` не сбрасывается при получении сигнала. Для восстановления после исключений в операциях с плавающей запятой заключайте такие операции в конструкции try/except. Кроме того, восстановление возможно с помощью [setjmp](../../c-runtime-library/reference/setjmp.md) с [longjmp](../../c-runtime-library/reference/longjmp.md). В любом случае вызывающий процесс продолжает выполнение, а значение состояния операции с плавающей запятой в процессе остается неопределенным.  
  
 Если обработчик сигналов возвращает значение, вызывающий процесс возобновляет процесс непосредственного с того момента, когда он получил сигнал прерывания. Это верно независимо от вида сигнала или режима работы.  
  
 Перед выполнением указанной функцией для `func` устанавливается значение `SIG_DFL`. Следующий сигнал прерывания обрабатывается так же, как это было описано для `SIG_DFL`, если только промежуточный вызов `signal` не указывает иное. Эту особенность можно использовать для сброса сигналов в вызванной функции.  
  
 Поскольку подпрограммы обработчика сигналов обычно вызываются асинхронно в случае прерывания, функция обработчика сигнала может получить управление в то время, когда операция среды выполнения не завершена или находится в неизвестном состоянии. В следующем списке указаны ограничения, которые определяют, какие функции могут использоваться в подпрограмме обработчика сигнала.  
  
-   Не указывайте подпрограммы ввода-вывода низкого уровня или подпрограммы из файла STDIO.H (например, `printf` или `fread`).  
  
-   Не вызывайте подпрограммы кучи или другие подпрограммы, использующие подпрограммы кучи (например, `malloc`, `_strdup` или `_putenv`). Дополнительные сведения см. в разделе [malloc](../../c-runtime-library/reference/malloc.md).  
  
-   Не используйте какие-либо функции, которые создают системный вызов (например, `_getcwd` или `time`).  
  
-   Не используйте `longjmp`, если прерывание не вызвано исключением в операции с плавающей запятой (то есть, значение `sig` равно `SIGFPE`). В этом случае вначале следует инициализировать пакет операций с плавающей запятой с помощью вызова функции `_fpreset`.  
  
-   Не используйте подпрограммы наложения.  
  
 Программа должна содержать код с операциями с плавающей запятой, если она должна перехватывать исключение `SIGFPE` с помощью этой функции. Если программа не содержит код, использующий операции с плавающей запятой, и требует выполнение кода обработчиков сигналов библиотеки времени выполнения, просто объявите переменную volatile double и инициализируйте ее нулевым значением.  
  
`volatile double d = 0.0f;`  
  
 Сигналы `SIGILL` и `SIGTERM` не создаются в Windows. Они включены для обеспечения совместимости с ANSI. Таким образом, можно задать обработчики сигнала для этих сигналов с помощью функции `signal`, а также явно создавать эти сигналы с помощью вызова функции [raise](../../c-runtime-library/reference/raise.md).  
  
 Параметры сигнала не сохраняются в порожденных процессах, создаваемых вызовами функций `_exec` или `_spawn`. В новом процессе параметры сигнала сбрасываются в значения по умолчанию.  
  
## <a name="requirements"></a>Требования  
  
|Подпрограмма|Обязательный заголовок|  
|-------------|---------------------|  
|`signal`|\<signal.h>|  
  
 Дополнительные сведения о совместимости см. в разделе [Совместимость](../../c-runtime-library/compatibility.md).  
  
## <a name="example"></a>Пример  
 В следующем примере показано, как использовать функцию `signal` для добавления пользовательского поведения в сигнал `SIGABRT`. Дополнительные сведения о прерывании работы см. в разделе [_set_abort_behavior](../../c-runtime-library/reference/set-abort-behavior.md).  
  
```cpp  
// crt_signal.c  
// compile with: /EHsc /W4  
// Use signal to attach a signal handler to the abort routine  
#include <stdlib.h>  
#include <signal.h>  
#include <tchar.h>  
  
void SignalHandler(int signal)  
{  
    if (signal == SIGABRT) {  
        // abort signal handler code  
    } else {  
        // ...  
    }  
}  
  
int main()  
{  
    typedef void (*SignalHandlerPointer)(int);  
  
    SignalHandlerPointer previousHandler;  
    previousHandler = signal(SIGABRT, SignalHandler);  
  
    abort();  
}  
```  
  
```Output  
This application has requested the Runtime to terminate it in an unusual way.  
Please contact the application's support team for more information.  
```  
  
## <a name="net-framework-equivalent"></a>Эквивалент .NET Framework  
 Неприменимо. Для вызова стандартной функции C используйте `PInvoke`. Дополнительные сведения см. в разделе [Примеры вызова неуправляемого кода](http://msdn.microsoft.com/Library/15926806-f0b7-487e-93a6-4e9367ec689f).  
  
## <a name="see-also"></a>См. также  
 [Управление процессами и средой](../../c-runtime-library/process-and-environment-control.md)   
 [abort](../../c-runtime-library/reference/abort.md)   
 [Функции _exec, _wexec](../../c-runtime-library/exec-wexec-functions.md)   
 [exit, _Exit, _exit](../../c-runtime-library/reference/exit-exit-exit.md)   
 [_fpreset](../../c-runtime-library/reference/fpreset.md)   
 [Функции _spawn, _wspawn](../../c-runtime-library/spawn-wspawn-functions.md)
